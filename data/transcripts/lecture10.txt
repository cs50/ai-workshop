Alright, this is CS 50 week 10. The very end and we will end today's class just as we ended week zero, which is a little bit of cake outside in the transept. But over these past 10+ weeks, if you've been feeling like it was that proverbial fire hose sort of hitting you in the face with so much new content, so many new skills, so many new challenges, um, realize that you're in very good company and we can officially declare nonetheless that if you started the class among those less comfortable, you are officially after today no longer less comfortable. You're at least somewhere in between and if you were in between. You're more comfortable and if you were more comfortable, you're perhaps now most comfortable among those here. But keep in mind as for CS 50 syllabus, what does ultimately matter in this course is not so much where you end up relative to your classmates, but where you end up relative to where you yourself began, and that's taken into account come final projects, come final grades, but most importantly, that's really what's most important educationally in general is that Delta from week 0 to, in our case here now, week 10. So if it's any reassurance. And something I like to bring up around this time is just how badly I did in CS 50 and like the very first problem set. Like I didn't even get Hello world right somehow in the fall of 1996. So here's a photograph of my homework assignment for assignment one. It was a program to print Hello World on the screen. I was incredibly detailed with my comments, even commenting that Maine is Maine, which is not the way you're supposed to program, even telling the TF where my file ended, which is not really necessary, and I got -2 for not even following directions. Correctly, so take some comfort in that even if by problems at 9 you're still getting points off, you're hopefully, at least in my case, in some very good company. It only gets better and easier and faster in time. But the whole course ultimately has really been about this picture, right? Problem solving is computer science and you have inputs, which is the problem to be solved. You have the outputs that you want to get to, which is presumably the solutions there too. And inside of that proverbial black box are these algorithms, step by step instruction. For solving some problem, and I pulled up my own notes from CS 50's first lecture some 25 plus years ago too, where I wrote down this in my horrible writing, handwriting to this day, but I noted that what an algorithm is is a precise sequence of steps for getting something done, which is pretty much what we now say. I noted that programming itself, as we have for weeks now, is the process of taking an algorithm and putting it into a language that computer can process, and that's what you've done in Scratch and C, and Python and SQL and Java. and anything in between, and most important, at least my takeaway that day when it comes to algorithms is precision and correctness, and indeed those are points we've made perhaps not as emphatically over the past several weeks as well. But we thought we'd see just how much those two lessons in particular have sunk in, by doing a bit of an exercise, some CS 50 pictionary in this, our last lecture altogether this term, um, for which to begin we need one brave volunteer to come on upstage. Who would like to volunteer? Who, how about, OK, over here, we never call from the middle of the section, come on up, come on up, a round of applause for being so brave. Nice. All right, come on over. And In just a moment, let's go ahead and do introductions. First, if you want to come up over to the middle of the stage and introduce yourself to the world. Hi, I'm Jia. I'm a freshman. All right, nice, nice to meet you. Thank you for joining us. So what we're about to do is Gia's going to look at my screen where there's going to be a picture on a white screen. All of you presumably have a white sheet of paper in front of you that you grabbed on the way in. If you don't. Just grab one from a friend or your binder or the like, and if you really don't, that's OK too, but hopefully everyone has a pen or pencil or someone near you does. And what we're going to ask you to do is program the audience to draw what it is you see on the screen. You can say anything you want, but you may not use any physical gestures or the like, verbal programming only. OK. All right, come on over to the lectern. And in just a moment, GN only Gia will see what is actually here on the screen. So. Step 1 for your audience. OK, so the first thing that you need to do is draw two lines right next to each other, 2 vertical lines. OK. OK. Step 2, once you have done that, you need to draw 3 dots, one on above those two vertical lines, one right in the middle between those two vertical lines, and one on the bottom of these 3 vertical lines beneath those two vertical lines. Yeah, so 3 dots. OK. Step 3. Step 3 is on the top of the left vertical line, you're gonna connect a line from that position to the top dot that you drew and then on the top of the right vertical line, you're gonna connect that position to the top dot that you drew. All right, step 4 is, remember that top left position? You're going to connect that to the middle dot that you drew. And then the top right of the vertical line, uh, the, yes, you're going to connect that to the middle dot of the line that you drew. Mhm. And then step 5 on the bottom left of your left vertical line, you're gonna connect that position to the bottom dot that you drew and then on the bottom right of the right vertical line you're gonna connect that position to the bottom dot that you drew. And now from the middle dot to the bottom dot you should have no line in between that, and you can now draw a line between those two dots. Step 6 and the last. I think you should be done. All right, a round of applause for our programmer. Let me give you a little something. If you want to take a seat, well, now what Kelly and I are going to do is very quickly collect your execution of this program, and we'll see just how it went with Gia as the programmer. If you want to just reach out and hand me or Kelly over there any of your handwritings, we don't need all of them, just a representative sample will suffice. If you're proud of your work, extend your hand quite a bit. OK, very proud. OK. OK. OK, OK, one more, one more, that's OK. All right, I'm gonna run back to the stage. OK. It's OK if we didn't grab yours. All right. All right, thank you to Kelly for grabbing these as well. So, without having seen any of these, here is how you all interpreted Gia's instructions. So here's one interpretation. OK. Perhaps similar or different from your own. Uh, here's another several. Vertical vertical line, question mark, OK. He is. Very narrow one. All right, and And let's see if we got any other variants thereof. Actually, the rest of them are pretty consistent. So, gee, if it's any reassurance, I'm seeing a lot of ones that look like this. Here's another that looks like this and here's yet another that looks like this. So if you're wondering where we're going with this, if I go ahead and reveal what it was Gia was looking at on the screen, she was in fact having you draw this here cube. So some of the takeaways here. So suffice to say, not all of that went well, uh, but why was that? Well, I dare say it was very easy to get confused, I think, G, in some of your words because you had in your mind's eye exactly what it was you were drawing and. Of course it was right there on the screen, but we didn't leverage, at least in GSA instructions, any abstractions. I dare say it might have been a little bit easier for all of us if maybe she had just teed things up by saying, All right, everyone, we're going to draw a cube, for instance, which is indeed an abstraction over these lower level details that she was focusing on. But perhaps there could have been another approach altogether, which is even more pedantic. For instance, a lot of the earliest drawing programs. And even worlds like Scratch sort of take for granted that you have a coordinate system like X's and Y's and you can go up, down, left and right. So an alternative to just saying, hey, I'll draw a cube, which could be subject to interpretation because there's a cube like this, is it like this rotated so we still would have needed more information than just a cube from Gia. But here maybe an alternative approach would have been to really get into the weeds and say put your pen at the top of the page and then draw a Straight line to the southwest, for instance, and then draw another line of the same distance to the south and then to the southeast or so forth and it could have been in terms of degrees, it could be directionally in that way, but it might not have been clear to anyone what it was we were drawing until enough of the lines suddenly appear on the screen and then voila, you see that we've been drawing a cube this whole time. So the degree to which we're precise and the layer of the level of abstraction that operate in is incredibly important whether it's for another human to understand us, for an AI to understand us nowadays, or anything in between. All right, why don't we go ahead and flip things around a bit um for this, why don't we go ahead and get one more volunteer to do something a little different here on stage? One more OK, how about here on the aisle? Come on down. Round of applause for this brave volunteer. Come on down. All right. So in this exercise, we're gonna flip things around. So you all will be giving the instructions verbally by just shouting them out and our volunteer whose name is Preston. Presley. Presley, Presley, you want to say a quick introduction? Yeah, uh, my name is Presley. I'm a freshman, uh, living in Stton House. Nice. Well, welcome. Come on over to the, the, uh, the easel here, and we have a black marker for Presley here. And the only thing that we ask is that you not look up or behind you because the answer is going to be Right there on the screen, but everyone else is welcome to look up or over to the TV screen. And if you want to go ahead and face the easel here and as you draw, just make sure to kind of open up after each stroke of the pen so that everyone can see what you have done. All right, so no looking up as of now because what the audience is about to do is to program you to draw this on the screen. Oh, way to encourage him. OK, so step one, feel free to just raise your hand and we'll shout them out. I heard draw circle over here, but not too big, I heard over here. Good abstraction, you're gonna end up drawing a stick figure. But we should probably be a little more helpful than that. So let's do the hand thing just so we can be more precise and not overwhelm Presley with the was the hand over here, yeah, and back. Draw a line down from the circle, Presley. From the bottom of the circle. OK, someone else? So actually, let me, let me rewind, sorry, say it again. Draw two diagonal lines from the line you just drew. Well, I don't think the audience likes this. Wait, let's, uh, mm. OK. OK, that's what we were told. Next step, someone else? So OK. Good one. OK. Extends the original vertical line to be about the same height as the circle. OK, yeah, that's good, good feedback. All right, someone else. Next step. Next step. Yes. Nice. Draw two diagonal lines from the bottom of that line that look like legs, good use of detail and abstraction. OK, nice. Next step. Anyone? We're close. Yeah, over here. On the left. So you're gonna draw a speech bubble to the left of the head with the word high, capital H with a short line. No bubble, just high. And you wanted to clarify one other detail. A line from high to the face, with space in between. OK, no, you're doing great, it's OK, Presley. Hang in there. OK, final step or two. Next step, Anyone at all Feel free to shout it out. Adjust the arms to make them look like they're running. Good luck. Oh, I like that. Draw a perpendicular line from the left arm. To the bottom. OK. And lastly, one final step. No. Same side. Yeah, it's permanent. Uh. I think we need a final touch on the other arm, maybe, yes, one final step. Anyone? Draw a perpendicular line per uh diagonally to the left. Of the right arm Mm Just a little bit. All right, I think I've, I think we've withheld our applause long enough. Presley, if you want to take a step back and look at what you, they were trying to get you to draw a round of applause. So here too, let me, here you go, your dorm room if you would like. OK. And a little Super Mario as well. All right, so here too, um, I think you were the problem this time. Round of applause for Presley. And of course since it's, you know, permanent ink, it's easy to sort of go off the rails early on and make a mistake, but I think that was actually a nice mix of low level details like the directions of the lines and the lengths thereof and also some abstractions because I do dare say someone shouting out that it is to be a stick figure gave him a much more helpful mental model. So that might be sort of the comments on top of the function, but when we really got into the weeds of implementing that function, it was more akin to step by step instructions for solving this here. Particular problem. So my thanks to Presley for bearing with us with that one as well. So beyond this, where have we been up until now? So, uh, if we look back at the past several weeks, this is sort of the trajectory on which, uh, we've been. So we started with scratch from scratch, literally in the very first week, the goal of VoI was to introduce you to some of those procedural fundamentals like what a loop is and a conditional and Boolean expressions and variables which are pretty. Much recurred in different forms and different languages over the weeks since thereafter we transition to a more traditional language C, which many of you will never use again and admittedly even I only use it for like a month or two of the year during CS 50 itself, but the intent was to be this incredibly foundational language that so many other languages today are built on top of. Case in point, the interpreter that you might use for Python itself can be written in C and that speaks to how we sort of talked. Bootstrapping from one language to another, from low level to high level and beyond, arrays and algorithms, all of that and memory and data structures like all of that is sort of omnipresent in computing, in programming and the like, even though you might not need to in modern languages like Python, worry as much about managing your own memory because good programmers, better programmers have figured out how to solve those problems for you in the language itself or in the libraries that you're using. You can take for granted now that you at least know what a hash table is. What a linked list is, what the trade-offs are among those, what the running times are, and that's what computer scientists and software engineers think about and talk about and whiteboard about in the real world when trying to implement algorithms of their own to real world problems or implementing real world products. And then of course over the past few weeks we've sort of used that as a stepping stone to talk about very modern programming paradigms, most recently web programming, and even though we didn't use it explicitly in the class, mobile programming is increasingly based on HTML and CSS. And JavaScript, which might be something some of you will tackle for your own final projects, and you can't escape now using or seeing or leveraging somehow artificial intelligence. And among the goals for today is to at least point you in the direction of tools that now, having finished Problem set 9, you are welcome and encouraged to use for your final project so that you can build all the more and all the more successfully than even some of your predecessors just a few years ago could have now that your own work and your own know-how can be amplified by the impact. Of AI itself. This of course now brings us to today, the end, but wanted to give you a sense of where you can go here on out. So with your final project, this really is the the intent of the final project is to be the very first of hopefully many projects that you decide to spec out for yourself. Like every problem set thus far has been written by me and the team, and you've been following our instructions step by step. The Frontal Project takes all of those training wheels off, and even though you are welcome and encouraged to borrow, code. From say problem set 9 if you want to do something web-based or even earlier, if you want to do something that's more similar to past Pets, is to make it ultimately your own. And even if you want, start with a completely empty window and just a blinking prompt and build something of your own, um, setting out for yourself, as you've seen in the specification, a good goal which you intend to meet no matter what, a better goal, which is a bit more of a stretch and a best goal, which in practice rarely ever happens with software to this day, 25 years since. Taking CS 50 myself, um, or plus now, um, even I consistently underappreciate just how long it takes sometimes to solve problems, but that's beginning to go away, at least to some extent thanks to AI, where at least now you essentially have a junior colleague next to you who can help solve bugs for you, point you in the right direction, even tackle features as well. Um, all that we ask for this final project is that you build something of interest to you, that you solve an actual problem, that you input to campus, or that you. As we say in the spec, change the world and try to achieve something, try to create something that outlives the course itself over these final few weeks of the class and even continue on with it if you'd like in January and beyond. So what are the support structures in place and how might you go about this? So a long standing tradition of CS 50 is this epic late nighter, the CS 50 hackathon, where by around 7 p.m. we'll serve some pizza around. p.m. we'll serve some ice cream, and if you're still awake come midnight when the event will start to wrap, we'll get in a whole bunch of CS 50 shuttles, drive down the road to the International House of Pancakes, which is open 24/7, and have some breakfast together if you choose, with some pancakes together at this local IHOP. Here are just a few visuals from the past year's hackathon of students gathering in the engineering building across campus. Um, here having some of that same pizza and here still being awake at uh early morning hours as well. uh, to paint a picture of this too, the team a few years back kindly put together a video, a sort of sizzle video that paints a picture of what it might be like if you at least were a Muppett attending this year, uh, CS 50 hackathon. If we could go ahead and dim the lights, I think we can go ahead and play, uh, this teaser of what awaits later this week. Just one night all we got. Just one night, all we got. Just one night. Does Still On the weekend. All right, so what then is the CSMC hack upon itself? What really is the late night opportunity to dive into, to start, uh, to make progress on your final project? The teaching staff and I will be there on hand, not so much to answer any and all questions for you, but to help you help yourselves, point you at resources, point you at, uh, the requisite websites, the documentation, so as to empower you ultimately to solve this here problem, uh, for yourself without some of those same prior training wheels that we've had. On, uh, the goal ultimately is to prepare you for the end of semester exhibition, the so-called CS 50 fair, which will be an opportunity to present your final projects on your phones or laptops, uh, to passersby from the faculty, from students, from staff, from visitors all across campus here, uh, some emoji balloons will await you here, uh, a photo booth if you'd like to uh immortalize the the memory, uh, and the goal of the hack of the fair will be really just a Present your projects to others that come by, uh, delighting in what it is you have achieved over these past few months alone, and of course by the end of it you'll pick up your very own CS 50 t-shirt which says hopefully proudly that you have now indeed taken CS 50. But let's just see in preparation for that how much has indeed sunk in. We did have that test a couple of weeks back, oh, which went great, but we thought we'd pluck some of these same review questions that you prepared over the past couple of weeks to challenge at least. 6 of your classmates to come up. Uh, for now, this, the so-called CS 50 charades for which we need 2 teams of 3. So if you're sitting there in a group of 3 of friends total, or we'll form one up here live, so come on up as our first volunteer, needed 5 more volunteers. Feel free to volunteer the persons next to you 3 in a row. How about 2 more over here, 1 and how about 2 on the end. Come on up. All right, a round of applause for these 6 year volunteers and. All right, so let me give you one microphone. Let me give you a 2nd microphone and Kelly, if you want to come on up as well. I think these three seem to know each other already, so we'll have them be one team if you guys want to be another team as well. Come on up. Uh, let me just take one microphone actually for the other team. All right. And how about quick introductions to this team here and we first we need a team name from you all. You haven't had time to think about this? Team A. OK, so Team A is who? I'm Leah. I'm a first year and I'm in Hoorthy. Welcome. Uh, my name is Stephen. I'm a freshman in. I'm Charlotte. I'm a freshman and I'm also in Canada. All right, let's do introductions on the other team as well. You are going to be team. Awesome sauce. Awesome sauce, OK, versus Team A, uh, if you wanna go ahead and introduce yourselves here. Hi, my name is Jenny Pan. I'm a freshman in Hollis. Hi, my name is Noah. I'm a freshman in Holbut. And hi, my name is Marie, and I'm a freshman, sorry, I'm a freshman in Canada B. All right, welcome to both of our teams here. And among the goals now, let's leave one microphone with each team, uh, is to play a bit of charades whereby one of you in a moment is going to be responsible for acting out a word that you see on the screen. So we're going to put on this screen and the screen over here some term that relates to CS 50 somehow, and that person's goal over the course of 60 seconds. Going to be to act that out in such a way that their teammates can hopefully guess what the word is. We'll give you 60 seconds at a time. Kelly has kindly offered to keep score, um, and if you solve it in fewer than 60 seconds, we've got another word for you in another word, and we'll see how many points you can accrue over the course of those 60 seconds. And depending on how this goes, we'll do maybe 1 or 2 rounds in total. Questions. How many skips do you get? I guess you can skip uh as many as you want until we run out of questions. But try not to run through all of our questions. All right, any questions that'll be on that. All right, so if you guys want to step off stage over there, why don't we have team A begin? So one of you, Leah, if you're holding the mic, if you want to be the curator, let's go ahead and have you stand here so you can see the screen, and we only ask that you two not look up because the answer is going to be right there. All right, and you should just shout out, uh, the word that Lee is acting out. Question. Acting only charades speaking. Yeah, yeah, I can't speak because that would kind of defeat the point. So yes, just acting out, just acting out physically. All right, I'm gonna go over here. Give me just a moment to get the slides ready with your questions. And Leah, the first clue, oh, and Kelly's gonna be timing you 60 seconds to accrue as many points as you can. All right, here we go. Go Act that out. 00, that was weird, thank you. Sorry. Yes, act out, this is CS 50. All right. No, act this out, please. Go. Calling a recursion. Yes, 1 point. uh, in array linkless. Abstraction? Python, Python, Python. Duck, the duck Nice. Binary uh 10 binary digit. Bite 10, definitely binary. Asky. Want to pass They Linkless array. Yes, array. Loop loop. Time. All right. Very nicely done. All right. 5 is the score to beat. So if you guys want to step over here, if, uh, one of you has the mic, go ahead and assume the same roles. 5 is the score to beat. Alright, 5 is the score to beat. All right, here we go, final round. First word and you guys just make sure you don't look up. Go. Head node algorithm input. Algorithm Yes Well. These are hard No. Sure, you have to act it out, act it out. Oh, they go. Run time, run time. 3. Yes, 3. Next one. Next one. Binary search binary bullying? No. A merge phone call. It was binary search wasn't it? Oh, that's right, but a round of applause for our awesome sauce. OK, we have some, some parting prizes for you, your very own Super Mario Pezs for you guys as well. I'm glad we squared away the, the ability to pass though on the question, so thank you for that. All right, so admittedly pretty hard. Our thanks to all of these volunteers for playing that out. Allow me to turn our attention back to here in just a moment where else uh we can go from here. So up until now, up until now. We've been using Visual Studio Code for CS 50 at the URL CS50.dv. Recall that this is just an adaptation of a commercial tool called GitHub CodeSpaces, which is like a cloud-based version of Visual Studio Code itself, or VS Code, which is an largely open source tool for Microsoft that's incredibly popular in industry, which is to say, even though we had the CS50 library in there and we turned off by default some of the menu options and we disabled AI, it is the tool that so many programmers around the world do use every day to write code. So you have been learning. All this time sort of industry standards in that sense. It is now time, if you so choose, but you are welcome to keep using this for your final project if feeling more comfortable with it, to drop the 4 CS 50 and actually install on your own Mac or PC if you so choose, Visual Studio Code itself. You can go to this URL here. It's fairly straightforward to install it, but invariably you'll run into probably some technical support headaches depending on the language that you're trying to use with it. For instance, if you're trying to use it with Python, you'll probably also have to download and install Python on. Your computer, at least if you want the latest version, and just know a priori that sometimes just stuff happens and it just doesn't work and you have to Google or ask Chat GPT, and that's fine. And honestly that's kind of normal. But this is also why we don't do any of this in week zero of the class so that we can focus on Hello world and Mario and cash and credit and get into the interesting parts of computing and programming and not frustrating, not frustrating you so with technical support challenges. But now, given that all of you are somewhere in between. are among those more comfortable, you're now ready to sort of deal with those same technical challenge yourself, but who knows, maybe it will go perfectly smoothly. You can go to CS 50's own documentation because if you want to be able to use all of the same software that CS50 has pre-installed, you can use a technology known as containerization with a tool called Docker and actually run a CS50 environment on your Mac or PC or even in the cloud, but still run VS code on your own Mac and PC, among the upsides of which are that you're not dependent necessarily on the. You can do everything offline, which is useful in general. You can do things more quickly sometimes if you're using the full capabilities of your own computer and not just a browser. So this is generally how programmers approach their code using something like VS code or alternative products. And in fact there's a bunch of others out there, but perhaps the trendiest right now are these 3 here, not just Visual Studio code itself, but a tool called Cursor, another one called Windsurf, and there's dozens of other text editors, often known as integrated. Development environments which tend to have even more features that you can download for free or commercially on your own Macs, PCs and the like, uh, but you can't go wrong transitioning from CS 50 to VS code on your own Mac or PC if only because you're already familiar with it. As for the command line, so those of you with Macs might have found somewhere in your utilities folder a program called Terminal. Um, if not, poke around there later today and you'll see that all this time you've had a command line interface available to you on Mac OS. Windows has something similar as well. They they. Necessarily come with all of the same tools that we've been using within CS50. Dev, but if you're a Mac user and you go to this URL here or you're a Windows user and you go to this URL here, or if you're a Linux user, you probably know all of this already, so there's no URL for you there. You can install some of those same tools on your Mac and PC and feel all the more at home doing things in a command line as well. Um, Git, this is something that we actually in CS 50 abstract on top of. This is essentially the de facto standard nowadays for collaborating with other people. Using a central cloud server in order to share your code with it and in turn other people for versioning your code so that you keep track of multiple versions thereof and changes that you've made. Go to this URL here if you would like, and you'll see a tutorial by CS 50's own Brian Yu introducing you to actual Git because we've been sort of abstracting away this particular tool by just doing it all automatically for you. If you've ever gone through your timeline in CS50.dev being able to roll back to previous versions of your code, we're just using Git, but we're. Automatically running this command for you. If you want to collaborate with partners for your final project, you can use Git. However, I will encourage you to alternatively use Visual Studio Code's live share feature, which allows one of you to log into your code space, click some buttons, and then share access to your code space with your friend or your partner with whom you're working on the project, and you can both in real time, like Google Docs, edit the code or different files they're in using that one code space, a little easier than getting onboarded at least with. hosting a website if this proves of interest for your final project or even after the course, if it's a static website, two popular places to go, if only because they offer free tiers, is what's called GitHub pages, which you can use to just host HTML, CSS and JavaScript with no Python, no flask, no back end, or NetLFy is a popular company nowadays too that has an entry level account for which you can sign up for free. If you just want to have like a portfolio website, if you're an artist or a programmer or you just want to have static content that you write once and deploy, these. Good starting points, but not all of them. Hosting a web app, so this, this list gets even longer, and all of these recommendations are essentially curated by the teaching staff, so they're all opinionated, but these are perhaps the most common places you can go. Amazon, Microsoft, Google, Cloudflare, they all have student type accounts. So if you use your .edu email address, for instance, or some other form of proving your status as a current student, you can generally sign up for discounts and free access to a lot of these same services as well without. Having to pay while you're just learning along the way. GitHub has something similar called the Student Developer Pack, and then a couple of other companies for hosting web apps that have been popular are Hiroku, Versal, and bunches of others. So by web app we mean not just HTML CSS and JavaScript, but maybe some Python, maybe some JavaScript on the server, maybe Ruby, yet another language or any number of others when you actually need a back end in addition to the front end, maybe you need a database as well. This would be the place to start, whether it's at the CS 50 hack. or beyond, and nowadays this is a slide that didn't even need to exist a couple of years ago asking AI again for your final projects, you are welcome and encouraged to amplifying your own productivity with AI, not by having it do it for you, but moving away from the duck, which by design has been fairly limited and meant to be a good teacher, but not necessarily one that's going to be a good partner when it comes to building your final project. So Chachi BT, Claw, Gemini, GitHub copilot, OpenAI Codex, vro, um, are all, uh. Popular tools right now that you might want to play around with. The easiest of these to use perhaps, if not familiar with say Chacha BT already, would be GitHub co-pilot only because you can enable it within your CS50 code space by following our own documentation at cs50.readThe docs.o where we'll tell you the sequence of steps via which you can re-enable AI now that you're allowed to for your final project and turn on all of those features that were disabled by default. Um, and then there's still humans out there, like what remains to be seen just. Popular these websites are in the years to come, for better or for worse, but among the places that programmers and technophiles have gone for years are Reddit, Stack Overflow, Server fault, where there's a rich history of questions and answers that ironically all of those AIs have been trained on, which unfortunately means some of these might be driven out of business eventually in some sense if we're all just turning only to AI. But when you actually want that human component, these are still good places to go. And then news, two of the many places you can go for news and technology, computing, computer. Science more broadly would be TechCrunch is still a good one. Hacker news, so to speak, and then you might have some of your own popular choices as well. Um, and then if, uh, with some bias, um, take other classes like CS 50 besides this undergraduate class has a rich history now over the past decade of creating all the more open courseware, so courses in more Python, more SQL, a language called R, cybersecurity, uh, game development, and more. All of those are linked at this URL here edX.org.cs50 where you need not pay or sign up beyond. the course and all of the content is freely available, something for winter break, for instance, if you want to dive a little more deeply into some subject for the sake of your final project, your professional aspirations, or even just prepare for spring term. And then over the coming weeks too, will CS50 itself be soliciting interest and applications for becoming a teaching fellow or TF, a course assistant, or CA? If you would like to get all the more involved as a teacher of CS 50 next fall, uh, do, uh, follow the application link that we will soon circulate via email. And do stay in touch too if you just enjoy answering other people's questions or seeing what the pulse of sort of computing is, at this URL here is a whole bunch of CS 50's own communities in social media largely via which you can follow along at home in the months and years to come too. So a few thanks before we do one final game altogether to all of the people who have been making this course possible. So our friends at Memorial Hall who make bringing us into this beautiful space and make it possible for us to have, of all things, a class in such a. Space, um, our friends at ESS who help with the audio each and every week in CS 50, um, the restaurant Changzhou down the road. We hope you'll continue to visit our friends there. Wesley Chen is a good friend of ours and the manager. Um, please tell him you're from CS 50 and I'm sure he'll be delighted to see you. Um, and then CS 50's own team, well, most of whom were in back there are sitting next to you with cameras, um, without whom the course wouldn't be possible. And of course CS 50's own teaching fellows in CAs, just a few of whom posed here for this photo. If I could invite you to all give everyone here a round of applause, my thanks to all of them. So, um, and then of course, the CS 50 duck should be thanked as well. OK. Thanks to CSFT's own Rong Xin Lu and some of our own former teaching fellows and students who have been behind the development of that their duck that you've gotten to know over these past several months. All right, if Kelly could join me again on screen, the only thing between us and Cake is a final game, namely a quiz show in which all of you can partake. Here we go. Question one. What is the largest number in 8 bit unsigned binary digit can represent? 256, 128, 255, or 1? Starting strong and keep in mind all of these questions came from you all, because we asked you recently for review questions that are now on the screen. Again, the timer is clicking and most popular answer was 255, which I think if we click once more, we'll confirm was in fact the correct answer. So, why is that and why is it not 256? Well, if we start counting from zero, as we always have. That's consuming one of the 256 possibilities, so the largest number that we can represent with that's 8 bit and unsigned, which means no negative numbers involved, is indeed going to be 255. Treasure, that information now always. All right, next question from Kelly. Which issue is at the center of the year 2038 problem, which hopefully you added to your Google calendars a few weeks back, entered your overflow, malicious inputs, SQL injection attacks, or memory leak? Which of those is at the core of the year 2038 problem? All right, let's go ahead and reveal the number one answer with 92% of you saying integer overflow is in fact correct because we're still in the habit of using 32 bit integers to keep track of time from the so-called epoch, which was January 1st, 1970, and unfortunately we humans aren't great at sort of planning ahead and so we're going to run out of permutations of 32 bits. By a certain date in the year 2038 unless everyone upgrades their computers to 64 bit counters, which thankfully most every piece of modern hardware nowadays is using already your Macs, your PCs, and your phones. So hopefully this will be really a non-event, but hopefully you'll think of us in CS 50 in, uh, you know, 10 plus years when your Google Calendar reminder goes off. Question three, which of the following is not a step of compiling, linking, pre-processing, assembling, or interpreting? A bit more of a challenge, which of these is not a step of compiling. Alright, almost 200 responses coming in. All right, why don't we go ahead and reveal the most popular answer with 54% of you saying interpreting is in fact correct. Recall that we, we talked about compiling. Compiling itself is just one of several steps. There is in fact the preprocessing step which takes care of any of the hash symbols in C that start. With hash include hashdefine, and the like, that's preprocessing. There was then assembling or there was then compiling, which actually compiled your code into assembly code. There was then the assembler which would actually take it down further to machine code and then linking. 29 this is for 29% of you. The linking step recall was taking your zeros and ones and combining them with say CS 50's libraries zeros and ones and maybe the standard IO library zeros and ones linking them all together to give you one executable program like hell itself. All right, next question. What does a pointer store, the name of a variable, the memory addresses of a value, the size of a value, or the value of a variable? Think for a moment. What does a pointer store? Alright, about 200 responses in and yes, the memory address of a variable with 96% of you confirming as much. That is correct. Question 5. What is the running time of linear search? Bigo of 1, big go of N, big go of N squared, or big O of N log N? Linear search running time. I recall that with something like search you could get lucky, but if big O is the upper bound on our running time you might not you might hit the end of the list that you're searching and so the running time of linear search is of course big O of. And it might be omega of 1, but not big O of one, at least if we're considering what the worst case scenarios might be. All right, on to question six. What what data structure follows the first in, first out principle? A queue, a link list, a stack, or a hash table? first in, first out, AKA FIFO. Which of these is FIFO? All right, first in, first out is in fact a queue, as you would hope if you're getting in line for a restaurant, for a store, you'd hope that if you're the first one in line, you're going to be the first one out, equitably speaking, and so it is in fact a queue. The opposite of that in some sense then would have been a stack whereby when you think about the cafeteria trays, the sort of first one in is actually the last one out, so LIFO instead for a stack. All right, question 7, which operator returns the memory address of a variable? An asterisk, a dollar sign, an ampersand, or a hyphen, and a greater than sign. Presumably in C. Which returns the memory address. Of a variable All right, let's see what everyone thinks. So the most popular and correct answer is the ampersand. This is the address of operator. The asterisk recall in most contexts is the opposite of that, that's the reference operators actually go to an address, um. This is not a thing in C. This though is similar in spirit to a combination of the star operator and the dot operator, which means to de-reference and follow a pointer to something inside of a struct typically. All right, question 8, which SQL command is used to remove duplicate rows from a result set? Remove unique, distinct, or clean. We didn't spend a huge amount of time on these keywords, but only one of them applies here. A result set is just the answers that you get back when doing your select. And if you want to filter out duplicates, you can in fact say. Distinct is correct. Unique is also a keyword in SQL, but that is when you want to define in your schema that a column's values are going to be unique like an email address column. Instead, distinct is how you filter out duplicates in your selects. All right, question 9, we're past the halfway mark. What does an HTTP code of 418 signify? Not found, I'm a teapot, forbidden, unauthorized. 4:18. This too, if you know this one moving forward, you'll be considered among the CS. Elite Answers are coming in a little slower, but I'm a teapot is correct, which is not actually a thing or useful technology. It was in fact an April Fool's joke years ago where a bunch of computer scientists got together in a room and wrote out an entire specification for what it means for a server to return 418, I'm a teapot. All right, number 10. Where does Mao dynamically allocate memory from? The heap, the stack, global variables, or assembly? All right. Heap is in fact correct. That's the sort of top part of the memory, even though top and bottom make no actual technical sense. It's just our artist's rendition thereof. The stack recall is what is used when functions are being called. Every time a function is called, it gets a so-called frame on the stack. That's where your local variables and your arguments get put. But if in C you use Mao, it does in fact end up on the heap. In C, if you allocate memory with Mao but forget to call free, what problem can occur a memory leak, segmentation fault, stack overflow, or all of the above? If you allocate memory with Mao, but forget to call free, what problem can occur? All right, most popular answer is in fact memory leak, which is correct. Um, you could imagine scenarios in which you also get a segmentation fault and or a stack overflow, but those aren't direct consequences of not calling free. That's generally. Consequence of using too much memory, for instance, or in this case doing something wrong with your memory. So interrelated, yes, but in terms of not calling free for each Mallock, this is what's going to happen by definition. All right, well done there. Next question, which is 12, what does this domain name give the web page of Safetyschool.org? Is it Harvard University? Is it Princeton University? Is it Yale University or Columbia University? All right, recall that this was in the context of our HTTP redirections. Yes, interesting. Yes, in fact, uh, Yale University, some alum has been paying like $10 a year for like 20 years for this joke. Safetyschool.org, if you visit it, returns an HDP 301 HDP header, which says the location of it is in fact yale.edu. All right, 13, 3 to go. What is the purpose of DNS? Uh, to encrypt data sent over the dark web. To find the nearest coffee shop for you, to protect your location against hackers or to translate domain names into IP addresses. What is the purpose of DNS? If helpful, domain name system. Alright, about at the 200 mark, and the correct answer is indeed domain names into IP addresses. That is a server that is on your home network, on your ISP's network, on your campus's network, your corporate network that just answers questions like that for you. All right, second to last question, which of the following is not a built-in SQL feature to tackle race conditions? Begin transaction, commit, roll back, or enroll. We talked ever so briefly about this in the context of ending up with too much milk, recall. And the correct answer is. Indeed, enroll. All three of those, even though you didn't have to use them for problem sets, 7 or 9 are indeed, uh, features of SQL, uh, but enroll is not a thing. All right. And the very last question, try to answer this as quickly as you can. What does Professor Mayland say at the beginning of every CS 50 lecture? Welcome to Harvard's Computer Science class. Hello everyone, ready to code? All right, this is CS 50 or let's get started with some programming. All of these questions were in fact written by you all. All right. And the correct answer, I'm pretty sure with 98% of you saying so is all right. This is CS 50 and all right, this was CS 50, cake is now served.