All right, this is CS 50, and this is week 4, the week in which we take off the proverbial training wheels that have been the CS 50 library and reveal to you all the more what's going on underneath the hood of a computer in terms of its memory. We'll also talk about files and how you can actually persist information for a long time whether. A file you've downloaded or today that you've created yourself, but first I just wanted to share some artwork that two of your classmates, Avery and Marie, kindly made before class, which is a picture made out of Post-it notes, uh, some green, some purple, which collectively from where you are looks like what? Yeah, so indeed it's a cat that they made using only zeros and ones or green and purple pieces. And in fact, even though this is fairly low resolution in that it only has a few pixels this way and a few pixels this way, it's actually representative of how computers do actually store images underneath the hood. So let's actually start there. In fact, we've had this bowl of stress balls for some time here on the lectern, and if we take a beautiful photo of it, they look a little something like this. Of course, this too is a finite resolution. And by resolution I just mean how many dots go horizontally and how many dots go vertically, multiply those two together and you get some number of bytes, maybe in kilobytes, megabytes, or heck, if it's a massive image, it could be even bigger than that. But it is in fact finite. And if we zoom in on this image, you start to see a little more detail. But at the same time, if you keep zooming in, you start to see indeed that there's only finite detail. And when we go really zoomed in, you start to see actual dots or pixels as they're called. In fact, on almost any screen, any. The image you look at, if you look close enough by pulling your phone up to your eyes or walking really close to a TV, you may very well see the same thing because any image on a screen like this is represented by hundreds, thousands, millions of tiny little dots called pixels, and each of those pixels has a color that gives it collectively the appearance of stress balls in this case, or cats in this case. So in fact, among the things we're going to do this week and the problem set is actually have you write code via which you can manipulate your own images, um, not only. To understand what's going on underneath the hood, but to apply some of today's most familiar filters, so to speak. In fact, if we go all the way down here, you'll see that this image, of course, has multiple colors. We've got some white and some red and shades in between, but let's keep things simple for a moment and propose that instead of looking at these dots, we look at these zeros and ones. And let me propose that in a picture like this, any zero will be interpreted as black, any 1 will be interpreted as white accordingly, if you can see it. What is this a picture of? 00, smiley face is in fact right because if you kind of focus only on the zeros and try to ignore those ones as I can do here for you, you'll see that embedded in that image was in fact this smiley face. Now this would be a sort of one bit image. You either have a 0 or 1 representing each of the colors. In modern times we would actually use 16 bits per color, 24 bits per color, maybe even more, and that's how we can get every color of the rainbow instead of just something black and white. But in effect, what's happening here is If you did have a file on your Mac or PC or phone storing this pattern of zeros and ones and you opened it up in some kind of image program or like the photos app, it would be depicted to you visually as this simply a grid X and Y, where some of the dots are white, some of the dot dots are black. All right, so with that said, how, what kinds of um representations might be involved here? Well, we can actually rewind to week zero. Recall that we talked briefly about RGB, which just means red. green and blue, which is one of the most common ways to represent colors inside of a computer. And if any of you have ever dabbled with Photoshop or similar editing programs or if maybe in high school or earlier you made your own web pages, odds are you're actually familiar with a syntax we're going to see a lot of today. This doesn't add anything intellectually new. It's just an introduction to a common convention for how else we can represent numbers. So this is a screenshot of Photoshop's color picker, Photoshop being a popular program for editing photos and files, and you'll see here that My selected color looks to the human eye as black, and I've highlighted here how I got that. I chose black by typing in 00,0000, which also if you look up here means that I want 0 red, 0 green, and 0 blue, and yet we somehow translated to 60s instead of just 3. Well, if we take a look at another color like white instead, I claim that you can represent white in Photoshop and today in code with FF FF. or equivalently 255 red, 255 green, 255 blue. And here, if you think back to week zeros, maybe a hint at where we're going with this. If you're using an 8 bit number, which means then you can count from 0 on up to 255. So recall that 255 is like the biggest number you can represent with just 8 bits. And yet somehow there's going to be a relationship between the 255s and these Fs that we see down here. Let's just run through a few more. If we wanted to represent something like Red, we're going to use FF 0000. If we want to represent green, we're going to use 00 FF 00. And lastly, to represent blue, we're going to use 0000 FF. So what's going on here and why do we have just this different convention? Well, it turns out in the context of images and also memory in general, it's just human convention or programmer convention to use this alternate representation of numbers, not the so-called decimal system, but another one that's not all that. Far off from what we've been doing over the past few weeks. So here again was the binary system. You've got just two digits in your vocabulary, 0 and 1. Here is the familiar decimal system where you've got 10 instead 0 through 9. Suppose we wanted a few more digits. Well, we're sort of out of Arabic numerals here, but I could toss into the mix like A, B, C, D, E, and F either in lower case or uppercase. And in fact, that's what computer scientists do when they want to have more than just 10 digits available to them, but as many. 16 digits available and in fact when you want to use this many digits, you call it hexa decimal, implying that you've got 16 digits, aka base 16. Now this, there's an infinite number of base systems we could do base 3, base 4, base 15, base 17 on up, but this is just one of the relatively few conventions that are popular in computing. And let's just tease it apart because we're going to see these kinds of numbers a lot. Well, thankfully, like in week zero, like it's the same old number system with which you're familiar with the. Columns and the placeholders, it's just the bases in those columns mean a little something different. So instead of using powers of 2 or powers of 10, we're going to today use powers of 16. So 160 of course is 1, 16 to the first power is 16. So we have the one's column, the 16s column, and so forth. Meanwhile, if we wanted to therefore start counting in hexadecimal, this two digit number in hexadecimal is of course the number you and I know in decimal as 0 because it's still just 16 times 0 plus 1 times 0. This in hexadecimal is how you would represent 1, but you would say 01 or 01 instead of just 1 to make clear there's two digits. This would be 02 03 04 05, 6789. Now things get a little interesting. In the decimal world we're about to carry the 1 and give ourselves two digits 1 and 0, but in hexadecimal you can keep going. So the next number in hexadecimal is going to be 0 A. 0 B 0 C 0 D 0 E 0 F. and now things get interesting again. What probably comes after 0 F, even if you've never seen hex before? So 10 you still still carry the one as before. This goes back to 0. And why is this now appropriate? Well, how many digits did we just, how many numbers did we just count through? Well, we started at 00, we went up through 0F and that's a total of 16 combinations. So the highest we counted, let me rewind this number here of course is going to be 1 times F, but what is F? Well, let's rewind further. In fact, let's have our little cheat sheet here. If we want to have these. Digits at our disposal, I dare say that 0123456789, 1011, 1213, 1415. So F is just going to represent the number 15. So if we now fast forward back to where we were just counting from 0 on up through 0A through 0F, we land here. This of course is 16 times 0.1 times F, which is 1 times 15. So this is how in hexadecimal you would represent the number 15. This in hexadecimal is how you would represent the number 16 instead, 15 to 16. This is not 10, that's how you would pronounce it in decimal. This is 10 in hexadecimal, because 16 times 1 plus 1 times 0 gives us, of course, 16. Now we could do this toward infinity, but. We won't 12, 13 dot all the way up to FF. So quick mental math, 16 times F, that is to say 16 times 15 plus 1 times 15 is any guesses? It is in fact 255. You don't even have to do the math because if you just think about where we were going with this, indeed we saw pairs of F's in the Photoshop screenshots because this is how a computer would represent the number you and I know in decimal is 255 by just using two Fs. So why do we care about hexadecimal? Well, it turns out that it's just convenient to use two hexadecimal digits to represent numbers because a single hexadecimal digit can be used to represent 4. Bits at once. For instance, let me go ahead and explode this by putting a little bit of space between the two digits here and let's consider how you would represent F. Well, if F is 15 and you want to represent 15 in binary, I think that's just going to be 1111. Now why is that? Well, 1 in the 8th place plus 1 in the 4th place plus 1 in the 2's place plus 1 in the one's place indeed gives me 15. So using a single f. I can count up, as we've seen already, as high as 15, but of course I've claimed in the past that it's super common to use 8 bits at a time or 1 byte to represent any value because that's just a very useful common unit of measure. And so in hexadecimal, if you wanted to represent 4 ones, you can say F. If you want to represent another 4 ones, you can just say F, which is to say that F and F together is just like the same as 81s together. is how we finally get to the total number of 255 because this is the one's place, the two's place, the 4s place, the eights, 1632, 64, 128s. But if you group these into clusters of 4 bits alone, you can represent all of the possibilities from 0 through 15 just using zero through F. So with one hex digit you can represent 4 bits, which is a long way of saying is it's just convenient for that reason, which is why the world tends to use hex when. Talking about colors and as we'll see memory as well. So in fact, let's consider what is meant by memory and what's going on inside of the computer when we've been storing values thus far. Well, here's that canvas of memory I proposed last time I proposed last time and before that we can sort of number these bytes arbitrarily but reasonably. This is byte 01234567, and maybe this is by 15. That's fine. Nothing wrong with that. But in the real world, any programmer would actually think of these locations instead, not in decimal notation, but in hexadecimal notation just because, because it's convenient for the reasons discussed. So we would actually number these from 0 on up through 9 and then keep going with A, B, C, D, E, F. And so forth. So what does that mean for the other digits? Well, this would be 10, this would be 11, this would be 12. Here now is 19, but here's 1A 1 B 1 C 1 D 1 E 1 F, and so forth just using hexadecimal notation. But there's arguably some ambiguity here. For instance, if you just at a glance were to look at this board and see this address 10, is that by 10 or is that? By 16, it's just non obvious because if you don't know what base system you're working in, which you could infer by looking at the rest of it, it could potentially be ambiguous. So in the world of hexadecimal, super common to literally prefix any number you ever write in hexadecimal notation using zero X. The 0 doesn't mean anything per se or the X, it just means what follows the 0 X is a number in hexadecimal notation, which makes unambiguous the fact that OX 10, which if you do the math and decimal again ends up being 16, not of course the number 10. In short, today you're about to see a lot of zero X's and a lot of two digit or 4 digit or eight digit numbers in hexadecimal notation. Generally we don't care what the numbers translate to. You don't need to do a lot of math, but it's going to be commonplace to see syntax like this. All right, back to sort of normal time. So here is a line of code. Inn equals 50 wherein me might want to declare a variable called N and store a number like 50 in it. Let's actually go ahead and do this simple now as it probably is in a file called how about addresses.c. We're going to play around with computer addresses, and in addresses.c I'm going to do something super simple at first whereby I'm going to include standardio.h. Then I'm going to go ahead and write in main void, with no command line arguments here. Then I'm going to declare this variable n, set it equal to the arbitrary but familiar value of 50, and then just so that this program does something mildly useful, let's go ahead and print out with percent I and a backslash N that value of N. So nothing new here. I'm just literally going through the motions of declaring a variable and printing its value. So let's do that. Make addresses, enter addresses, and hopefully I'll indeed see the number 50. So. Not all that much going on in the code, but let's consider what's going on in the computer's memory. This line of code and the one after it is giving the results of that program, but where is that n ending up? Well, here's my grid of memory, and let's just suppose for the sake of discussion that the 50 ends up down here. Maybe there's other things going on in my program, so this part of my computer's memory is already in use, so it's reasonable that it could end up in this location here. But what is important is that how many bytes am I using for N apparently. 4 and that's because we've said integers tend to be 4 bytes, AKA 32 bits, so this is at least 2 scale, even though I'm just imagining where it ends up in memory. So that's where the 50 actually ends up. So when I actually call printF and pass in N, clearly the computer is going to that location in memory and actually. Printing out that value, but that value is indeed at a specific memory address. It's not going to be quite as simple as OX 0 or OX1 or a small number typically. It's maybe it is going to be something arbitrary like OX 123, where I'm just making this up. It's an easily pronounceable number in hexadecimal notation. All right, so what can I use that information for? Well, thus far this hasn't been useful to us, but certainly programs we've been writing have actually been making use of this. But with a bit more syntax I can actually start to see things like this, not just on the screen but in code. In fact, let me propose that we introduce two new operators and see, so 2 new pieces of syntax. One is a single ampersand and one is a single asterisk, and we'll see that the asterisk has a few different uses, but the ampersand has a very simple straightforward one which is to just get the address of a variable in memory. So if you've got a variable like N, if you prefix it with ampersand N, you can actually ask the computer at what address is this variable. Stored. You can find out if it's indeed OX123 or something else altogether. So in fact, let me go ahead and do this by going back to my addresses.c program and let's see if we can print out not the value, which is obviously going to be 50, but let's actually print out the address thereof. So up here in my code I'm going to change the N on line 6 to be ampersand N instead. And I'm going to go ahead and make one other change because yes n lives at an address and yes that address is technically a number but it's conventional not to use percent I to display that number but rather another piece of syntax which is just a new format code which you don't often need. This is more demonstrative than useful I would say, but percent P is going to be what we use when we want to print out an address of something in the computer's memory. So back to VS code one more change. I'm going to change my percent I to percent P instead. So at this moment we should see a version of the program that's not going to display 50 anymore, but something like OX 123, but probably a bigger number than that because my computer has way more memory than that address suggests. So let's again make addresses. Let's run addresses, and indeed this variable at that moment in Time apparently lives somewhere in the computer's memory at address OX7 FFFD3C34 ECC. All of those are hexadecimal digits. It would be painful to do the mental math to figure out what the numeric address is, but we're seeing it indeed in this common hexadecimal notation, which is not going to be often useful for us as humans, but the computer is and has been using this information for some time. So in fact what we're about to introduce is admittedly one of the more complicated concepts in computing and in C in particular, namely a topic called pointers, and I will say today more so than ever might feel like a bit of a fire hose. In fact, all these years later, I still remember the day in which I finally understood this topic, which was not the day of the lecture in which I was introduced, but it was in like the back right corner of the Elliott House dining hall. I was sitting down during office hours with my teaching fellow, and he finally helped. light bulb go off over my head. So if some of this feels a little arcane today, it just comes with time and with practice like everything else. So what is a pointer? A pointer is going to be a variable that can store in address. Now, yes, that address is technically just a number like an integer, but we distinguish between integers that we care about like 50 and things we might do math on, and a pointer which in this case is just going to be the address of a variable, uh, the address of a value in memory. So what does this mean? Well, we can start to do things like this. I can declare my variable N as before and set it equal to the value of 50, but I can actually get the address of N. And put that address in another variable, and that variable we now call a pointer. So P is going to be the name of this variable. It's going to store the address of n, which we can get using the ampersand, but there's one more piece of syntax which I promised before this asterisk here, and the asterisk here means that this variable p stores the. Dress of an integer, not an actual integer per se. It's weird looking syntax. It kind of looks like multiplication, but it isn't. It's just the developers of C decades ago decided to use an asterisk even though it's admittedly non-obvious what it's doing. But in this context, when you see an asterisk right after a data type like in, it just means that the variable in question is not going to be an in per se, but an address of an integer. OK, so let's put this to the test using a line of this code in my own file here. Let me propose that we do this. Let me go back to VS code here. Let me introduce this additional variable in P as it's typically pronounced, set that equal to ampersand N, and then do the exact same thing as before. Let's not print out ampersand N, but let's actually print out the value of P itself because P is now equivalent to ampersand N. So let me go back to VS code. Let me do make addresses again. And huh, I did something wrong and stupid here. This was not meant to be the moral of the story. What did I do wrong? Yeah. Yeah, I just missed the semicolon, so still making those mistakes here. All right, and I'm gonna clear my screen again and do make addresses enter addresses, and now I should indeed see the address of N. I just so happen to temporarily store it this time inside of a variable called P. Now just so you've seen it, it turns out that when using this syntax of using a star to declare a so-called pointer and ampersand over here to get the address of something, you might see in online references in such different formattings of this. This is the canonical way to declare a pointer in space, then the star, then without a space, the name of the variable. However, it will work and you will sometimes see that the star is over here or the star is in the middle. But again, we would recommend stylistically that it just go here. Admittedly, I think it would have been clearer if the star were over here, making clear that it's related more to the in than it is to the variable name, but This is simply the convention. So this means hey computer, give me a variable called P that's going to store the address of an integer and the ampers is just saying Hey computer, tell me the address of N and it's the compiler and computer itself that decided where to put that variable in memory.ues. Would you get an error if you didn't put the asterisk? You would. And let's take a look. So let me go ahead and clear my terminal. Let me go ahead and delete the star before the variable P. Now let me go ahead and do make addresses again, and indeed I'm getting an error incompatible pointer to integer conversion initialized. And even though that's a lot of big words, it kind of says what it means you're trying to go from a pointer on the right to an integer on the left, which is just not appropriate here. Yes, at the end of the day they're all numbers, but it's more properly a pointer or an address on the right, but a little old in now incorrectly on the left. So the fix there is just to indeed put it back. Other questions on this new syntax, yeah. like Indeed, to recap the question, can you use the address of operator to find the address of other data types like strings? Absolutely, and we'll do that with a couple of examples today as well. We're just using it to keep it super simple initially. Other questions on these addresses and pointers. Correct, correct. Even if it's not an ant in question, we'll come back to other data types in a little bit. You're still gonna use the star that is the same syntax for everything. And yes. Oh yes, can you tell the computer you want to store a variable in this address? That's where we're going in just a bit. Indeed, now that we have the ability to find out the address of something in memory stands to reason that we can go to that address ourselves and maybe poke around and actually put values there. And in fact that's, that's among our goals for. So let's consider how we might get there. So here now is my canvas of memory, and let me propose that the number 50 happen to get stored in the variable n down there at bottom right just because, and that's probably OX 123 or in reality a much larger address, but it's easier and quicker for us to just pretend it's at Xerox 123. What is actually happening in code when I declare P and put a value there? We'll recall a moment ago I declared P to be a pointer to an integer that is the address of an integer. So what's happening in memory is this if N is down here and happens to be at address OX 123, when I actually assign P to Ampersand N, that just literally takes that address of N. And puts it inside of P. Now P as an aside, happens to be pretty big. It turns out by convention on most systems, a pointer that is a variable that stores an address is actually going to be 8 bytes large. It's going to be 64 bits. Why is that? Our computers have so much darn memory nowadays and the gigabytes that you need to be able to count higher than 4 billion. As an aside, if you only used 32 bits. For your pointers, you can only count recall as high as 4 billion. 4 billion is 4 gigabytes equivalently. That would mean your computers could not have 8 gigabytes of memory, 16 gigabytes of memory. Your servers couldn't have tens of gigabytes of memories. We use 64 bits or 8 bytes nowadays for pointers because our computers have that much more memory. All right, so what is? Storing literally just an address like this. So when we wrote this code just a moment ago, what the computer did and has been doing for the past several weeks is literally just finding the location of N in memory and plopping that value inside of P, which itself is taking up a bit of memory, but by convention more memory, 8 bytes in this case. The thing is, who really cares about this level of detail typically as programmers, it's useful to understand what's going on, but rarely are we going to care precisely about where things are in memory. Today it is really about just kind of looking at what's going on underneath the hood. So in fact we can abstract away most of my computer's memory I would propose, because at the moment all we care about is P existing and N existing. So who really cares what else is going on? And frankly, generally I am not going to care that N is at a. OX 123 just that it is at an address that happens to be OX 123. And so the way a programmer or computer scientist when talking about design on like a whiteboard or frankly in sections in office hours on a whiteboard, we rarely care what the actual addresses are so we generally abstract the specific address away and literally represent pointers with arrows on the screen or on the whiteboard or the like. This just means that P is a variable that points to. The number 50 in memory. OK, questions on this mental model for what a pointer is. It's a pointer in like very much the literal sense. Oh, OK, so if you're on board with that, let me propose that we consider now um what these things look like maybe more physically. In fact, we've, we've got a couple of mailboxes here to make clear with a little metaphor that, uh, here is a physical representation of our variable, say P. Labeled as such inside of this is presumably gonna be the address of some actual value. That value at the end of the story is gonna be the value of N, which recall for consistency is that address OX123. So what happens when you actually try to. A locate a value in memory is analogous to sort of looking up something inside of these mailboxes which if you think of your computer's memory as hundreds or thousands of little mailboxes, maybe more apartment style where you've just got rows and columns of mailboxes as opposed to individual ones for single family homes, each of those mailboxes can contain the address of some value in memory. And so what's really happening is that if this is P. Not drawn to scale because they only make mailboxes so large. Inside of P is going to be an address like OX 123. And just to be dramatic, since there's a big football game this weekend, uh, here is a Harvard foam finger metaphorically like this pointer is like pointing at that value over there. And in fact we're going to see, as you asked a moment ago, can we actually go to an address in memory? We don't yet have the syntax for that, but we're about to, yes you can. And in fact if I follow what I'm pointing at, open up this location in memory. Voila, there is the 50 in question. So any time we're talking about values or we're talking about the addresses thereof, you can think of it analogously as being like physical mailboxes, one of which might contain a useful number like 50, 1 of which might contain the address of that value, and we now have the syntax we'll see to actually go from one to the other. Let me actually go back into VS code here, which in the most recent version of my program, what I was doing was getting the address of N and storing it in P, and then I was literally printing out P itself, and that's when we saw the big hexadecimal number. That is generally not useful, but it's maybe interesting to see that one time. Let me instead though introduce another use of that star. Asterisk operator that allows us, as was asked a moment ago to actually go to that address. So in this version of my program I'm going to keep n equal to 50. I'm going to keep p equal to the address of N, but what I'm now going to do is show you how syntactically I can print out not P but N. But by using P, following the proverbial uh foam finger metaphor by printing out percent I backslash N and printing out N instead. Now obviously I could cheat and just say N and print out N like in version one, but that doesn't really demonstrate anything interesting here. However, if. I only have P at this point in the story, it turns out you can use the star for another purpose. If you simply prefix your variable name with a star, that is the so-called now Dreference operator, which means go to the address in P. So if I now open up my terminal here, do make addresses for this version, then do slash addresses and enter, I now get back the number 50. So what's really happening? In line 5, as has been true for several weeks now, we have. A variable called N being initialized to the number 50. Then on my next line 6 I'm declaring P as an address of some value, an integer specifically, and putting the address of N in there exactly. And then on line 7 I'm actually saying print out an integer. percent I as we've done for weeks, but what integer? Go to the address in P and print out what you find there. So that's equivalent again to the foam finger which is over there, pointing at the address I actually want to print out instead. OK, so. Usefulness. Well, I think we can get there by taking a look at one of our little white lies that we've been telling. In fact, let's turn our attention to strings, which up until now have been a sequence of characters in the computer's memory. A string is a thing in programming more generally, but in C, it technically doesn't exist by this name. But you can still use strings in C, but just not by calling them. T R I N G as the actual data type. But let's let's start with our familiar code here. Let me go into addresses.c. Let me add our trading wheels in for now and include CS50.h because in this version of my addresses program, what I want to do is declare a strings and I'm going to set it equal to high. Then, as we did in week one, let's go ahead and print out with percent S backslash N that value of S. So nothing new, nothing interesting here, so let me just do it quickly and do make addresses, then slash addresses, and we see high on the screen. So that has all been something we've been taking for granted, but let's consider what is going on underneath the hood of even that program. So the string we've declared in memory exists somewhere in the computer's canvas of memory. So strings equals high might end up somewhere down here, and I'm going to stop drawing all of the boxes when not necessary, but here we have HI exclamation point and as we discussed two weeks ago. The null character and UL, which just means the string stops here. So as a quick refresher, even though the word is three characters, it takes up how many bytes, 4, always because you need that null terminator. All right, so maybe that string could be accessed then by its name, S, and we've seen this before. S 0 is the first character, S 12, and then if you want to poke around, you can go into S3, but you'll probably see quote unquote. All on the screen or the compiler will sort of the computer will sort of remind you that you don't really want to look there at that point. So 3 characters accessible via this array syntax, but we know now that everything in the computer's memory is addressable and maybe that H just so happened to end up at OX 123 and the I ends up at OX 124, 125, 126 respectively. It doesn't matter what these numbers are, but because strings. Are sequences of characters back to back to back in memory, it must be the case that these addresses are themselves contiguous back to back to back without gaps inside of them. That's how a string has always been stored in memory. It's just an array of characters. All right, so with that said, what really is S? We've thought of S in every program we've used strings in before as just a string like that is the sequence of characters or really it's the name of an array. But that's a bit of a white lie because what S really is, is going to be a more specific value. Take a guess, what is actually going to be the value in S? Yeah, the address of, if I may, that array. So we've got like sort of 4 possible answers here, A, B, C, and D, multiple choice. Which of those numbers probably makes sense to store in the variable called S in order to get to this string? What is S's value? Yeah. 0 X 123 is correct. So we don't talk about this in like week one because like it's already hard to like remember semicolons in week one like God forbid start thinking about like what these specific addresses are. S is a string, yes, but technically S is and has been since week one. A pointer, the address of an array of characters in memory. The address specifically of the first character in memory, which is sufficient. Why? Because of this null terminating convention that we talked about weeks ago that tells the computer where the string ends the. Pointer tells the computer where the string begins, and that's how you get using just numbers, zeros and ones inside of a computer to store something as interesting as an actual string. So in fact, let's let's take a closer look at this. In fact, let me go into. Uh, VS code again, and just for the sake of discussion, let me declare S as before, but instead of printing out, uh, the whole string at once, let's go ahead and do this. Print F, uh, quote unquote per P backslash N. And then let's print out S itself initially to see whether it's actually OX123 or presumably a much bigger number. Then after that, let's print out another pointer, another address rather per P backslash N, and now I'd like to print out the address of the first character of S, but let's, let's not get ahead of ourselves. Let me go ahead and make addresses again. Dot slash addresses OK there now in this high program is the address at which the string itself is stored OX 5A 7143027004, so bigger than OX 123. Well, let's now poke around. What if I were to do this? What if I want to print out the address of how about the first character in that string? Well, at the moment recall that S 0 is literally the first character that is a char. So with what syntax could I get the address of the first character? Well, we haven't learned all that much that's new today. It's just a single ampersand that will get me the address of that character. If I do this for the next character, I can see one after another, and in fact this is going to have 4 characters in total, including the null character. So let me copy paste, which is generally frowned upon but not for a lecture demo because we're just trying to do this quickly. Let's print out. The address of S itself and then more specifically the address of S's first character, the address of S's second character, 3rd, and the address of that null terminator. All right, let's go back into make addresses. Let me go ahead and clear my terminal and do slash addresses and we see if I zoom in on my terminal here. The following S itself contains OX 561999 BD 0004 and the address of the first character in S, AKA S 0 is exactly the same thing. The next character, the. High and high is one bite away. The exclamation point is one more bite away, and the null Terminator is one more bite away. So again, bigger numbers, but the point is these are indeed just the actual addresses of all of these characters in memory. Alright, let me pause for any questions here. Yeah. Why do you need Good question. Why do I need the ampersan before the specific characters in S but not S itself? Think what S actually is. I'm claiming for the moment that S itself is the address of that whole string, which just so happens by design to be equivalent to the address of the first character, because that is the convention humans came up with decades ago to represent a string. Now you might think that you need the address of every character in the string, but no, that's why humans decades ago decided to just terminate every string in memory with The backslash zero or null terminator, because if you give me the beginning of the string and the end, I can obviously with a loop find everything else in between. Other questions? All right. Well, what is then this actual thing in memory? Well, it turns out that S is, yes, a string as we've been describing it. It turns out that yes, S is a string as we've been describing it all this time. But technically, I think we're ready to reveal what little white lie we've been telling or if you will what abstractions actually is in the CS 50 library. The type you know as string since week one, all this time has simply been a synonym for char star S. This is where. Maybe so what does this really mean? Well, we saw in P earlier here we're seeing char stars, but what does that really mean? Well, S is the name of the variable and yes it's a string, but what is it really? S is the address of a char. And so in week one of the course in the actual CS 50 library, we've told this little white lie by just creating a synonym in the library. That makes char star, so to speak, the exact same thing as string, S T R I N G, just so that we don't have to think about this level of detail, let alone hexideecimal notation and addresses and pointers and dereferencing and all of this complexity in the first weeks of the course. It simply abstracts away what the char what a string actually is. And in fact we've seen this technique. Or in a more complicated way, in fact, if you recall a couple of lectures last week, we actually claimed that you could create a phone book, for instance, using persons and persons have names and numbers, and we created our own type by saying type death and that type was a whole structure which is the complexity part, a structure containing a name and a number, and we gave that data type ultimately. The keyword person. So we've already invented in class our own make-believe data types to create things that didn't come with C itself like a person. Well, the struct is very specific to what we were trying to do with the phone book, but typede is more generally useful because it literally allows you to define your own type. So for instance, if we wanted to create a synonym. For in, because we never remember what it is and call it integer, instead you could simply say typed in integer semicolon, and that would create in your programming environment a data type called integer that is literally equivalent to in. Now this is not all that useful, so instead in the CS 50 library, we do use TyD to tell the computer thatcharStar should instead be spelled as string. Semicolon, and that just means that string ever after is the same thing as saying char star. So all of this time since week one, I could have been doing exactly that if I wanted. And in fact, if I go back to VS code here, let's simplify this quite a bit and go back to the very first version of the program wherein I use percent S and just print it out S is value itself, the string high. Well this of course is going to work as always as follows. It's just going to print out high on the screen. But now, if I get rid of the CS 50 library and try to recompile this, notice we'll get an error that I think I've seen before. Here we have, if I scroll up to the very first line, use of undeclared identifier string. Did I mean standard in? And no, I don't, and no I didn't a couple weeks ago when I accidentally did that, but the compiler does not know about the keyword string at the moment. Well, that's fine. Even if I don't have the CS50 library installed on this computer, I can just get rid of the word string, which is a concept but not a. Keyword in C and just rename it to chartar and now in my terminal window I can do make addresses again, slash addresses, and voila, we're back in business with no CS 50 training wheels whatsoever because printF knows given a charge star, go to that address, print, print, print, print until you get to the null Terminator and then stop printing. There's a loop in there that does exactly that. Questions on char star or what a string actually now is. Yeah, in front. I I know. Good question. How does print F know to keep going until it gets to the null, the format code? Because I've been using percents, which means print a string, instead of percent C, which means print a single character, print FC is that percents, and it was like, oh, I should use a loop to print out all of the characters until the null terminator. If I instead passed in just percent C, it would stop after a single character. Other questions. Good question. Why don't I de-references in order to print it out? So let me try that for just a moment here. Why do I not have to now or any week prior do stars here? Because after all, if S is the string, I want to go to the string and print it out. Well, the first answer is that print F is doing this for you because it's being handed the address and it is going to the address for you. So that star is somewhere in print F's implementation. But this is also incorrect conceptually because yes, S is the string, but more technically today S is the address of the first character in the string. So I really want to provide print F in this case with the address, not the specific character because I wanted to treat it as a string, not a single character indeed. So I could use the percent S if I changed to uh I could use S if I changed to C to print out the single character. All right, so let's play around just syntactically for just a moment here. In VS code, let me propose that we still use ChartarS here and then just demonstrate exactly what's going on. So I'll do exactly what was just asked. So I'll use percent C, and then I'm going to go ahead and print out for now our old week 2 syntax treating S as an array. So S 0, S1 and S2. Using some copy paste just for time's sake. This of course is not going to do anything all that interesting, but it is going to demonstrate that indeed we have HI exclamation point back to back to back in memory. And if I really want, I could print it all in one line by getting rid of, of course, those new lines. But what more can I do with this syntax? Well, I could take literally the fact that S is the address of the First character in memory. So instead of using this array notation which we introduced in week two, I could technically go to the address of S. Why? Well, S is the address of the first character of the string. Star S means go to that address and voila, you're at the first character by definition of what S is. So I could print out the first character using S instead of S bracket 0. How could I do this? Well, here's where we can actually take advantage of the fact that pointers and addresses more generally are in fact. Numbers and you can actually do arithmetic on pointers themselves. In other words, there is a concept known as pointer arithmetic, which means given an address you can add to it, subtract to it. Heck, you could even multiply or divide, even though that would probably be weird in most cases. We could certainly add numbers to an address. So for instance, if I want to print out the second character of S, that's kind of equivalent to going to S. But then moving over one character, so maybe I should do a little bit of pointer arithmetic and do S + 1 in parentheses just so that like in math class we do order of operations correctly and then down here I could go to S again but wait a minute, I want to go to S plus 2 characters away or 2 bytes away. So now I can do make addresses down here and I did mess up up new mistake, unintentional. Yep, I forgot my parenthesis on the very end here, so that was just user error. Make addresses again, addresses, and now I indeed see HI one more time using pointer arithmetic instead of our familiar array notation. So what is that array? It's what we would generally call syntactic sugar, which is a very weird way of saying like it's just nicer syntax. Like no one wants to write code that looks like this. It sort of, you know, bends the mind a little bit to read and parse all of this visually. Just S 0 is much more straightforward, but what it's really doing is this, and the computer is essentially converting that bracket notation for us into this more esoteric but correct version instead. All right, what else can I do? Well, just for fun, for some definition of fun, let's go ahead and print out three different strings and recall that a string is a sequence of characters that starts at some address. So let's first print out the sequence of characters that starts at S. Let's next print out the sequence of characters that starts at S + 1 and let's lastly print out the string that starts at S + 2, just playing around with the definition of what these pointers are. Let me do make addresses and uh. Not my day. What did I forget? Semicolon. So if it happens to you, it happens to me too. Make addresses slash addresses, and now this one's gonna be a little curious, but I see hi, I, and just exclamation point. Why? Because I'm treating a string literally as what it is, a sequence of characters, but I'm giving print F the address of the first character. Initially then of the 2nd character, then of the 3rd, but all three of those statements work because all three of them happened to be terminated by the same null character, even though I, and the exclamation point alone was not really my intention. That doesn't stop me from being able to do it nonetheless. All right, well, let's do one other maybe application of this idea. Let me propose that. Let me propose that we take a look at our computer's memory here and let's suppose that we want to start comparing values because in week one we did a lot of that and even in week 0 we did a lot of that with if and else if and else and so forth. So let's make this a little more real and also reveal why last week we had to solve an unexpected problem using another string function, namely stircom STR CMP. So here for instance are two arbitrary. A variables in memory I and J and I gave them both the value of 50 and maybe they indeed end up there, each of them taking up 4 bytes. Last time recall that we weren't able to compare two values in memory just by using the equal equal operator unless those values last time were actually integers. In fact, let's do that. Let me go back into VS code here, close out addresses, and let's code up maybe another version of my compare program from last, uh, from the past. This time I am going to use. The CS 50 library just to keep things simple initially. I'm going to include both it and the standard IO library here. I'm going to give myself Main with no command line arguments and then in Main I'm going to declare exactly what we just saw on the screen a variable I set to 50, a variable J set to 50, and then we're going to do our old familiar syntax from week one. If I equals equals J, then let's go ahead and print out something like same backslash N else let's go ahead and print out quote unquote, uh, different. Backslash N. So super simple program that simply compares two variables that yes are obviously going to be the same, but let's do this. So let's do make compare slash compare. They're in fact the same. OK, so that actually works as intended, but why didn't it work last time when we tried comparing strings, the solution to which was actually to introduce stircom. Well, let's go back to VS code and resurrect that buggy example initially. In fact, let me go into VS code here. And instead of using, say, integers, let's go ahead and do this, and I'll rename them just by convention. So my first string will be quote unquote, let's do my first string will be whatever get string gives me. So we'll prompt the user for S. My next string will be called T by convention. And I'm going to ask the user for that. Then down here, instead of using I and J, which are common for integers, I'm just going to use S&T, which are common for strings, and just ask literally the same question as we have in the past. All right, let me go ahead and do make, uh, compare. And, wow, what's the error? Well, I'll show you the error message. What did I unintentionally do wrong here? Yeah, I'm getting a string, but I'm trying to store it into an end, so this is just frowned upon. So let me go ahead and change that to what I should have typed the first time. Give me a strings and a string T. Now if I do make compare, we're back in business. All right, let me do compare, and I'm going to go ahead and type in, for instance, let's say hi and both for S&T, which are obviously clearly. Different. Now we've tripped over this before and recalled that the solution was indeed to introduce a function called stom, and I explained it at a high level, well, that's because you're not just comparing two values, you got to compare character after character after character, and that's what indeed Stircom does. So let's go ahead and do that. Let me go back into this file. Let's go ahead and include. The string library at the top here and instead of doings equals equals t, let's do if the string comparison of S and T happens to equal equals 0, which per the documentation for the function means they're equal instead of one before or one after the. Uh, no, I did not get it wrong this time. I got it. Um, yes, so how do we actually go ahead and compare the strings this time? Well, let me go ahead and do make compare compare and now type in exactly the same thing, and now they're in fact the same. And just to demonstrate that this isn't just some fluke, I can type in hi, for instance, and by, and those are in fact different. So clearly Stircom is doing something useful, but what is it actually doing? Well, first of all, Let's make clear that what was a string last week is technically a char star this week, so I can remove that training wheel. I'm still going to include the CS 50 library because as we'll see by the end of class today, get string and get into and all of those get functions from CS50 are actually still useful because it's a pain in the neck and see still to get user input without using functions like those, but I'm going to get rid of the data type that we thought was called. string. This will still work exactly as before if I do make compare compare and type in high and high, we're indeed seeing that they are now the same. So what's actually going on inside of the computer's memory with strings? Well, I would offer thats probably ends up like over here in memory and then maybe it actually has its characters down here. So notice the duality S as of now. Is an address, which means it takes up 8 bytes or 64 bits, but the actual characters, it turns out, end up somewhere else in the computer's memory. And this is what's different about an in. The in I and the in J both ended up exactly where the variables were named. But with strings, the variable itself contains not the string, but the address of the first character in that string, which I claim could end up anywhere else in the computer's memory. So, uh that those addresses might be OX 123, 124, 125, and 126, for instance. Meanwhile, S is going to contain literally the address of that first character. When I create T in memory now, it ends up maybe over there taking up 8 bytes of its own. Down here ends up the second thing that I typed in, not at the same address but at OX 456 457 458459. Now if the computer were really smart and generous, it could probably notice, oh wait a minute, you typed that thing in already. Let me just point you at the other memory, but that's not how it works. When you call GetString, you get your own chunk of memory for whatever the human typed in, even if by coincidence it's exactly the same. So T's characters are ending up here, S's characters are ending up here. What value should go in T? Exactly 0 X 456 because that's the first address of the first character in T. So we put OX 456 there. So at this point in the story we have two strings in memory and two pointers there too. And so in fact if we kind of abstract that away, it's kind of equivalent to S pointing at the chunk of memory on the left and T pointing at the chunk of memory on the right. So why was string comparison actually necessary? Well, in this case, we wanted to make sure. That the stom function was handed the address of S and the address of T so that the stircom function written by someone else decades ago actually has its own 4 loop or while loop that essentially starts at the beginning of each string and compares them character by character by character by character. That's what it's designed to do. By contrast, when I was using equal equals a few minutes ago and also last week incorrectly to compare strings, what Was getting compared. Well, if you literally compare S equals equals T, that's like saying does OX 123 equal equal OX 456, and that's obviously not true because those are literally two different addresses. So the answer I was getting last week and today was correct. Those addresses are different, but conceptually, of course, I actually intended for the program to compare the actual characters in the string, not the simply. The addresses thereof. So how do we go about fixing something like that? Well, using Stirom ensures that we can actually go ahead and compare them character by character, and I don't need to create my own for loop or Y loop. The stom function does that for me. And we can see this too. If I go back to VS code here, get those two strings, and just for kicks, go ahead and print them both out using print F of percent Pslash N. Then let's go ahead and print out with percent P again backslash N for each of them passing in those variables S and T respectively. What I should see that even if I type the exact same thing, we're going to see two different addresses when I make this version of the program. Here's my first high, here's my second, and the two addresses are, it's subtle. Very much different. The first one ends in B0, the second one ends in F0, both of which are hexadecimal values. Question On any of that thus far Any que oh yeah question in front. Yeah. What's that? Really good question. When you create a pointer in memory or really when you allocate a string or an integer in memory, how does the computer decide where to put it? It uses different chunks of memory for different purposes. And in fact, one of the topics we'll look at after break today is exactly that how a computer decides where to lay things out. It's often very intentional and it is often auto incremented, so they'll go back to back to back when possible, but over time things will start to get messier, especially in larger programs where you're adding and subtracting values from memory all the time. So more to come. Other questions on what we have done here. All right, before we break, let's do one other example that elucidates perhaps what can go wrong without understanding some of these underlying building blocks whereby let's go ahead and create a program this time that aspires to copy two strings, which seems pretty reasonable at a glance because it's certainly easy to copy two integers. You just set one equal to the other. That's not going to be the case. It turns out with copying a string. So let me open up how about copy.c, a new program, and I'm going to include a few. at the top we'll use CS50.h so that we can still use get string conveniently. We're going to include C type. H for reasons we'll soon see, but we saw that a few weeks back. We'll include standard IO as always, and lastly we'll include string.h. Inside of my main function, which won't take any command line arguments, let's go ahead as before and declare a string equal to get string and just prompt the user for a variables. Then let's go ahead and try to copy. Uh, S into a new variable T just like I would copy any two variables using the assignment operator. Then let's treat the copy, otherwise known as T now, as an array, which we're allowed to do per week two. So let's say the first character in T. We actually want to set equal to the uppercase version of that same character. So this line 12 at the moment is literally on the right hand side saying use the two upper function from the C-type library, which we used a couple weeks back, pass in the first character of the copy T. And then update the actual first character of T. So let's capitalize T but not S. Now at the very bottom of this program, let's go ahead and print out the value of S at this point in time, and then let's print out the value of T at this point in time. And when I go ahead and make this program called Copy and do copy, let's type in high no, let's do it lower case first. Let's do high in lowercase E. And we'll see curiously that S and T both got capitalized even though the only character I touched was T 0. I didn't touch S after making this copy. Now to be clear, what's going on, why don't we remove one of these training wheels so string really doesn't technically exist. It's always been a char star and this string is also a char star. So what's really going on? Well, more clearly now, S is the address of the string. Uh, that the human typed in, but he is a copy of what literally? The address of the thing the human typed in, which is going to be one and the same. So in fact, pictorally you can think about it this way. If here's my canvas of memory and the user is prompted for S and the user types in high in lowercase as I did and it happens to end up down there, what gets stored in S is going to be the address of that memory which for the sake of discussion is maybe OX 123. So OX 123 is what is stored in S. When I then on my second line of code create T, I get another 8 bytes of memory or 64 bits to store a point. star aka string, but what is put ins what is put in t literally SOX 123. So abstractly it's essentially equivalent to S and T both pointing to the same chunk of memory. So when I do t 0 and go to the zero or first character of T, that happens to be the exact same chunk of memory that S is pointing to. And so when that lowercase h becomes a capital H, it's as though both S and T. Have changed and recall too if you're enjoying the syntax, if I go back to VS code here, I did use a ray notation, but I equivalently could have said go to the address in T. Go to the address of that first character, which functionally is exactly the same. We're just not using the syntactic sugar now of the square brackets. That is why high is actually being capitalized for seemingly both versions. Of it, the original and the copy. So how do we go about fixing this? Well, we need a couple of new solutions, namely two new functions here. Mao is going to be a function that allocates memory, so memory allocation, AKA Mao, and then free, which is going to be the opposite, which is when you're done with new memory you can hand it back to the computer and say use this for something else. So using these two functions alone, I dare say we can solve now this. Problem in memory by making an actual conceptual copy of the string by copying HI exclamation point and the null character elsewhere in memory so that we can actually manipulate the copy thereof. So how do I do this? Well, let me go back to VS code here. Let me propose that we get rid of much of what we did earlier, except we'll keep around the Declaration of S. But now if I want to create a copy of S. It turns out I'm gonna need to ask the computer for as much memory as S itself takes up. So HI exclamation point takes up how many bytes in memory. 4 is correct because you need the null character. So how do we figure this out? You can do this. Let me give myself another string called T, but we don't need that white lie anymore. Another char star called T. And set it equal to nots, which we knew was going to go wrong, set it equal to the return value of this new function mao, which is going to return the address of a chunk of memory for me. How many bytes do I want? Well, technically I just want 4 bytes, so I could do Malloch of 4, and that will literally ask the operating system running in the cloud in VS code for. 4 bytes of memory somewhere in that black and yellow grid I keep drawing on the screen. I don't know where it's going to be, but I don't care because Mallock's return value will be the address of the first bye thereof. Now it's a little dumb to hard code for not knowing what the human's going to type in, but that's OK. We can do this more dynamically and use our old friend Sterling, ask the computer what is the length of S. And then Add one because we know that we need to additionally have an extra byte even though the length of high in the real world is 3, but we know underneath the hood we actually need that 4th byte, hence the plus 1. Now to use Malock, I actually need to add another library here, Stanlib for standard library.h, and that's going to give me access to the prototype for and in turn. The Mao function. Now with this chunk of memory, it's up to me to copy the string. So how do I go about copying a string from S into T? Well, I can do this in a bunch of ways, but let me propose that we do it like this for into i equals 0, I is less than the string length of S, whatever that is, I + plus, and then inside of this fairly mundane loop, let's just set this uh I. Value of T equal to the value of S, and copy literally, very mechanically, every character from S into T. Then down here let's go ahead and capitalize just the first character of T by using 2 upper as before with or without the syntactic sugar, and then at the very bottom of this program, let's print out the value of S itself just for good measure to make sure we didn't screw it up this time and let's print out the value of T just so we see that I in fact have capitalized T and only T, but I'm not quite done yet. There's a design flaw here and a mistake, but it's subtle. Does anyone want to pluck off one or the other? Check 50 and design 50 are not gonna like this. Yeah. Yes, because Stirling always returns the sort of real world length of the string, H3, this would seem to accidentally forget to copy the null character. So I can fix this in a few different ways. I could, for instance, at the bottom of my loop actually do something like T4 equals singles and manually terminate it myself because I know it's got to end with a null. This would be frowned upon too. I shouldn't be hard coding the 4. This is all too sloppy. So don't do this. What I could instead do is say go up to and through the length of S because if the length of S is 3, but I use less than or equal to, that thing's going to iterate of course 4 times because I'm starting at 0 as always. So that I think fixes that problem, but now the design flaw, which is subtle, but we've seen it before, yeah. Exactly. It's just dumb of me to be asking the computer what's the length of S? What's the length of S? What's the length of S? And every iteration. So this is why we introduced this trick where you can set another integer variable like N equal to that string length, and then after the semicolon just keep comparing I against N, which means you're not calling functions wastefully as before. All right, if I didn't mess up anything else, let me go into my terminal. Let me do uh oh, did I mess something up? I still, yes, I did mess something up. I should have put this back as well. Thank you. All right, so let's go ahead and do make copy, Escopy, and now, I'm gonna go ahead and type in high in all lowercase and hit enter. And you'll see now that s is unchanged. It's printed out again in lowercase, but t is in fact capitalized here. Now why is this? Well, in this case, what's happened is that I've got s in memory, but this time when I allocate T, I then use Malloch to get a whole chunk of memory here that initially just contains who knows what garbage values as we've called them before. I'll just leave them as blank here, but it happens to be. For the sake of discussion at OX 456, 78 and 9, when then I actually set T equal to the return value of Mao, it's as though T is just pointing to this chunk of memory. Then in my own loop when I go from zero on up through N, that just means to copy the H, then the I, then the exclamation point, and because of the equal sign also print copy the null character instead. So this is getting a little tedious though admittedly like this is a lot of work just to copy a couple of strings. Could we be doing this a little bit better? So we actually can because of the libraries we're including turns out there's functions for copying strings that come with C. So in fact if I go back to BS code here, I don't actually need any of. This for loop here so long as I have actually allocated enough memory for the string, which I do think I've had, I can actually use literally a function called stircopy STRCPY for short, and pass in the destination and the source in that order almost feels a little backwards, but that's the way it's done to copy S's bytes into T. It's easy to mess them up, but don't mess them up for the documentation, the destination comes first and then the source string. Instead, so if I do this now, let's do make copy. We're good to go. If I do scopy now and type in high and all lowercase, we still have preserved that good property. But let me propose that things can go wrong and in fact this is about to make the program look way more complicated than it feels ideal, but I've been a little lazy here. There's a bunch of things that can go wrong for which it's worth knowing about the return values of these here functions. So all of this time. It has been possible for certain functions we've been using, get string among them to return confusingly, this null value NULL again humans decades ago decided that one would be called NUL, other humans decided this new thing would be called NULL. NUL pronounced null, it's just a null terminator backslash zero. It is a single byte of 8 bits, all of which are zeros. That's been true for a few weeks now. NULL happens to be a special memory address, literally OX0 at which nothing is supposed to ever live. So whenever I describe the top left corner is this is address 0, this is 1, this is 2, humans years ago. Decided, you know what, let's just waste bye location 0 and never put anything there so that we have a special value to ensure that we can signal when something has gone wrong. So humans just decided don't use memory address OX 0 specifically and a few bytes after it. So what does this mean? Well, in my code all this time and since week one, frankly things could have gone wrong. So in VS code here I'm using Getstring and I'm using Mao and I'm using Stir Copy and all of these print statements here, but I'm not actually adding as many error checks as I should. So it turns out if you read the actual documentation for Get string, which in fairness we never told you about until now, in cases of error, get string can return null. Why would it ever have an error if the human types in such a large paragraph of text maybe that there's no room in the computer's memory for everything they've typed in? Well, you don't want to just get back part of the text and not know that something went wrong. Get string is designed to return a special sentinel value, NULL in all caps. That just means I can't oblige. I can't return you a correct value. Here's an error instead. So what I should always have been doing since week one, but we consciously don't because it adds just too much overhead, is check if S equals equals null, then we should abort the program altogether and for instance like return one, as we've done before to just signify error like we cannot proceed because get string did not work. That is true of Mallock too. Technically we should say if the address in T also equals null, that is OX 0, we should also return 1 because something. Uh, went wrong. So let's do this one more time. Turns out that even 2 upper is taking for granted the fact that the humans typed in anything at all. What if the human just types enter? Well, that's a valid string. It's the so-called empty string, quote unquote, but what is the length of nothing? It's going to be 0 and that's problematic because if you try to go to T at the first location, what is actually there? Well, that's actually the null character, which is not something you should even try to capitalize it would seem. So what we should really do here too is check only if. The sterling of S is greater than 0. Should you even bother upper casing that first character? I mean, one, at best it makes no sense because if there's no string, there's nothing uppercase. At worst I could break something by touching memory that I should not. And if I may, there's another issue now. On line 15, I'm asking the computer for memory, and it's going to hand me those 4 bytes, but technically I'm never giving them back. And so even though this program is so short that it's going to quit pretty soon and it's not a big deal, the computer will automatically reclaim that memory in long running programs that like servers or things that are running for a long time. If you use Malock and ask for memory but never give. Back to the computer, never free it, so to speak. Your computer might get slower and slower and slower and slower, essentially because it's running out of memory, not physically, but the computer thinks it's using all of its memory even if it's not actively in use. You, as the human know best and so at the end of this program, when I am completely done with T, you should similarly call free of T. Passing in the address that you allocated previously so that the operating system gets that memory back. If you don't do that, it's what's called a memory leak. If you've ever used a Mac program, a Windows program, iPhone or Android program that some of how it's just getting slower and slower and slower and slower, that is often a symptom of a human having messed up and not freeing memory that they don't actually need anymore. Questions on null or any of these kinds of checks. No All right, well, as a teaser, in just a bit we're going to reveal when and why things can go terribly wrong by way of a little bit of claymation from our friends at Stanford, but it feels like we're long past a good snack break. So why don't we go ahead and have some oranges and some fruit snacks, and we'll see you in 10. All right, we are back. So with memory, a lot of things can go wrong and in fact, a question came up during the break about whether or not I should have also called free on S, which was the string that I actually got back from GetString. The short answer is no. This has been a deliberate choice over the past several weeks whereby the implementation by CS 50 of GetString automatically frees memory that it has given to you once it is no longer needed, so that's a bit. Magic underneath the hood. Once those once you no longer use that though that feature goes away. But because I actually used Mao to get my memory for T, I did have to free that specific memory. So the rule of thumb quite simply is if you mallocked it, you must free it. If we get string mallocked it, you do not have to free it yourself. But of course things can go wrong and thankfully there are tools by which we can find memory related errors. And one thing we're To show you briefly is another tool called Valgrind, which is a nice complement to something like Debug 50 and PrintF and the Duck for actually chasing down specifically in this case memory related errors. So in fact, let me go over to VS code and open up a program I wrote in advance because it's just not all that useful, but it is demonstrative of some things that can go wrong. And in memory.c we have this code here. We include standardio.h and we include standard lib.h, the last. Of which recall is necessary now when you want to use Mao and in turn free and inside of this main function I'm doing a few things. I am first allocating 3 integers in kind of an interesting way because it turns out that Malloch takes as its argument the number of bytes that you want to get. Now I know on most systems an integer is indeed 4 bytes. So if I want space for 3 integers, I could just do 3 times 4 is 12 and put 12. the parenthesis here, but that's generally frowned upon because it would make my code less portable to other systems where it might not be 4 bytes. So turns out you can use this operator size of and actually ask the computer how big is a data type, like an ant on this specific system. And for CHARS you'll always get back 1. For ins you'll usually get back 4, and same goes for other data types as well, but this is the more dynamic way to ask that question if you want to get 3. Uh integers worth of memory. What I'm then going to do is assign on the left hand side the return value of Mao to this variable X just because an X itself is a pointer to an integer, more specifically to this chunk of memory, which is a sequence of 3 integers. This is very arbitrary and this is only meant to demonstrate things you can do incorrectly ultimately, but this is how I would dynamically get space for 3 integers. From Mallock and store the address thereof in X. So it stands to reason that I could put my first value at X1 equals 72, my second value equaling 73, and my third value equaling 33. Now if some of this is rubbing you wrong, like these are actually, there's riddled with mistakes already, some of which are old to us, what's the first thing I've done wrong, even if you have no idea what's going on with line 8? What about lines 9, 1011? What I do wrong? Yeah. Yeah, my indexing is wrong. Like we've known for weeks now that with the arrays or with the ray syntax you always start counting at 0, then 1, then 2, not 123. So that's an issue, and this is a new detail. But given that I've used Mao Online 8, what other mistake have I done in this version of the program? What's missing? Free. So I didn't actually call free so this program has a memory leak. It's asking for memory and never handing it back. Now that's pretty good, you know, a few of us were able to just kind of eyeball the code and debug it, but that's not gonna be true for all people, all programs, certainly when the programs get larger and more complicated, so a program. Like Valgrin's purpose in life is to help you spot these kinds of errors. So for instance, when I run, make memory to compile this program and then do slash memory at a glance, it actually seems perfectly fine if only because I'm not seeing any errors even when I compile it or when I run it. But I do claim that there's at least 2 that we've seen here. It's just we're not getting so unlucky that the program's actually crashing as a result. So this is a more latent harder to detect bug. But what I'm going to do now is this I'm going to open up my terminal window and full screen. I'm going to then do Valgrind space.slash memory so as to run the Valgrind memory checker on this. Program, so similar to debug 50, but the name now is Valgrind. This isn't a CS 50 thing. This is a common program that programmers use. When I hit enter, the output is going to be atrocious, frankly. It's more way more complicated than it needs to be. They put this number here, which means something specific, but it's just stupid that it's on every line of output. So it's overwhelming at a glance. But once you've trained your eyes to look for useful information, there's a couple of useful insights here. So one, invalid right of size 4 that apparently is somehow related to line 11. So let's go there. Let me use this minimize my terminal window. look at line 11 of memory.c and just see which line that was. OK, invalid right of size 4. Well, writing means like changing a value. Reading means accessing a value, so they're sort of opposites. Invalid right of size 4. Well, here's why it's generally useful to know generally how big an it is like 4 you're trying to write 4 bytes incorrectly. So why is line 11 invalid? Just to be clear, Because the index is off, like I'm touching memory that I should not. If I ask the computer for space for 3 integers, each of which is 4 bytes, that should give me location 01 and 2, not location 3. So you still have to know a little something about programming to be able to make good use of that information invalid right of size 4. But once you've sort of trained your mind and your eye to catch it like, oh, now I'm an idiot, I have to go in and fix that problem. But what else? Wrong based on Valgrin's output here. So this is kind of worrisome leak summary. Definitely lost 12 bytes in one block. I don't really know what 1 blocks means for now, but 12 bytes should be familiar because if you generally remember that an inch is 4 bytes and you ask for 3 of them, oh, there's my 12. So somehow I'm losing 12 bytes of memory, not in the literal sense, but it means by the time the program finishes, you have not returned or free. all of the memory that you asked for. So this line here is your hint that you've done something wrong with respect to 12 bytes in total. And sometimes you'll see slightly different output here. For instance, we see mention up here 12 bytes and 1 blocks are definitely lost in lost record 101, very verbose, but the juicy part is, ah, on line 8 is the source of that error specifically. So there too, it's a little bit of a bread crumb leading me to the solution for fixing this. So if I go up here. I look at line 8. OK, there's only so much that I could have done wrong on line 8 if I've mallocked the memory on line 8. Sounds like I do need to free it later on. So let's fix both of these problems. The first one is just the indexing issue. Change the 123 to 012. Let's then fix the second problem by just freeing X at the very end and just for good measure. This was not caught by Valgrin because it doesn't always happen, but there's one other scenario that could go wrong, and it relates to line 8. What should I be doing? Uh I am doing an array, but recall that we can use array syntax on chunks of memory. So technically what Lion 8 is doing is this it is allocating 12 bytes of memory from the computer just because, just to demonstrate how Malock works, and it's storing the address of that first byte in a variable called X. The bracket notation is just the syntactic sugar that allows me to change values at X's address. I could alternatively just use pointers and say go to X and put 72 there. Go to X + 1 and put 73 there. Go to X + 2 and put 33 there. Using pointer arithmetic, but those are identical and no, generally, you know, most people would just use square bracket notation because it's just a little cleaner and easier to read and write. OK, but back to this question, there's still a subtle bug here, based on our example just before break, what should you be doing any time you call Malock and get string, and a few other functions for that matter. Did I hear the answer? Checking for Checking for null, right, because if lock has an error, there's not enough memory for whatever reason, you should not be proceeding to touch that memory because it might be the null address that is 0 X0. So what you should really be checking is, well, if X equals equals null, there's no more work to be done here. Let's just return one down here and only if we get all the way to the bottom should we maybe return 0 to signify. Uh, explicitly that there is in fact successful operation. All right, with that said, let's go back down here, remake memory, no error messages from the compiler slash memory that too seems OK, but it was fine the first time. Let's now run Valgrin. Let me, uh, maximize my window. One run Valgrin.slash memory crossing my fingers as always, and now. This is actually pretty good. It's much shorter output even though it's just as scary at a glance, but most of this is fluffy and not very revealing. Heap summary in use at exit 0 and 0. So look, like all heap blocks were freed, no leaks are possible. Heap is a word we'll come back to, but this means there's nothing wrong. In fact, zero errors, which is a good thing. So in short, Valgrind is among the most arcane programs we're going to use. Its output was really designed for those more comfortable, if you will, but there's still juicy insights there if you just kind of look for things that lead you to like this file on this line number, odds are that will lead you to the most subtle of bugs. In fact, another type of bug is when we do indeed touch memory, we shouldn't. So let me zoom out on that, clear my terminal, and let me open up another program or maybe write this one real. Fast incorrectly. So let me create a program called Garbage.c to demonstrate what we've generally called garbage values, that is values that are still in memory, but I didn't put them there myself necessarily. I'm going to include standardio.h. I'm going to include standard lib.h. and then I'm going to go ahead and actually no need for standard lib this time. Let's do in main void. And inside of Maine, let's give myself an array of like way too many exam scores or whatnot. We used to do just a few, but let's say there's 1,0024. Then let's go ahead and do 4 in uh for in I equals 0, I less than 124, I plus plus, and in here, let's go ahead and print out, uh, whoops, let's go ahead and print out using print F each of those scores. Of course, I have clearly forgotten to do something in this program, which is what? I haven't actually put in any scores there for real. Like I've asked the computer, give me an array for 11,024 integers, but I've not used get into or even manually typed in any of my quiz scores, which we did in the past. That's because I'm intentionally trying to show us garbage inside of the. Computer's memory. What this loop is going to do on line 8 now is literally print out the first in, the second in, the 3rd in all 100 24 ins, but all of them should be garbage values because I myself haven't put anything in those dresses yet. So let's go ahead and make garbage. Let's go ahead and maximize my terminal window just to see more on the screen. Do garbage. It's going to be super fast output because the computer is way faster than 1,0024 variable values alone. There is a lot of garbage output. So when we talk about garbage values in the abstract, like here's just some random zeros, a 25, a 32,000, a negative number, and so forth, that's because it's essentially remnants from the computer's memory of stuff that might have happened previously, not necessarily by me in this moment, which is to say you just shouldn't touch that memory at all whatsoever. So now we're seeing garbage values for the actual first time. Let's consider another example of a program that doesn't contain that does. Contain potentially memory errors and let's look at this too. So this is not really a useful program, it's meant to be demonstrative of some of these concepts. So here we have a program takes no command line arguments. Up here we've got a line. That pair of lines that declares two pointers but doesn't yet initialize them to any variables and that's fine. You don't have to have an equal sign with any variable. You just eventually should assign it some value. But this just tells the computer, give me a variable X that's going to store the address of an end. Give me another variable Y that's going to store the address of another N. OK. What happens next? Well, on this line of code. This simple example, we're allocating enough space for a single integer just because it's a stupid exercise. There's no reason to do this other than to demonstrate how Mao works for the moment. Malloch returns the address of that chunk of memory, so that's what goes in X. So X is now pointing at somewhere in memory 4 bytes of space that it can certainly put a value at. How do we do that? Well, if you do X and use the D-reference operator, that means go to that chunk of memory and put the number 42 there. That's totally valid. This says, go to the address in Y and put the unlucky number 13 there. Unlucky quite literally because what is Y pointing to at this moment? It's just the garbage address. Why? Because if you don't initialize why, who knows what it's going to be pointing to. Maybe it's 0, maybe it's 25, maybe it's 32,000, a negative number, just like we saw in the previous example. You have no idea what values are going to be in X and Y unless you yourself put those values there. So this is highlighted in red because bad things are going to happen if you try to de-reference an invalid or a bogus pointer, even worse than just touching uh variables that might not have value. If you de-reference an address and try going to some random place, the computer is generally not going to like that. And in fact, our friends at Stanford wonderfully brought this particular scenario to life whereby even though this example is a bit contrived just to fit it all on the screen at once, it is going to be the case that bad things happen if we don't check for these values and actually assign valid values in the form of, as we'll see now, some claymation. So here I give you a binky. Uh, which is a bit of claymation from our friend Nick Parlante at Stanford if we could dim the lights unnecessarily dramatically. Hey Binky, wake up. It's time for pointer fun. What's that? Learn about pointers. Oh, goody. Well, to get started, I guess we're gonna need a couple pointers. OK, this code allocates two pointers which can point to integers. OK, well, I see the two pointers, but they don't seem to be pointing to anything. That's right. Initially, pointers don't point to anything. The things they point to are called pointees, and setting them up's a separate step. Oh, right, right, I knew that the pointees are separate. So how do you allocate a pointee? OK, well, this code allocates a new integer pointee, and this part sets X to point to it. Hey, that looks better. So make it do something. OK, I'll dereference the pointer X to store the number 42 into its pointee. For this trick, I'll need my magic wand of dereferencing. Your magic wand of dereferencing, uh, that, that's great. This is what the code looks like. I'll just set up the number and Hey, look, there it goes. So doing a D-reference on X follows the arrow to access its pointee in this case to store 42 in there. Hey, try using it to store the number 13 through the other pointer. Why? OK, I'll just go over here to Y and get the number 13 set up and then take the wand of D referencing and just. Oh hey, that didn't work. Say, uh, Binky, I don't think dereferencing Y is a good idea because, uh, you know, setting up the pointee is a separate step and uh I don't think we ever did it. Hm, good point. Yeah, we, we allocated the pointer Y but we never set it to point to a pointee. Very observant. Eh, you're looking good there, Binkie. Can you fix it so that Y points to the same pointee as X? Sure, I'll use my magic wand of pointer assignment. Is that gonna be a problem like before? No, this doesn't touch the pointees. It just changes one pointer to point to the same thing as another. Oh, I see. Now Y points to the same place as X. So, so wait, now Y is fixed, it has a pointee. So you can try the wand of dereferencing again to send the 13 over. OK, here goes. Hey, look at that. Now dereferencing works on Y, and because the pointers are sharing that one pointee, they both see the 13. Yeah, sharing, uh, whatever. So are we gonna switch places now? Oh look, we're out of time. I can only imagine how long that took Nick, but the key detail was that bad things happened to Binki when we did this line of code, de-referencing an invalid pointer that had no true value assigned. It was just some garbage value. Now what's the solution? Well, as Nick proposed, just don't do that and instead at least do something sensible like assign X equal toy, not to make a copy of anything per se, but to literally point X at the same location in memory. To pointy at the same location in memory as X, then a line like this is perfectly valid. You can go to that address, which happens to be the same as the 42, and that's why in the claymation form we saw that the 42 became a 13 instead. So again, at the end of the day, this is only demonstrative of these basic building blocks that we now have at our disposal, but also how easy it is to do things incorrectly. So this is one of those with great. Power comes great responsibility. C is one of the languages that is incredibly high performing. It's so close to the hardware that you have so much control over the memory and operation that you can write really good, really fast code. And that's why even all these decades later, it's among the most omnipresent programming languages in the world. At the same time, you can really screw things up and so many of today's software that are hacked in some way or crashed for some reason is often. Humans have just missed some simple mistake like this that happens to relate to memory, so more modern languages that we'll soon see like Python and if in high school you study Java, you don't have this much control over the computer's memory. There's many more defenses put in place to protect you and me from ourselves, so to speak, but you pay the price by some of those languages tend to be uh less uh slower and less performance, yeah. My I What? Like like difference What is the difference here that we're now playing with memory? This will become clear this week and next, and in fact some of the examples on which will end today will motivate needing to have finer grain control over what's going on inside of the computer when you want to deal with files, for instance, you're going to need to know a little something about memory addresses and where things are when you want to build structures in memory beyond the complexity of an array. In fact, next week we're going to start building. Two dimensional structures in the computer's memory to represent the equivalent of like a family tree for instance or trees more generally that can store data in a more efficient way. Up until now all we have is arrays, and with arrays you can achieve something like binary search, but we're going to see there are things you can't do with arrays, especially if speed is important. I was saying like for example if you were to ask me to do this like last week. I'll be like X equals 13 or something. Correct. So last week, if you just said in X equals 13 or in Y equals 42 or whatnot, totally fine. And again this program sole purpose in life is to demonstrate how you can make mistakes in and of itself is not useful here, but it's representative of how we're gonna start using this syntax, not only in this week's problem sets but next week as well. All right, so with that claim made that we can do a lot of damage, let's consider how pointers and knowledge of memory addresses can actually solve some useful problems. Um, can we get one volunteer to come on up and help pour a drink? Come on up. All right, what is your name? From on over If you want to say a quick hello to the group. I'm Olivia. OK, and, and a little something about yourself. Oh, I live in Canada. OK, welcome. Well, come on over here, Olivia, and we have, um, 2 glasses, well, really 3 glasses. So we have these fancy ray bands that have cameras built in whereby we can sort of capture your point of view. If you're comfortable, we'll put these on. There's no lenses in them. The white light will mean we're recording, hopefully a memorable moment. This battery too is dead. All right, we don't have a backup for the backup, so we're gonna pretend that this part never happens, so. Olivia, we have 2 glasses here for you, and I'm gonna go ahead and pour some colored liquid into both. So we've got some blue liquid here into this glass. All right, so we'll fill this up here. And then in this one we're gonna go ahead and pour this orange liquid, and at this point in the story I'm going to exclaim, oh no, I accidentally put the wrong liquid in the wrong glass so I got this backwards. So what I'd like you to do is swap the values in these glasses so that the blue goes into that glass and the the orange goes into this glass without mixing it without mixing it. So what you're hesitating. Why? Well, it would be hard to do. Unless you can like oh it would be like hard to do um without mixing the two because like you don't have anywhere to put the other one. Of course. So in the real world this is not really solvable unless for instance we have a temporary variable if you will, like an empty glass in which to do this. So here is your third variable if you want to go ahead now and get the blue into that one and the orange into that one, yeah. No pressure. All right, so we're putting one value into the temporary variable, we're putting the other value into the original value. OK, and now you're probably gonna take, yep, I'm guessing the temporary value, put it into the original variable. And that that was very well done. If maybe we can give Olivia a round of applause for just that. Thank you. Little partying before you're here too. So. The goal here really being to create a memorable moment of like, oh remember the time Olivia tried to swap two values she needed a temporary variable is the takeaway. So why is that? Well, in code, if we wanted to do the same principle, we're going to need somewhere temporary to put one of those values before we can make this happen. The catch is though that if we don't do this intelligently, like it's just not going to work in C unless we take advantage of some of these new capabilities. So in fact, I'm going to go over to VS code here and I'm going to open up a program called. Swap.c that I wrote in advance whose purpose in life is simply to swap two variables values. So I've got standard IO.h at the top so I can use print F. I've got the prototype for a swap function which is might as well be Olivia in this case that's going to take two inputs A and B or two glasses and swap their values ultimately is its purpose. Inside of Maine though, I'm going to do this. I'm going to set two variables X and Y equal to 1 and 2 respective. I'm then just as a point of clarification going to print out the value of X is such and such, Y is such and such. Then I'm going to call the swap function, AKA Olivia to swap the values X and Y. Then I'm going to print out X is this and why is this so that hopefully I'll see that they've indeed been swapped. At the bottom of this file we have the actual swap function, and as you might expect, it takes two inputs A and B, both of which are integers, so I could have called them anything I want. The first thing this function does is it grabs an empty glass called temp, puts a or the blue liquid into it. Then we put into a the value of B. So we've sort of lost the value of a at this point except that we did make a copy of it into temp. And then lastly we put into B the temporary variable and at the end the temp variable is empty, although technically it still has a copy of the value, but it's no longer useful because the job is done and A has become B and B has become A. So I dare say this is like the literal translation of what Olivia just did and I like the logic of it. However, when I actually run this program, something goes awry. So let me go ahead and do make swap. slash swap and I'll maximize my window. I should see hopefully that X is 1, Y is 2, and then X is 2, and Y is 1. But no, like, even though I literally translated into code what Olivia did, this didn't actually seem to work. And why is that? Well, it turns out that this version of the program is not right, in fact, because of issues of scope, and we've talked about scope before, generally in the context of like where variable lives. We've said that a variable only exists in like the most recent curly braces that you opened up for it, and that was true. It's just sort of a colloquial way of describing what scope is, but scope comes into play here because it turns out that A and B insofar as they are the arguments or parameters for the swap function, they. Have a different scope than X and Y and that still follows the same definition. They're inside of different curly braces than X and Y are, so it seems that I may very well be swapping A and B, but I'm not having any impact on X and Y. So why is that? Well, in C, all this time, any time you pass in arguments to a function, you are passing in those arguments by value, so to speak. You're literally passing in copies of the variables to the function you are calling. So what does this mean? Well, more concretely, if like this is a photograph of a chunk of memory inside of the computer and we sort of zoom in as we've done before and we abstract away all of the bytes from top to bottom, what's really happening inside of the computer's memory? Is that we're using some of it for X and Y and some other memory for A and B, but how is that in fact happening? Well, it turns out to a question that came up before the break, memory in a computer is actually assigned in a somewhat deliberate fashion. And generally if we think of this rectangle as representing my computer's whole chunk of memory, generally what happens when you run a program with something or on a Mac or PC by double clicking. Or on a phone by single tapping, what happens is all of the zeros and ones that were compiled by the company or person who made that program are loaded into the top of the computer's memory, so to speak. This is just an artist's rendition. There's no notion of top or bottom per se, but it's loaded into this chunk of memory at the very edge of the computer's memory, AKA machine code. The zeros and ones that compose the actual program, that's where they go. So they're copied from the hard drive or the SS. whatever you know it as the persistent storage, and it's put there in the computer's RAM or random access memory, which is the faster memory where programs and files live while you are using them. Meanwhile, if your program or the program you're using has any global variables, global in the sense that they're defined outside of Maine and not inside of Maine or inside of other functions, they end up right below that machine code by convention just so they're accessible everywhere. Meanwhile, there's this big chunk of memory below that called the heap. The heap is the chunk of memory that Mao uses to allocate memory for you. So the first time you call Mao, it's going to give you probably this chunk of memory. The second time, this chunk, the 3rd time, this chunk, and this chunk, and so forth, back to back to back in memory. But Malloch is going to manage all of that for you. You don't have to worry about where it's coming from, but it's coming more generally from this big heap area. But it turns out that the way computers are designed is that the heap of course sort of grows and therefore downward again even though there's no notion of up down inside of the computer but it grows in this direction. But it'd be nice to make use of this other area of memory and that's what's called the stack and the stack is the area of memory that's used any time you create local variables or call functions. So again, Mao uses memory from up here and functions and variables use memory down here just because the. What humans in a room decided years ago is how the computer's memory would be used. Therefore, the stack grows sort of vertically, much like stacking trays in a cafeteria or the dining hall. They go from bottom to top in this model. All right, well, let's consider for the moment just how the stack is used because we're using a main function in this program. We're using a swap function in this program, so I claim that those functions are going to use memory down here. Well, how are they going to use it and how is this in fact bad for our current goal? Well, when you call the main function. It uses this chunk of memory here, specifically if Maine has any arguments like command line arguments or if Maine has any local variables, they end up down here in memory. Meanwhile, when Maine calls swap, swap gets the next available chunk of memory above it, so to speak, in memory, and any of its arguments or local variables end up there. So when, when Swap is done executing, it's as though that memory disappears even though the zeros and ones are still there, but the computer can now reuse. That same chunk of memory later ergo garbage values when functions are being called going up and down conceptually, that's why you're getting remnants of previous values in the computer's memory. But let's focus on main for a moment. In Maine in this program, recall that I declared two variables X and Y X getting the value 1, Y getting the value 2 per these two lines of code. Then I called the swap function. So swap is going to get its own chunk of memory, more technically called a frame of memory. And inside of that frame it has two arguments A and B and a local variable called temp. So I'll draw them as such. When you actually call swap, passing in X and Y, X and Y are passed in by value, that is to say copy. So A becomes a copy of X and B becomes a copy of Y. So when this line of code. Or rather this prototype for swap just makes clear that it takes two arguments A and B, both of which are integers in that same order. So X. Y lines up with a B. So what happens then inside of the swap function if A is a copy of X and B is a copy of Y? Well, at the moment it's equal to 1 and 2 respectively, but consider this first line of code in temp gets A. So temp takes on the value of a. Next line of code A gets B. So A gets the value of B, sorry, which just happened. Meanwhile, B gets the value of temp, so B gets the value of T. Now temp still has a copy of one, so it's not quite analogous to the liquid because we're that glass is clearly now empty, but it does contain remnants of what it once did. But the key here is that A and B have successfully been swapped. If I were to print out A and B, I would see that they've been swapped. But what has obviously not been swapped in this story, no one has touched X or Y because when swap returns, especially if I don't even print out anything in swap, X and Y are unchanged. So A and B, the copies were swapped but not the original values, and that's the essence of the problem here with this this simple example of swapping values because I was passing by value. But as of today we now. Have a solution to this problem because previously to today if I asked you to write a function that swaps two values, you could not physically do it in code because you had no way of expressing the solution to this problem. But now we have the ability to pass by reference, that is use pointers and addresses more generally to tell the function how to go to an address and do something there, how to go to another address and do something there. How do I express this syntactically? It's going to look a little scary at first glance, but it's just an application of today's new building blocks. This bad version of the program. Where A and B are both integers just needs to change to be addresses of integers. So give the function a sort of treasure map that leads it to the actual X and Y by saying that A is now not going to be an in per se but the address of an N. B is going to be the address of an in and now to use those values you can say the following in temp gets whatever is at location A. Go to location A and put whatever's at location B. Go to location B and put in the temp value. And here is a perfect example of where this use and overuse of the star or asterisk operator is just like cognitively confusing, frankly, because we use star for multiplication, we use it for declaring a pointer, we use it for de-referencing a pointer ideally. Years ago would have come up with another symbol on the US English keyboard to represent these different ideas, but this is where we're at. We're using the star for different things in different contexts. So this just tells the computer that A is going to be a pointer an address of an ant. This tells the computer that B is going to be the address of an ant. This star, when there's no data type to the left of it means go to that address, as does every other example thereof. So what's happening this time if we actually look at the diagram again, X and Y are still 1 and 2 respectively. Swap gets called, it gets now the values of the address of X and the address of. So pictorally we might draw that as following A is pointing to X, B is pointing to 2. I mean technically it's like OX 123 and OX12 whatever, but who cares? We're just going to abstract it away now with actual arrows or pointers. The beauty of this now then is if we look at the swap function, in temp gets star A. That means started A and Go there sort of shoots and ladder style familiar with the game and you find the value 1 so you put the value 1 inside of temp which is why it's there now. Meanwhile, this next line of code go to A's address, go to B's address and copy the latter to the former. So this means go to A, this means go to B, where you find the 2, so put the 2. Where A is pointing. Lastly, go to B and put temp there so that's easy. Go to B and point temp, which is why we now have the 1. And the beauty of this now is that when swap is done executing, this memory, this frame sort of goes away conceptually, even though the zeros and ones are still there, but it's done being used, but we have now mutated the actual values of X and Y by giving them a proverbial treasure map of the addresses of X and Y, not copies of the values themselves. So hopefully this is the beginning of an answer to like why is this stuff useful you can now solve a whole new class of problems and even more next week. Other questions they want to need the syntax, pictures or the like. This is good use of pointers now instead of bad. All right, so with that new capability, let us consider here. How things can still go wrong and why indeed with this power comes that responsibility. Well, if you consider now the bad version of the code is fixable via this good version of the code, we've still left a big glaring problem in the diagram itself, designing something that grows this way against something that grows this way, like this is not going to end well. Why? Because the more you call Mao, the more memory that gets used here. The more functions you call, the more memory that gets used here, and at some point, like they will collide because the computer only has a finite amount of memory. So how do you avoid this situation? Like you kind of don't. Like you honestly just make sure that you minimize how much memory you're using by calling Malock only as much as you need to and not calling for a million bytes of memory just because you might need them. You only allocate what memory you need. And you try not to call functions again and again and again and again and again and again without them finally returning. So if you ever did something recursive a couple of weeks ago where you accidentally maybe called a function that never had a base case, never divided and conquered and actually shrunk the problem, you could overflow the stack or equivalently heap by just using too many frames of memory. So it's just a mistake. in the programmer for the programmers themselves. So if you've ever heard these phrases now, which some of you might have heap overflow or stack overflow, there's a very popular website called Stack Overflow, and this is the etymology thereof like Stack Overflow refers to this representative big problem with computers' memories if you're not mindful of how you're using the computer's memory, and this is just the way it is if you've got finite amount. Of anything that resource can eventually run out, at which point the program will crash or something else might very well go wrong. In fact, this is a general, more specific examples of what are called buffer overflows. A buffer overflow is generally just a chunk of memory like an array that actually just gets overflowed with too many values like using allocating a small array and trying to put too many numbers therein. There's problems that, um, and in fact you can see this very simply if we take off those last of our training wheels. So for instance, these are the functions in the CS 50 library, get in, get string, and so forth, um, they're harder to take off these training it's harder to take off these training wheels because C does not fundamentally make it that easy to manage memory yourself so. For instance, let's focus for just a moment on get in. I'm going to go over to VS code here in just a second, and let's go ahead and create our very simple program called Get.c whose purpose in life is to just get an integer, much like CS 50's own function. So in get.C, I'm going to propose that we write a program that does a little something like this, uh, include CS50. H, include standardio.h, and then inside of Maine. Let's go ahead and declare an inn, set it equal to get in, and we'll just ask the user for the value of N. Then let's go ahead and print out N's value verbatim back by just doing quote unquote N. This program is simply using the get in function or in order to get it in and store it in N. So let's run it, make get.get, type in a number like 50 seems to work. And yes, I think this program is correct, even though it is using the CS50 training wheel of get in. Let's stop using GetI though. It turns out that you don't have to use GetI if you instead use a function called scanF, which scans formatted input, which just means read something from the keyboard into memory. This is essentially what get string and get into using, although that too is a bit of an oversimplification, but let's use it. Here now is an opportunity to get rid of the training wheel of the CS 50 library altogether and down here, let's do this. Instead of using get in, let's declare a variable N but not give it a value yet. Let's now print out just a little prompt just to tell the human what we want. We want them to type in a value for N. And now let's use this new function called scanF and say scan from the user's keyboard in integer, represented by percent I, our old friend and format code, and please put the integer that the human types in. In the variable n. This is slightly buggy though, because if I want a function like scanF to be able to change the value of a variable just like the swap function, I can't just pass in N. I need to pass in the address of N here. In fact, let's take a moment now to go into. The swap function, which we knew to be buggy before and actually updated to match what we saw on the slides. I claim that the problem is that we're passing in originally X and Y is 1 and 2 into the swap function, but therefore we're passing in copies. But what if we change the swap function to take indeed the address of an N and the address of an in? Let me change my prototype accordingly because that too must be changed. Then when I change this function to take in those pointers, I need to change my code to de-reference them. But there's one last thing I need to do. I'm still on this line of swap passing in X and Y, which is literally the values X and Y. If I want to pass in the address of X and the address of Y, what other operator do I now need? The ampersand X and the ampersand Y to pass in sort of the treasure map, the pointer to those two variables locations. So if I open up my terminal window now, do make swap on this version swap, cross my fingers, now this new and improved version of swap as claimed does actually swap the values, the key being swap now has access not to X and Y per se, but to the addresses of X and Y. So if we now close out swap and go back to get here is the same principle applied to ScanF. If ScanF exists and it comes with C, its purpose in life is to scan an integer from the keyboard and put it somewhere you want. You can't just give it the variable name because it's going to get a copy of whatever garbage value is in there. You have to say put this answer in the address at the address of N itself. So lastly, after this, let me go ahead and print out and colon and then percent I again as a format code backslash NN. This line is just my prompt because I just want the human to know what they're being asked for. This line is printing out and colon and the actual value. So the only interesting part here is that I'm declaring a variable called N, but I'm not giving it a value myself, but I'm using scan F instead of get in to scan, so to speak, an integer from the keyboard and put it at the address of N so that scanF has access to that value. So if I now do make get without any CS 50 library.get, let's type in the number 50. I indeed see the number spit back at me. And just to be clear, printF uses these format codes of percent I and so forth. ScanF uses essentially the same format code. So that's why I'm using percent I in both places, both functions for their documentation are designed to do just that. So this is great. We've gotten rid of get in. Catch is that getting rid of get string is much, much harder. Why? Well, let's try another example. Let's go ahead and try to get a string from the user instead of just an inch. So we'll call it strings, but wait a minute. CS 50 library is not included, so we need to use the actual thing that this is. So chartar S means give me a variable that's going to store a string. Let's go ahead and print out that prompt just to prompt the user for S. Just for clarity, now let's use scan F and scan a string with percent S and put it at location S. Then let's go ahead and print out just a reminder that the value of S is now that passing in S. Now there's something a little bit different here. Notice that I've deliberately not used an ampersand before this S Y, even though I did before the N, yeah. the first character. Yeah, so I want to pass in the address of the string, which is, if I may, like already S. like S is by definition the address of some string that is what a charge star is, or rather it's the address of a character, but we know already that if you lead it to the first character, whatever function can find the end of it thanks to the null character, except that. That's not going to be wholly true here, but I don't want to do Ampersand here because if S is an address, doing Ampersand S would be the address of an address, which is actually a thing called a pointer to a pointer, but none of that today. But it's going to be correct as written here. N was an integer, so I needed the address of it. S is already a pointer. By definition, it's a charge star, so I don't use the ampersand here. The problem is this If I now do make getget and let's type in a word like about high. OK, it did work. Let me try something even bigger, like, hi, let's just hold this down a lot. Uh, let's do, how about this, really long string, oh come on. Let's type in a really long string. Hi. And it's always a gamble to see if I've done this long enough, but. OK. It didn't break. OK, you'd like to think that this is correct, but let's go ahead and do this. Valgrind of getge enter. Let me maximize my screen. Oh, and let me go ahead and type in a value for S while Valgrind is running. I'm going to type in high, and now. Well, let's actually scroll down to the scroll up to the top of this. A lot of error seems to have happened here. Use of uninitialized value of size 8, use of uninitialized value of size 8, like a lot of stuff is going wrong here apparently on it looks like maybe line 4, which is quite early in the program, and in fact, well actually that's not it line. Multiple lines of code here we're having issues with, but why? Well, let's focus on the code here alone for a moment. Line 5 is giving me what? A variable called S? That's the address of a char, but what is S right now? Like what value is in there? It's a garbage value because there's no equal sign involved. I'm just saying give me space, like give me 8 bytes, 64 bits to store the address of a character, but if I don't use the equal sign and actually put anything there, it is in fact just some garbage value. The print F is uninteresting, it's just printing out S colon scan. Though is saying go to this address and store the characters that the human typed in, but that means like following the wiggly line that we drew on the screen before because we have no idea where S is pointing. It might be there, there, there, there, you're putting the string at a bogus location in memory. You haven't actually allocated memory, so when you then try to print it, you're just trusting that you're going to memory again. That you control. So what is the solution here? Well, there's a few different ways we could solve this. We could do something like this, actually allocate space for like 4 bytes so that the human can safely type in. Uh, so the human can safely type in high with room for the null character. We could changes to actually be an array of size 4 because we can treat arrays as though they are addresses and addresses as though they are arrays. It turns out that syntactic sugar really goes in both directions. This too would solve that problem, or better still, we wouldn't use scanF at all because. How do I know how many characters the human's going to type in? Like this was a question two that came up during break. Well, hi will fit in 4 bytes with the null character. by will not. So maybe I need 5. Well, what if they type in a longer word? 6? Well, maybe the longer word, 7, well, maybe 100 or maybe 1000 or 10,000 or 100,000 or a million. Like at some point you've got to draw a line in the sand. And say you can't type in something longer than this, and you see this in applications all the time like on the web you can only type in so many characters sometimes into forms, and that's for various reasons. Among them is this Get string though will handle almost an infinite number of characters because the way we implemented get string is to take baby steps through the input. When you type in a word on the keyboard or even a paragraph on the keyboard, we get strings implementers call Mao essentially a. and again and again and again just asking for one more bite if we need it, one more bite if we need it, one more bite so that you don't have to worry about doing that. The problem is if you were to write code yourself without the CS 50 library or someone else's equivalent library, you have to decide like how many bytes do you want to allow, and you have to trust that the human is not going to mess around and type in more values than you actually expect. So what's happening with all of these examples. Thus far is that if you think of your memory as kind of a minefield of garbage values wasn't a problem when we declared N to have a value of 50 because we told ScanF to go to that address and put the number 50 there, and it fits. That's fine because an in is always 4 bytes in this case. Who knows how many times the human is going to hit the keyboard when typing in a string? Could be 3 or 4 or a million or anything else. So when we declares here. To be a pointer, it takes up 8 bits for the Oscars to the Oscars the grouch here whereby that's 8 garbage values that collectively represent that address at the moment because we've not assigned it to any other value. So if we try to tell ScanF, go to this address and store high or anything else there, like who knows where it's going to end up in memory, hence the squiggly line again. And the program will quite often crash. I didn't get it because I didn't type in long enough of a string, but it would eventually, if I tried hard enough, crash because you're touching memory that you yourself did not allocate as an array via Mao or some other mechanism. So what is the solution? Honestly, like don't use C for user input like this unless you're prepared to implement that complexity. use the CS 50 library or some other library. This too is why in 2 weeks we're going to switch to Python because Python makes life so much easier when it comes to basic things like getting user input, as do many other modern languages, but those languages just have code that other humans have written to solve these problems for you. So these problems exist, but they'll be abstracted away for you. All right. Let's tie this now together with where we began, which was to convey ultimately that we want to have Uh, the ability now to actually access files, and we introduce now a topic called FiO IO for input and output. A file is just a bunch of bytes that are stored on disk, where disc might mean a hard drive, the thing that spins around with a platter with lots of zeros and ones on it, or an SSD, a solid state drive, which is no moving parts nowadays and generally where our data is stored long term, whereas RAM, random access memory. all the yellow pictures we've been drawing is volatile. That is to say, when you lose power, the battery dies, you lose everything in RAM on a hard drive or a solid state drive that's persistent storage or non-volatile storage, which means when the power goes out, thankfully you don't lose all of your documents and essays and so forth, whether it's on your Mac or PC or somewhere in the cloud. But we haven't yet seen any code via which you yourselves can create files. like literally every program we've written, even the phonebook example last time when I typed in names and numbers, they got deleted as soon as the program quit and ended. So with FileIO though, we have the ability now to start creating, saving, editing, deleting files, much like you would from the File menu of Google Docs, Microsoft Word, or the like. Here are just some of the functions that come with. The programming language C that allow you to open files, aka F open, close files, aka F close, print to a file, scan from a file, read a file, write to a file, lots of different functions, some of which we'll explore this coming week. But why don't we first use them to solve a problem here in VS code. So let me go ahead and close get.c. Let's go ahead and open up a new program called Phonebook.c but implement a persistent version of it ultimately that doesn't just get deleted from memory when the program quits. Let's go ahead and only because it will make life easier, let's include the CS 50 library still for this. Let's include standard IO.H for this, and let's include string. H for this. Then inside of Maine, no command line arguments. Let's go ahead and. Open a file called phonebook.csv. CSV stands for comma separated values. Many of you have probably used them in the real world. They're like very lightweight spreadsheets where things are effectively stored in rows and columns where the columns are represented by just commas between values, and we'll see this in just a moment. How do you open a new file called phonebook. CSV? Well, I'm going to do file, file equals F open. Phonebook.csv and then I'm going to do quote unquote W for right. So what's going on here? F open is opening a file, whether or not it exists yet, called phonebook. CSV, and it's opening it in such a way that I will be allowed to write to it, hence the quote unquote W per the documentation. It means I can write to this file and not just read it. The return value is going to be stored in a variable called file, all lower case by convention, but that file is technically a struct called file in all caps. It's a little weird. It's among the few things that is fully capitalized in C. It doesn't mean it's a constant or anything like that. It's just how someone implemented it years ago. This is giving me. A pointer to essentially the contents of that file. It's a bit of a white lie, technically giving you a pointer to a chunk of memory that represents that file, but for all intents and purposes it's a pointer to the file for now. Now let's go ahead and ask the user for a name and number to add to this phone book. Let's do chart star name equals get string, quote unquote name to prompt the human for that chart star number. Let's prompt them for that. And do it with this, and I could be using the string data type, but I'm trying to at least remove what training wheels we don't technically need anymore. And now that we've got a name and number in variables, let's print them to the file. That is, let's save them to the file instead of print F we're going to use F printF. We're going to specify what file we want to print to in case we have multiple ones open. What. Do I want to print a string followed by a string followed by a new line, ergo, comma separated values, one after the other per line, then I'm gonna pass in the value's name and number respectively, and now I'm gonna go ahead and. Do F close to close that file so that it's effectively saved. All right, so let me go ahead and demonstrate first that phonebook.csv does not really exist. It's empty initially. Let me go ahead and switch it over to the right here so we can see both at the same time. I'm now going to do make phonebook enter, so far so good, phonebook, and let me go ahead and type in, for instance, uh, let's see, uh my name. 617-495 1000 and watch the top right of your screen as the program F writes to it and F closes the contents. All good. All right, let's run it again because maybe like the iOS app or the Android app, I'm adding new friends to my phone book here, so I'm going to do slash phonebook and I'm going to go ahead and 00. Top right just got turned blank. Well, let's try this. Kelly 617495-1000 enter. OK, she's back. Let me run it again. slash phonebook gone. Well, what's going on here? It's not persisting, at least as long as I would like. It seems to be the case that like writing to a file means literally rewrite the file. So if you use W, you're going to write to the file, but literally starting at the first bite. If you want to be smart about it and a pen to the file, well, per the documentation for F open, you instead use quote unquote a for a pen. Instead of quote unquote W for right, and this is a convention in other languages too. All right, let's start this over. Let me go ahead and recompile this program, make phonebook. Now let me do phonebook. I'll type in my name again 1st, 617-495-1000. Enter so far so good phonebook. So far so good. Kelly 617495-1000 E. And now we're on our way. In fact, I can close this file. I can close this file. I can then open up Phonebook.csv, and indeed it has persisted. And in fact, if I downloaded this file onto my Mac or my PC, I could then right click it or double click on it and probably open it in Microsoft Excel or Apple Numbers. I could import it into Google Sheets or any number of other spreadsheet tools because now I am persisting and writing files of my own. Questions on any of the techniques. We just tried out here. If we really want to be nitpicky, like technically I should fix one bug or missed opportunity if I open up Phonebook.c. I'm going to propose that as with any use of pointers and addresses more generally, here too something could be wrong, like maybe I'm just out of space and so FO can't physically open the file for me. Here too I should check if file equals equals null. OK, fine. Return 1 and then maybe at the very bottom here I return 0 to make clear, nope, nope, if I get this far, all is well. So in short, any time you are dealing now with pointers, you should be checking the return values to see if all in fact went well, yeah. Yes, everything we are using is part of Stanio.H, which is wonderfully useful now because it has not just printF but F printF and so forth as well. Good questions, yeah. I don't Yes, so we have how are pointers used in this code? The short answer is you have to use pointers because this is how C designed files to work. So we couldn't really introduce you all to files, file IO in week 1 or 2 or 3 because we had to, we'd have to introduce like this stupid little character to you and you'd be like, what does this mean? It's not multiplication. Because the way file IO works is that when you open a file, you are essentially handed the address of that file in memory. That's an oversimplification. You're technically handed the address of a data structure in memory that references the file actually on disk, but for all intents and purposes. I said, this gives you a pointer to the contents of the file, and if you want to write to the file, you need to then do a use F print F. In this case tell it what file to write to so you can go there and then store something like this string with these values plugged in. So in short, in C without pointers you just can't do file IO unless it's abstracted away for you by some library. Good question. Other questions on file. I owe All right, well, let me do one other example here that's a little reminiscent of things we see all the time on our phones and laptops and desktops like these progress bars for like video players, and you're all probably generally familiar with the term like buffering, if only because YouTube and other apps, when they are slow or you have a slow internet connection, they might say buffering. Well, what does that mean? Well, a buffer is just a chunk of memory. More specifically, it's often an array that is only a finite size that stores bytes of stuff. Context of a video player, for instance, this red line here which represents you're that way through that much through the video, it's an array that stores like the next few bytes of a video and ideally if you have a fast enough connection when you hit play, those bytes keep getting downloaded and added to the buffer and hopefully you don't finish watching the bytes that have been downloaded before more bytes have been downloaded. So a buffer is just a chunk of memory or more specifically an array in a language like C. Well, just Demonstrate how else you can do things with file IO. Let me propose that we write a simple little program that is our own implementation of the CP program, the copy program that we've used a few times already that allows you in your terminal window to copy one file to another, likening it to this idea of a progress bar where byte by bye you want to do something, namely in this case, copy it, not watch it instead. So let me go in VS code and code up a program called CP.C, and in this program I'm going to go ahead and include standardio.h at the top. I'm going to then give myself a main function that this time does take finally a command line argument via InargC and our old friend string RGV, which today We can now reveal to be also just a char star. In fact, this is how we can now technically write the Declaration for Maine cause string no longer exists without the CS 50 library per se. So that's really what's been going on this whole time. Now let me go ahead and do this. I want to be able to write a program that takes two command line arguments actually the name of the file to copy and the name of the new file to create from it. So let's go ahead and create a file using the same syntax as before called SRC for short source as is a convention, and let's open a file using Uh, the file name RV1, so the first word, the human types, and let's go ahead and open it in read mode because I want to read the source and write to the destination. My next file, filetar DST destination for short, will be F open of RV2 right. Now Y 1 and 2 and not 0 and 1 and 0 is the name of the program, which is not interesting. 1 and 2 will contain the next two words. The human types. Now let me propose that I want to copy this file from source to destination byte by byte, similar in spirit to a buffer like this where you're just grabbing from the internet one bite of the video at a time so as to watch it. In this case, I want to copy it. So how can I do this? Well, we don't have a data type per se for representing a bit, 8 bits. However, a common convention is to actually use our new friend typedef and simply declare byte to be something significant or something specific. So let me declare a type. Uh, called byte and what is a byte going to be? Well, ideally it's just a char because a char we know is 1 bite or 8 bits, but recall that chars can be treated as integers and integers of course can be positive and negative. So even though this is a little esoteric, technically. I want to define a bye to be what we'll call an unsigned char, which is probably a keyword you haven't yet seen, but it just tells the compiler that this char, that is this sequence of 8 bits, cannot be interpreted as a negative number because I am not doing anything with math. These are just raw bytes or 8 bits. So now down here I can give myself a bye and I'll call it B for short, and now I'm going to write a loop similar in spirit to what YouTube and other players are probably doing, which is iterates over a file byte by bite, making in our case a copy thereof. So while I am reading from this file into this byte, the size of one byte, one at a time into this destination. Go ahead and check that I've read at least one. So while the return value of a new function called Fread is not equal to 0, go ahead and Oops, sorry. So, go ahead and call F right, another new function. Going to that address of the bytes, grabbing the size of it, which happens to be one, but I'll use size of for consistency, grab one such bye and write it to destination. This is a huge mouthful admittedly, the last thing of which I need to do is close the destination so as to save it, close the original file, the source, um, but this huge mouthful, which you'll get more familiar with the next problem set is essentially saying on line 12, while I can read one byte at a time. Write on line 14, that bye to the file, implementing essentially this idea of the red progress bar going bye to byte to byte reading one bite at a time, reading from one file the source, writing to the other, the destination. And here too, to your question earlier, like why why pointers, this is the way file IO is done. You have to be able to express, go to this address, go to this file if you want to get data from it or to it and a minor refinement to. Technically when you open in files, if you know they're binary files that is zeros and ones and not Ay or Unicode text files, you can technically tell F open, write and read in binary mode so there's no mistaking the bits for something other than raw data, an image or otherwise. All right, so if I go ahead now and do make CP it's so far. Piles. Let's try this out. So here again is phonebook.csv. Whoops here, that's phonebook.c. Here again is phonebook. CSV with two of us, David and Kelly. Let's try to make a copy of this file as follows.slash CP. So this is my version of the copy program, not the one that comes with the system. Let's copy phonebook.csv into copy.csv. Enter. Let's open now the copy of. The CSV enter and voila, thank God, like it actually worked. I have made a 4 byte copy of this file using syntax that was not available to us until today. So who cares and what's the motivation? Well, it's a lot more fun to treat not just text files and these tiny little examples, but to actually play with real world examples. And in the next problem set among the things you'll do is experiment with BMP files, bit mapped files, which essentially just means a grid of pixels top to bottom, left to right, much like our cat that our volunteers atlas of Star created for us with a bitmap file you'll store in files literal sequences of pixels or dots, each of which is going to be represented with a specific color, a red value. A green value and a blue value. And among the things you'll be able to do given such beautiful photos as this is the Week's Bridge down by the Charles River is actually make your own Instagram-like filters to apply to photos like this, understanding now as you do or soon will understand to be able to iterate over the file top to bottom, left to right over each of the bytes they're in and somehow mutate the bytes to look a little bit different. So if this is the original photo, you might be able to make it all grayscale by changing the R's, the G's, and the B's to smaller values somehow that are. Simpler values that are just black and white and gray tones. You might take that same photo as input and give it more of a sepia tone like an old school photograph instead. You might actually reflect it like actually put these bits over here and these bytes over here so as to create the inverse of the image by reflecting it over the vertical axis here, or you might even blur the image like this. This is kind of a common feature in a lot of photo editing programs to either blur or de blur. Well, you can sort of do a little bit of math and make every pixel a little fuzzier by kind of cloud. In what the human is actually seeing or feeling more comfortable, you can actually write code now that you know how to manipulate files and addresses thereof and actually do edge detection and find the salient characteristics of something like the bridge to distinguish it from the sky and actually find filter-like edges like these. So those are just some of the problems that you're going to solve over the coming weeks problems set in manipulating ultimately files like these as well as JPEGs, and the last thing we thought we'd end on is a sort of computer science joke which for better or for worse, you're now getting more and more. Able to interpret, so I'll leave you dramatically with this here famous joke. Oh, That's more laughter than usual. All right, that's it for week 4. We will see you next time.
