0
00:00:43,490 --> 00:00:43,500
All

1
00:00:44,439 --> 00:00:44,680
right,

2
00:00:44,959 --> 00:00:46,560
this is CS 50,

3
00:00:46,689 --> 00:00:47,930
and this is week 4,

4
00:00:48,000 --> 00:00:51,650
the week in which we take off the proverbial training wheels that have been

5
00:00:51,880 --> 00:00:54,650
the CS 50 library and reveal to you all the more what's going

6
00:00:54,650 --> 00:00:57,389
on underneath the hood of a computer in terms of its memory.

7
00:00:57,520 --> 00:00:59,159
We'll also talk about files and how you can

8
00:00:59,159 --> 00:01:01,360
actually persist information for a long time whether.

9
00:01:01,514 --> 00:01:04,434
A file you've downloaded or today that you've created yourself,

10
00:01:04,595 --> 00:01:07,985
but first I just wanted to share some artwork that two of your classmates,

11
00:01:08,235 --> 00:01:09,125
Avery and Marie,

12
00:01:09,194 --> 00:01:10,824
kindly made before class,

13
00:01:11,154 --> 00:01:13,785
which is a picture made out of Post-it notes,

14
00:01:14,235 --> 00:01:14,474
uh,

15
00:01:14,635 --> 00:01:15,345
some green,

16
00:01:15,635 --> 00:01:16,315
some purple,

17
00:01:16,355 --> 00:01:19,275
which collectively from where you are looks like what?

18
00:01:20,809 --> 00:01:21,230
Yeah,

19
00:01:21,360 --> 00:01:23,720
so indeed it's a cat that they made using

20
00:01:23,720 --> 00:01:27,040
only zeros and ones or green and purple pieces.

21
00:01:27,080 --> 00:01:27,669
And in fact,

22
00:01:27,839 --> 00:01:31,160
even though this is fairly low resolution in that it only has

23
00:01:31,160 --> 00:01:33,949
a few pixels this way and a few pixels this way,

24
00:01:34,000 --> 00:01:37,430
it's actually representative of how computers do actually store

25
00:01:38,000 --> 00:01:38,790
images

26
00:01:39,040 --> 00:01:39,819
underneath the hood.

27
00:01:39,919 --> 00:01:41,019
So let's actually start there.

28
00:01:41,080 --> 00:01:41,360
In fact,

29
00:01:41,400 --> 00:01:44,400
we've had this bowl of stress balls for some time here on the lectern,

30
00:01:44,559 --> 00:01:45,989
and if we take a beautiful photo of it,

31
00:01:46,000 --> 00:01:47,389
they look a little something like this.

32
00:01:47,519 --> 00:01:48,190
Of course,

33
00:01:48,480 --> 00:01:50,449
this too is a finite resolution.

34
00:01:50,574 --> 00:01:53,165
And by resolution I just mean how many dots

35
00:01:53,165 --> 00:01:55,474
go horizontally and how many dots go vertically,

36
00:01:55,605 --> 00:01:58,275
multiply those two together and you get some number of bytes,

37
00:01:58,285 --> 00:01:59,165
maybe in kilobytes,

38
00:01:59,245 --> 00:01:59,925
megabytes,

39
00:02:00,044 --> 00:02:00,324
or heck,

40
00:02:00,345 --> 00:02:01,355
if it's a massive image,

41
00:02:01,364 --> 00:02:02,635
it could be even bigger than that.

42
00:02:02,925 --> 00:02:04,355
But it is in fact finite.

43
00:02:04,474 --> 00:02:06,404
And if we zoom in on this image,

44
00:02:06,415 --> 00:02:08,074
you start to see a little more detail.

45
00:02:08,163 --> 00:02:08,845
But at the same time,

46
00:02:08,854 --> 00:02:10,035
if you keep zooming in,

47
00:02:10,163 --> 00:02:12,565
you start to see indeed that there's only finite detail.

48
00:02:12,625 --> 00:02:13,955
And when we go really

49
00:02:14,404 --> 00:02:15,005
zoomed in,

50
00:02:15,044 --> 00:02:18,404
you start to see actual dots or pixels as they're called.

51
00:02:18,445 --> 00:02:18,725
In fact,

52
00:02:18,804 --> 00:02:19,764
on almost any screen,

53
00:02:19,964 --> 00:02:20,244
any.

54
00:02:20,389 --> 00:02:21,089
The image you look at,

55
00:02:21,130 --> 00:02:23,970
if you look close enough by pulling your phone up

56
00:02:23,970 --> 00:02:26,179
to your eyes or walking really close to a TV,

57
00:02:26,210 --> 00:02:28,050
you may very well see the same thing because any

58
00:02:28,050 --> 00:02:31,330
image on a screen like this is represented by hundreds,

59
00:02:31,410 --> 00:02:31,970
thousands,

60
00:02:32,130 --> 00:02:34,339
millions of tiny little dots called pixels,

61
00:02:34,369 --> 00:02:36,679
and each of those pixels has a color

62
00:02:36,889 --> 00:02:40,240
that gives it collectively the appearance of stress balls in this case,

63
00:02:40,410 --> 00:02:42,320
or cats in this case.

64
00:02:42,449 --> 00:02:43,000
So in fact,

65
00:02:43,009 --> 00:02:45,410
among the things we're going to do this week and the problem set is

66
00:02:45,410 --> 00:02:48,880
actually have you write code via which you can manipulate your own images,

67
00:02:49,289 --> 00:02:49,490
um,

68
00:02:49,529 --> 00:02:50,009
not only.

69
00:02:50,294 --> 00:02:52,005
To understand what's going on underneath the hood,

70
00:02:52,014 --> 00:02:52,785
but to apply

71
00:02:53,054 --> 00:02:55,085
some of today's most familiar filters,

72
00:02:55,175 --> 00:02:55,884
so to speak.

73
00:02:56,014 --> 00:02:56,294
In fact,

74
00:02:56,395 --> 00:02:58,085
if we go all the way down

75
00:02:58,294 --> 00:02:58,414
here,

76
00:02:58,494 --> 00:02:59,324
you'll see that this image,

77
00:02:59,335 --> 00:02:59,574
of course,

78
00:02:59,654 --> 00:03:00,615
has multiple colors.

79
00:03:00,695 --> 00:03:02,845
We've got some white and some red and shades in between,

80
00:03:02,895 --> 00:03:04,695
but let's keep things simple for a moment and

81
00:03:04,695 --> 00:03:06,455
propose that instead of looking at these dots,

82
00:03:06,494 --> 00:03:07,044
we look at

83
00:03:07,255 --> 00:03:08,695
these zeros and ones.

84
00:03:08,725 --> 00:03:11,524
And let me propose that in a picture like this,

85
00:03:11,654 --> 00:03:14,324
any zero will be interpreted as black,

86
00:03:14,535 --> 00:03:18,324
any 1 will be interpreted as white accordingly,

87
00:03:18,494 --> 00:03:19,604
if you can see it.

88
00:03:20,429 --> 00:03:21,979
What is this a picture of?

89
00:03:24,020 --> 00:03:24,710
00,

90
00:03:24,740 --> 00:03:29,860
smiley face is in fact right because if you kind of focus only on the

91
00:03:29,860 --> 00:03:33,309
zeros and try to ignore those ones as I can do here for you,

92
00:03:33,339 --> 00:03:36,660
you'll see that embedded in that image was in fact this smiley face.

93
00:03:36,740 --> 00:03:39,220
Now this would be a sort of one bit image.

94
00:03:39,300 --> 00:03:42,449
You either have a 0 or 1 representing each of the colors.

95
00:03:42,500 --> 00:03:45,460
In modern times we would actually use 16 bits per color,

96
00:03:45,539 --> 00:03:46,729
24 bits per color,

97
00:03:46,820 --> 00:03:47,570
maybe even more,

98
00:03:47,660 --> 00:03:48,779
and that's how we can get every color of

99
00:03:48,779 --> 00:03:50,889
the rainbow instead of just something black and white.

100
00:03:51,059 --> 00:03:51,660
But in effect,

101
00:03:51,740 --> 00:03:54,100
what's happening here is If you did have a file

102
00:03:54,100 --> 00:03:56,820
on your Mac or PC or phone storing this pattern

103
00:03:56,820 --> 00:03:58,539
of zeros and ones and you opened it up in

104
00:03:58,539 --> 00:04:00,929
some kind of image program or like the photos app,

105
00:04:01,139 --> 00:04:03,509
it would be depicted to you visually

106
00:04:03,740 --> 00:04:06,160
as this simply a grid X and Y,

107
00:04:06,179 --> 00:04:07,259
where some of the dots are white,

108
00:04:07,419 --> 00:04:09,089
some of the dot dots are

109
00:04:09,580 --> 00:04:10,110
black.

110
00:04:10,619 --> 00:04:10,940
All right,

111
00:04:11,029 --> 00:04:12,119
so with that said,

112
00:04:12,559 --> 00:04:12,970
how,

113
00:04:12,979 --> 00:04:14,350
what kinds of um

114
00:04:15,300 --> 00:04:17,459
representations might be involved here?

115
00:04:17,540 --> 00:04:17,630
Well,

116
00:04:17,660 --> 00:04:19,059
we can actually rewind to week zero.

117
00:04:19,160 --> 00:04:21,010
Recall that we talked briefly about RGB,

118
00:04:21,100 --> 00:04:21,738
which just means red.

119
00:04:21,959 --> 00:04:22,519
green and blue,

120
00:04:22,600 --> 00:04:26,630
which is one of the most common ways to represent colors inside of a computer.

121
00:04:26,799 --> 00:04:30,359
And if any of you have ever dabbled with Photoshop or similar editing programs

122
00:04:30,359 --> 00:04:33,200
or if maybe in high school or earlier you made your own web pages,

123
00:04:33,329 --> 00:04:37,179
odds are you're actually familiar with a syntax we're going to see a lot of today.

124
00:04:37,359 --> 00:04:39,000
This doesn't add anything intellectually new.

125
00:04:39,079 --> 00:04:41,279
It's just an introduction to a common convention

126
00:04:41,279 --> 00:04:43,440
for how else we can represent numbers.

127
00:04:43,600 --> 00:04:46,519
So this is a screenshot of Photoshop's color picker,

128
00:04:46,600 --> 00:04:49,309
Photoshop being a popular program for editing photos and files,

129
00:04:49,559 --> 00:04:54,179
and you'll see here that My selected color looks to the human eye as black,

130
00:04:54,299 --> 00:04:56,170
and I've highlighted here how I got that.

131
00:04:56,420 --> 00:05:01,209
I chose black by typing in 00,0000,

132
00:05:01,579 --> 00:05:04,700
which also if you look up here means that I want 0 red,

133
00:05:04,859 --> 00:05:05,619
0 green,

134
00:05:05,720 --> 00:05:06,730
and 0 blue,

135
00:05:06,940 --> 00:05:10,970
and yet we somehow translated to 60s instead of just 3.

136
00:05:11,140 --> 00:05:11,220
Well,

137
00:05:11,299 --> 00:05:14,410
if we take a look at another color like white instead,

138
00:05:14,579 --> 00:05:19,739
I claim that you can represent white in Photoshop and today in code with FF FF.

139
00:05:20,559 --> 00:05:23,200
or equivalently 255 red,

140
00:05:23,209 --> 00:05:24,239
255 green,

141
00:05:24,290 --> 00:05:25,609
255 blue.

142
00:05:25,720 --> 00:05:26,109
And here,

143
00:05:26,119 --> 00:05:27,160
if you think back to week zeros,

144
00:05:27,250 --> 00:05:29,329
maybe a hint at where we're going with this.

145
00:05:29,399 --> 00:05:31,230
If you're using an 8 bit number,

146
00:05:31,519 --> 00:05:35,739
which means then you can count from 0 on up to 255.

147
00:05:35,799 --> 00:05:38,869
So recall that 255 is like the biggest number you can represent

148
00:05:39,200 --> 00:05:40,510
with just 8 bits.

149
00:05:40,579 --> 00:05:42,799
And yet somehow there's going to be a relationship between

150
00:05:42,799 --> 00:05:45,829
the 255s and these Fs that we see down here.

151
00:05:45,959 --> 00:05:47,230
Let's just run through a few more.

152
00:05:47,359 --> 00:05:48,859
If we wanted to represent something like

153
00:05:49,019 --> 00:05:49,309
Red,

154
00:05:49,500 --> 00:05:52,140
we're going to use FF 0000.

155
00:05:52,179 --> 00:05:53,410
If we want to represent green,

156
00:05:53,540 --> 00:05:56,890
we're going to use 00 FF 00.

157
00:05:56,940 --> 00:05:57,450
And lastly,

158
00:05:57,459 --> 00:05:58,619
to represent blue,

159
00:05:58,779 --> 00:06:01,970
we're going to use 0000 FF.

160
00:06:02,200 --> 00:06:04,779
So what's going on here and why do we have just this different convention?

161
00:06:04,820 --> 00:06:04,899
Well,

162
00:06:05,019 --> 00:06:08,890
it turns out in the context of images and also memory in general,

163
00:06:09,019 --> 00:06:11,769
it's just human convention or programmer convention

164
00:06:11,980 --> 00:06:14,459
to use this alternate representation of numbers,

165
00:06:14,579 --> 00:06:16,100
not the so-called decimal system,

166
00:06:16,140 --> 00:06:17,779
but another one that's not all that.

167
00:06:17,929 --> 00:06:20,149
Far off from what we've been doing over the past few weeks.

168
00:06:20,320 --> 00:06:21,679
So here again was the binary system.

169
00:06:21,760 --> 00:06:23,890
You've got just two digits in your vocabulary,

170
00:06:23,950 --> 00:06:24,910
0 and 1.

171
00:06:25,200 --> 00:06:29,309
Here is the familiar decimal system where you've got 10 instead 0 through 9.

172
00:06:29,519 --> 00:06:31,839
Suppose we wanted a few more digits.

173
00:06:31,880 --> 00:06:32,040
Well,

174
00:06:32,279 --> 00:06:34,170
we're sort of out of Arabic numerals here,

175
00:06:34,239 --> 00:06:36,329
but I could toss into the mix like A,

176
00:06:36,480 --> 00:06:36,750
B,

177
00:06:36,859 --> 00:06:37,149
C,

178
00:06:37,359 --> 00:06:37,640
D,

179
00:06:37,839 --> 00:06:38,179
E,

180
00:06:38,320 --> 00:06:40,589
and F either in lower case or uppercase.

181
00:06:40,679 --> 00:06:41,359
And in fact,

182
00:06:41,480 --> 00:06:43,679
that's what computer scientists do when they want to

183
00:06:43,679 --> 00:06:46,149
have more than just 10 digits available to them,

184
00:06:46,200 --> 00:06:46,890
but as many.

185
00:06:47,000 --> 00:06:48,809
16 digits available

186
00:06:48,980 --> 00:06:52,059
and in fact when you want to use this many digits,

187
00:06:52,220 --> 00:06:53,769
you call it hexa decimal,

188
00:06:53,779 --> 00:06:55,559
implying that you've got 16 digits,

189
00:06:56,410 --> 00:06:57,529
aka base 16.

190
00:06:57,700 --> 00:06:58,179
Now this,

191
00:06:58,299 --> 00:07:00,739
there's an infinite number of base systems we could do base 3,

192
00:07:00,899 --> 00:07:01,420
base 4,

193
00:07:01,700 --> 00:07:02,260
base 15,

194
00:07:02,380 --> 00:07:03,540
base 17 on up,

195
00:07:03,579 --> 00:07:05,179
but this is just one of the relatively

196
00:07:05,179 --> 00:07:08,450
few conventions that are popular in computing.

197
00:07:08,529 --> 00:07:11,170
And let's just tease it apart because we're going to see these kinds of numbers a lot.

198
00:07:11,339 --> 00:07:11,420
Well,

199
00:07:11,459 --> 00:07:11,820
thankfully,

200
00:07:11,859 --> 00:07:12,579
like in week zero,

201
00:07:12,700 --> 00:07:15,859
like it's the same old number system with which you're familiar with the.

202
00:07:15,970 --> 00:07:17,380
Columns and the placeholders,

203
00:07:17,559 --> 00:07:21,029
it's just the bases in those columns mean a little something different.

204
00:07:21,239 --> 00:07:23,709
So instead of using powers of 2 or powers of 10,

205
00:07:23,959 --> 00:07:26,119
we're going to today use powers of 16.

206
00:07:26,290 --> 00:07:28,470
So 160 of course is 1,

207
00:07:28,480 --> 00:07:31,489
16 to the first power is 16.

208
00:07:31,519 --> 00:07:33,160
So we have the one's column,

209
00:07:33,359 --> 00:07:34,609
the 16s column,

210
00:07:34,799 --> 00:07:35,750
and so forth.

211
00:07:35,880 --> 00:07:36,510
Meanwhile,

212
00:07:36,720 --> 00:07:39,589
if we wanted to therefore start counting in hexadecimal,

213
00:07:39,899 --> 00:07:43,029
this two digit number in hexadecimal is of course

214
00:07:43,029 --> 00:07:44,940
the number you and I know in decimal as

215
00:07:45,339 --> 00:07:48,730
0 because it's still just 16 times 0 plus 1 times 0.

216
00:07:48,940 --> 00:07:51,809
This in hexadecimal is how you would represent 1,

217
00:07:51,940 --> 00:07:56,709
but you would say 01 or 01 instead of just 1 to make clear there's two digits.

218
00:07:56,899 --> 00:08:00,209
This would be 02 03 04 05,

219
00:08:00,299 --> 00:08:02,459
6789.

220
00:08:02,540 --> 00:08:03,790
Now things get a little interesting.

221
00:08:03,940 --> 00:08:09,010
In the decimal world we're about to carry the 1 and give ourselves two digits 1 and 0,

222
00:08:09,100 --> 00:08:10,769
but in hexadecimal you can keep going.

223
00:08:10,899 --> 00:08:11,570
So the next

224
00:08:11,820 --> 00:08:13,859
number in hexadecimal is going to be 0 A.

225
00:08:14,380 --> 00:08:17,589
0 B 0 C 0 D 0 E 0 F.

226
00:08:17,600 --> 00:08:19,390
and now things get interesting again.

227
00:08:19,760 --> 00:08:21,640
What probably comes after 0 F,

228
00:08:21,679 --> 00:08:23,559
even if you've never seen hex before?

229
00:08:24,640 --> 00:08:27,950
So 10 you still still carry the one as before.

230
00:08:28,029 --> 00:08:28,950
This goes back to 0.

231
00:08:28,989 --> 00:08:31,329
And why is this now appropriate?

232
00:08:31,470 --> 00:08:31,589
Well,

233
00:08:31,630 --> 00:08:32,840
how many digits did we just,

234
00:08:33,030 --> 00:08:34,390
how many numbers did we just count through?

235
00:08:34,510 --> 00:08:34,558
Well,

236
00:08:34,590 --> 00:08:35,900
we started at 00,

237
00:08:36,070 --> 00:08:38,580
we went up through 0F

238
00:08:39,150 --> 00:08:42,270
and that's a total of 16 combinations.

239
00:08:42,390 --> 00:08:43,590
So the highest we counted,

240
00:08:43,669 --> 00:08:47,380
let me rewind this number here of course is going to be 1 times F,

241
00:08:47,869 --> 00:08:48,669
but what is F?

242
00:08:48,780 --> 00:08:48,869
Well,

243
00:08:48,950 --> 00:08:49,840
let's rewind further.

244
00:08:49,869 --> 00:08:50,150
In fact,

245
00:08:50,229 --> 00:08:51,500
let's have our little cheat sheet here.

246
00:08:51,510 --> 00:08:52,380
If we want to

247
00:08:52,669 --> 00:08:53,190
have these.

248
00:08:53,340 --> 00:08:54,609
Digits at our disposal,

249
00:08:54,820 --> 00:08:56,130
I dare say that

250
00:08:56,409 --> 00:08:59,679
0123456789,

251
00:08:59,690 --> 00:09:00,510
1011,

252
00:09:00,520 --> 00:09:02,849
1213,

253
00:09:02,859 --> 00:09:04,840
1415.

254
00:09:04,849 --> 00:09:06,809
So F is just going to represent the number 15.

255
00:09:06,820 --> 00:09:08,580
So if we now fast forward back to where we were

256
00:09:08,580 --> 00:09:12,809
just counting from 0 on up through 0A through 0F,

257
00:09:13,140 --> 00:09:13,809
we land

258
00:09:13,909 --> 00:09:14,450
here.

259
00:09:14,739 --> 00:09:17,559
This of course is 16 times 0.1 times F,

260
00:09:17,820 --> 00:09:18,859
which is 1 times 15.

261
00:09:18,940 --> 00:09:21,780
So this is how in hexadecimal you would represent the number 15.

262
00:09:22,340 --> 00:09:24,840
This in hexadecimal is how you would represent the number

263
00:09:25,539 --> 00:09:26,900
16 instead,

264
00:09:26,979 --> 00:09:28,330
15 to 16.

265
00:09:28,419 --> 00:09:29,369
This is not 10,

266
00:09:29,539 --> 00:09:30,780
that's how you would pronounce it in decimal.

267
00:09:30,799 --> 00:09:32,590
This is 10 in hexadecimal,

268
00:09:32,619 --> 00:09:35,049
because 16 times 1 plus 1 times 0 gives us,

269
00:09:35,059 --> 00:09:35,330
of course,

270
00:09:35,340 --> 00:09:35,969
16.

271
00:09:36,059 --> 00:09:37,729
Now we could do this toward infinity,

272
00:09:37,739 --> 00:09:37,900
but.

273
00:09:37,989 --> 00:09:39,169
We won't 12,

274
00:09:39,179 --> 00:09:43,750
13 dot all the way up to FF.

275
00:09:44,020 --> 00:09:45,169
So quick mental math,

276
00:09:45,400 --> 00:09:46,849
16 times F,

277
00:09:47,020 --> 00:09:49,770
that is to say 16 times 15

278
00:09:50,020 --> 00:09:52,330
plus 1 times 15 is

279
00:09:52,619 --> 00:09:53,570
any guesses?

280
00:09:54,219 --> 00:09:55,690
It is in fact 255.

281
00:09:55,770 --> 00:09:57,169
You don't even have to do the math because if

282
00:09:57,169 --> 00:09:59,090
you just think about where we were going with this,

283
00:09:59,169 --> 00:10:01,239
indeed we saw pairs of F's in the

284
00:10:01,239 --> 00:10:04,409
Photoshop screenshots because this is how a computer would

285
00:10:04,409 --> 00:10:08,570
represent the number you and I know in decimal is 255 by just using two Fs.

286
00:10:08,650 --> 00:10:10,330
So why do we care about hexadecimal?

287
00:10:10,429 --> 00:10:10,489
Well,

288
00:10:10,570 --> 00:10:11,400
it turns out

289
00:10:11,570 --> 00:10:16,969
that it's just convenient to use two hexadecimal digits to represent numbers

290
00:10:16,969 --> 00:10:20,570
because a single hexadecimal digit can be used to represent 4.

291
00:10:20,679 --> 00:10:21,780
Bits at once.

292
00:10:21,989 --> 00:10:22,349
For instance,

293
00:10:22,469 --> 00:10:24,229
let me go ahead and explode this by putting a little

294
00:10:24,229 --> 00:10:26,859
bit of space between the two digits here and let's consider

295
00:10:27,070 --> 00:10:28,390
how you would represent F.

296
00:10:28,590 --> 00:10:28,669
Well,

297
00:10:28,710 --> 00:10:32,159
if F is 15 and you want to represent 15 in binary,

298
00:10:32,309 --> 00:10:35,760
I think that's just going to be 1111.

299
00:10:35,869 --> 00:10:36,830
Now why is that?

300
00:10:36,919 --> 00:10:37,030
Well,

301
00:10:37,190 --> 00:10:42,869
1 in the 8th place plus 1 in the 4th place plus 1 in

302
00:10:42,869 --> 00:10:45,909
the 2's place plus 1 in the one's place indeed gives me 15.

303
00:10:45,969 --> 00:10:46,950
So using a single f.

304
00:10:47,140 --> 00:10:48,010
I can count up,

305
00:10:48,090 --> 00:10:49,080
as we've seen already,

306
00:10:49,169 --> 00:10:50,289
as high as 15,

307
00:10:50,409 --> 00:10:52,530
but of course I've claimed in the past that it's super

308
00:10:52,530 --> 00:10:55,359
common to use 8 bits at a time or 1 byte

309
00:10:55,570 --> 00:10:59,719
to represent any value because that's just a very useful common unit of measure.

310
00:10:59,929 --> 00:11:01,599
And so in hexadecimal,

311
00:11:01,729 --> 00:11:03,969
if you wanted to represent 4 ones,

312
00:11:04,010 --> 00:11:04,729
you can say F.

313
00:11:04,770 --> 00:11:06,690
If you want to represent another 4 ones,

314
00:11:06,809 --> 00:11:07,799
you can just say F,

315
00:11:08,090 --> 00:11:09,369
which is to say that F

316
00:11:09,650 --> 00:11:13,239
and F together is just like the same as 81s together.

317
00:11:13,599 --> 00:11:18,469
is how we finally get to the total number of 255 because this is the one's place,

318
00:11:18,510 --> 00:11:19,109
the two's place,

319
00:11:19,190 --> 00:11:19,909
the 4s place,

320
00:11:19,950 --> 00:11:20,539
the eights,

321
00:11:20,669 --> 00:11:21,669
1632,

322
00:11:21,750 --> 00:11:22,340
64,

323
00:11:22,349 --> 00:11:23,489
128s.

324
00:11:23,500 --> 00:11:26,859
But if you group these into clusters of 4 bits alone,

325
00:11:27,109 --> 00:11:30,739
you can represent all of the possibilities from 0 through 15

326
00:11:30,950 --> 00:11:32,659
just using zero through F.

327
00:11:32,909 --> 00:11:35,150
So with one hex digit you can represent 4 bits,

328
00:11:35,229 --> 00:11:36,619
which is a long way of saying is

329
00:11:36,799 --> 00:11:38,140
it's just convenient for that reason,

330
00:11:38,229 --> 00:11:39,869
which is why the world tends to use hex when.

331
00:11:40,059 --> 00:11:41,599
Talking about colors

332
00:11:41,809 --> 00:11:42,799
and as we'll see

333
00:11:43,169 --> 00:11:44,320
memory as well.

334
00:11:44,570 --> 00:11:44,969
So in fact,

335
00:11:45,049 --> 00:11:49,159
let's consider what is meant by memory and what's going on

336
00:11:49,159 --> 00:11:51,809
inside of the computer when we've been storing values thus far.

337
00:11:51,890 --> 00:11:52,000
Well,

338
00:11:52,049 --> 00:11:56,809
here's that canvas of memory I proposed last time I proposed last time

339
00:11:56,809 --> 00:12:00,080
and before that we can sort of number these bytes arbitrarily but reasonably.

340
00:12:00,250 --> 00:12:03,200
This is byte 01234567,

341
00:12:03,770 --> 00:12:05,049
and maybe this is by 15.

342
00:12:05,130 --> 00:12:05,559
That's fine.

343
00:12:05,609 --> 00:12:06,409
Nothing wrong with that.

344
00:12:06,669 --> 00:12:07,809
But in the real world,

345
00:12:07,820 --> 00:12:10,929
any programmer would actually think of these locations instead,

346
00:12:11,219 --> 00:12:12,179
not in decimal notation,

347
00:12:12,260 --> 00:12:14,479
but in hexadecimal notation just because,

348
00:12:14,599 --> 00:12:16,729
because it's convenient for the reasons discussed.

349
00:12:17,099 --> 00:12:20,049
So we would actually number these from 0 on up through 9

350
00:12:20,299 --> 00:12:21,880
and then keep going with A,

351
00:12:22,030 --> 00:12:22,289
B,

352
00:12:22,500 --> 00:12:22,770
C,

353
00:12:23,020 --> 00:12:23,289
D,

354
00:12:23,539 --> 00:12:23,789
E,

355
00:12:23,940 --> 00:12:24,510
F.

356
00:12:24,969 --> 00:12:25,950
And so forth.

357
00:12:26,559 --> 00:12:27,150
So

358
00:12:27,520 --> 00:12:28,840
what does that mean for the other digits?

359
00:12:28,960 --> 00:12:29,080
Well,

360
00:12:29,239 --> 00:12:30,369
this would be 10,

361
00:12:30,440 --> 00:12:31,400
this would be 11,

362
00:12:31,440 --> 00:12:32,440
this would be 12.

363
00:12:33,190 --> 00:12:34,510
Here now is 19,

364
00:12:34,760 --> 00:12:38,770
but here's 1A 1 B 1 C 1 D 1 E 1 F,

365
00:12:38,780 --> 00:12:40,929
and so forth just using hexadecimal notation.

366
00:12:41,159 --> 00:12:42,830
But there's arguably some ambiguity here.

367
00:12:42,960 --> 00:12:43,359
For instance,

368
00:12:43,440 --> 00:12:47,950
if you just at a glance were to look at this board and see this address 10,

369
00:12:48,280 --> 00:12:51,000
is that by 10 or is that?

370
00:12:51,085 --> 00:12:51,594
By

371
00:12:52,044 --> 00:12:53,544
16,

372
00:12:53,755 --> 00:12:56,974
it's just non obvious because if you don't know what base system you're working in,

373
00:12:57,155 --> 00:12:59,075
which you could infer by looking at the rest of it,

374
00:12:59,195 --> 00:13:00,625
it could potentially be ambiguous.

375
00:13:00,755 --> 00:13:02,265
So in the world of hexadecimal,

376
00:13:02,474 --> 00:13:05,275
super common to literally prefix any number you

377
00:13:05,275 --> 00:13:08,984
ever write in hexadecimal notation using zero X.

378
00:13:09,034 --> 00:13:10,844
The 0 doesn't mean anything per se or the X,

379
00:13:10,914 --> 00:13:15,265
it just means what follows the 0 X is a number in hexadecimal notation,

380
00:13:15,434 --> 00:13:17,155
which makes unambiguous the fact that

381
00:13:17,469 --> 00:13:18,789
OX 10,

382
00:13:18,950 --> 00:13:20,380
which if you do the math and decimal

383
00:13:20,750 --> 00:13:22,539
again ends up being 16,

384
00:13:22,789 --> 00:13:24,580
not of course the number 10.

385
00:13:24,710 --> 00:13:25,150
In short,

386
00:13:25,309 --> 00:13:27,510
today you're about to see a lot of zero X's and a lot

387
00:13:27,510 --> 00:13:31,900
of two digit or 4 digit or eight digit numbers in hexadecimal notation.

388
00:13:32,109 --> 00:13:34,270
Generally we don't care what the numbers translate to.

389
00:13:34,309 --> 00:13:35,659
You don't need to do a lot of math,

390
00:13:35,950 --> 00:13:39,659
but it's going to be commonplace to see syntax like this.

391
00:13:39,880 --> 00:13:40,150
All right,

392
00:13:40,309 --> 00:13:42,010
back to sort of normal time.

393
00:13:42,109 --> 00:13:43,260
So here is a line of code.

394
00:13:43,424 --> 00:13:47,505
Inn equals 50 wherein me might want to declare a variable

395
00:13:47,505 --> 00:13:49,265
called N and store a number like 50 in it.

396
00:13:49,344 --> 00:13:51,664
Let's actually go ahead and do this simple now as

397
00:13:51,664 --> 00:13:55,474
it probably is in a file called how about addresses.c.

398
00:13:55,594 --> 00:13:57,974
We're going to play around with computer addresses,

399
00:13:58,065 --> 00:14:00,375
and in addresses.c I'm going to do something super

400
00:14:00,375 --> 00:14:04,364
simple at first whereby I'm going to include standardio.h.

401
00:14:04,585 --> 00:14:07,455
Then I'm going to go ahead and write in main void,

402
00:14:07,645 --> 00:14:09,135
with no command line arguments here.

403
00:14:09,429 --> 00:14:11,250
Then I'm going to declare this variable n,

404
00:14:11,419 --> 00:14:14,210
set it equal to the arbitrary but familiar value of 50,

405
00:14:14,419 --> 00:14:16,859
and then just so that this program does something mildly useful,

406
00:14:16,900 --> 00:14:20,010
let's go ahead and print out with percent I and a backslash N

407
00:14:20,500 --> 00:14:22,169
that value of N.

408
00:14:22,500 --> 00:14:23,849
So nothing new here.

409
00:14:23,940 --> 00:14:26,140
I'm just literally going through the motions of

410
00:14:26,140 --> 00:14:27,900
declaring a variable and printing its value.

411
00:14:27,979 --> 00:14:28,690
So let's do that.

412
00:14:28,900 --> 00:14:29,929
Make addresses,

413
00:14:30,179 --> 00:14:32,150
enter addresses,

414
00:14:32,179 --> 00:14:32,969
and hopefully

415
00:14:33,219 --> 00:14:35,140
I'll indeed see the number 50.

416
00:14:35,260 --> 00:14:35,489
So.

417
00:14:35,655 --> 00:14:37,054
Not all that much going on in the code,

418
00:14:37,135 --> 00:14:39,684
but let's consider what's going on in the computer's memory.

419
00:14:39,974 --> 00:14:43,614
This line of code and the one after it is giving the results of that program,

420
00:14:43,705 --> 00:14:45,604
but where is that n ending up?

421
00:14:45,734 --> 00:14:45,815
Well,

422
00:14:45,875 --> 00:14:46,974
here's my grid of memory,

423
00:14:46,984 --> 00:14:50,484
and let's just suppose for the sake of discussion that the 50 ends up down here.

424
00:14:50,575 --> 00:14:52,294
Maybe there's other things going on in my program,

425
00:14:52,375 --> 00:14:54,604
so this part of my computer's memory is already in use,

426
00:14:54,734 --> 00:14:57,405
so it's reasonable that it could end up in this location here.

427
00:14:57,575 --> 00:15:01,534
But what is important is that how many bytes am I using for N apparently.

428
00:15:02,880 --> 00:15:05,840
4 and that's because we've said integers tend to be 4 bytes,

429
00:15:05,919 --> 00:15:07,039
AKA 32 bits,

430
00:15:07,119 --> 00:15:08,770
so this is at least 2 scale,

431
00:15:08,780 --> 00:15:11,500
even though I'm just imagining where it ends up in memory.

432
00:15:11,679 --> 00:15:13,549
So that's where the 50 actually ends up.

433
00:15:13,640 --> 00:15:16,969
So when I actually call printF and pass in N,

434
00:15:17,440 --> 00:15:21,520
clearly the computer is going to that location in memory and actually.

435
00:15:21,710 --> 00:15:23,260
Printing out that value,

436
00:15:23,469 --> 00:15:24,299
but that

437
00:15:24,770 --> 00:15:28,380
value is indeed at a specific memory address.

438
00:15:28,469 --> 00:15:33,299
It's not going to be quite as simple as OX 0 or OX1 or a small number typically.

439
00:15:33,469 --> 00:15:36,340
It's maybe it is going to be something arbitrary like OX 123,

440
00:15:36,349 --> 00:15:37,419
where I'm just making this up.

441
00:15:37,590 --> 00:15:40,630
It's an easily pronounceable number in hexadecimal notation.

442
00:15:41,010 --> 00:15:41,030
All right,

443
00:15:42,080 --> 00:15:42,510
so

444
00:15:42,799 --> 00:15:43,270
what

445
00:15:43,520 --> 00:15:45,710
can I use that information for?

446
00:15:45,840 --> 00:15:46,190
Well,

447
00:15:46,400 --> 00:15:49,070
thus far this hasn't been useful to us,

448
00:15:49,119 --> 00:15:52,510
but certainly programs we've been writing have actually been making use of this.

449
00:15:52,640 --> 00:15:56,020
But with a bit more syntax I can actually start to see things like this,

450
00:15:56,030 --> 00:15:58,049
not just on the screen but in code.

451
00:15:58,080 --> 00:15:58,429
In fact,

452
00:15:58,590 --> 00:15:59,469
let me propose

453
00:15:59,679 --> 00:16:02,270
that we introduce two new operators and see,

454
00:16:02,479 --> 00:16:03,880
so 2 new pieces of syntax.

455
00:16:04,112 --> 00:16:07,143
One is a single ampersand and one is a single asterisk,

456
00:16:07,273 --> 00:16:08,223
and we'll see that

457
00:16:08,643 --> 00:16:11,023
the asterisk has a few different uses,

458
00:16:11,033 --> 00:16:14,273
but the ampersand has a very simple straightforward one

459
00:16:14,273 --> 00:16:17,922
which is to just get the address of a variable

460
00:16:18,232 --> 00:16:18,982
in memory.

461
00:16:19,153 --> 00:16:20,353
So if you've got a variable like N,

462
00:16:20,672 --> 00:16:23,072
if you prefix it with ampersand N,

463
00:16:23,353 --> 00:16:26,872
you can actually ask the computer at what address is this variable.

464
00:16:26,995 --> 00:16:27,226
Stored.

465
00:16:27,265 --> 00:16:31,426
You can find out if it's indeed OX123 or something else altogether.

466
00:16:31,625 --> 00:16:31,986
So in fact,

467
00:16:32,065 --> 00:16:36,255
let me go ahead and do this by going back to my addresses.c program

468
00:16:36,466 --> 00:16:38,226
and let's see if we can print out not the value,

469
00:16:38,265 --> 00:16:39,776
which is obviously going to be 50,

470
00:16:39,945 --> 00:16:42,375
but let's actually print out the address thereof.

471
00:16:42,635 --> 00:16:49,866
So up here in my code I'm going to change the N on line 6 to be ampersand N instead.

472
00:16:50,250 --> 00:16:54,780
And I'm going to go ahead and make one other change because yes n

473
00:16:55,419 --> 00:16:58,169
lives at an address and yes that address is technically

474
00:16:58,169 --> 00:17:01,179
a number but it's conventional not to use percent I to

475
00:17:01,179 --> 00:17:04,060
display that number but rather another piece of syntax which is

476
00:17:04,060 --> 00:17:06,260
just a new format code which you don't often need.

477
00:17:06,339 --> 00:17:08,689
This is more demonstrative than useful I would say,

478
00:17:08,939 --> 00:17:09,890
but percent P

479
00:17:10,339 --> 00:17:11,900
is going to be what we use when we want to

480
00:17:11,900 --> 00:17:15,030
print out an address of something in the computer's memory.

481
00:17:15,526 --> 00:17:17,375
So back to VS code one more change.

482
00:17:17,425 --> 00:17:20,276
I'm going to change my percent I to percent P instead.

483
00:17:21,586 --> 00:17:23,826
So at this moment we should see a version of

484
00:17:23,826 --> 00:17:26,955
the program that's not going to display 50 anymore,

485
00:17:27,066 --> 00:17:29,426
but something like OX 123,

486
00:17:29,436 --> 00:17:32,416
but probably a bigger number than that because my computer has way more memory

487
00:17:32,666 --> 00:17:33,855
than that address suggests.

488
00:17:33,946 --> 00:17:35,336
So let's again make addresses.

489
00:17:35,546 --> 00:17:37,095
Let's run addresses,

490
00:17:37,186 --> 00:17:38,135
and indeed

491
00:17:38,465 --> 00:17:41,751
this variable at that moment in Time apparently lives somewhere

492
00:17:41,751 --> 00:17:47,682
in the computer's memory at address OX7 FFFD3C34 ECC.

493
00:17:47,791 --> 00:17:49,312
All of those are hexadecimal digits.

494
00:17:49,391 --> 00:17:52,661
It would be painful to do the mental math to figure out what the numeric address is,

495
00:17:52,712 --> 00:17:56,212
but we're seeing it indeed in this common hexadecimal notation,

496
00:17:56,271 --> 00:17:58,741
which is not going to be often useful for us

497
00:17:58,952 --> 00:17:59,822
as humans,

498
00:17:59,952 --> 00:18:04,862
but the computer is and has been using this information for some time.

499
00:18:05,219 --> 00:18:07,359
So in fact what we're about to introduce

500
00:18:07,810 --> 00:18:10,569
is admittedly one of the more complicated concepts

501
00:18:10,569 --> 00:18:12,640
in computing and in C in particular,

502
00:18:12,890 --> 00:18:14,359
namely a topic called pointers,

503
00:18:14,410 --> 00:18:17,699
and I will say today more so than ever might feel like a bit of a fire hose.

504
00:18:17,849 --> 00:18:18,400
In fact,

505
00:18:18,410 --> 00:18:19,199
all these years later,

506
00:18:19,290 --> 00:18:20,280
I still remember

507
00:18:20,609 --> 00:18:23,489
the day in which I finally understood this topic,

508
00:18:23,530 --> 00:18:26,199
which was not the day of the lecture in which I was introduced,

509
00:18:26,329 --> 00:18:29,250
but it was in like the back right corner of the Elliott House dining hall.

510
00:18:29,260 --> 00:18:31,359
I was sitting down during office hours with my teaching fellow,

511
00:18:31,410 --> 00:18:32,369
and he finally helped.

512
00:18:32,545 --> 00:18:34,064
light bulb go off over my head.

513
00:18:34,104 --> 00:18:36,415
So if some of this feels a little arcane today,

514
00:18:36,665 --> 00:18:39,614
it just comes with time and with practice like everything else.

515
00:18:39,864 --> 00:18:40,785
So what is a pointer?

516
00:18:40,895 --> 00:18:44,474
A pointer is going to be a variable that can store

517
00:18:44,785 --> 00:18:45,694
in address.

518
00:18:45,944 --> 00:18:46,045
Now,

519
00:18:46,064 --> 00:18:46,295
yes,

520
00:18:46,305 --> 00:18:48,584
that address is technically just a number like an integer,

521
00:18:48,625 --> 00:18:50,744
but we distinguish between integers that we care about

522
00:18:50,744 --> 00:18:52,814
like 50 and things we might do math on,

523
00:18:53,064 --> 00:18:57,694
and a pointer which in this case is just going to be the address of a variable,

524
00:18:57,944 --> 00:18:58,135
uh,

525
00:18:58,145 --> 00:18:59,655
the address of a value

526
00:19:00,025 --> 00:19:00,704
in memory.

527
00:19:01,109 --> 00:19:02,609
So what does this mean?

528
00:19:02,650 --> 00:19:02,750
Well,

529
00:19:02,810 --> 00:19:04,800
we can start to do things like this.

530
00:19:04,930 --> 00:19:08,839
I can declare my variable N as before and set it equal to the value of 50,

531
00:19:08,949 --> 00:19:11,209
but I can actually get the address of N.

532
00:19:11,510 --> 00:19:14,079
And put that address in another variable,

533
00:19:14,099 --> 00:19:16,050
and that variable we now call a pointer.

534
00:19:16,339 --> 00:19:18,729
So P is going to be the name of this variable.

535
00:19:18,979 --> 00:19:20,739
It's going to store the address of n,

536
00:19:20,819 --> 00:19:22,650
which we can get using the ampersand,

537
00:19:22,660 --> 00:19:25,089
but there's one more piece of syntax which I promised before

538
00:19:25,420 --> 00:19:26,729
this asterisk here,

539
00:19:26,939 --> 00:19:30,089
and the asterisk here means that this

540
00:19:30,380 --> 00:19:31,449
variable p

541
00:19:32,060 --> 00:19:32,579
stores the.

542
00:19:32,765 --> 00:19:34,385
Dress of an integer,

543
00:19:34,555 --> 00:19:36,824
not an actual integer per se.

544
00:19:37,035 --> 00:19:38,104
It's weird looking syntax.

545
00:19:38,114 --> 00:19:39,354
It kind of looks like multiplication,

546
00:19:39,395 --> 00:19:39,954
but it isn't.

547
00:19:40,035 --> 00:19:42,994
It's just the developers of C decades ago decided to use

548
00:19:42,994 --> 00:19:46,155
an asterisk even though it's admittedly non-obvious what it's doing.

549
00:19:46,234 --> 00:19:47,224
But in this context,

550
00:19:47,395 --> 00:19:50,194
when you see an asterisk right after a data type like in,

551
00:19:50,275 --> 00:19:53,994
it just means that the variable in question is not going to be an in per se,

552
00:19:54,395 --> 00:19:55,425
but an address

553
00:19:55,675 --> 00:19:56,104
of

554
00:19:56,314 --> 00:19:57,165
an integer.

555
00:19:57,859 --> 00:19:58,369
OK,

556
00:19:58,540 --> 00:20:02,849
so let's put this to the test using a line of this code in my own

557
00:20:03,219 --> 00:20:03,969
file here.

558
00:20:04,099 --> 00:20:06,170
Let me propose that we do this.

559
00:20:06,400 --> 00:20:08,170
Let me go back to VS code here.

560
00:20:08,560 --> 00:20:13,329
Let me introduce this additional variable in P as it's typically pronounced,

561
00:20:13,579 --> 00:20:16,050
set that equal to ampersand N,

562
00:20:16,300 --> 00:20:18,530
and then do the exact same thing as before.

563
00:20:18,660 --> 00:20:20,060
Let's not print out ampersand N,

564
00:20:20,099 --> 00:20:21,410
but let's actually print out

565
00:20:21,660 --> 00:20:26,579
the value of P itself because P is now equivalent to ampersand N.

566
00:20:26,849 --> 00:20:28,390
So let me go back to VS code.

567
00:20:28,660 --> 00:20:30,630
Let me do make addresses again.

568
00:20:31,400 --> 00:20:31,900
And huh,

569
00:20:32,050 --> 00:20:33,930
I did something wrong and stupid here.

570
00:20:34,010 --> 00:20:36,069
This was not meant to be the moral of the story.

571
00:20:37,040 --> 00:20:37,969
What did I do wrong?

572
00:20:38,030 --> 00:20:38,339
Yeah.

573
00:20:39,160 --> 00:20:39,349
Yeah,

574
00:20:39,469 --> 00:20:40,699
I just missed the semicolon,

575
00:20:40,709 --> 00:20:42,339
so still making those mistakes here.

576
00:20:42,510 --> 00:20:42,670
All right,

577
00:20:42,770 --> 00:20:46,989
and I'm gonna clear my screen again and do make addresses enter addresses,

578
00:20:47,000 --> 00:20:47,780
and now

579
00:20:48,109 --> 00:20:50,800
I should indeed see the address of N.

580
00:20:51,270 --> 00:20:56,020
I just so happen to temporarily store it this time inside of a variable called P.

581
00:20:56,390 --> 00:20:57,380
Now just so you've seen it,

582
00:20:57,390 --> 00:21:00,380
it turns out that when using this syntax

583
00:21:00,750 --> 00:21:04,030
of using a star to declare a so-called pointer and

584
00:21:04,030 --> 00:21:06,459
ampersand over here to get the address of something,

585
00:21:06,550 --> 00:21:09,875
you might see in online references in such different formattings of this.

586
00:21:09,915 --> 00:21:14,145
This is the canonical way to declare a pointer in space,

587
00:21:14,314 --> 00:21:15,185
then the star,

588
00:21:15,415 --> 00:21:16,545
then without a space,

589
00:21:16,635 --> 00:21:17,704
the name of the variable.

590
00:21:17,875 --> 00:21:18,224
However,

591
00:21:18,314 --> 00:21:20,224
it will work and you will sometimes see

592
00:21:20,395 --> 00:21:21,864
that the star is over here

593
00:21:22,155 --> 00:21:23,625
or the star is in the middle.

594
00:21:23,834 --> 00:21:24,224
But again,

595
00:21:24,275 --> 00:21:26,785
we would recommend stylistically that it just go here.

596
00:21:26,875 --> 00:21:27,435
Admittedly,

597
00:21:27,474 --> 00:21:30,545
I think it would have been clearer if the star were over here,

598
00:21:30,675 --> 00:21:34,015
making clear that it's related more to the in than it is to the variable name,

599
00:21:34,074 --> 00:21:34,415
but

600
00:21:34,699 --> 00:21:36,170
This is simply the convention.

601
00:21:36,260 --> 00:21:37,609
So this means hey computer,

602
00:21:37,739 --> 00:21:39,079
give me a variable called P

603
00:21:39,420 --> 00:21:41,530
that's going to store the address of

604
00:21:41,859 --> 00:21:42,689
an integer

605
00:21:42,859 --> 00:21:44,729
and the ampers is just saying Hey computer,

606
00:21:45,020 --> 00:21:48,260
tell me the address of N and it's the

607
00:21:48,260 --> 00:21:52,619
compiler and computer itself that decided where to put

608
00:21:53,060 --> 00:21:56,180
that variable in memory.ues.

609
00:21:59,219 --> 00:22:01,140
Would you get an error if you didn't put the asterisk?

610
00:22:01,180 --> 00:22:01,500
You would.

611
00:22:01,579 --> 00:22:02,329
And let's take a look.

612
00:22:02,459 --> 00:22:04,060
So let me go ahead and clear my terminal.

613
00:22:04,260 --> 00:22:05,260
Let me go ahead and

614
00:22:05,500 --> 00:22:07,760
delete the star before the variable P.

615
00:22:08,000 --> 00:22:10,369
Now let me go ahead and do make addresses again,

616
00:22:10,619 --> 00:22:12,290
and indeed I'm getting an error

617
00:22:12,290 --> 00:22:15,619
incompatible pointer to integer conversion initialized.

618
00:22:17,000 --> 00:22:19,239
And even though that's a lot of big words,

619
00:22:19,300 --> 00:22:22,060
it kind of says what it means you're trying to go from

620
00:22:22,060 --> 00:22:25,369
a pointer on the right to an integer on the left,

621
00:22:25,660 --> 00:22:27,349
which is just not appropriate here.

622
00:22:27,459 --> 00:22:27,579
Yes,

623
00:22:27,630 --> 00:22:29,069
at the end of the day they're all numbers,

624
00:22:29,079 --> 00:22:32,510
but it's more properly a pointer or an address on the right,

625
00:22:32,859 --> 00:22:35,609
but a little old in now incorrectly on the left.

626
00:22:35,819 --> 00:22:37,770
So the fix there is just to indeed put it back.

627
00:22:38,219 --> 00:22:40,099
Other questions on this new syntax,

628
00:22:40,189 --> 00:22:40,500
yeah.

629
00:22:45,050 --> 00:22:45,060
like

630
00:22:47,719 --> 00:22:48,040
Indeed,

631
00:22:48,079 --> 00:22:48,719
to recap the question,

632
00:22:48,800 --> 00:22:50,520
can you use the address of operator to find

633
00:22:50,520 --> 00:22:52,849
the address of other data types like strings?

634
00:22:52,859 --> 00:22:53,270
Absolutely,

635
00:22:53,319 --> 00:22:55,469
and we'll do that with a couple of examples today as well.

636
00:22:55,560 --> 00:22:57,989
We're just using it to keep it super simple initially.

637
00:22:58,160 --> 00:23:00,250
Other questions on these addresses and pointers.

638
00:23:05,979 --> 00:23:06,689
Correct,

639
00:23:07,089 --> 00:23:07,260
correct.

640
00:23:07,369 --> 00:23:08,819
Even if it's not an ant in question,

641
00:23:08,859 --> 00:23:11,180
we'll come back to other data types in a little bit.

642
00:23:11,219 --> 00:23:14,380
You're still gonna use the star that is the same syntax for everything.

643
00:23:15,489 --> 00:23:16,329
And yes.

644
00:23:19,900 --> 00:23:20,660
Oh yes,

645
00:23:20,770 --> 00:23:24,760
can you tell the computer you want to store a variable in this address?

646
00:23:24,890 --> 00:23:26,290
That's where we're going in just a bit.

647
00:23:26,410 --> 00:23:26,689
Indeed,

648
00:23:26,770 --> 00:23:28,520
now that we have the ability to find out

649
00:23:28,520 --> 00:23:31,329
the address of something in memory stands to reason

650
00:23:31,329 --> 00:23:33,689
that we can go to that address ourselves and

651
00:23:33,689 --> 00:23:35,920
maybe poke around and actually put values there.

652
00:23:36,089 --> 00:23:37,250
And in fact that's,

653
00:23:37,410 --> 00:23:38,329
that's among our goals for.

654
00:23:38,939 --> 00:23:40,699
So let's consider how we might get there.

655
00:23:40,910 --> 00:23:43,060
So here now is my canvas of memory,

656
00:23:43,150 --> 00:23:46,069
and let me propose that the number 50 happen to get stored

657
00:23:46,069 --> 00:23:48,780
in the variable n down there at bottom right just because,

658
00:23:48,949 --> 00:23:53,310
and that's probably OX 123 or in reality a much larger address,

659
00:23:53,349 --> 00:23:56,949
but it's easier and quicker for us to just pretend it's at Xerox 123.

660
00:23:57,699 --> 00:24:00,410
What is actually happening in code

661
00:24:00,739 --> 00:24:02,380
when I declare P

662
00:24:02,739 --> 00:24:04,209
and put a value there?

663
00:24:04,380 --> 00:24:07,180
We'll recall a moment ago I declared P to be a

664
00:24:07,180 --> 00:24:10,209
pointer to an integer that is the address of an integer.

665
00:24:10,510 --> 00:24:12,859
So what's happening in memory is this if N is

666
00:24:12,859 --> 00:24:16,209
down here and happens to be at address OX 123,

667
00:24:16,459 --> 00:24:18,699
when I actually assign P

668
00:24:19,339 --> 00:24:19,859
to

669
00:24:20,099 --> 00:24:21,260
Ampersand N,

670
00:24:21,459 --> 00:24:24,270
that just literally takes that address of N.

671
00:24:24,599 --> 00:24:26,359
And puts it inside of P.

672
00:24:26,589 --> 00:24:27,670
Now P as an aside,

673
00:24:27,750 --> 00:24:28,709
happens to be pretty big.

674
00:24:28,829 --> 00:24:30,869
It turns out by convention on most systems,

675
00:24:30,949 --> 00:24:33,239
a pointer that is a variable that stores an

676
00:24:33,239 --> 00:24:35,790
address is actually going to be 8 bytes large.

677
00:24:35,829 --> 00:24:37,229
It's going to be 64 bits.

678
00:24:37,349 --> 00:24:37,869
Why is that?

679
00:24:37,910 --> 00:24:40,790
Our computers have so much darn memory nowadays and the gigabytes that

680
00:24:40,790 --> 00:24:42,949
you need to be able to count higher than 4 billion.

681
00:24:43,189 --> 00:24:43,750
As an aside,

682
00:24:43,829 --> 00:24:46,109
if you only used 32 bits.

683
00:24:46,203 --> 00:24:47,192
For your pointers,

684
00:24:47,392 --> 00:24:49,532
you can only count recall as high as 4 billion.

685
00:24:49,583 --> 00:24:53,743
4 billion is 4 gigabytes equivalently.

686
00:24:53,912 --> 00:24:56,753
That would mean your computers could not have 8 gigabytes of memory,

687
00:24:56,792 --> 00:24:57,902
16 gigabytes of memory.

688
00:24:57,912 --> 00:25:00,103
Your servers couldn't have tens of gigabytes of memories.

689
00:25:00,312 --> 00:25:03,052
We use 64 bits or 8 bytes nowadays for

690
00:25:03,052 --> 00:25:06,003
pointers because our computers have that much more memory.

691
00:25:06,333 --> 00:25:06,512
All right,

692
00:25:06,633 --> 00:25:07,662
so what is?

693
00:25:07,806 --> 00:25:10,625
Storing literally just an address like this.

694
00:25:10,796 --> 00:25:12,625
So when we wrote this code just a moment ago,

695
00:25:12,755 --> 00:25:15,316
what the computer did and has been doing for the past

696
00:25:15,316 --> 00:25:19,826
several weeks is literally just finding the location of N in memory

697
00:25:20,115 --> 00:25:22,916
and plopping that value inside of P,

698
00:25:23,235 --> 00:25:25,465
which itself is taking up a bit of memory,

699
00:25:25,556 --> 00:25:27,446
but by convention more memory,

700
00:25:27,546 --> 00:25:29,235
8 bytes in this case.

701
00:25:29,650 --> 00:25:30,630
The thing is,

702
00:25:30,800 --> 00:25:34,469
who really cares about this level of detail typically as programmers,

703
00:25:34,560 --> 00:25:36,589
it's useful to understand what's going on,

704
00:25:36,800 --> 00:25:40,520
but rarely are we going to care precisely about where things are in memory.

705
00:25:40,670 --> 00:25:43,829
Today it is really about just kind of looking at what's going on underneath the hood.

706
00:25:44,000 --> 00:25:47,229
So in fact we can abstract away most of my computer's memory I would propose,

707
00:25:47,400 --> 00:25:50,920
because at the moment all we care about is P existing and N existing.

708
00:25:50,930 --> 00:25:52,680
So who really cares what else is going on?

709
00:25:52,800 --> 00:25:53,400
And frankly,

710
00:25:53,520 --> 00:25:57,280
generally I am not going to care that N is at a.

711
00:25:57,685 --> 00:26:01,555
OX 123 just that it is at an address

712
00:26:01,925 --> 00:26:03,655
that happens to be OX 123.

713
00:26:03,724 --> 00:26:05,064
And so the way a programmer

714
00:26:05,405 --> 00:26:08,354
or computer scientist when talking about design on like a whiteboard

715
00:26:08,354 --> 00:26:10,635
or frankly in sections in office hours on a whiteboard,

716
00:26:10,885 --> 00:26:12,925
we rarely care what the actual addresses are

717
00:26:12,925 --> 00:26:15,635
so we generally abstract the specific address away

718
00:26:15,635 --> 00:26:19,405
and literally represent pointers with arrows on the

719
00:26:19,405 --> 00:26:21,555
screen or on the whiteboard or the like.

720
00:26:21,724 --> 00:26:25,135
This just means that P is a variable that points to.

721
00:26:25,619 --> 00:26:26,739
The number 50

722
00:26:26,930 --> 00:26:27,689
in memory.

723
00:26:28,859 --> 00:26:29,140
OK,

724
00:26:29,219 --> 00:26:32,050
questions on this mental model for what a pointer is.

725
00:26:32,540 --> 00:26:33,640
It's a pointer in

726
00:26:33,890 --> 00:26:35,530
like very much the literal sense.

727
00:26:37,079 --> 00:26:37,089
Oh,

728
00:26:38,589 --> 00:26:39,329
OK,

729
00:26:39,630 --> 00:26:42,030
so if you're on board with that,

730
00:26:42,069 --> 00:26:43,599
let me propose that

731
00:26:43,910 --> 00:26:45,300
we consider now

732
00:26:45,589 --> 00:26:47,670
um what these things look like maybe more physically.

733
00:26:47,750 --> 00:26:47,989
In fact,

734
00:26:48,109 --> 00:26:48,209
we've,

735
00:26:48,349 --> 00:26:51,550
we've got a couple of mailboxes here to make clear with a little metaphor

736
00:26:51,810 --> 00:26:52,020
that,

737
00:26:52,030 --> 00:26:52,349
uh,

738
00:26:52,359 --> 00:26:54,699
here is a physical representation

739
00:26:55,069 --> 00:26:56,579
of our variable,

740
00:26:56,910 --> 00:26:57,670
say P.

741
00:26:58,630 --> 00:27:01,510
Labeled as such inside of this is presumably

742
00:27:01,510 --> 00:27:03,699
gonna be the address of some actual value.

743
00:27:03,800 --> 00:27:06,680
That value at the end of the story is gonna be the value of N,

744
00:27:06,910 --> 00:27:10,219
which recall for consistency is that address OX123.

745
00:27:10,510 --> 00:27:13,219
So what happens when you actually

746
00:27:13,589 --> 00:27:14,390
try to.

747
00:27:14,910 --> 00:27:17,760
A locate a value in memory is analogous

748
00:27:17,760 --> 00:27:19,839
to sort of looking up something inside of these

749
00:27:19,839 --> 00:27:21,959
mailboxes which if you think of your computer's

750
00:27:21,959 --> 00:27:24,640
memory as hundreds or thousands of little mailboxes,

751
00:27:24,719 --> 00:27:27,959
maybe more apartment style where you've just got rows and columns

752
00:27:27,959 --> 00:27:31,560
of mailboxes as opposed to individual ones for single family homes,

753
00:27:31,760 --> 00:27:37,150
each of those mailboxes can contain the address of some value in memory.

754
00:27:37,319 --> 00:27:39,719
And so what's really happening is that if this is P.

755
00:27:40,209 --> 00:27:42,680
Not drawn to scale because they only make mailboxes so large.

756
00:27:43,040 --> 00:27:43,839
Inside of

757
00:27:44,250 --> 00:27:47,040
P is going to be an address like OX 123.

758
00:27:47,209 --> 00:27:47,969
And just to be dramatic,

759
00:27:48,050 --> 00:27:49,680
since there's a big football game this weekend,

760
00:27:50,040 --> 00:27:50,089
uh,

761
00:27:50,290 --> 00:27:53,609
here is a Harvard foam finger metaphorically like this

762
00:27:53,609 --> 00:27:56,319
pointer is like pointing at that value over there.

763
00:27:56,489 --> 00:27:57,569
And in fact we're going to see,

764
00:27:57,650 --> 00:27:58,729
as you asked a moment ago,

765
00:27:58,969 --> 00:28:01,390
can we actually go to an address in memory?

766
00:28:01,410 --> 00:28:02,949
We don't yet have the syntax for that,

767
00:28:02,969 --> 00:28:03,810
but we're about to,

768
00:28:04,010 --> 00:28:04,699
yes you can.

769
00:28:04,770 --> 00:28:06,969
And in fact if I follow what I'm pointing at,

770
00:28:07,020 --> 00:28:08,689
open up this location in memory.

771
00:28:09,599 --> 00:28:10,199
Voila,

772
00:28:10,349 --> 00:28:12,300
there is the 50 in question.

773
00:28:12,469 --> 00:28:14,699
So any time we're talking about values

774
00:28:14,699 --> 00:28:16,750
or we're talking about the addresses thereof,

775
00:28:16,949 --> 00:28:20,030
you can think of it analogously as being like physical mailboxes,

776
00:28:20,150 --> 00:28:22,229
one of which might contain a useful number like 50,

777
00:28:22,510 --> 00:28:25,140
1 of which might contain the address of that value,

778
00:28:25,430 --> 00:28:27,459
and we now have the syntax we'll see

779
00:28:27,670 --> 00:28:29,390
to actually go from one to the other.

780
00:28:29,790 --> 00:28:31,630
Let me actually go back into VS code here,

781
00:28:31,719 --> 00:28:33,979
which in the most recent version of my program,

782
00:28:34,079 --> 00:28:37,709
what I was doing was getting the address of N and storing it in P,

783
00:28:37,739 --> 00:28:39,599
and then I was literally printing out P itself,

784
00:28:39,609 --> 00:28:41,550
and that's when we saw the big hexadecimal number.

785
00:28:41,839 --> 00:28:43,349
That is generally not useful,

786
00:28:43,430 --> 00:28:45,829
but it's maybe interesting to see that one time.

787
00:28:46,079 --> 00:28:49,680
Let me instead though introduce another use of that star.

788
00:28:49,859 --> 00:28:51,969
Asterisk operator that allows us,

789
00:28:52,010 --> 00:28:55,199
as was asked a moment ago to actually go to that address.

790
00:28:55,410 --> 00:28:59,319
So in this version of my program I'm going to keep n equal to 50.

791
00:28:59,530 --> 00:29:02,199
I'm going to keep p equal to the address of N,

792
00:29:02,329 --> 00:29:03,880
but what I'm now going to do

793
00:29:04,130 --> 00:29:08,000
is show you how syntactically I can print out not P

794
00:29:08,849 --> 00:29:09,859
but N.

795
00:29:10,430 --> 00:29:12,170
But by using P,

796
00:29:12,329 --> 00:29:15,229
following the proverbial uh foam finger metaphor

797
00:29:15,229 --> 00:29:17,239
by printing out percent I backslash N

798
00:29:17,530 --> 00:29:18,920
and printing out N instead.

799
00:29:19,050 --> 00:29:22,930
Now obviously I could cheat and just say N and print out N like in version one,

800
00:29:22,969 --> 00:29:25,359
but that doesn't really demonstrate anything interesting here.

801
00:29:25,729 --> 00:29:26,400
However,

802
00:29:26,449 --> 00:29:26,609
if.

803
00:29:26,755 --> 00:29:29,084
I only have P at this point in the story,

804
00:29:29,305 --> 00:29:32,614
it turns out you can use the star for another purpose.

805
00:29:32,744 --> 00:29:35,255
If you simply prefix your variable name

806
00:29:35,505 --> 00:29:36,454
with a star,

807
00:29:36,785 --> 00:29:38,175
that is the so-called now

808
00:29:38,564 --> 00:29:40,135
Dreference operator,

809
00:29:40,305 --> 00:29:42,805
which means go to the address in P.

810
00:29:43,359 --> 00:29:45,180
So if I now open up my terminal here,

811
00:29:45,329 --> 00:29:47,119
do make addresses for this version,

812
00:29:47,290 --> 00:29:49,390
then do slash addresses and enter,

813
00:29:49,689 --> 00:29:51,479
I now get back the number 50.

814
00:29:51,689 --> 00:29:52,760
So what's really happening?

815
00:29:52,770 --> 00:29:53,619
In line 5,

816
00:29:53,770 --> 00:29:55,709
as has been true for several weeks now,

817
00:29:55,930 --> 00:29:56,790
we have.

818
00:29:57,109 --> 00:29:58,640
A variable called N

819
00:29:58,930 --> 00:30:01,000
being initialized to the number 50.

820
00:30:01,290 --> 00:30:01,680
Then

821
00:30:01,969 --> 00:30:05,280
on my next line 6 I'm declaring P as an address

822
00:30:05,530 --> 00:30:06,630
of some value,

823
00:30:06,810 --> 00:30:07,810
an integer specifically,

824
00:30:07,890 --> 00:30:09,839
and putting the address of N in there

825
00:30:10,300 --> 00:30:10,839
exactly.

826
00:30:10,969 --> 00:30:13,969
And then on line 7 I'm actually saying print out an integer.

827
00:30:14,089 --> 00:30:15,729
percent I as we've done for weeks,

828
00:30:15,880 --> 00:30:17,040
but what integer?

829
00:30:17,449 --> 00:30:18,520
Go to

830
00:30:18,839 --> 00:30:22,969
the address in P and print out what you find there.

831
00:30:23,050 --> 00:30:26,119
So that's equivalent again to the foam finger which is over there,

832
00:30:26,130 --> 00:30:27,000
pointing at

833
00:30:27,209 --> 00:30:30,890
the address I actually want to print out instead.

834
00:30:32,489 --> 00:30:33,119
OK,

835
00:30:33,579 --> 00:30:34,359
so.

836
00:30:35,329 --> 00:30:36,089
Usefulness.

837
00:30:36,130 --> 00:30:36,209
Well,

838
00:30:36,290 --> 00:30:38,170
I think we can get there by taking a look at

839
00:30:38,170 --> 00:30:40,530
one of our little white lies that we've been telling.

840
00:30:40,569 --> 00:30:40,770
In fact,

841
00:30:40,849 --> 00:30:42,449
let's turn our attention to strings,

842
00:30:42,569 --> 00:30:45,569
which up until now have been a sequence of characters in the computer's memory.

843
00:30:45,729 --> 00:30:47,540
A string is a thing in programming more generally,

844
00:30:47,650 --> 00:30:48,810
but in C,

845
00:30:49,089 --> 00:30:51,040
it technically doesn't exist by this name.

846
00:30:51,209 --> 00:30:53,060
But you can still use strings in C,

847
00:30:53,290 --> 00:30:55,130
but just not by calling them.

848
00:30:55,545 --> 00:30:58,314
T R I N G as the actual data type.

849
00:30:58,385 --> 00:31:01,094
But let's let's start with our familiar code here.

850
00:31:01,305 --> 00:31:03,064
Let me go into addresses.c.

851
00:31:03,505 --> 00:31:05,665
Let me add our trading wheels in for now and

852
00:31:05,665 --> 00:31:10,155
include CS50.h because in this version of my addresses program,

853
00:31:10,265 --> 00:31:14,334
what I want to do is declare a strings and I'm going to set it equal to high.

854
00:31:16,160 --> 00:31:16,459
Then,

855
00:31:16,520 --> 00:31:17,520
as we did in week one,

856
00:31:17,560 --> 00:31:20,439
let's go ahead and print out with percent S backslash N

857
00:31:20,760 --> 00:31:21,839
that value of S.

858
00:31:21,959 --> 00:31:22,520
So nothing new,

859
00:31:22,640 --> 00:31:23,520
nothing interesting here,

860
00:31:23,560 --> 00:31:25,800
so let me just do it quickly and do make addresses,

861
00:31:25,839 --> 00:31:27,069
then slash addresses,

862
00:31:27,239 --> 00:31:28,729
and we see high on the screen.

863
00:31:29,010 --> 00:31:31,939
So that has all been something we've been taking for granted,

864
00:31:32,020 --> 00:31:33,010
but let's consider

865
00:31:33,250 --> 00:31:36,089
what is going on underneath the hood of even that program.

866
00:31:36,339 --> 00:31:39,369
So the string we've declared in memory exists somewhere

867
00:31:39,619 --> 00:31:41,020
in the computer's canvas of memory.

868
00:31:41,060 --> 00:31:43,930
So strings equals high might end up somewhere down here,

869
00:31:43,979 --> 00:31:46,449
and I'm going to stop drawing all of the boxes when not necessary,

870
00:31:46,540 --> 00:31:50,380
but here we have HI exclamation point and as we discussed two weeks ago.

871
00:31:50,719 --> 00:31:53,010
The null character and UL,

872
00:31:53,239 --> 00:31:55,189
which just means the string stops here.

873
00:31:55,400 --> 00:31:56,469
So as a quick refresher,

874
00:31:56,599 --> 00:31:58,550
even though the word is three characters,

875
00:31:58,589 --> 00:32:00,359
it takes up how many bytes,

876
00:32:00,680 --> 00:32:01,270
4,

877
00:32:01,640 --> 00:32:03,750
always because you need that null terminator.

878
00:32:03,959 --> 00:32:04,250
All right,

879
00:32:04,439 --> 00:32:07,869
so maybe that string could be accessed then by its name,

880
00:32:07,959 --> 00:32:08,209
S,

881
00:32:08,280 --> 00:32:09,390
and we've seen this before.

882
00:32:09,560 --> 00:32:11,150
S 0 is the first character,

883
00:32:11,280 --> 00:32:12,589
S 12,

884
00:32:12,599 --> 00:32:13,719
and then if you want to poke around,

885
00:32:13,800 --> 00:32:15,530
you can go into S3,

886
00:32:15,640 --> 00:32:16,760
but you'll probably see quote unquote.

887
00:32:16,946 --> 00:32:19,816
All on the screen or the compiler will sort of the computer will sort

888
00:32:19,816 --> 00:32:22,885
of remind you that you don't really want to look there at that point.

889
00:32:23,095 --> 00:32:26,245
So 3 characters accessible via this array syntax,

890
00:32:26,456 --> 00:32:27,485
but we know now

891
00:32:27,776 --> 00:32:30,725
that everything in the computer's memory is addressable

892
00:32:30,975 --> 00:32:37,686
and maybe that H just so happened to end up at OX 123 and the I ends up at OX 124,

893
00:32:37,696 --> 00:32:38,566
125,

894
00:32:38,635 --> 00:32:40,156
126 respectively.

895
00:32:40,296 --> 00:32:41,625
It doesn't matter what these numbers are,

896
00:32:41,735 --> 00:32:42,105
but

897
00:32:42,495 --> 00:32:43,186
because strings.

898
00:32:43,241 --> 00:32:45,952
Are sequences of characters back to back to back in memory,

899
00:32:46,151 --> 00:32:50,232
it must be the case that these addresses are themselves contiguous

900
00:32:50,232 --> 00:32:52,991
back to back to back without gaps inside of them.

901
00:32:53,082 --> 00:32:55,302
That's how a string has always been stored in memory.

902
00:32:55,472 --> 00:32:56,771
It's just an array

903
00:32:57,072 --> 00:32:58,102
of characters.

904
00:32:58,552 --> 00:32:58,712
All right,

905
00:32:58,791 --> 00:32:59,702
so with that said,

906
00:32:59,871 --> 00:33:01,541
what really is S?

907
00:33:01,871 --> 00:33:06,072
We've thought of S in every program we've used strings in before as just a string

908
00:33:06,072 --> 00:33:09,391
like that is the sequence of characters or really it's the name of an array.

909
00:33:09,719 --> 00:33:11,290
But that's a bit of a white lie

910
00:33:11,619 --> 00:33:13,729
because what S really is,

911
00:33:14,060 --> 00:33:15,050
is going to be

912
00:33:15,420 --> 00:33:16,810
a more specific value.

913
00:33:17,420 --> 00:33:17,949
Take a guess,

914
00:33:17,979 --> 00:33:21,119
what is actually going to be the value in S?

915
00:33:24,979 --> 00:33:25,140
Yeah,

916
00:33:25,300 --> 00:33:26,689
the address of,

917
00:33:26,819 --> 00:33:27,329
if I may,

918
00:33:27,540 --> 00:33:28,540
that array.

919
00:33:28,699 --> 00:33:30,810
So we've got like sort of 4 possible answers here,

920
00:33:30,949 --> 00:33:31,180
A,

921
00:33:31,219 --> 00:33:31,380
B,

922
00:33:31,459 --> 00:33:31,609
C,

923
00:33:31,619 --> 00:33:31,969
and D,

924
00:33:32,020 --> 00:33:32,729
multiple choice.

925
00:33:32,859 --> 00:33:35,709
Which of those numbers probably makes sense to store

926
00:33:36,060 --> 00:33:37,800
in the variable called S

927
00:33:38,459 --> 00:33:39,939
in order to get to this string?

928
00:33:40,939 --> 00:33:42,630
What is S's value?

929
00:33:42,910 --> 00:33:43,229
Yeah.

930
00:33:46,369 --> 00:33:48,790
0 X 123 is correct.

931
00:33:48,959 --> 00:33:51,989
So we don't talk about this in like week one because like it's already hard to like

932
00:33:51,989 --> 00:33:54,530
remember semicolons in week one like God forbid start

933
00:33:54,530 --> 00:33:56,430
thinking about like what these specific addresses are.

934
00:33:56,719 --> 00:33:57,439
S is a string,

935
00:33:57,479 --> 00:33:57,810
yes,

936
00:33:58,000 --> 00:34:01,119
but technically S is and has been since week one.

937
00:34:01,709 --> 00:34:02,630
A pointer,

938
00:34:02,780 --> 00:34:04,819
the address of an array

939
00:34:05,109 --> 00:34:06,819
of characters in memory.

940
00:34:06,989 --> 00:34:10,739
The address specifically of the first character in memory,

941
00:34:10,949 --> 00:34:11,918
which is sufficient.

942
00:34:11,989 --> 00:34:12,379
Why?

943
00:34:12,840 --> 00:34:16,620
Because of this null terminating convention that we talked about weeks ago

944
00:34:16,949 --> 00:34:19,350
that tells the computer where the string ends the.

945
00:34:19,504 --> 00:34:22,155
Pointer tells the computer where the string

946
00:34:22,645 --> 00:34:23,313
begins,

947
00:34:23,645 --> 00:34:26,415
and that's how you get using just numbers,

948
00:34:26,524 --> 00:34:28,655
zeros and ones inside of a computer

949
00:34:29,043 --> 00:34:31,074
to store something as interesting

950
00:34:31,364 --> 00:34:33,195
as an actual string.

951
00:34:33,364 --> 00:34:33,685
So in fact,

952
00:34:33,764 --> 00:34:35,594
let's let's take a closer look at this.

953
00:34:35,645 --> 00:34:36,094
In fact,

954
00:34:36,245 --> 00:34:37,405
let me go into.

955
00:34:37,929 --> 00:34:38,168
Uh,

956
00:34:38,179 --> 00:34:39,149
VS code again,

957
00:34:39,340 --> 00:34:41,060
and just for the sake of discussion,

958
00:34:41,179 --> 00:34:42,580
let me declare S as before,

959
00:34:42,620 --> 00:34:44,060
but instead of printing out,

960
00:34:44,340 --> 00:34:44,530
uh,

961
00:34:44,540 --> 00:34:45,620
the whole string at once,

962
00:34:45,699 --> 00:34:46,810
let's go ahead and do this.

963
00:34:46,938 --> 00:34:47,600
Print F,

964
00:34:48,129 --> 00:34:48,389
uh,

965
00:34:48,458 --> 00:34:50,409
quote unquote per P

966
00:34:50,659 --> 00:34:51,580
backslash N.

967
00:34:52,668 --> 00:34:56,378
And then let's print out S itself initially to see

968
00:34:56,378 --> 00:34:59,608
whether it's actually OX123 or presumably a much bigger number.

969
00:34:59,858 --> 00:35:00,539
Then after that,

970
00:35:00,648 --> 00:35:02,418
let's print out another pointer,

971
00:35:02,938 --> 00:35:04,849
another address rather per P

972
00:35:05,339 --> 00:35:06,229
backslash N,

973
00:35:07,339 --> 00:35:09,638
and now I'd like to print out

974
00:35:09,928 --> 00:35:13,279
the address of the first character of S,

975
00:35:13,458 --> 00:35:13,858
but let's,

976
00:35:14,059 --> 00:35:14,979
let's not get ahead of ourselves.

977
00:35:15,059 --> 00:35:16,618
Let me go ahead and make addresses again.

978
00:35:17,050 --> 00:35:21,649
Dot slash addresses OK there now in this high program is the

979
00:35:21,649 --> 00:35:28,520
address at which the string itself is stored OX 5A 7143027004,

980
00:35:28,580 --> 00:35:30,399
so bigger than OX 123.

981
00:35:30,610 --> 00:35:30,669
Well,

982
00:35:30,689 --> 00:35:31,850
let's now poke around.

983
00:35:32,169 --> 00:35:33,159
What if I were to do this?

984
00:35:33,250 --> 00:35:34,610
What if I want to print out

985
00:35:34,889 --> 00:35:36,199
the address of

986
00:35:36,810 --> 00:35:40,320
how about the first character in that string?

987
00:35:40,530 --> 00:35:40,610
Well,

988
00:35:40,649 --> 00:35:45,370
at the moment recall that S 0 is literally the first character that is a char.

989
00:35:45,929 --> 00:35:46,800
So with what

990
00:35:46,949 --> 00:35:50,060
syntax could I get the address of the first character?

991
00:35:50,989 --> 00:35:51,149
Well,

992
00:35:51,270 --> 00:35:52,860
we haven't learned all that much that's new today.

993
00:35:52,949 --> 00:35:57,699
It's just a single ampersand that will get me the address of that character.

994
00:35:57,949 --> 00:35:59,899
If I do this for the next character,

995
00:36:00,189 --> 00:36:01,050
I can see

996
00:36:01,389 --> 00:36:02,709
one after another,

997
00:36:02,750 --> 00:36:05,550
and in fact this is going to have 4 characters in total,

998
00:36:05,709 --> 00:36:06,899
including the null character.

999
00:36:07,139 --> 00:36:08,189
So let me copy paste,

1000
00:36:08,229 --> 00:36:09,989
which is generally frowned upon but not for a lecture

1001
00:36:09,989 --> 00:36:11,659
demo because we're just trying to do this quickly.

1002
00:36:11,949 --> 00:36:12,870
Let's print out.

1003
00:36:13,239 --> 00:36:15,550
The address of S itself and then more

1004
00:36:15,550 --> 00:36:17,820
specifically the address of S's first character,

1005
00:36:17,989 --> 00:36:19,659
the address of S's second character,

1006
00:36:19,790 --> 00:36:20,370
3rd,

1007
00:36:20,590 --> 00:36:22,610
and the address of that null terminator.

1008
00:36:23,229 --> 00:36:23,429
All right,

1009
00:36:23,510 --> 00:36:26,020
let's go back into make addresses.

1010
00:36:26,229 --> 00:36:28,979
Let me go ahead and clear my terminal and do slash addresses

1011
00:36:28,979 --> 00:36:32,070
and we see if I zoom in on my terminal here.

1012
00:36:32,659 --> 00:36:33,580
The following

1013
00:36:34,030 --> 00:36:43,100
S itself contains OX 561999 BD 0004 and the address of the first character in S,

1014
00:36:43,189 --> 00:36:44,639
AKA S 0

1015
00:36:45,030 --> 00:36:46,459
is exactly the same thing.

1016
00:36:46,629 --> 00:36:47,310
The next character,

1017
00:36:47,340 --> 00:36:47,629
the.

1018
00:36:47,770 --> 00:36:49,770
High and high is one bite away.

1019
00:36:49,969 --> 00:36:51,810
The exclamation point is one more bite away,

1020
00:36:51,850 --> 00:36:55,280
and the null Terminator is one more bite away.

1021
00:36:55,370 --> 00:36:55,649
So again,

1022
00:36:55,729 --> 00:36:56,250
bigger numbers,

1023
00:36:56,330 --> 00:36:58,520
but the point is these are indeed just

1024
00:36:58,520 --> 00:37:01,280
the actual addresses of all of these characters

1025
00:37:01,689 --> 00:37:02,120
in

1026
00:37:02,290 --> 00:37:02,770
memory.

1027
00:37:03,679 --> 00:37:03,760
Alright,

1028
00:37:03,840 --> 00:37:05,389
let me pause for any questions here.

1029
00:37:05,600 --> 00:37:05,919
Yeah.

1030
00:37:07,159 --> 00:37:07,600
Why do you need

1031
00:37:12,729 --> 00:37:13,370
Good question.

1032
00:37:13,409 --> 00:37:18,800
Why do I need the ampersan before the specific characters in S but not S itself?

1033
00:37:19,110 --> 00:37:20,770
Think what S actually is.

1034
00:37:20,810 --> 00:37:25,679
I'm claiming for the moment that S itself is the address of that whole string,

1035
00:37:26,330 --> 00:37:28,370
which just so happens by design to be

1036
00:37:28,370 --> 00:37:30,800
equivalent to the address of the first character,

1037
00:37:30,850 --> 00:37:32,290
because that is the convention humans came up

1038
00:37:32,290 --> 00:37:34,250
with decades ago to represent a string.

1039
00:37:34,370 --> 00:37:37,510
Now you might think that you need the address of every character in the string,

1040
00:37:37,530 --> 00:37:38,000
but no,

1041
00:37:38,250 --> 00:37:42,209
that's why humans decades ago decided to just terminate every string in memory with

1042
00:37:42,419 --> 00:37:44,300
The backslash zero or null terminator,

1043
00:37:44,330 --> 00:37:46,159
because if you give me the beginning of the string and the end,

1044
00:37:46,290 --> 00:37:48,719
I can obviously with a loop find everything else

1045
00:37:49,110 --> 00:37:49,879
in between.

1046
00:37:51,129 --> 00:37:52,399
Other questions?

1047
00:37:53,570 --> 00:37:54,120
All right.

1048
00:37:54,290 --> 00:37:54,449
Well,

1049
00:37:54,649 --> 00:37:58,469
what is then this actual thing in memory?

1050
00:37:58,560 --> 00:37:58,689
Well,

1051
00:37:58,810 --> 00:37:59,830
it turns out

1052
00:38:00,169 --> 00:38:01,439
that S is,

1053
00:38:01,449 --> 00:38:01,679
yes,

1054
00:38:01,689 --> 00:38:03,600
a string as we've been describing it.

1055
00:38:03,770 --> 00:38:04,620
It turns out that yes,

1056
00:38:04,729 --> 00:38:07,449
S is a string as we've been describing it all this time.

1057
00:38:07,800 --> 00:38:08,639
But technically,

1058
00:38:08,689 --> 00:38:12,090
I think we're ready to reveal what little white lie we've been telling

1059
00:38:12,090 --> 00:38:15,850
or if you will what abstractions actually is in the CS 50 library.

1060
00:38:16,520 --> 00:38:19,530
The type you know as string since week one,

1061
00:38:20,010 --> 00:38:22,360
all this time has simply been

1062
00:38:22,530 --> 00:38:23,919
a synonym for

1063
00:38:24,370 --> 00:38:26,030
char star

1064
00:38:26,409 --> 00:38:27,000
S.

1065
00:38:27,530 --> 00:38:28,139
This is where.

1066
00:38:29,370 --> 00:38:29,860
Maybe

1067
00:38:30,250 --> 00:38:31,610
so what does this really mean?

1068
00:38:31,649 --> 00:38:31,739
Well,

1069
00:38:31,780 --> 00:38:32,729
we saw in

1070
00:38:33,679 --> 00:38:36,689
P earlier here we're seeing char stars,

1071
00:38:36,729 --> 00:38:37,649
but what does that really mean?

1072
00:38:37,810 --> 00:38:37,889
Well,

1073
00:38:37,969 --> 00:38:40,239
S is the name of the variable and yes it's a string,

1074
00:38:40,379 --> 00:38:41,330
but what is it really?

1075
00:38:41,409 --> 00:38:42,959
S is the address of

1076
00:38:43,250 --> 00:38:43,800
a char.

1077
00:38:44,080 --> 00:38:46,689
And so in week one of the course in the actual CS 50 library,

1078
00:38:46,729 --> 00:38:49,239
we've told this little white lie by just creating a synonym

1079
00:38:49,489 --> 00:38:50,449
in the library.

1080
00:38:50,595 --> 00:38:52,206
That makes char star,

1081
00:38:52,335 --> 00:38:52,736
so to speak,

1082
00:38:52,815 --> 00:38:54,375
the exact same thing as string,

1083
00:38:54,456 --> 00:38:55,766
S T R I N G,

1084
00:38:55,936 --> 00:38:57,815
just so that we don't have to think about this level of detail,

1085
00:38:57,855 --> 00:39:01,095
let alone hexideecimal notation and addresses and pointers and dereferencing and

1086
00:39:01,095 --> 00:39:03,365
all of this complexity in the first weeks of the course.

1087
00:39:03,575 --> 00:39:05,325
It simply abstracts away

1088
00:39:05,615 --> 00:39:08,595
what the char what a string actually is.

1089
00:39:08,775 --> 00:39:09,446
And in fact

1090
00:39:09,676 --> 00:39:10,976
we've seen this technique.

1091
00:39:11,172 --> 00:39:12,931
Or in a more complicated way,

1092
00:39:12,971 --> 00:39:13,172
in fact,

1093
00:39:13,251 --> 00:39:15,562
if you recall a couple of lectures last week,

1094
00:39:15,731 --> 00:39:17,691
we actually claimed that you could create a phone book,

1095
00:39:17,741 --> 00:39:18,302
for instance,

1096
00:39:18,332 --> 00:39:21,562
using persons and persons have names and numbers,

1097
00:39:21,572 --> 00:39:25,172
and we created our own type by saying type death and

1098
00:39:25,172 --> 00:39:27,882
that type was a whole structure which is the complexity part,

1099
00:39:27,971 --> 00:39:29,652
a structure containing a name and a number,

1100
00:39:29,662 --> 00:39:31,491
and we gave that data type ultimately.

1101
00:39:31,750 --> 00:39:32,989
The keyword person.

1102
00:39:33,139 --> 00:39:37,219
So we've already invented in class our own make-believe data types to

1103
00:39:37,219 --> 00:39:40,449
create things that didn't come with C itself like a person.

1104
00:39:40,699 --> 00:39:40,780
Well,

1105
00:39:40,820 --> 00:39:44,179
the struct is very specific to what we were trying to do with the phone book,

1106
00:39:44,340 --> 00:39:46,540
but typede is more generally useful because it

1107
00:39:46,540 --> 00:39:48,489
literally allows you to define your own type.

1108
00:39:48,699 --> 00:39:49,510
So for instance,

1109
00:39:49,540 --> 00:39:52,219
if we wanted to create a synonym.

1110
00:39:52,405 --> 00:39:53,034
For in,

1111
00:39:53,145 --> 00:39:55,544
because we never remember what it is and call it integer,

1112
00:39:55,804 --> 00:39:57,475
instead you could simply say typed

1113
00:39:58,225 --> 00:39:58,784
in

1114
00:39:59,145 --> 00:40:00,344
integer semicolon,

1115
00:40:00,364 --> 00:40:01,735
and that would create

1116
00:40:02,104 --> 00:40:04,504
in your programming environment a data type called

1117
00:40:04,504 --> 00:40:06,745
integer that is literally equivalent to in.

1118
00:40:07,024 --> 00:40:08,354
Now this is not all that useful,

1119
00:40:08,465 --> 00:40:10,175
so instead in the CS 50 library,

1120
00:40:10,304 --> 00:40:12,975
we do use TyD to tell the computer

1121
00:40:13,264 --> 00:40:17,455
thatcharStar should instead be spelled

1122
00:40:17,705 --> 00:40:18,504
as string.

1123
00:40:19,239 --> 00:40:20,070
Semicolon,

1124
00:40:20,199 --> 00:40:25,030
and that just means that string ever after is the same thing as saying char star.

1125
00:40:25,320 --> 00:40:27,030
So all of this time since week one,

1126
00:40:27,080 --> 00:40:29,560
I could have been doing exactly that if I wanted.

1127
00:40:29,610 --> 00:40:30,179
And in fact,

1128
00:40:30,320 --> 00:40:32,310
if I go back to VS code here,

1129
00:40:32,479 --> 00:40:35,679
let's simplify this quite a bit and go back to the very first

1130
00:40:35,679 --> 00:40:39,550
version of the program wherein I use percent S and just print it out

1131
00:40:39,909 --> 00:40:41,629
S is value itself,

1132
00:40:41,679 --> 00:40:42,530
the string high.

1133
00:40:42,719 --> 00:40:45,919
Well this of course is going to work as always as follows.

1134
00:40:45,959 --> 00:40:47,909
It's just going to print out high on the screen.

1135
00:40:48,250 --> 00:40:49,149
But now,

1136
00:40:49,330 --> 00:40:51,520
if I get rid of the CS 50 library

1137
00:40:51,689 --> 00:40:53,010
and try to recompile this,

1138
00:40:53,090 --> 00:40:55,000
notice we'll get an error that I think I've

1139
00:40:55,370 --> 00:40:56,250
seen before.

1140
00:40:57,129 --> 00:40:58,060
Here we have,

1141
00:40:58,330 --> 00:40:59,840
if I scroll up to the very first line,

1142
00:41:00,050 --> 00:41:02,320
use of undeclared identifier string.

1143
00:41:02,370 --> 00:41:03,489
Did I mean standard in?

1144
00:41:03,550 --> 00:41:03,850
And no,

1145
00:41:03,949 --> 00:41:04,520
I don't,

1146
00:41:04,530 --> 00:41:07,320
and no I didn't a couple weeks ago when I accidentally did that,

1147
00:41:07,550 --> 00:41:11,199
but the compiler does not know about the keyword string at the moment.

1148
00:41:11,370 --> 00:41:11,469
Well,

1149
00:41:11,489 --> 00:41:12,040
that's fine.

1150
00:41:12,209 --> 00:41:15,719
Even if I don't have the CS50 library installed on this computer,

1151
00:41:15,969 --> 00:41:17,570
I can just get rid of the word string,

1152
00:41:17,610 --> 00:41:19,610
which is a concept but not a.

1153
00:41:19,735 --> 00:41:20,735
Keyword in C

1154
00:41:21,014 --> 00:41:23,935
and just rename it to chartar and now in

1155
00:41:23,935 --> 00:41:26,195
my terminal window I can do make addresses again,

1156
00:41:26,514 --> 00:41:27,254
slash addresses,

1157
00:41:27,294 --> 00:41:27,955
and voila,

1158
00:41:28,054 --> 00:41:31,945
we're back in business with no CS 50 training wheels whatsoever

1159
00:41:32,254 --> 00:41:34,774
because printF knows given a charge star,

1160
00:41:34,854 --> 00:41:35,685
go to that address,

1161
00:41:35,754 --> 00:41:36,014
print,

1162
00:41:36,024 --> 00:41:36,245
print,

1163
00:41:36,254 --> 00:41:36,485
print,

1164
00:41:36,495 --> 00:41:39,844
print until you get to the null Terminator and then stop printing.

1165
00:41:40,014 --> 00:41:41,764
There's a loop in there that does exactly

1166
00:41:42,014 --> 00:41:42,415
that.

1167
00:41:44,479 --> 00:41:45,610
Questions

1168
00:41:46,280 --> 00:41:49,229
on char star or what a string actually

1169
00:41:49,840 --> 00:41:50,429
now

1170
00:41:50,719 --> 00:41:51,429
is.

1171
00:41:53,010 --> 00:41:53,280
Yeah,

1172
00:41:53,370 --> 00:41:53,919
in front.

1173
00:41:55,949 --> 00:41:56,070
I

1174
00:42:02,409 --> 00:42:02,939
I know.

1175
00:42:05,120 --> 00:42:05,639
Good question.

1176
00:42:05,679 --> 00:42:08,590
How does print F know to keep going until it gets to the null,

1177
00:42:08,870 --> 00:42:09,870
the format code?

1178
00:42:10,320 --> 00:42:12,159
Because I've been using percents,

1179
00:42:12,199 --> 00:42:13,590
which means print a string,

1180
00:42:14,080 --> 00:42:15,370
instead of percent C,

1181
00:42:15,560 --> 00:42:17,310
which means print a single character,

1182
00:42:17,459 --> 00:42:18,909
print FC is that percents,

1183
00:42:18,919 --> 00:42:19,310
and it was like,

1184
00:42:19,320 --> 00:42:19,520
oh,

1185
00:42:19,600 --> 00:42:21,830
I should use a loop to print out

1186
00:42:22,120 --> 00:42:24,429
all of the characters until the null terminator.

1187
00:42:24,600 --> 00:42:26,550
If I instead passed in just percent C,

1188
00:42:26,760 --> 00:42:28,590
it would stop after a single character.

1189
00:42:30,679 --> 00:42:31,320
Other questions.

1190
00:42:37,600 --> 00:42:38,070
Good question.

1191
00:42:38,110 --> 00:42:41,340
Why don't I de-references in order to print it out?

1192
00:42:41,629 --> 00:42:44,060
So let me try that for just a moment here.

1193
00:42:44,379 --> 00:42:49,429
Why do I not have to now or any week prior do stars here?

1194
00:42:49,510 --> 00:42:50,030
Because after all,

1195
00:42:50,100 --> 00:42:51,459
if S is the string,

1196
00:42:51,750 --> 00:42:53,899
I want to go to the string and print it out.

1197
00:42:54,030 --> 00:42:54,070
Well,

1198
00:42:54,110 --> 00:42:57,510
the first answer is that print F is doing this for you because it's

1199
00:42:57,510 --> 00:43:00,469
being handed the address and it is going to the address for you.

1200
00:43:00,510 --> 00:43:03,350
So that star is somewhere in print F's implementation.

1201
00:43:03,659 --> 00:43:06,959
But this is also incorrect conceptually because yes,

1202
00:43:07,169 --> 00:43:08,239
S is the string,

1203
00:43:08,370 --> 00:43:12,840
but more technically today S is the address of the first character

1204
00:43:13,169 --> 00:43:14,149
in the string.

1205
00:43:14,489 --> 00:43:18,520
So I really want to provide print F in this case with the address,

1206
00:43:18,689 --> 00:43:20,479
not the specific character

1207
00:43:20,919 --> 00:43:23,139
because I wanted to treat it as a string,

1208
00:43:23,290 --> 00:43:23,760
not

1209
00:43:23,919 --> 00:43:25,459
a single character indeed.

1210
00:43:25,770 --> 00:43:31,729
So I could use the percent S if I changed to uh I could use S if I changed to C

1211
00:43:31,889 --> 00:43:33,169
to print out the single character.

1212
00:43:34,209 --> 00:43:34,449
All right,

1213
00:43:34,530 --> 00:43:37,129
so let's play around just syntactically for just a moment here.

1214
00:43:37,169 --> 00:43:38,159
In VS code,

1215
00:43:38,370 --> 00:43:41,360
let me propose that we still use ChartarS here

1216
00:43:41,360 --> 00:43:43,330
and then just demonstrate exactly what's going on.

1217
00:43:43,409 --> 00:43:44,939
So I'll do exactly what was just asked.

1218
00:43:45,050 --> 00:43:46,239
So I'll use percent C,

1219
00:43:46,370 --> 00:43:48,159
and then I'm going to go ahead and print out for

1220
00:43:48,159 --> 00:43:52,080
now our old week 2 syntax treating S as an array.

1221
00:43:52,250 --> 00:43:53,540
So S 0,

1222
00:43:53,610 --> 00:43:55,010
S1 and S2.

1223
00:43:55,709 --> 00:43:57,810
Using some copy paste just for time's sake.

1224
00:43:57,979 --> 00:44:00,379
This of course is not going to do anything all that interesting,

1225
00:44:00,429 --> 00:44:02,939
but it is going to demonstrate that indeed we have

1226
00:44:02,939 --> 00:44:06,100
HI exclamation point back to back to back in memory.

1227
00:44:06,340 --> 00:44:07,449
And if I really want,

1228
00:44:08,179 --> 00:44:10,159
I could print it all in one line by getting rid of,

1229
00:44:10,169 --> 00:44:10,459
of course,

1230
00:44:10,500 --> 00:44:11,419
those new lines.

1231
00:44:11,580 --> 00:44:13,260
But what more can I do with this syntax?

1232
00:44:13,379 --> 00:44:13,459
Well,

1233
00:44:13,580 --> 00:44:16,179
I could take literally the fact that S is

1234
00:44:16,179 --> 00:44:18,820
the address of the First character in memory.

1235
00:44:19,030 --> 00:44:22,820
So instead of using this array notation which we introduced in week two,

1236
00:44:23,149 --> 00:44:25,500
I could technically go to

1237
00:44:25,820 --> 00:44:27,100
the address

1238
00:44:27,310 --> 00:44:27,979
of S.

1239
00:44:28,159 --> 00:44:28,620
Why?

1240
00:44:28,870 --> 00:44:28,989
Well,

1241
00:44:29,149 --> 00:44:32,129
S is the address of the first character of the string.

1242
00:44:32,530 --> 00:44:35,590
Star S means go to that address and voila,

1243
00:44:35,709 --> 00:44:39,239
you're at the first character by definition of what S is.

1244
00:44:39,790 --> 00:44:45,219
So I could print out the first character using S instead of S bracket 0.

1245
00:44:45,840 --> 00:44:47,020
How could I do this?

1246
00:44:47,159 --> 00:44:47,280
Well,

1247
00:44:47,439 --> 00:44:50,030
here's where we can actually take advantage of the fact

1248
00:44:50,360 --> 00:44:51,030
that

1249
00:44:51,479 --> 00:44:55,209
pointers and addresses more generally are in fact.

1250
00:44:55,870 --> 00:45:00,030
Numbers and you can actually do arithmetic on pointers themselves.

1251
00:45:00,110 --> 00:45:00,510
In other words,

1252
00:45:00,550 --> 00:45:02,070
there is a concept known as pointer arithmetic,

1253
00:45:02,090 --> 00:45:03,949
which means given an address you can add to it,

1254
00:45:04,070 --> 00:45:04,649
subtract to it.

1255
00:45:04,709 --> 00:45:04,830
Heck,

1256
00:45:04,870 --> 00:45:05,989
you could even multiply or divide,

1257
00:45:06,060 --> 00:45:08,810
even though that would probably be weird in most cases.

1258
00:45:08,909 --> 00:45:10,179
We could certainly add

1259
00:45:10,550 --> 00:45:11,429
numbers to an address.

1260
00:45:11,510 --> 00:45:12,260
So for instance,

1261
00:45:12,350 --> 00:45:15,379
if I want to print out the second character of S,

1262
00:45:15,709 --> 00:45:18,219
that's kind of equivalent to going to S.

1263
00:45:18,959 --> 00:45:20,879
But then moving over one character,

1264
00:45:21,090 --> 00:45:25,360
so maybe I should do a little bit of pointer arithmetic and do S + 1

1265
00:45:25,530 --> 00:45:28,120
in parentheses just so that like in math class

1266
00:45:28,120 --> 00:45:30,959
we do order of operations correctly and then down here

1267
00:45:31,250 --> 00:45:32,290
I could go to

1268
00:45:32,570 --> 00:45:33,760
S again but wait a minute,

1269
00:45:33,770 --> 00:45:37,320
I want to go to S plus 2 characters away

1270
00:45:37,489 --> 00:45:38,600
or 2 bytes away.

1271
00:45:38,810 --> 00:45:43,679
So now I can do make addresses down here and I did mess up

1272
00:45:44,639 --> 00:45:45,310
up new mistake,

1273
00:45:45,530 --> 00:45:46,639
unintentional.

1274
00:45:49,120 --> 00:45:49,199
Yep,

1275
00:45:49,320 --> 00:45:51,139
I forgot my parenthesis on the very end here,

1276
00:45:51,209 --> 00:45:52,590
so that was just user error.

1277
00:45:52,840 --> 00:45:54,050
Make addresses again,

1278
00:45:54,610 --> 00:45:54,989
addresses,

1279
00:45:55,000 --> 00:46:00,199
and now I indeed see HI one more time

1280
00:46:00,199 --> 00:46:03,350
using pointer arithmetic instead of our familiar array notation.

1281
00:46:03,479 --> 00:46:04,199
So what is that array?

1282
00:46:04,290 --> 00:46:06,649
It's what we would generally call syntactic sugar,

1283
00:46:06,719 --> 00:46:07,669
which is a very

1284
00:46:07,879 --> 00:46:10,290
weird way of saying like it's just nicer syntax.

1285
00:46:10,320 --> 00:46:12,159
Like no one wants to write code that looks like this.

1286
00:46:12,239 --> 00:46:12,830
It sort of,

1287
00:46:12,959 --> 00:46:13,080
you know,

1288
00:46:13,120 --> 00:46:15,870
bends the mind a little bit to read and parse all of this visually.

1289
00:46:16,040 --> 00:46:17,840
Just S 0 is much more straightforward,

1290
00:46:17,919 --> 00:46:19,550
but what it's really doing

1291
00:46:19,959 --> 00:46:21,030
is this,

1292
00:46:21,189 --> 00:46:24,239
and the computer is essentially converting that bracket notation for

1293
00:46:24,239 --> 00:46:28,830
us into this more esoteric but correct version instead.

1294
00:46:29,820 --> 00:46:30,169
All right,

1295
00:46:30,370 --> 00:46:31,280
what else can I do?

1296
00:46:31,409 --> 00:46:31,489
Well,

1297
00:46:31,610 --> 00:46:32,600
just for fun,

1298
00:46:32,969 --> 00:46:34,090
for some definition of fun,

1299
00:46:34,169 --> 00:46:35,320
let's go ahead and print out

1300
00:46:35,770 --> 00:46:38,090
three different strings and recall that a string is

1301
00:46:38,090 --> 00:46:40,840
a sequence of characters that starts at some address.

1302
00:46:41,090 --> 00:46:42,449
So let's first print out

1303
00:46:42,919 --> 00:46:44,909
the sequence of characters that starts at S.

1304
00:46:45,209 --> 00:46:47,570
Let's next print out the sequence of characters that

1305
00:46:47,570 --> 00:46:50,199
starts at S + 1 and let's lastly print out

1306
00:46:50,370 --> 00:46:52,600
the string that starts at S + 2,

1307
00:46:52,770 --> 00:46:55,719
just playing around with the definition of what these pointers are.

1308
00:46:55,889 --> 00:46:57,320
Let me do make addresses

1309
00:46:58,090 --> 00:46:58,889
and uh.

1310
00:46:59,959 --> 00:47:00,590
Not my day.

1311
00:47:01,310 --> 00:47:02,030
What did I forget?

1312
00:47:02,879 --> 00:47:03,550
Semicolon.

1313
00:47:03,639 --> 00:47:04,479
So if it happens to you,

1314
00:47:04,530 --> 00:47:05,360
it happens to me too.

1315
00:47:05,479 --> 00:47:07,760
Make addresses slash addresses,

1316
00:47:07,770 --> 00:47:10,110
and now this one's gonna be a little curious,

1317
00:47:10,239 --> 00:47:10,989
but I see

1318
00:47:11,270 --> 00:47:11,729
hi,

1319
00:47:11,919 --> 00:47:12,479
I,

1320
00:47:12,600 --> 00:47:14,389
and just exclamation point.

1321
00:47:14,399 --> 00:47:14,790
Why?

1322
00:47:15,250 --> 00:47:17,350
Because I'm treating a string literally as what it is,

1323
00:47:17,360 --> 00:47:18,669
a sequence of characters,

1324
00:47:18,719 --> 00:47:21,399
but I'm giving print F the address of the first character.

1325
00:47:21,629 --> 00:47:23,899
Initially then of the 2nd character,

1326
00:47:24,030 --> 00:47:24,669
then of the 3rd,

1327
00:47:24,750 --> 00:47:25,989
but all three of those

1328
00:47:26,429 --> 00:47:27,379
statements work

1329
00:47:27,750 --> 00:47:31,659
because all three of them happened to be terminated by the same null character,

1330
00:47:31,870 --> 00:47:32,879
even though I,

1331
00:47:32,929 --> 00:47:36,449
and the exclamation point alone was not really my intention.

1332
00:47:36,590 --> 00:47:38,659
That doesn't stop me from being able to do it

1333
00:47:39,110 --> 00:47:39,939
nonetheless.

1334
00:47:41,479 --> 00:47:41,500
All right,

1335
00:47:42,469 --> 00:47:42,530
well,

1336
00:47:42,550 --> 00:47:43,860
let's do one other

1337
00:47:44,149 --> 00:47:46,030
maybe application of this idea.

1338
00:47:46,149 --> 00:47:47,429
Let me propose that.

1339
00:47:47,510 --> 00:47:50,419
Let me propose that we take a look at our computer's memory here

1340
00:47:50,419 --> 00:47:54,189
and let's suppose that we want to start comparing values because in week one

1341
00:47:54,189 --> 00:47:56,270
we did a lot of that and even in week 0 we did a

1342
00:47:56,270 --> 00:47:58,479
lot of that with if and else if and else and so forth.

1343
00:47:58,629 --> 00:48:01,870
So let's make this a little more real and also reveal why last

1344
00:48:01,870 --> 00:48:06,120
week we had to solve an unexpected problem using another string function,

1345
00:48:06,229 --> 00:48:06,620
namely

1346
00:48:06,899 --> 00:48:08,870
stircom STR CMP.

1347
00:48:09,070 --> 00:48:10,800
So here for instance are two arbitrary.

1348
00:48:10,975 --> 00:48:13,354
A variables in memory I and J and I gave them both

1349
00:48:13,354 --> 00:48:15,725
the value of 50 and maybe they indeed end up there,

1350
00:48:15,824 --> 00:48:17,554
each of them taking up 4 bytes.

1351
00:48:18,205 --> 00:48:22,715
Last time recall that we weren't able to compare two values in memory

1352
00:48:23,044 --> 00:48:28,754
just by using the equal equal operator unless those values last time were actually

1353
00:48:29,044 --> 00:48:29,685
integers.

1354
00:48:29,715 --> 00:48:30,004
In fact,

1355
00:48:30,084 --> 00:48:30,564
let's do that.

1356
00:48:30,625 --> 00:48:32,715
Let me go back into VS code here,

1357
00:48:33,044 --> 00:48:33,955
close out addresses,

1358
00:48:33,965 --> 00:48:38,165
and let's code up maybe another version of my compare program from last,

1359
00:48:38,324 --> 00:48:38,385
uh,

1360
00:48:38,564 --> 00:48:39,354
from the past.

1361
00:48:39,564 --> 00:48:40,364
This time I am going to use.

1362
00:48:40,469 --> 00:48:42,449
The CS 50 library just to keep things

1363
00:48:42,820 --> 00:48:43,929
simple initially.

1364
00:48:44,139 --> 00:48:46,969
I'm going to include both it and the standard IO library here.

1365
00:48:47,060 --> 00:48:48,540
I'm going to give myself Main with no

1366
00:48:48,540 --> 00:48:50,820
command line arguments and then in Main I'm going

1367
00:48:50,820 --> 00:48:54,790
to declare exactly what we just saw on the screen a variable I set to 50,

1368
00:48:54,979 --> 00:48:56,600
a variable J set to 50,

1369
00:48:56,620 --> 00:48:59,729
and then we're going to do our old familiar syntax from week one.

1370
00:48:59,820 --> 00:49:01,489
If I equals equals J,

1371
00:49:01,820 --> 00:49:02,290
then

1372
00:49:02,500 --> 00:49:05,060
let's go ahead and print out something like same

1373
00:49:05,060 --> 00:49:07,530
backslash N else let's go ahead and print out

1374
00:49:07,860 --> 00:49:08,469
quote unquote,

1375
00:49:08,739 --> 00:49:09,300
uh,

1376
00:49:09,340 --> 00:49:09,820
different.

1377
00:49:10,195 --> 00:49:10,955
Backslash N.

1378
00:49:11,274 --> 00:49:14,514
So super simple program that simply compares two variables

1379
00:49:14,514 --> 00:49:16,395
that yes are obviously going to be the same,

1380
00:49:16,475 --> 00:49:17,385
but let's do this.

1381
00:49:17,554 --> 00:49:20,544
So let's do make compare slash compare.

1382
00:49:20,754 --> 00:49:22,064
They're in fact the same.

1383
00:49:22,274 --> 00:49:22,554
OK,

1384
00:49:22,675 --> 00:49:25,145
so that actually works as intended,

1385
00:49:25,314 --> 00:49:29,185
but why didn't it work last time when we tried comparing strings,

1386
00:49:29,195 --> 00:49:32,685
the solution to which was actually to introduce stircom.

1387
00:49:32,995 --> 00:49:33,074
Well,

1388
00:49:33,155 --> 00:49:36,824
let's go back to VS code and resurrect that buggy example initially.

1389
00:49:36,995 --> 00:49:37,274
In fact,

1390
00:49:37,354 --> 00:49:39,314
let me go into VS code here.

1391
00:49:39,659 --> 00:49:41,120
And instead of using,

1392
00:49:41,610 --> 00:49:42,239
say,

1393
00:49:42,330 --> 00:49:43,219
integers,

1394
00:49:43,489 --> 00:49:45,639
let's go ahead and do this,

1395
00:49:45,709 --> 00:49:47,320
and I'll rename them just by convention.

1396
00:49:47,370 --> 00:49:49,719
So my first string will be quote unquote,

1397
00:49:50,969 --> 00:49:53,239
let's do my first string will be whatever

1398
00:49:53,530 --> 00:49:54,479
get string gives me.

1399
00:49:54,489 --> 00:49:56,040
So we'll prompt the user for S.

1400
00:49:56,370 --> 00:49:59,250
My next string will be called T by convention.

1401
00:49:59,530 --> 00:50:01,949
And I'm going to ask the user for that.

1402
00:50:02,159 --> 00:50:02,949
Then down here,

1403
00:50:03,120 --> 00:50:04,110
instead of using I and J,

1404
00:50:04,159 --> 00:50:05,080
which are common for integers,

1405
00:50:05,120 --> 00:50:06,330
I'm just going to use S&T,

1406
00:50:06,360 --> 00:50:07,590
which are common for strings,

1407
00:50:07,639 --> 00:50:11,030
and just ask literally the same question as we have in the past.

1408
00:50:11,320 --> 00:50:11,520
All right,

1409
00:50:11,600 --> 00:50:13,030
let me go ahead and do make,

1410
00:50:13,280 --> 00:50:14,070
uh,

1411
00:50:14,080 --> 00:50:14,639
compare.

1412
00:50:15,879 --> 00:50:16,570
And,

1413
00:50:16,969 --> 00:50:17,209
wow,

1414
00:50:17,489 --> 00:50:18,350
what's the error?

1415
00:50:18,489 --> 00:50:18,570
Well,

1416
00:50:18,610 --> 00:50:19,840
I'll show you the error message.

1417
00:50:19,929 --> 00:50:22,080
What did I unintentionally do wrong here?

1418
00:50:25,070 --> 00:50:25,260
Yeah,

1419
00:50:25,340 --> 00:50:25,979
I'm getting a string,

1420
00:50:25,989 --> 00:50:27,340
but I'm trying to store it into an end,

1421
00:50:27,379 --> 00:50:28,719
so this is just frowned upon.

1422
00:50:28,790 --> 00:50:31,850
So let me go ahead and change that to what I should have typed the first time.

1423
00:50:31,969 --> 00:50:33,469
Give me a strings and a string T.

1424
00:50:33,659 --> 00:50:35,050
Now if I do make compare,

1425
00:50:35,300 --> 00:50:36,129
we're back in business.

1426
00:50:36,370 --> 00:50:36,500
All right,

1427
00:50:36,580 --> 00:50:38,010
let me do compare,

1428
00:50:38,090 --> 00:50:39,489
and I'm going to go ahead and type in,

1429
00:50:39,500 --> 00:50:40,449
for instance,

1430
00:50:41,340 --> 00:50:42,530
let's say hi

1431
00:50:45,250 --> 00:50:46,219
and both for S&T,

1432
00:50:46,260 --> 00:50:48,500
which are obviously clearly.

1433
00:50:49,469 --> 00:50:50,159
Different.

1434
00:50:50,969 --> 00:50:52,860
Now we've tripped over this before and recalled

1435
00:50:52,860 --> 00:50:55,760
that the solution was indeed to introduce a function

1436
00:50:56,050 --> 00:50:56,760
called stom,

1437
00:50:56,810 --> 00:50:58,360
and I explained it at a high level,

1438
00:50:58,409 --> 00:50:58,530
well,

1439
00:50:58,610 --> 00:51:00,050
that's because you're not just comparing two values,

1440
00:51:00,060 --> 00:51:02,280
you got to compare character after character after character,

1441
00:51:02,330 --> 00:51:03,729
and that's what indeed Stircom does.

1442
00:51:03,790 --> 00:51:05,610
So let's go ahead and do that.

1443
00:51:05,770 --> 00:51:07,600
Let me go back into this file.

1444
00:51:07,649 --> 00:51:08,770
Let's go ahead and include.

1445
00:51:09,074 --> 00:51:14,195
The string library at the top here and instead of doings equals equals t,

1446
00:51:14,415 --> 00:51:15,635
let's do if

1447
00:51:15,955 --> 00:51:18,725
the string comparison of S and T

1448
00:51:19,054 --> 00:51:20,925
happens to equal equals 0,

1449
00:51:21,004 --> 00:51:22,685
which per the documentation for the function means

1450
00:51:22,685 --> 00:51:25,715
they're equal instead of one before or one after

1451
00:51:26,084 --> 00:51:26,814
the.

1452
00:51:27,409 --> 00:51:27,419
Uh,

1453
00:51:30,000 --> 00:51:30,159
no,

1454
00:51:30,320 --> 00:51:31,280
I did not get it wrong this time.

1455
00:51:31,389 --> 00:51:32,149
I got it.

1456
00:51:32,840 --> 00:51:32,909
Um,

1457
00:51:32,959 --> 00:51:33,310
yes,

1458
00:51:33,479 --> 00:51:36,639
so how do we actually go ahead and compare the strings this time?

1459
00:51:36,760 --> 00:51:36,879
Well,

1460
00:51:36,959 --> 00:51:41,229
let me go ahead and do make compare compare and now type in exactly the same thing,

1461
00:51:43,719 --> 00:51:45,199
and now they're in fact the same.

1462
00:51:45,260 --> 00:51:47,469
And just to demonstrate that this isn't just some fluke,

1463
00:51:47,600 --> 00:51:48,550
I can type in hi,

1464
00:51:48,639 --> 00:51:48,959
for instance,

1465
00:51:49,040 --> 00:51:49,669
and by,

1466
00:51:49,870 --> 00:51:51,399
and those are in fact different.

1467
00:51:51,479 --> 00:51:54,270
So clearly Stircom is doing something useful,

1468
00:51:54,520 --> 00:51:56,000
but what is it actually doing?

1469
00:51:56,199 --> 00:51:56,320
Well,

1470
00:51:56,439 --> 00:51:56,770
first of all,

1471
00:51:56,830 --> 00:51:59,379
Let's make clear that what was a string last

1472
00:51:59,379 --> 00:52:02,020
week is technically a char star this week,

1473
00:52:02,060 --> 00:52:03,729
so I can remove that training wheel.

1474
00:52:03,899 --> 00:52:06,850
I'm still going to include the CS 50 library because as we'll see

1475
00:52:07,100 --> 00:52:08,129
by the end of class today,

1476
00:52:08,459 --> 00:52:10,330
get string and get into and all of those

1477
00:52:10,330 --> 00:52:12,699
get functions from CS50 are actually still useful because

1478
00:52:12,699 --> 00:52:15,020
it's a pain in the neck and see still

1479
00:52:15,020 --> 00:52:17,610
to get user input without using functions like those,

1480
00:52:17,820 --> 00:52:21,219
but I'm going to get rid of the data type that we thought was called.

1481
00:52:21,500 --> 00:52:22,129
string.

1482
00:52:22,340 --> 00:52:24,659
This will still work exactly as before if I do

1483
00:52:24,659 --> 00:52:27,959
make compare compare and type in high and high,

1484
00:52:28,219 --> 00:52:30,530
we're indeed seeing that they are now the same.

1485
00:52:30,739 --> 00:52:34,860
So what's actually going on inside of the computer's memory with strings?

1486
00:52:34,899 --> 00:52:35,290
Well,

1487
00:52:35,540 --> 00:52:40,969
I would offer thats probably ends up like over here in memory and then maybe it

1488
00:52:41,219 --> 00:52:43,370
actually has its characters down here.

1489
00:52:43,500 --> 00:52:45,729
So notice the duality S as of now.

1490
00:52:45,919 --> 00:52:46,699
Is an address,

1491
00:52:46,780 --> 00:52:49,060
which means it takes up 8 bytes or 64 bits,

1492
00:52:49,100 --> 00:52:50,169
but the actual characters,

1493
00:52:50,219 --> 00:52:50,969
it turns out,

1494
00:52:51,260 --> 00:52:53,870
end up somewhere else in the computer's memory.

1495
00:52:54,020 --> 00:52:55,510
And this is what's different about an in.

1496
00:52:55,899 --> 00:53:00,209
The in I and the in J both ended up exactly where the variables were named.

1497
00:53:00,379 --> 00:53:01,540
But with strings,

1498
00:53:01,689 --> 00:53:04,250
the variable itself contains not the string,

1499
00:53:04,459 --> 00:53:07,199
but the address of the first character in that string,

1500
00:53:07,459 --> 00:53:10,100
which I claim could end up anywhere else in the computer's memory.

1501
00:53:10,580 --> 00:53:11,030
So,

1502
00:53:11,350 --> 00:53:13,459
uh that those addresses might be OX 123,

1503
00:53:13,500 --> 00:53:13,899
124,

1504
00:53:13,939 --> 00:53:14,459
125,

1505
00:53:14,469 --> 00:53:15,429
and 126,

1506
00:53:15,449 --> 00:53:16,169
for instance.

1507
00:53:16,500 --> 00:53:17,179
Meanwhile,

1508
00:53:17,340 --> 00:53:20,100
S is going to contain literally the address of that first character.

1509
00:53:20,820 --> 00:53:22,850
When I create T in memory now,

1510
00:53:22,860 --> 00:53:26,050
it ends up maybe over there taking up 8 bytes of its own.

1511
00:53:26,280 --> 00:53:28,810
Down here ends up the second thing that I typed in,

1512
00:53:28,899 --> 00:53:32,899
not at the same address but at OX 456 457 458459.

1513
00:53:33,020 --> 00:53:34,830
Now if the computer were really smart and generous,

1514
00:53:35,139 --> 00:53:36,090
it could probably notice,

1515
00:53:36,250 --> 00:53:36,649
oh wait a minute,

1516
00:53:36,699 --> 00:53:38,050
you typed that thing in already.

1517
00:53:38,139 --> 00:53:39,419
Let me just point you at the other memory,

1518
00:53:39,459 --> 00:53:40,649
but that's not how it works.

1519
00:53:40,820 --> 00:53:41,949
When you call GetString,

1520
00:53:42,060 --> 00:53:44,729
you get your own chunk of memory for whatever the human typed in,

1521
00:53:44,780 --> 00:53:46,939
even if by coincidence it's exactly the same.

1522
00:53:47,360 --> 00:53:49,830
So T's characters are ending up here,

1523
00:53:50,080 --> 00:53:51,709
S's characters are ending up here.

1524
00:53:52,040 --> 00:53:54,159
What value should go in T?

1525
00:53:56,250 --> 00:54:01,100
Exactly 0 X 456 because that's the first address of the first character in T.

1526
00:54:01,290 --> 00:54:03,959
So we put OX 456 there.

1527
00:54:04,250 --> 00:54:05,760
So at this point in the story

1528
00:54:06,090 --> 00:54:10,239
we have two strings in memory and two pointers there too.

1529
00:54:10,449 --> 00:54:12,879
And so in fact if we kind of abstract that away,

1530
00:54:13,000 --> 00:54:15,850
it's kind of equivalent to S pointing at the chunk of memory on

1531
00:54:15,850 --> 00:54:19,050
the left and T pointing at the chunk of memory on the right.

1532
00:54:19,360 --> 00:54:23,449
So why was string comparison actually necessary?

1533
00:54:23,699 --> 00:54:23,899
Well,

1534
00:54:23,979 --> 00:54:25,010
in this case,

1535
00:54:25,179 --> 00:54:26,699
we wanted to make sure.

1536
00:54:27,209 --> 00:54:27,889
That

1537
00:54:28,229 --> 00:54:32,709
the stom function was handed the address of S

1538
00:54:33,070 --> 00:54:34,229
and the address of T

1539
00:54:34,510 --> 00:54:37,189
so that the stircom function written by someone else decades

1540
00:54:37,189 --> 00:54:39,550
ago actually has its own 4 loop or while loop

1541
00:54:39,550 --> 00:54:42,510
that essentially starts at the beginning of each string and

1542
00:54:42,510 --> 00:54:46,580
compares them character by character by character by character.

1543
00:54:46,709 --> 00:54:47,790
That's what it's designed to do.

1544
00:54:47,989 --> 00:54:48,899
By contrast,

1545
00:54:48,909 --> 00:54:50,750
when I was using equal equals a few minutes

1546
00:54:50,750 --> 00:54:54,939
ago and also last week incorrectly to compare strings,

1547
00:54:55,030 --> 00:54:56,294
what Was getting compared.

1548
00:54:56,465 --> 00:54:56,544
Well,

1549
00:54:56,554 --> 00:54:59,735
if you literally compare S equals equals T,

1550
00:55:00,094 --> 00:55:05,054
that's like saying does OX 123 equal equal OX 456,

1551
00:55:05,064 --> 00:55:06,435
and that's obviously not true because

1552
00:55:06,435 --> 00:55:08,455
those are literally two different addresses.

1553
00:55:08,745 --> 00:55:12,495
So the answer I was getting last week and today was correct.

1554
00:55:12,725 --> 00:55:14,455
Those addresses are different,

1555
00:55:14,584 --> 00:55:15,425
but conceptually,

1556
00:55:15,504 --> 00:55:15,824
of course,

1557
00:55:15,864 --> 00:55:20,735
I actually intended for the program to compare the actual characters in the string,

1558
00:55:21,104 --> 00:55:23,185
not the simply.

1559
00:55:23,530 --> 00:55:25,129
The addresses thereof.

1560
00:55:25,840 --> 00:55:29,010
So how do we go about fixing something like that?

1561
00:55:29,120 --> 00:55:29,199
Well,

1562
00:55:29,320 --> 00:55:32,870
using Stirom ensures that we can actually go ahead

1563
00:55:33,159 --> 00:55:35,479
and compare them character by character,

1564
00:55:35,520 --> 00:55:37,879
and I don't need to create my own for loop or Y loop.

1565
00:55:37,919 --> 00:55:39,790
The stom function does that for me.

1566
00:55:39,919 --> 00:55:40,770
And we can see this too.

1567
00:55:40,840 --> 00:55:42,429
If I go back to VS code here,

1568
00:55:42,719 --> 00:55:43,909
get those two strings,

1569
00:55:43,919 --> 00:55:45,239
and just for kicks,

1570
00:55:45,399 --> 00:55:49,280
go ahead and print them both out using print F of percent Pslash N.

1571
00:55:49,620 --> 00:55:51,540
Then let's go ahead and print out with percent P again

1572
00:55:53,020 --> 00:55:58,010
backslash N for each of them passing in those variables S and T respectively.

1573
00:55:58,219 --> 00:56:01,330
What I should see that even if I type the exact same thing,

1574
00:56:01,379 --> 00:56:04,969
we're going to see two different addresses when I make this version of the program.

1575
00:56:05,139 --> 00:56:06,070
Here's my first high,

1576
00:56:06,300 --> 00:56:07,209
here's my second,

1577
00:56:07,340 --> 00:56:07,889
and

1578
00:56:08,100 --> 00:56:09,489
the two addresses are,

1579
00:56:09,659 --> 00:56:10,459
it's subtle.

1580
00:56:11,340 --> 00:56:12,649
Very much different.

1581
00:56:12,939 --> 00:56:14,550
The first one ends in B0,

1582
00:56:14,620 --> 00:56:16,580
the second one ends in F0,

1583
00:56:16,780 --> 00:56:19,659
both of which are hexadecimal values.

1584
00:56:21,360 --> 00:56:22,010
Question

1585
00:56:23,290 --> 00:56:25,790
On any of that thus far

1586
00:56:28,620 --> 00:56:30,370
Any que oh yeah question in front.

1587
00:56:31,760 --> 00:56:32,050
Yeah.

1588
00:56:33,270 --> 00:56:33,780
What's that?

1589
00:56:37,000 --> 00:56:37,560
Really good question.

1590
00:56:37,600 --> 00:56:40,610
When you create a pointer in memory or really when

1591
00:56:40,610 --> 00:56:42,750
you allocate a string or an integer in memory,

1592
00:56:42,959 --> 00:56:44,639
how does the computer decide where to put it?

1593
00:56:44,760 --> 00:56:45,870
It uses different

1594
00:56:46,370 --> 00:56:48,520
chunks of memory for different purposes.

1595
00:56:48,570 --> 00:56:48,870
And in fact,

1596
00:56:48,919 --> 00:56:50,919
one of the topics we'll look at after break today is

1597
00:56:50,919 --> 00:56:53,669
exactly that how a computer decides where to lay things out.

1598
00:56:53,840 --> 00:56:56,679
It's often very intentional and it is often auto incremented,

1599
00:56:56,760 --> 00:56:59,229
so they'll go back to back to back when possible,

1600
00:56:59,399 --> 00:57:01,919
but over time things will start to get messier,

1601
00:57:02,040 --> 00:57:04,399
especially in larger programs where you're adding and

1602
00:57:04,399 --> 00:57:06,080
subtracting values from memory all the time.

1603
00:57:06,479 --> 00:57:07,149
So more to come.

1604
00:57:07,229 --> 00:57:08,090
Other questions

1605
00:57:08,389 --> 00:57:09,620
on what we have done here.

1606
00:57:11,540 --> 00:57:11,739
All right,

1607
00:57:12,139 --> 00:57:12,659
before we break,

1608
00:57:12,739 --> 00:57:16,280
let's do one other example that elucidates perhaps what

1609
00:57:16,659 --> 00:57:18,739
can go wrong without understanding some

1610
00:57:18,739 --> 00:57:20,969
of these underlying building blocks whereby

1611
00:57:21,260 --> 00:57:25,260
let's go ahead and create a program this time that aspires to copy two strings,

1612
00:57:25,300 --> 00:57:27,100
which seems pretty reasonable at a glance because

1613
00:57:27,100 --> 00:57:28,610
it's certainly easy to copy two integers.

1614
00:57:28,620 --> 00:57:30,250
You just set one equal to the other.

1615
00:57:30,500 --> 00:57:31,570
That's not going to be the case.

1616
00:57:31,580 --> 00:57:33,070
It turns out with copying a string.

1617
00:57:33,219 --> 00:57:36,790
So let me open up how about copy.c,

1618
00:57:37,020 --> 00:57:37,969
a new program,

1619
00:57:38,100 --> 00:57:39,060
and I'm going to include a few.

1620
00:57:39,524 --> 00:57:43,435
at the top we'll use CS50.h so that we can still use get string conveniently.

1621
00:57:43,645 --> 00:57:44,675
We're going to include

1622
00:57:45,405 --> 00:57:45,885
C type.

1623
00:57:46,364 --> 00:57:47,764
H for reasons we'll soon see,

1624
00:57:47,804 --> 00:57:49,235
but we saw that a few weeks back.

1625
00:57:49,485 --> 00:57:51,254
We'll include standard IO as always,

1626
00:57:51,405 --> 00:57:54,435
and lastly we'll include string.h.

1627
00:57:54,685 --> 00:57:56,034
Inside of my main function,

1628
00:57:56,084 --> 00:57:57,524
which won't take any command line arguments,

1629
00:57:57,685 --> 00:57:59,875
let's go ahead as before and declare a string

1630
00:57:59,875 --> 00:58:02,514
equal to get string and just prompt the user for

1631
00:58:02,764 --> 00:58:04,235
a variables.

1632
00:58:04,445 --> 00:58:07,165
Then let's go ahead and try to copy.

1633
00:58:07,879 --> 00:58:08,379
Uh,

1634
00:58:08,560 --> 00:58:10,310
S into a new variable T

1635
00:58:10,560 --> 00:58:13,709
just like I would copy any two variables using the assignment operator.

1636
00:58:14,000 --> 00:58:14,439
Then

1637
00:58:14,719 --> 00:58:16,070
let's treat the copy,

1638
00:58:16,280 --> 00:58:17,629
otherwise known as T now,

1639
00:58:18,030 --> 00:58:19,389
as an array,

1640
00:58:19,439 --> 00:58:21,040
which we're allowed to do per week two.

1641
00:58:21,239 --> 00:58:22,830
So let's say the first character in T.

1642
00:58:22,969 --> 00:58:27,419
We actually want to set equal to the uppercase version of that same character.

1643
00:58:27,590 --> 00:58:30,399
So this line 12 at the moment is literally on the right hand side

1644
00:58:30,709 --> 00:58:33,459
saying use the two upper function from the C-type library,

1645
00:58:33,469 --> 00:58:34,860
which we used a couple weeks back,

1646
00:58:35,110 --> 00:58:37,989
pass in the first character of the copy T.

1647
00:58:38,379 --> 00:58:41,840
And then update the actual first character of T.

1648
00:58:41,969 --> 00:58:44,020
So let's capitalize T but not S.

1649
00:58:44,449 --> 00:58:45,810
Now at the very bottom of this program,

1650
00:58:45,929 --> 00:58:47,080
let's go ahead and print out

1651
00:58:47,290 --> 00:58:49,679
the value of S at this point in time,

1652
00:58:49,850 --> 00:58:52,100
and then let's print out the value of T

1653
00:58:52,330 --> 00:58:54,280
at this point in time.

1654
00:58:54,689 --> 00:58:55,449
And

1655
00:58:56,290 --> 00:58:57,159
when I

1656
00:58:57,449 --> 00:59:00,610
go ahead and make this program called Copy and do copy,

1657
00:59:00,649 --> 00:59:01,870
let's type in high

1658
00:59:03,330 --> 00:59:03,370
no,

1659
00:59:03,570 --> 00:59:04,840
let's do it lower case first.

1660
00:59:04,969 --> 00:59:06,659
Let's do high in lowercase

1661
00:59:07,860 --> 00:59:07,870
E.

1662
00:59:08,110 --> 00:59:10,010
And we'll see curiously

1663
00:59:10,379 --> 00:59:12,379
that S and T

1664
00:59:12,699 --> 00:59:17,110
both got capitalized even though the only character I touched was T 0.

1665
00:59:17,179 --> 00:59:20,010
I didn't touch S after making this copy.

1666
00:59:20,350 --> 00:59:21,060
Now to be clear,

1667
00:59:21,100 --> 00:59:22,010
what's going on,

1668
00:59:22,139 --> 00:59:24,040
why don't we remove one of these training

1669
00:59:24,040 --> 00:59:27,260
wheels so string really doesn't technically exist.

1670
00:59:27,300 --> 00:59:31,270
It's always been a char star and this string is also a char star.

1671
00:59:31,310 --> 00:59:32,699
So what's really going on?

1672
00:59:32,810 --> 00:59:32,909
Well,

1673
00:59:33,260 --> 00:59:34,429
more clearly now,

1674
00:59:34,739 --> 00:59:36,840
S is the address of

1675
00:59:37,219 --> 00:59:37,860
the string.

1676
00:59:38,540 --> 00:59:38,820
Uh,

1677
00:59:38,850 --> 00:59:39,969
that the human typed in,

1678
00:59:40,219 --> 00:59:42,379
but he is a copy of what literally?

1679
00:59:43,800 --> 00:59:45,129
The address

1680
00:59:45,459 --> 00:59:46,050
of

1681
00:59:46,290 --> 00:59:47,500
the thing the human typed in,

1682
00:59:47,540 --> 00:59:49,090
which is going to be one and the same.

1683
00:59:49,219 --> 00:59:49,580
So in fact,

1684
00:59:49,610 --> 00:59:51,570
pictorally you can think about it this way.

1685
00:59:51,739 --> 00:59:55,699
If here's my canvas of memory and the user is prompted for S and the user

1686
00:59:55,699 --> 00:59:59,330
types in high in lowercase as I did and it happens to end up down there,

1687
00:59:59,540 --> 01:00:01,540
what gets stored in S is going to be the address of

1688
01:00:01,540 --> 01:00:04,419
that memory which for the sake of discussion is maybe OX 123.

1689
01:00:04,540 --> 01:00:07,129
So OX 123 is what is stored in S.

1690
01:00:07,419 --> 01:00:09,810
When I then on my second line of code create T,

1691
01:00:10,300 --> 01:00:13,620
I get another 8 bytes of memory or 64 bits to store a point.

1692
01:00:14,409 --> 01:00:15,810
star aka string,

1693
01:00:16,020 --> 01:00:19,090
but what is put ins what is put in t

1694
01:00:19,459 --> 01:00:22,010
literally SOX 123.

1695
01:00:22,260 --> 01:00:25,620
So abstractly it's essentially equivalent to S and T

1696
01:00:25,620 --> 01:00:27,939
both pointing to the same chunk of memory.

1697
01:00:27,979 --> 01:00:33,629
So when I do t 0 and go to the zero or first character of T,

1698
01:00:33,969 --> 01:00:37,219
that happens to be the exact same chunk of memory that S is pointing to.

1699
01:00:37,300 --> 01:00:40,570
And so when that lowercase h becomes a capital H,

1700
01:00:40,899 --> 01:00:43,439
it's as though both S and T.

1701
01:00:44,020 --> 01:00:45,040
Have changed

1702
01:00:45,300 --> 01:00:48,139
and recall too if you're enjoying the syntax,

1703
01:00:48,219 --> 01:00:49,889
if I go back to VS code here,

1704
01:00:50,219 --> 01:00:51,639
I did use a ray notation,

1705
01:00:51,820 --> 01:00:54,489
but I equivalently could have said go to

1706
01:00:54,820 --> 01:00:56,409
the address in T.

1707
01:00:56,699 --> 01:00:58,449
Go to the address of that first character,

1708
01:00:58,620 --> 01:01:00,129
which functionally is exactly the same.

1709
01:01:00,179 --> 01:01:02,939
We're just not using the syntactic sugar now of the square brackets.

1710
01:01:03,139 --> 01:01:07,929
That is why high is actually being capitalized for seemingly both

1711
01:01:08,270 --> 01:01:09,020
versions.

1712
01:01:09,830 --> 01:01:10,370
Of it,

1713
01:01:10,520 --> 01:01:12,260
the original and the copy.

1714
01:01:12,469 --> 01:01:13,909
So how do we go about fixing this?

1715
01:01:14,030 --> 01:01:14,070
Well,

1716
01:01:14,120 --> 01:01:15,949
we need a couple of new solutions,

1717
01:01:16,070 --> 01:01:17,659
namely two new functions here.

1718
01:01:18,070 --> 01:01:18,560
Mao

1719
01:01:19,030 --> 01:01:21,209
is going to be a function that allocates memory,

1720
01:01:21,270 --> 01:01:22,350
so memory allocation,

1721
01:01:22,469 --> 01:01:23,350
AKA Mao,

1722
01:01:23,750 --> 01:01:24,370
and then free,

1723
01:01:24,429 --> 01:01:25,350
which is going to be the opposite,

1724
01:01:25,389 --> 01:01:27,350
which is when you're done with new memory you can hand it

1725
01:01:27,350 --> 01:01:29,699
back to the computer and say use this for something else.

1726
01:01:29,909 --> 01:01:31,899
So using these two functions alone,

1727
01:01:32,189 --> 01:01:34,350
I dare say we can solve now this.

1728
01:01:34,530 --> 01:01:38,979
Problem in memory by making an actual conceptual copy of the string

1729
01:01:38,979 --> 01:01:43,429
by copying HI exclamation point and the null character elsewhere in memory

1730
01:01:43,620 --> 01:01:46,560
so that we can actually manipulate the copy thereof.

1731
01:01:46,679 --> 01:01:47,360
So how do I do this?

1732
01:01:47,409 --> 01:01:47,489
Well,

1733
01:01:47,560 --> 01:01:49,070
let me go back to VS code here.

1734
01:01:49,320 --> 01:01:52,510
Let me propose that we get rid of much of what we did earlier,

1735
01:01:52,600 --> 01:01:55,310
except we'll keep around the Declaration of S.

1736
01:01:55,560 --> 01:01:59,090
But now if I want to create a copy of S.

1737
01:01:59,570 --> 01:02:03,449
It turns out I'm gonna need to ask the computer for as much memory

1738
01:02:03,840 --> 01:02:05,750
as S itself takes up.

1739
01:02:06,000 --> 01:02:08,719
So HI exclamation point takes up how many bytes in memory.

1740
01:02:09,879 --> 01:02:12,330
4 is correct because you need the null character.

1741
01:02:12,419 --> 01:02:14,100
So how do we figure this out?

1742
01:02:14,139 --> 01:02:14,989
You can do this.

1743
01:02:15,179 --> 01:02:17,419
Let me give myself another string called T,

1744
01:02:17,580 --> 01:02:19,449
but we don't need that white lie anymore.

1745
01:02:19,620 --> 01:02:21,429
Another char star called T.

1746
01:02:21,719 --> 01:02:23,709
And set it equal to nots,

1747
01:02:23,790 --> 01:02:25,979
which we knew was going to go wrong,

1748
01:02:26,459 --> 01:02:28,909
set it equal to the return value of this new function mao,

1749
01:02:29,030 --> 01:02:30,100
which is going to return

1750
01:02:30,270 --> 01:02:32,260
the address of a chunk of memory for me.

1751
01:02:32,510 --> 01:02:33,560
How many bytes do I want?

1752
01:02:33,750 --> 01:02:33,810
Well,

1753
01:02:33,909 --> 01:02:35,429
technically I just want 4 bytes,

1754
01:02:35,469 --> 01:02:37,219
so I could do Malloch of 4,

1755
01:02:37,260 --> 01:02:41,060
and that will literally ask the operating system running in the cloud in VS code for.

1756
01:02:41,675 --> 01:02:43,844
4 bytes of memory somewhere in that

1757
01:02:44,175 --> 01:02:46,604
black and yellow grid I keep drawing on the screen.

1758
01:02:46,735 --> 01:02:47,735
I don't know where it's going to be,

1759
01:02:47,774 --> 01:02:50,215
but I don't care because Mallock's return value will

1760
01:02:50,215 --> 01:02:53,245
be the address of the first bye thereof.

1761
01:02:53,854 --> 01:02:57,695
Now it's a little dumb to hard code for not knowing what the human's going to type in,

1762
01:02:57,814 --> 01:02:58,495
but that's OK.

1763
01:02:58,594 --> 01:03:01,604
We can do this more dynamically and use our old friend Sterling,

1764
01:03:02,054 --> 01:03:04,814
ask the computer what is the length of S.

1765
01:03:05,530 --> 01:03:06,179
And then

1766
01:03:07,620 --> 01:03:08,370
Add one

1767
01:03:08,689 --> 01:03:12,080
because we know that we need to additionally have an extra byte

1768
01:03:12,080 --> 01:03:15,239
even though the length of high in the real world is 3,

1769
01:03:15,270 --> 01:03:17,570
but we know underneath the hood we actually need that 4th byte,

1770
01:03:17,610 --> 01:03:18,879
hence the plus 1.

1771
01:03:19,050 --> 01:03:20,050
Now to use Malock,

1772
01:03:20,129 --> 01:03:21,360
I actually need to add

1773
01:03:21,889 --> 01:03:23,040
another library here,

1774
01:03:23,409 --> 01:03:26,360
Stanlib for standard library.h,

1775
01:03:26,560 --> 01:03:29,770
and that's going to give me access to the prototype for and in turn.

1776
01:03:30,129 --> 01:03:31,429
The Mao function.

1777
01:03:31,760 --> 01:03:32,270
Now

1778
01:03:32,760 --> 01:03:34,120
with this chunk of memory,

1779
01:03:34,199 --> 01:03:36,060
it's up to me to copy the string.

1780
01:03:36,120 --> 01:03:38,389
So how do I go about copying a string

1781
01:03:38,719 --> 01:03:39,800
from S into T?

1782
01:03:39,879 --> 01:03:39,959
Well,

1783
01:03:40,040 --> 01:03:41,040
I can do this in a bunch of ways,

1784
01:03:41,120 --> 01:03:44,590
but let me propose that we do it like this for into i equals 0,

1785
01:03:44,840 --> 01:03:47,139
I is less than the string length of S,

1786
01:03:47,239 --> 01:03:47,919
whatever that is,

1787
01:03:48,040 --> 01:03:48,679
I + plus,

1788
01:03:48,689 --> 01:03:51,070
and then inside of this fairly mundane loop,

1789
01:03:51,239 --> 01:03:52,169
let's just set

1790
01:03:52,520 --> 01:03:53,979
this uh I.

1791
01:03:54,610 --> 01:03:58,949
Value of T equal to the value of S,

1792
01:03:59,110 --> 01:04:00,389
and copy literally,

1793
01:04:00,510 --> 01:04:01,580
very mechanically,

1794
01:04:02,030 --> 01:04:03,780
every character from S

1795
01:04:04,110 --> 01:04:04,830
into T.

1796
01:04:06,360 --> 01:04:07,870
Then down here

1797
01:04:08,199 --> 01:04:10,719
let's go ahead and capitalize just

1798
01:04:10,909 --> 01:04:14,909
the first character of T by using 2 upper as before

1799
01:04:15,280 --> 01:04:16,909
with or without the syntactic sugar,

1800
01:04:17,120 --> 01:04:18,600
and then at the very bottom of this program,

1801
01:04:18,679 --> 01:04:21,989
let's print out the value of S itself

1802
01:04:22,280 --> 01:04:23,939
just for good measure to make sure we didn't screw it

1803
01:04:23,939 --> 01:04:26,709
up this time and let's print out the value of T

1804
01:04:27,159 --> 01:04:31,000
just so we see that I in fact have capitalized T and only T,

1805
01:04:31,600 --> 01:04:33,389
but I'm not quite done yet.

1806
01:04:34,129 --> 01:04:36,199
There's a design flaw here

1807
01:04:36,530 --> 01:04:37,129
and

1808
01:04:37,409 --> 01:04:38,280
a mistake,

1809
01:04:38,409 --> 01:04:39,320
but it's subtle.

1810
01:04:40,310 --> 01:04:42,379
Does anyone want to pluck off one or the other?

1811
01:04:43,679 --> 01:04:45,639
Check 50 and design 50 are not gonna like this.

1812
01:04:45,750 --> 01:04:46,110
Yeah.

1813
01:04:49,870 --> 01:04:50,229
Yes,

1814
01:04:50,510 --> 01:04:54,389
because Stirling always returns the sort of real world length of the string,

1815
01:04:55,830 --> 01:04:56,300
H3,

1816
01:04:56,510 --> 01:05:00,610
this would seem to accidentally forget to copy the null character.

1817
01:05:00,760 --> 01:05:03,330
So I can fix this in a few different ways.

1818
01:05:03,550 --> 01:05:04,149
I could,

1819
01:05:04,189 --> 01:05:04,669
for instance,

1820
01:05:04,750 --> 01:05:06,469
at the bottom of my loop

1821
01:05:06,870 --> 01:05:13,270
actually do something like T4 equals singles and manually terminate it

1822
01:05:13,270 --> 01:05:14,709
myself because I know it's got to end with a null.

1823
01:05:15,465 --> 01:05:16,435
This would be frowned upon too.

1824
01:05:16,504 --> 01:05:17,824
I shouldn't be hard coding the 4.

1825
01:05:17,905 --> 01:05:18,864
This is all too sloppy.

1826
01:05:18,945 --> 01:05:20,074
So don't do this.

1827
01:05:20,385 --> 01:05:24,764
What I could instead do is say go up to and through the length of S

1828
01:05:25,064 --> 01:05:27,935
because if the length of S is 3,

1829
01:05:28,264 --> 01:05:30,225
but I use less than or equal to,

1830
01:05:30,264 --> 01:05:34,455
that thing's going to iterate of course 4 times because I'm starting at 0 as always.

1831
01:05:34,784 --> 01:05:36,814
So that I think fixes that problem,

1832
01:05:36,834 --> 01:05:38,064
but now the design flaw,

1833
01:05:38,104 --> 01:05:38,665
which is subtle,

1834
01:05:38,675 --> 01:05:39,455
but we've seen it before,

1835
01:05:39,504 --> 01:05:39,864
yeah.

1836
01:05:45,570 --> 01:05:45,879
Exactly.

1837
01:05:45,929 --> 01:05:48,449
It's just dumb of me to be asking the computer what's the length of S?

1838
01:05:48,469 --> 01:05:49,129
What's the length of S?

1839
01:05:49,189 --> 01:05:49,929
What's the length of S?

1840
01:05:49,969 --> 01:05:51,120
And every iteration.

1841
01:05:51,340 --> 01:05:52,199
So this is why

1842
01:05:52,370 --> 01:05:56,159
we introduced this trick where you can set another integer variable like N

1843
01:05:56,520 --> 01:05:57,850
equal to that string length,

1844
01:05:57,860 --> 01:06:01,330
and then after the semicolon just keep comparing I against N,

1845
01:06:01,449 --> 01:06:05,459
which means you're not calling functions wastefully as before.

1846
01:06:05,770 --> 01:06:06,100
All right,

1847
01:06:06,250 --> 01:06:08,080
if I didn't mess up anything else,

1848
01:06:08,209 --> 01:06:09,649
let me go into my terminal.

1849
01:06:09,850 --> 01:06:10,989
Let me do uh oh,

1850
01:06:11,050 --> 01:06:11,889
did I mess something up?

1851
01:06:15,989 --> 01:06:16,489
I still,

1852
01:06:16,649 --> 01:06:16,850
yes,

1853
01:06:16,889 --> 01:06:17,840
I did mess something up.

1854
01:06:17,889 --> 01:06:19,409
I should have put this back as well.

1855
01:06:19,489 --> 01:06:20,000
Thank you.

1856
01:06:20,209 --> 01:06:20,449
All right,

1857
01:06:20,530 --> 01:06:22,360
so let's go ahead and do make copy,

1858
01:06:23,120 --> 01:06:23,909
Escopy,

1859
01:06:23,929 --> 01:06:24,560
and now,

1860
01:06:24,689 --> 01:06:27,489
I'm gonna go ahead and type in high in all lowercase

1861
01:06:27,810 --> 01:06:28,909
and hit enter.

1862
01:06:29,300 --> 01:06:32,560
And you'll see now that s is unchanged.

1863
01:06:32,729 --> 01:06:34,340
It's printed out again in lowercase,

1864
01:06:34,649 --> 01:06:37,439
but t is in fact capitalized here.

1865
01:06:37,649 --> 01:06:38,489
Now why is this?

1866
01:06:38,530 --> 01:06:38,649
Well,

1867
01:06:38,739 --> 01:06:39,489
in this case,

1868
01:06:39,570 --> 01:06:40,840
what's happened is that

1869
01:06:41,050 --> 01:06:42,320
I've got s in memory,

1870
01:06:42,530 --> 01:06:44,459
but this time when I allocate T,

1871
01:06:44,850 --> 01:06:47,409
I then use Malloch to get a whole chunk of memory here that

1872
01:06:47,409 --> 01:06:50,760
initially just contains who knows what garbage values as we've called them before.

1873
01:06:50,850 --> 01:06:52,360
I'll just leave them as blank here,

1874
01:06:52,570 --> 01:06:53,479
but it happens to be.

1875
01:06:53,534 --> 01:06:55,344
For the sake of discussion at OX 456,

1876
01:06:55,354 --> 01:06:56,594
78 and 9,

1877
01:06:56,965 --> 01:07:01,215
when then I actually set T equal to the return value of Mao,

1878
01:07:01,324 --> 01:07:03,385
it's as though T is just pointing to this chunk of memory.

1879
01:07:03,564 --> 01:07:07,925
Then in my own loop when I go from zero on up through N,

1880
01:07:08,324 --> 01:07:09,955
that just means to copy the H,

1881
01:07:10,125 --> 01:07:10,814
then the I,

1882
01:07:10,925 --> 01:07:11,915
then the exclamation point,

1883
01:07:11,925 --> 01:07:14,395
and because of the equal sign also

1884
01:07:14,885 --> 01:07:17,675
print copy the null character instead.

1885
01:07:18,790 --> 01:07:21,290
So this is getting a little tedious though admittedly like this is

1886
01:07:21,290 --> 01:07:23,659
a lot of work just to copy a couple of strings.

1887
01:07:23,729 --> 01:07:25,760
Could we be doing this a little bit better?

1888
01:07:25,969 --> 01:07:29,090
So we actually can because of the libraries we're including turns

1889
01:07:29,090 --> 01:07:31,979
out there's functions for copying strings that come with C.

1890
01:07:32,050 --> 01:07:34,000
So in fact if I go back to BS code here,

1891
01:07:34,250 --> 01:07:36,209
I don't actually need any of.

1892
01:07:36,304 --> 01:07:41,534
This for loop here so long as I have actually allocated enough memory for the string,

1893
01:07:41,574 --> 01:07:42,764
which I do think I've had,

1894
01:07:42,935 --> 01:07:47,445
I can actually use literally a function called stircopy STRCPY for short,

1895
01:07:47,534 --> 01:07:47,945
and

1896
01:07:48,334 --> 01:07:49,804
pass in the destination

1897
01:07:50,175 --> 01:07:53,155
and the source in that order almost feels a little backwards,

1898
01:07:53,215 --> 01:07:58,375
but that's the way it's done to copy S's bytes into T.

1899
01:07:58,415 --> 01:07:59,425
It's easy to mess them up,

1900
01:07:59,495 --> 01:08:01,604
but don't mess them up for the documentation,

1901
01:08:01,735 --> 01:08:03,995
the destination comes first and then the source string.

1902
01:08:04,290 --> 01:08:04,879
Instead,

1903
01:08:05,159 --> 01:08:06,060
so if I do this now,

1904
01:08:06,199 --> 01:08:07,989
let's do make copy.

1905
01:08:08,199 --> 01:08:09,070
We're good to go.

1906
01:08:09,639 --> 01:08:13,280
If I do scopy now and type in high and all lowercase,

1907
01:08:13,560 --> 01:08:15,750
we still have preserved that good property.

1908
01:08:15,959 --> 01:08:17,290
But let me propose that

1909
01:08:17,589 --> 01:08:19,799
things can go wrong and in fact this is about to

1910
01:08:19,799 --> 01:08:22,490
make the program look way more complicated than it feels ideal,

1911
01:08:22,560 --> 01:08:24,189
but I've been a little lazy here.

1912
01:08:24,319 --> 01:08:26,109
There's a bunch of things that can go wrong

1913
01:08:26,439 --> 01:08:29,879
for which it's worth knowing about the return values of these here functions.

1914
01:08:30,040 --> 01:08:30,419
So

1915
01:08:30,720 --> 01:08:31,720
all of this time.

1916
01:08:32,149 --> 01:08:35,080
It has been possible for certain functions we've been using,

1917
01:08:35,169 --> 01:08:36,240
get string among them

1918
01:08:36,569 --> 01:08:38,160
to return confusingly,

1919
01:08:38,770 --> 01:08:45,939
this null value NULL again humans decades ago decided that one would be called NUL,

1920
01:08:46,069 --> 01:08:49,330
other humans decided this new thing would be called NULL.

1921
01:08:49,490 --> 01:08:50,560
NUL

1922
01:08:51,089 --> 01:08:51,740
pronounced null,

1923
01:08:51,970 --> 01:08:53,930
it's just a null terminator backslash zero.

1924
01:08:54,089 --> 01:08:55,649
It is a single byte of 8 bits,

1925
01:08:55,729 --> 01:08:56,770
all of which are zeros.

1926
01:08:56,850 --> 01:08:58,439
That's been true for a few weeks now.

1927
01:08:58,970 --> 01:09:01,759
NULL happens to be a special

1928
01:09:02,169 --> 01:09:03,040
memory address,

1929
01:09:03,270 --> 01:09:04,939
literally OX0

1930
01:09:05,290 --> 01:09:07,939
at which nothing is supposed to ever

1931
01:09:08,430 --> 01:09:08,919
live.

1932
01:09:09,209 --> 01:09:12,009
So whenever I describe the top left corner is this is address 0,

1933
01:09:12,089 --> 01:09:12,529
this is 1,

1934
01:09:12,569 --> 01:09:13,200
this is 2,

1935
01:09:13,410 --> 01:09:14,169
humans years ago.

1936
01:09:14,328 --> 01:09:14,639
Decided,

1937
01:09:14,679 --> 01:09:15,038
you know what,

1938
01:09:15,158 --> 01:09:19,758
let's just waste bye location 0 and never put anything

1939
01:09:19,758 --> 01:09:22,667
there so that we have a special value to ensure

1940
01:09:22,917 --> 01:09:24,758
that we can signal when something has gone wrong.

1941
01:09:24,837 --> 01:09:27,508
So humans just decided don't use memory address OX

1942
01:09:27,508 --> 01:09:29,749
0 specifically and a few bytes after it.

1943
01:09:30,089 --> 01:09:31,189
So what does this mean?

1944
01:09:31,399 --> 01:09:31,560
Well,

1945
01:09:31,680 --> 01:09:32,750
in my code

1946
01:09:33,000 --> 01:09:35,080
all this time and since week one,

1947
01:09:35,160 --> 01:09:37,350
frankly things could have gone wrong.

1948
01:09:37,399 --> 01:09:40,720
So in VS code here I'm using Getstring and I'm using Mao

1949
01:09:40,720 --> 01:09:44,990
and I'm using Stir Copy and all of these print statements here,

1950
01:09:45,160 --> 01:09:46,470
but I'm not actually

1951
01:09:46,799 --> 01:09:48,879
adding as many error checks as I should.

1952
01:09:49,259 --> 01:09:51,930
So it turns out if you read the actual documentation for Get string,

1953
01:09:51,939 --> 01:09:54,040
which in fairness we never told you about until now,

1954
01:09:54,569 --> 01:09:55,799
in cases of error,

1955
01:09:56,089 --> 01:09:57,729
get string can return null.

1956
01:09:57,890 --> 01:10:01,629
Why would it ever have an error if the human types in such a large paragraph

1957
01:10:01,629 --> 01:10:03,209
of text maybe that there's no room in

1958
01:10:03,209 --> 01:10:05,120
the computer's memory for everything they've typed in?

1959
01:10:05,330 --> 01:10:05,370
Well,

1960
01:10:05,410 --> 01:10:06,770
you don't want to just get back part of

1961
01:10:06,770 --> 01:10:08,779
the text and not know that something went wrong.

1962
01:10:08,970 --> 01:10:12,000
Get string is designed to return a special sentinel value,

1963
01:10:12,169 --> 01:10:14,040
NULL in all caps.

1964
01:10:14,080 --> 01:10:15,609
That just means I can't oblige.

1965
01:10:15,649 --> 01:10:17,330
I can't return you a correct value.

1966
01:10:18,029 --> 01:10:19,509
Here's an error instead.

1967
01:10:19,799 --> 01:10:22,029
So what I should always have been doing since week one,

1968
01:10:22,109 --> 01:10:24,859
but we consciously don't because it adds just too much overhead,

1969
01:10:25,029 --> 01:10:26,100
is check

1970
01:10:26,310 --> 01:10:28,580
if S equals equals null,

1971
01:10:28,810 --> 01:10:32,700
then we should abort the program altogether and for instance like return one,

1972
01:10:32,709 --> 01:10:34,790
as we've done before to just signify error like

1973
01:10:34,790 --> 01:10:37,819
we cannot proceed because get string did not work.

1974
01:10:38,109 --> 01:10:39,569
That is true of Mallock too.

1975
01:10:39,790 --> 01:10:43,870
Technically we should say if the address in T also equals null,

1976
01:10:44,029 --> 01:10:45,859
that is OX 0,

1977
01:10:46,069 --> 01:10:48,830
we should also return 1 because something.

1978
01:10:49,270 --> 01:10:49,279
Uh,

1979
01:10:50,500 --> 01:10:50,890
went

1980
01:10:51,060 --> 01:10:51,500
wrong.

1981
01:10:52,569 --> 01:10:53,160
So

1982
01:10:53,419 --> 01:10:55,040
let's do this one more time.

1983
01:10:55,250 --> 01:10:58,290
Turns out that even 2 upper is taking for granted

1984
01:10:58,290 --> 01:11:00,439
the fact that the humans typed in anything at all.

1985
01:11:00,609 --> 01:11:02,439
What if the human just types enter?

1986
01:11:02,689 --> 01:11:02,750
Well,

1987
01:11:02,810 --> 01:11:03,729
that's a valid string.

1988
01:11:03,770 --> 01:11:05,299
It's the so-called empty string,

1989
01:11:05,490 --> 01:11:06,560
quote unquote,

1990
01:11:06,810 --> 01:11:08,689
but what is the length of nothing?

1991
01:11:09,620 --> 01:11:10,700
It's going to be 0

1992
01:11:11,049 --> 01:11:15,839
and that's problematic because if you try to go to T at the first location,

1993
01:11:16,089 --> 01:11:17,100
what is actually there?

1994
01:11:17,220 --> 01:11:17,290
Well,

1995
01:11:17,330 --> 01:11:18,649
that's actually the null character,

1996
01:11:18,689 --> 01:11:21,830
which is not something you should even try to capitalize it would seem.

1997
01:11:22,009 --> 01:11:25,450
So what we should really do here too is check only if.

1998
01:11:25,575 --> 01:11:26,595
The sterling

1999
01:11:26,845 --> 01:11:29,095
of S is greater than 0.

2000
01:11:29,234 --> 01:11:32,875
Should you even bother upper casing that first character?

2001
01:11:32,964 --> 01:11:33,125
I mean,

2002
01:11:33,245 --> 01:11:33,674
one,

2003
01:11:33,924 --> 01:11:36,205
at best it makes no sense because if there's no string,

2004
01:11:36,245 --> 01:11:37,165
there's nothing uppercase.

2005
01:11:37,205 --> 01:11:40,314
At worst I could break something by touching memory

2006
01:11:40,524 --> 01:11:41,404
that I should not.

2007
01:11:41,930 --> 01:11:42,810
And if I may,

2008
01:11:43,040 --> 01:11:44,390
there's another issue now.

2009
01:11:44,799 --> 01:11:45,839
On line 15,

2010
01:11:46,040 --> 01:11:47,790
I'm asking the computer for memory,

2011
01:11:47,799 --> 01:11:49,560
and it's going to hand me those 4 bytes,

2012
01:11:49,600 --> 01:11:51,359
but technically I'm never giving them back.

2013
01:11:51,479 --> 01:11:53,520
And so even though this program is so short that it's

2014
01:11:53,520 --> 01:11:55,069
going to quit pretty soon and it's not a big deal,

2015
01:11:55,080 --> 01:11:57,229
the computer will automatically reclaim that memory

2016
01:11:57,520 --> 01:12:00,000
in long running programs that like servers or

2017
01:12:00,000 --> 01:12:01,629
things that are running for a long time.

2018
01:12:02,020 --> 01:12:04,439
If you use Malock and ask for memory but never give.

2019
01:12:04,525 --> 01:12:05,746
Back to the computer,

2020
01:12:05,875 --> 01:12:06,596
never free it,

2021
01:12:06,636 --> 01:12:07,306
so to speak.

2022
01:12:07,476 --> 01:12:10,866
Your computer might get slower and slower and slower and slower,

2023
01:12:10,875 --> 01:12:12,395
essentially because it's running out of memory,

2024
01:12:12,636 --> 01:12:13,235
not physically,

2025
01:12:13,315 --> 01:12:17,905
but the computer thinks it's using all of its memory even if it's not actively in use.

2026
01:12:18,036 --> 01:12:18,186
You,

2027
01:12:18,195 --> 01:12:21,395
as the human know best and so at the end of this program,

2028
01:12:21,436 --> 01:12:23,465
when I am completely done with T,

2029
01:12:23,875 --> 01:12:26,866
you should similarly call free of T.

2030
01:12:27,122 --> 01:12:28,691
Passing in the address

2031
01:12:28,912 --> 01:12:32,702
that you allocated previously so that the operating system gets that memory back.

2032
01:12:32,771 --> 01:12:33,461
If you don't do that,

2033
01:12:33,472 --> 01:12:34,671
it's what's called a memory leak.

2034
01:12:34,791 --> 01:12:35,461
If you've ever

2035
01:12:35,751 --> 01:12:36,472
used a Mac program,

2036
01:12:36,551 --> 01:12:37,191
a Windows program,

2037
01:12:38,071 --> 01:12:40,271
iPhone or Android program that some of how it's

2038
01:12:40,271 --> 01:12:42,992
just getting slower and slower and slower and slower,

2039
01:12:43,001 --> 01:12:45,231
that is often a symptom of a human having

2040
01:12:45,231 --> 01:12:48,742
messed up and not freeing memory that they don't actually

2041
01:12:49,111 --> 01:12:49,702
need

2042
01:12:50,512 --> 01:12:50,932
anymore.

2043
01:12:53,470 --> 01:12:55,180
Questions on null

2044
01:12:55,509 --> 01:12:57,350
or any of these kinds of checks.

2045
01:12:59,379 --> 01:12:59,390
No

2046
01:13:00,819 --> 01:13:01,379
All right,

2047
01:13:01,660 --> 01:13:01,879
well,

2048
01:13:01,899 --> 01:13:02,930
as a teaser,

2049
01:13:03,140 --> 01:13:04,990
in just a bit we're going to reveal

2050
01:13:05,379 --> 01:13:08,140
when and why things can go terribly wrong by way of

2051
01:13:08,140 --> 01:13:10,140
a little bit of claymation from our friends at Stanford,

2052
01:13:10,220 --> 01:13:12,540
but it feels like we're long past a good snack break.

2053
01:13:12,589 --> 01:13:14,939
So why don't we go ahead and have some oranges and some fruit snacks,

2054
01:13:14,950 --> 01:13:16,060
and we'll see you in 10.

2055
01:13:17,069 --> 01:13:17,080
All

2056
01:13:17,620 --> 01:13:17,950
right,

2057
01:13:18,140 --> 01:13:19,339
we are back.

2058
01:13:19,700 --> 01:13:20,819
So with memory,

2059
01:13:20,859 --> 01:13:22,379
a lot of things can go wrong and in fact,

2060
01:13:22,390 --> 01:13:24,899
a question came up during the break about whether or

2061
01:13:24,899 --> 01:13:28,169
not I should have also called free on S,

2062
01:13:28,299 --> 01:13:30,549
which was the string that I actually got back from GetString.

2063
01:13:30,660 --> 01:13:31,729
The short answer is no.

2064
01:13:31,879 --> 01:13:33,500
This has been a deliberate choice over the past

2065
01:13:33,500 --> 01:13:37,089
several weeks whereby the implementation by CS 50 of GetString

2066
01:13:37,379 --> 01:13:42,169
automatically frees memory that it has given to you once it is no longer needed,

2067
01:13:42,299 --> 01:13:42,660
so that's a bit.

2068
01:13:42,766 --> 01:13:44,025
Magic underneath the hood.

2069
01:13:44,195 --> 01:13:47,585
Once those once you no longer use that though that feature goes away.

2070
01:13:47,755 --> 01:13:51,485
But because I actually used Mao to get my memory for T,

2071
01:13:51,956 --> 01:13:53,965
I did have to free that specific memory.

2072
01:13:53,996 --> 01:13:56,585
So the rule of thumb quite simply is if you mallocked it,

2073
01:13:56,905 --> 01:13:58,266
you must free it.

2074
01:13:58,275 --> 01:14:00,065
If we get string mallocked it,

2075
01:14:00,235 --> 01:14:02,666
you do not have to free it yourself.

2076
01:14:02,835 --> 01:14:04,956
But of course things can go wrong and thankfully there

2077
01:14:04,956 --> 01:14:07,806
are tools by which we can find memory related errors.

2078
01:14:07,835 --> 01:14:10,532
And one thing we're To show you briefly is another tool called Valgrind,

2079
01:14:10,812 --> 01:14:14,171
which is a nice complement to something like Debug 50 and PrintF and

2080
01:14:14,171 --> 01:14:16,412
the Duck for actually chasing down specifically

2081
01:14:16,412 --> 01:14:18,492
in this case memory related errors.

2082
01:14:18,611 --> 01:14:18,972
So in fact,

2083
01:14:19,051 --> 01:14:21,651
let me go over to VS code and open up a program

2084
01:14:21,651 --> 01:14:24,762
I wrote in advance because it's just not all that useful,

2085
01:14:24,812 --> 01:14:27,321
but it is demonstrative of some things that can go wrong.

2086
01:14:27,481 --> 01:14:30,171
And in memory.c we have this code here.

2087
01:14:30,251 --> 01:14:33,691
We include standardio.h and we include standard lib.h,

2088
01:14:33,771 --> 01:14:34,051
the last.

2089
01:14:34,158 --> 01:14:37,857
Of which recall is necessary now when you want to use Mao and in turn free

2090
01:14:38,027 --> 01:14:40,377
and inside of this main function I'm doing a few things.

2091
01:14:40,627 --> 01:14:42,498
I am first allocating

2092
01:14:42,917 --> 01:14:43,618
3

2093
01:14:43,908 --> 01:14:48,308
integers in kind of an interesting way because it turns out that Malloch

2094
01:14:48,308 --> 01:14:51,458
takes as its argument the number of bytes that you want to get.

2095
01:14:51,667 --> 01:14:54,467
Now I know on most systems an integer is indeed 4 bytes.

2096
01:14:54,507 --> 01:14:56,587
So if I want space for 3 integers,

2097
01:14:56,627 --> 01:14:59,708
I could just do 3 times 4 is 12 and put 12.

2098
01:14:59,854 --> 01:15:00,874
the parenthesis here,

2099
01:15:00,963 --> 01:15:03,403
but that's generally frowned upon because it would make my code less

2100
01:15:03,403 --> 01:15:07,124
portable to other systems where it might not be 4 bytes.

2101
01:15:07,324 --> 01:15:10,443
So turns out you can use this operator size of and

2102
01:15:10,443 --> 01:15:13,394
actually ask the computer how big is a data type,

2103
01:15:13,604 --> 01:15:15,793
like an ant on this specific system.

2104
01:15:15,804 --> 01:15:17,954
And for CHARS you'll always get back 1.

2105
01:15:18,204 --> 01:15:20,124
For ins you'll usually get back 4,

2106
01:15:20,164 --> 01:15:22,034
and same goes for other data types as well,

2107
01:15:22,083 --> 01:15:25,443
but this is the more dynamic way to ask that question if you want to get 3.

2108
01:15:25,870 --> 01:15:27,970
Uh integers worth of memory.

2109
01:15:28,149 --> 01:15:30,069
What I'm then going to do is assign on the left hand

2110
01:15:30,069 --> 01:15:34,419
side the return value of Mao to this variable X just because

2111
01:15:34,669 --> 01:15:36,560
an X itself is a pointer

2112
01:15:36,899 --> 01:15:38,069
to an integer,

2113
01:15:38,189 --> 01:15:39,899
more specifically to this chunk of memory,

2114
01:15:39,910 --> 01:15:42,149
which is a sequence of 3 integers.

2115
01:15:42,229 --> 01:15:44,830
This is very arbitrary and this is only meant to demonstrate

2116
01:15:45,189 --> 01:15:47,790
things you can do incorrectly ultimately,

2117
01:15:47,870 --> 01:15:49,939
but this is how I would dynamically get

2118
01:15:50,379 --> 01:15:51,950
space for 3 integers.

2119
01:15:52,049 --> 01:15:55,470
From Mallock and store the address thereof in X.

2120
01:15:55,720 --> 01:15:57,629
So it stands to reason that I could put

2121
01:15:57,879 --> 01:16:01,879
my first value at X1 equals 72,

2122
01:16:01,919 --> 01:16:02,870
my second value

2123
01:16:03,200 --> 01:16:04,160
equaling 73,

2124
01:16:04,200 --> 01:16:06,410
and my third value equaling 33.

2125
01:16:06,520 --> 01:16:07,919
Now if some of this is rubbing you wrong,

2126
01:16:07,959 --> 01:16:08,839
like these are actually,

2127
01:16:08,979 --> 01:16:10,359
there's riddled with mistakes already,

2128
01:16:10,439 --> 01:16:12,189
some of which are old to us,

2129
01:16:12,520 --> 01:16:13,600
what's the first thing I've done wrong,

2130
01:16:13,640 --> 01:16:16,450
even if you have no idea what's going on with line 8?

2131
01:16:16,560 --> 01:16:17,479
What about lines 9,

2132
01:16:17,490 --> 01:16:18,279
1011?

2133
01:16:18,990 --> 01:16:19,919
What I do wrong?

2134
01:16:21,129 --> 01:16:21,479
Yeah.

2135
01:16:22,459 --> 01:16:22,689
Yeah,

2136
01:16:22,810 --> 01:16:23,720
my indexing is wrong.

2137
01:16:23,810 --> 01:16:26,649
Like we've known for weeks now that with the arrays or

2138
01:16:26,649 --> 01:16:28,939
with the ray syntax you always start counting at 0,

2139
01:16:29,129 --> 01:16:29,720
then 1,

2140
01:16:29,729 --> 01:16:30,319
then 2,

2141
01:16:30,529 --> 01:16:31,529
not 123.

2142
01:16:31,569 --> 01:16:32,290
So that's an issue,

2143
01:16:32,299 --> 01:16:33,640
and this is a new detail.

2144
01:16:33,890 --> 01:16:35,890
But given that I've used Mao Online 8,

2145
01:16:36,029 --> 01:16:39,120
what other mistake have I done in this version of the program?

2146
01:16:42,270 --> 01:16:43,339
What's missing?

2147
01:16:44,549 --> 01:16:44,979
Free.

2148
01:16:45,029 --> 01:16:48,109
So I didn't actually call free so this program has a memory leak.

2149
01:16:48,149 --> 01:16:50,390
It's asking for memory and never handing it back.

2150
01:16:50,509 --> 01:16:51,350
Now that's pretty good,

2151
01:16:51,430 --> 01:16:51,589
you know,

2152
01:16:51,629 --> 01:16:54,339
a few of us were able to just kind of eyeball the code and debug it,

2153
01:16:54,350 --> 01:16:56,279
but that's not gonna be true for all people,

2154
01:16:56,390 --> 01:16:56,990
all programs,

2155
01:16:57,109 --> 01:16:59,859
certainly when the programs get larger and more complicated,

2156
01:17:00,149 --> 01:17:00,750
so a program.

2157
01:17:00,859 --> 01:17:05,100
Like Valgrin's purpose in life is to help you spot these kinds of errors.

2158
01:17:05,209 --> 01:17:05,970
So for instance,

2159
01:17:06,009 --> 01:17:06,839
when I run,

2160
01:17:07,169 --> 01:17:11,330
make memory to compile this program and then do slash memory at a glance,

2161
01:17:11,529 --> 01:17:14,259
it actually seems perfectly fine if only because I'm not seeing any

2162
01:17:14,259 --> 01:17:17,330
errors even when I compile it or when I run it.

2163
01:17:17,700 --> 01:17:20,799
But I do claim that there's at least 2 that we've seen here.

2164
01:17:20,839 --> 01:17:22,069
It's just we're not getting

2165
01:17:22,520 --> 01:17:26,500
so unlucky that the program's actually crashing as a result.

2166
01:17:26,600 --> 01:17:29,200
So this is a more latent harder to detect bug.

2167
01:17:29,359 --> 01:17:30,839
But what I'm going to do now is this I'm

2168
01:17:30,839 --> 01:17:33,189
going to open up my terminal window and full screen.

2169
01:17:33,399 --> 01:17:37,479
I'm going to then do Valgrind space.slash memory so

2170
01:17:37,479 --> 01:17:40,680
as to run the Valgrind memory checker on this.

2171
01:17:40,814 --> 01:17:41,095
Program,

2172
01:17:41,125 --> 01:17:42,285
so similar to debug 50,

2173
01:17:42,325 --> 01:17:43,365
but the name now is Valgrind.

2174
01:17:43,564 --> 01:17:44,564
This isn't a CS 50 thing.

2175
01:17:44,604 --> 01:17:46,595
This is a common program that programmers use.

2176
01:17:46,805 --> 01:17:47,524
When I hit enter,

2177
01:17:47,765 --> 01:17:49,044
the output is going to be atrocious,

2178
01:17:49,084 --> 01:17:49,674
frankly.

2179
01:17:50,125 --> 01:17:52,395
It's more way more complicated than it needs to be.

2180
01:17:52,444 --> 01:17:53,475
They put this number here,

2181
01:17:53,524 --> 01:17:54,834
which means something specific,

2182
01:17:54,884 --> 01:17:56,645
but it's just stupid that it's on every line of output.

2183
01:17:56,685 --> 01:17:58,194
So it's overwhelming at a glance.

2184
01:17:58,564 --> 01:18:01,274
But once you've trained your eyes to look for useful information,

2185
01:18:01,354 --> 01:18:03,205
there's a couple of useful insights here.

2186
01:18:03,325 --> 01:18:04,075
So one,

2187
01:18:04,444 --> 01:18:06,595
invalid right of size 4

2188
01:18:06,845 --> 01:18:10,245
that apparently is somehow related to line 11.

2189
01:18:10,560 --> 01:18:11,270
So let's go there.

2190
01:18:11,370 --> 01:18:13,939
Let me use this minimize my terminal window.

2191
01:18:14,270 --> 01:18:18,020
look at line 11 of memory.c and just see which line that was.

2192
01:18:18,109 --> 01:18:18,540
OK,

2193
01:18:18,750 --> 01:18:21,580
invalid right of size 4.

2194
01:18:21,790 --> 01:18:21,910
Well,

2195
01:18:22,069 --> 01:18:23,779
writing means like changing a value.

2196
01:18:23,950 --> 01:18:25,509
Reading means accessing a value,

2197
01:18:25,549 --> 01:18:26,750
so they're sort of opposites.

2198
01:18:26,910 --> 01:18:28,270
Invalid right of size 4.

2199
01:18:28,310 --> 01:18:28,439
Well,

2200
01:18:28,470 --> 01:18:31,270
here's why it's generally useful to know generally how big an

2201
01:18:31,270 --> 01:18:34,229
it is like 4 you're trying to write 4 bytes incorrectly.

2202
01:18:34,299 --> 01:18:36,060
So why is line 11 invalid?

2203
01:18:37,569 --> 01:18:38,390
Just to be clear,

2204
01:18:39,899 --> 01:18:41,049
Because the index is off,

2205
01:18:41,100 --> 01:18:43,049
like I'm touching memory that I should not.

2206
01:18:43,259 --> 01:18:46,819
If I ask the computer for space for 3 integers,

2207
01:18:46,979 --> 01:18:48,450
each of which is 4 bytes,

2208
01:18:48,580 --> 01:18:50,899
that should give me location 01 and 2,

2209
01:18:51,229 --> 01:18:52,450
not location 3.

2210
01:18:52,580 --> 01:18:54,620
So you still have to know a little something about

2211
01:18:54,620 --> 01:18:57,490
programming to be able to make good use of that information

2212
01:18:57,779 --> 01:18:59,850
invalid right of size 4.

2213
01:19:00,149 --> 01:19:02,740
But once you've sort of trained your mind and your eye to catch it like,

2214
01:19:02,779 --> 01:19:02,970
oh,

2215
01:19:03,180 --> 01:19:03,939
now I'm an idiot,

2216
01:19:03,979 --> 01:19:05,810
I have to go in and fix that problem.

2217
01:19:05,979 --> 01:19:06,620
But what else?

2218
01:19:06,712 --> 01:19:07,303
Wrong

2219
01:19:07,743 --> 01:19:09,462
based on Valgrin's output here.

2220
01:19:09,542 --> 01:19:09,913
So

2221
01:19:10,303 --> 01:19:12,612
this is kind of worrisome leak summary.

2222
01:19:12,783 --> 01:19:14,732
Definitely lost 12 bytes

2223
01:19:14,942 --> 01:19:15,703
in one block.

2224
01:19:15,823 --> 01:19:17,422
I don't really know what 1 blocks means for now,

2225
01:19:17,462 --> 01:19:20,942
but 12 bytes should be familiar because if you generally remember that

2226
01:19:20,942 --> 01:19:22,623
an inch is 4 bytes and you ask for 3 of them,

2227
01:19:22,703 --> 01:19:22,783
oh,

2228
01:19:22,862 --> 01:19:23,812
there's my 12.

2229
01:19:23,982 --> 01:19:26,893
So somehow I'm losing 12 bytes of memory,

2230
01:19:27,103 --> 01:19:28,103
not in the literal sense,

2231
01:19:28,183 --> 01:19:30,703
but it means by the time the program finishes,

2232
01:19:30,982 --> 01:19:32,942
you have not returned

2233
01:19:33,183 --> 01:19:33,542
or free.

2234
01:19:33,945 --> 01:19:35,616
all of the memory that you asked for.

2235
01:19:35,706 --> 01:19:38,625
So this line here is your hint that you've done

2236
01:19:38,625 --> 01:19:41,536
something wrong with respect to 12 bytes in total.

2237
01:19:41,706 --> 01:19:43,735
And sometimes you'll see slightly different output here.

2238
01:19:43,826 --> 01:19:44,226
For instance,

2239
01:19:44,306 --> 01:19:49,016
we see mention up here 12 bytes and 1 blocks are definitely lost in lost record 101,

2240
01:19:49,186 --> 01:19:49,866
very verbose,

2241
01:19:49,875 --> 01:19:50,985
but the juicy part is,

2242
01:19:51,036 --> 01:19:51,395
ah,

2243
01:19:51,625 --> 01:19:54,695
on line 8 is the source of that error specifically.

2244
01:19:54,866 --> 01:19:55,335
So there too,

2245
01:19:55,346 --> 01:19:59,136
it's a little bit of a bread crumb leading me to the solution for fixing this.

2246
01:19:59,386 --> 01:20:00,386
So if I go up here.

2247
01:20:00,770 --> 01:20:01,759
I look at line 8.

2248
01:20:01,799 --> 01:20:02,310
OK,

2249
01:20:02,479 --> 01:20:04,359
there's only so much that I could have done wrong on

2250
01:20:04,359 --> 01:20:06,970
line 8 if I've mallocked the memory on line 8.

2251
01:20:07,319 --> 01:20:09,479
Sounds like I do need to free it later on.

2252
01:20:09,759 --> 01:20:11,080
So let's fix both of these problems.

2253
01:20:11,160 --> 01:20:12,870
The first one is just the indexing issue.

2254
01:20:13,040 --> 01:20:14,950
Change the 123 to 012.

2255
01:20:15,160 --> 01:20:19,149
Let's then fix the second problem by just freeing X at the very end

2256
01:20:19,560 --> 01:20:21,029
and just for good measure.

2257
01:20:22,100 --> 01:20:25,169
This was not caught by Valgrin because it doesn't always happen,

2258
01:20:25,339 --> 01:20:26,890
but there's one other

2259
01:20:27,750 --> 01:20:29,609
scenario that could go wrong,

2260
01:20:29,660 --> 01:20:31,419
and it relates to line 8.

2261
01:20:33,100 --> 01:20:34,250
What should I be doing?

2262
01:20:35,500 --> 01:20:35,709
Uh

2263
01:20:41,660 --> 01:20:43,220
I am doing an array,

2264
01:20:43,299 --> 01:20:47,129
but recall that we can use array syntax on chunks of memory.

2265
01:20:47,500 --> 01:20:50,140
So technically what Lion 8 is doing is this it is

2266
01:20:50,140 --> 01:20:53,669
allocating 12 bytes of memory from the computer just because,

2267
01:20:53,779 --> 01:20:55,459
just to demonstrate how Malock works,

2268
01:20:55,500 --> 01:20:58,830
and it's storing the address of that first byte in a variable called X.

2269
01:20:59,540 --> 01:21:03,200
The bracket notation is just the syntactic sugar that

2270
01:21:03,200 --> 01:21:06,200
allows me to change values at X's address.

2271
01:21:06,279 --> 01:21:09,870
I could alternatively just use pointers and say go to X

2272
01:21:10,080 --> 01:21:11,390
and put 72 there.

2273
01:21:11,720 --> 01:21:12,779
Go to

2274
01:21:13,009 --> 01:21:15,669
X + 1 and put 73 there.

2275
01:21:16,040 --> 01:21:18,520
Go to X + 2

2276
01:21:18,759 --> 01:21:19,879
and put 33 there.

2277
01:21:20,879 --> 01:21:22,040
Using pointer arithmetic,

2278
01:21:22,080 --> 01:21:23,700
but those are identical and no,

2279
01:21:24,080 --> 01:21:24,790
generally,

2280
01:21:25,399 --> 01:21:25,520
you know,

2281
01:21:25,640 --> 01:21:28,669
most people would just use square bracket notation because it's just a little

2282
01:21:28,879 --> 01:21:30,640
cleaner and easier to read and write.

2283
01:21:31,279 --> 01:21:31,580
OK,

2284
01:21:31,700 --> 01:21:32,479
but back to this question,

2285
01:21:32,540 --> 01:21:33,930
there's still a subtle bug here,

2286
01:21:34,140 --> 01:21:36,009
based on our example just before break,

2287
01:21:36,419 --> 01:21:39,589
what should you be doing any time you call Malock

2288
01:21:39,939 --> 01:21:41,009
and get string,

2289
01:21:41,259 --> 01:21:42,729
and a few other functions for that matter.

2290
01:21:46,200 --> 01:21:47,129
Did I hear the answer?

2291
01:21:47,950 --> 01:21:48,799
Checking for

2292
01:21:50,859 --> 01:21:51,689
Checking for null,

2293
01:21:51,740 --> 01:21:51,890
right,

2294
01:21:52,060 --> 01:21:54,580
because if lock has an error,

2295
01:21:54,700 --> 01:21:56,529
there's not enough memory for whatever reason,

2296
01:21:56,700 --> 01:22:00,509
you should not be proceeding to touch that memory because it might be the null

2297
01:22:01,060 --> 01:22:01,569
address

2298
01:22:01,779 --> 01:22:03,350
that is 0 X0.

2299
01:22:03,540 --> 01:22:04,970
So what you should really be checking is,

2300
01:22:04,979 --> 01:22:05,169
well,

2301
01:22:05,200 --> 01:22:06,790
if X equals equals null,

2302
01:22:06,979 --> 01:22:08,259
there's no more work to be done here.

2303
01:22:08,299 --> 01:22:09,129
Let's just return

2304
01:22:09,259 --> 01:22:11,140
one down here and only if we get all the way

2305
01:22:11,140 --> 01:22:13,580
to the bottom should we maybe return 0 to signify.

2306
01:22:13,990 --> 01:22:14,149
Uh,

2307
01:22:14,220 --> 01:22:15,600
explicitly that there

2308
01:22:15,830 --> 01:22:17,669
is in fact successful operation.

2309
01:22:17,870 --> 01:22:18,149
All right,

2310
01:22:18,470 --> 01:22:18,950
with that said,

2311
01:22:19,069 --> 01:22:20,270
let's go back down here,

2312
01:22:20,390 --> 01:22:21,660
remake memory,

2313
01:22:22,120 --> 01:22:24,689
no error messages from the compiler slash memory

2314
01:22:25,029 --> 01:22:25,830
that too seems OK,

2315
01:22:25,910 --> 01:22:26,950
but it was fine the first time.

2316
01:22:27,029 --> 01:22:27,990
Let's now run Valgrin.

2317
01:22:28,069 --> 01:22:28,419
Let me,

2318
01:22:28,669 --> 01:22:28,890
uh,

2319
01:22:28,899 --> 01:22:29,939
maximize my window.

2320
01:22:30,540 --> 01:22:34,470
One run Valgrin.slash memory crossing my fingers as always,

2321
01:22:34,589 --> 01:22:35,299
and now.

2322
01:22:35,759 --> 01:22:36,790
This is actually pretty good.

2323
01:22:36,839 --> 01:22:39,359
It's much shorter output even though it's just as scary at a glance,

2324
01:22:39,399 --> 01:22:42,790
but most of this is fluffy and not very revealing.

2325
01:22:42,959 --> 01:22:45,479
Heap summary in use at exit 0 and 0.

2326
01:22:45,520 --> 01:22:46,040
So look,

2327
01:22:46,080 --> 01:22:47,879
like all heap blocks were freed,

2328
01:22:48,000 --> 01:22:49,549
no leaks are possible.

2329
01:22:49,720 --> 01:22:50,919
Heap is a word we'll come back to,

2330
01:22:50,959 --> 01:22:52,790
but this means there's nothing wrong.

2331
01:22:52,850 --> 01:22:53,189
In fact,

2332
01:22:53,319 --> 01:22:54,299
zero errors,

2333
01:22:54,399 --> 01:22:55,189
which is a good thing.

2334
01:22:55,359 --> 01:22:55,720
So in short,

2335
01:22:55,759 --> 01:22:58,279
Valgrind is among the most arcane programs we're going to use.

2336
01:22:58,362 --> 01:22:59,312
Its output was

2337
01:22:59,752 --> 01:23:01,123
really designed for those more comfortable,

2338
01:23:01,152 --> 01:23:01,663
if you will,

2339
01:23:01,833 --> 01:23:04,592
but there's still juicy insights there if you just kind of look for

2340
01:23:04,592 --> 01:23:08,132
things that lead you to like this file on this line number,

2341
01:23:08,172 --> 01:23:11,342
odds are that will lead you to the most subtle of bugs.

2342
01:23:11,433 --> 01:23:11,743
In fact,

2343
01:23:11,873 --> 01:23:14,112
another type of bug is when we do indeed touch memory,

2344
01:23:14,152 --> 01:23:14,672
we shouldn't.

2345
01:23:14,723 --> 01:23:16,462
So let me zoom out on that,

2346
01:23:16,553 --> 01:23:17,303
clear my terminal,

2347
01:23:17,312 --> 01:23:19,542
and let me open up another program

2348
01:23:19,873 --> 01:23:20,993
or maybe write this one real.

2349
01:23:21,136 --> 01:23:22,686
Fast incorrectly.

2350
01:23:22,866 --> 01:23:26,425
So let me create a program called Garbage.c

2351
01:23:26,706 --> 01:23:29,005
to demonstrate what we've generally called garbage values,

2352
01:23:29,065 --> 01:23:30,636
that is values that are still in memory,

2353
01:23:30,666 --> 01:23:33,136
but I didn't put them there myself necessarily.

2354
01:23:33,346 --> 01:23:34,895
I'm going to include standardio.h.

2355
01:23:35,025 --> 01:23:37,355
I'm going to include standard lib.h.

2356
01:23:37,866 --> 01:23:41,695
and then I'm going to go ahead and actually no need for standard lib this time.

2357
01:23:41,866 --> 01:23:43,746
Let's do in main void.

2358
01:23:44,299 --> 01:23:45,419
And inside of Maine,

2359
01:23:45,689 --> 01:23:49,609
let's give myself an array of like way too many exam scores or whatnot.

2360
01:23:49,770 --> 01:23:50,810
We used to do just a few,

2361
01:23:50,890 --> 01:23:52,859
but let's say there's 1,0024.

2362
01:23:53,089 --> 01:23:54,600
Then let's go ahead and do 4

2363
01:23:54,770 --> 01:23:57,580
in uh for in I equals 0,

2364
01:23:58,109 --> 01:23:59,649
I less than 124,

2365
01:23:59,689 --> 01:24:00,839
I plus plus,

2366
01:24:01,169 --> 01:24:02,080
and in here,

2367
01:24:02,089 --> 01:24:04,080
let's go ahead and print out,

2368
01:24:04,490 --> 01:24:04,879
uh,

2369
01:24:04,930 --> 01:24:05,450
whoops,

2370
01:24:05,540 --> 01:24:08,879
let's go ahead and print out using print F each of those scores.

2371
01:24:09,129 --> 01:24:09,680
Of course,

2372
01:24:09,890 --> 01:24:12,000
I have clearly forgotten to do something

2373
01:24:12,290 --> 01:24:12,810
in this program,

2374
01:24:12,819 --> 01:24:13,560
which is what?

2375
01:24:19,689 --> 01:24:22,040
I haven't actually put in any scores there for real.

2376
01:24:22,120 --> 01:24:22,870
Like I've asked the computer,

2377
01:24:22,959 --> 01:24:27,000
give me an array for 11,024 integers,

2378
01:24:27,200 --> 01:24:30,640
but I've not used get into or even manually typed in any of my quiz scores,

2379
01:24:30,680 --> 01:24:31,709
which we did in the past.

2380
01:24:31,879 --> 01:24:35,319
That's because I'm intentionally trying to show us garbage inside of the.

2381
01:24:35,404 --> 01:24:36,075
Computer's memory.

2382
01:24:36,145 --> 01:24:39,944
What this loop is going to do on line 8 now is literally print out the first in,

2383
01:24:40,024 --> 01:24:40,464
the second in,

2384
01:24:40,544 --> 01:24:43,245
the 3rd in all 100 24 ins,

2385
01:24:43,345 --> 01:24:45,825
but all of them should be garbage values because

2386
01:24:45,825 --> 01:24:49,174
I myself haven't put anything in those dresses yet.

2387
01:24:49,345 --> 01:24:51,194
So let's go ahead and make garbage.

2388
01:24:51,464 --> 01:24:54,615
Let's go ahead and maximize my terminal window just to see more on the screen.

2389
01:24:54,674 --> 01:24:55,584
Do garbage.

2390
01:24:55,625 --> 01:24:57,185
It's going to be super fast output because the

2391
01:24:57,185 --> 01:25:00,024
computer is way faster than 1,0024 variable values alone.

2392
01:25:00,580 --> 01:25:02,419
There is a lot of garbage output.

2393
01:25:02,580 --> 01:25:05,040
So when we talk about garbage values in the abstract,

2394
01:25:05,180 --> 01:25:06,569
like here's just some random zeros,

2395
01:25:06,580 --> 01:25:07,180
a 25,

2396
01:25:07,259 --> 01:25:08,140
a 32,000,

2397
01:25:08,220 --> 01:25:08,850
a negative number,

2398
01:25:08,879 --> 01:25:09,470
and so forth,

2399
01:25:09,620 --> 01:25:11,859
that's because it's essentially remnants from the computer's

2400
01:25:11,859 --> 01:25:13,850
memory of stuff that might have happened previously,

2401
01:25:14,020 --> 01:25:16,129
not necessarily by me in this moment,

2402
01:25:16,459 --> 01:25:18,660
which is to say you just shouldn't touch that memory

2403
01:25:18,979 --> 01:25:20,529
at all whatsoever.

2404
01:25:20,660 --> 01:25:24,250
So now we're seeing garbage values for the actual first time.

2405
01:25:24,580 --> 01:25:27,009
Let's consider another example of a program

2406
01:25:27,259 --> 01:25:30,020
that doesn't contain that does.

2407
01:25:30,839 --> 01:25:34,830
Contain potentially memory errors and let's look at this too.

2408
01:25:35,040 --> 01:25:37,000
So this is not really a useful program,

2409
01:25:37,009 --> 01:25:39,200
it's meant to be demonstrative of some of these concepts.

2410
01:25:39,240 --> 01:25:41,839
So here we have a program takes no command line arguments.

2411
01:25:42,000 --> 01:25:43,279
Up here we've got a line.

2412
01:25:43,799 --> 01:25:47,160
That pair of lines that declares two pointers but doesn't

2413
01:25:47,160 --> 01:25:49,629
yet initialize them to any variables and that's fine.

2414
01:25:49,680 --> 01:25:52,149
You don't have to have an equal sign with any variable.

2415
01:25:52,399 --> 01:25:55,270
You just eventually should assign it some value.

2416
01:25:55,359 --> 01:25:56,310
But this just tells the computer,

2417
01:25:56,359 --> 01:25:58,899
give me a variable X that's going to store the address of an end.

2418
01:25:59,069 --> 01:26:02,049
Give me another variable Y that's going to store the address of another N.

2419
01:26:02,569 --> 01:26:02,990
OK.

2420
01:26:03,160 --> 01:26:04,029
What happens next?

2421
01:26:04,120 --> 01:26:04,200
Well,

2422
01:26:04,319 --> 01:26:05,319
on this line of code.

2423
01:26:05,375 --> 01:26:06,515
This simple example,

2424
01:26:06,645 --> 01:26:08,484
we're allocating enough space for a single

2425
01:26:08,484 --> 01:26:10,765
integer just because it's a stupid exercise.

2426
01:26:10,865 --> 01:26:14,875
There's no reason to do this other than to demonstrate how Mao works for the moment.

2427
01:26:15,165 --> 01:26:17,475
Malloch returns the address of

2428
01:26:17,765 --> 01:26:18,875
that chunk of memory,

2429
01:26:19,084 --> 01:26:20,654
so that's what goes in X.

2430
01:26:20,884 --> 01:26:24,274
So X is now pointing at somewhere in memory 4 bytes

2431
01:26:24,274 --> 01:26:27,115
of space that it can certainly put a value at.

2432
01:26:27,404 --> 01:26:28,205
How do we do that?

2433
01:26:28,325 --> 01:26:28,444
Well,

2434
01:26:28,524 --> 01:26:31,125
if you do X and use the D-reference operator,

2435
01:26:31,165 --> 01:26:33,964
that means go to that chunk of memory and put the number 42 there.

2436
01:26:34,125 --> 01:26:35,174
That's totally valid.

2437
01:26:35,850 --> 01:26:36,600
This says,

2438
01:26:36,689 --> 01:26:37,839
go to the address

2439
01:26:37,970 --> 01:26:38,819
in Y

2440
01:26:39,049 --> 01:26:41,560
and put the unlucky number 13 there.

2441
01:26:42,089 --> 01:26:45,569
Unlucky quite literally because what is Y pointing to at this moment?

2442
01:26:47,629 --> 01:26:49,589
It's just the garbage address.

2443
01:26:49,700 --> 01:26:49,859
Why?

2444
01:26:50,029 --> 01:26:51,640
Because if you don't initialize why,

2445
01:26:51,819 --> 01:26:53,419
who knows what it's going to be pointing to.

2446
01:26:53,459 --> 01:26:54,020
Maybe it's 0,

2447
01:26:54,060 --> 01:26:54,740
maybe it's 25,

2448
01:26:54,839 --> 01:26:55,819
maybe it's 32,000,

2449
01:26:55,859 --> 01:26:56,459
a negative number,

2450
01:26:56,479 --> 01:26:58,049
just like we saw in the previous example.

2451
01:26:58,220 --> 01:27:01,490
You have no idea what values are going to be in

2452
01:27:01,490 --> 01:27:04,330
X and Y unless you yourself put those values there.

2453
01:27:04,549 --> 01:27:07,129
So this is highlighted in red because bad things are going

2454
01:27:07,129 --> 01:27:11,220
to happen if you try to de-reference an invalid or a bogus

2455
01:27:11,600 --> 01:27:12,080
pointer,

2456
01:27:12,100 --> 01:27:13,649
even worse than just touching

2457
01:27:13,939 --> 01:27:15,500
uh variables that might not have value.

2458
01:27:15,879 --> 01:27:18,700
If you de-reference an address and try going to some random place,

2459
01:27:18,830 --> 01:27:21,459
the computer is generally not going to like that.

2460
01:27:21,589 --> 01:27:22,020
And in fact,

2461
01:27:22,069 --> 01:27:24,229
our friends at Stanford wonderfully brought this

2462
01:27:24,229 --> 01:27:26,529
particular scenario to life whereby even though this

2463
01:27:26,529 --> 01:27:29,580
example is a bit contrived just to fit it all on the screen at once,

2464
01:27:29,830 --> 01:27:31,419
it is going to be the case

2465
01:27:31,870 --> 01:27:33,470
that bad things happen if

2466
01:27:33,750 --> 01:27:38,709
we don't check for these values and actually assign valid values in the form of,

2467
01:27:38,750 --> 01:27:39,740
as we'll see now,

2468
01:27:40,060 --> 01:27:41,109
some claymation.

2469
01:27:41,270 --> 01:27:43,549
So here I give you a binky.

2470
01:27:45,080 --> 01:27:45,720
Uh,

2471
01:27:45,859 --> 01:27:47,649
which is a bit of claymation from our friend

2472
01:27:47,649 --> 01:27:50,180
Nick Parlante at Stanford if we could dim the lights

2473
01:27:50,419 --> 01:27:51,799
unnecessarily dramatically.

2474
01:27:54,810 --> 01:27:55,509
Hey Binky,

2475
01:27:55,750 --> 01:27:56,379
wake up.

2476
01:27:56,509 --> 01:27:58,410
It's time for pointer fun.

2477
01:27:59,029 --> 01:27:59,899
What's that?

2478
01:28:00,270 --> 01:28:01,560
Learn about pointers.

2479
01:28:01,830 --> 01:28:02,240
Oh,

2480
01:28:02,290 --> 01:28:03,049
goody.

2481
01:28:03,629 --> 01:28:03,709
Well,

2482
01:28:03,790 --> 01:28:04,500
to get started,

2483
01:28:04,669 --> 01:28:06,379
I guess we're gonna need a couple pointers.

2484
01:28:06,629 --> 01:28:07,259
OK,

2485
01:28:07,430 --> 01:28:10,589
this code allocates two pointers which can point to integers.

2486
01:28:11,060 --> 01:28:11,370
OK,

2487
01:28:11,490 --> 01:28:11,609
well,

2488
01:28:11,770 --> 01:28:12,950
I see the two pointers,

2489
01:28:13,290 --> 01:28:15,040
but they don't seem to be pointing to anything.

2490
01:28:15,169 --> 01:28:15,799
That's right.

2491
01:28:15,970 --> 01:28:16,410
Initially,

2492
01:28:16,569 --> 01:28:17,959
pointers don't point to anything.

2493
01:28:18,129 --> 01:28:20,330
The things they point to are called pointees,

2494
01:28:20,350 --> 01:28:22,040
and setting them up's a separate step.

2495
01:28:22,370 --> 01:28:22,600
Oh,

2496
01:28:22,689 --> 01:28:22,850
right,

2497
01:28:22,970 --> 01:28:23,129
right,

2498
01:28:23,270 --> 01:28:25,240
I knew that the pointees are separate.

2499
01:28:25,910 --> 01:28:27,709
So how do you allocate a pointee?

2500
01:28:28,049 --> 01:28:28,839
OK,

2501
01:28:29,009 --> 01:28:29,279
well,

2502
01:28:29,410 --> 01:28:31,839
this code allocates a new integer pointee,

2503
01:28:32,040 --> 01:28:34,129
and this part sets X to point to it.

2504
01:28:35,100 --> 01:28:35,259
Hey,

2505
01:28:35,299 --> 01:28:36,129
that looks better.

2506
01:28:36,339 --> 01:28:37,529
So make it do something.

2507
01:28:37,939 --> 01:28:38,569
OK,

2508
01:28:38,779 --> 01:28:43,259
I'll dereference the pointer X to store the number 42 into its pointee.

2509
01:28:43,660 --> 01:28:44,290
For this trick,

2510
01:28:44,339 --> 01:28:46,689
I'll need my magic wand of dereferencing.

2511
01:28:47,220 --> 01:28:50,009
Your magic wand of dereferencing,

2512
01:28:50,259 --> 01:28:50,379
uh,

2513
01:28:50,540 --> 01:28:50,700
that,

2514
01:28:50,779 --> 01:28:51,299
that's great.

2515
01:28:52,299 --> 01:28:53,950
This is what the code looks like.

2516
01:28:54,100 --> 01:28:56,069
I'll just set up the number and

2517
01:28:57,089 --> 01:28:57,330
Hey,

2518
01:28:57,370 --> 01:28:57,620
look,

2519
01:28:57,750 --> 01:28:58,720
there it goes.

2520
01:28:59,290 --> 01:29:03,109
So doing a D-reference on X follows the arrow to access

2521
01:29:03,109 --> 01:29:05,919
its pointee in this case to store 42 in there.

2522
01:29:06,209 --> 01:29:06,419
Hey,

2523
01:29:06,729 --> 01:29:09,399
try using it to store the number 13 through the other pointer.

2524
01:29:09,609 --> 01:29:10,089
Why?

2525
01:29:10,689 --> 01:29:11,379
OK,

2526
01:29:11,810 --> 01:29:13,640
I'll just go over here to Y

2527
01:29:13,930 --> 01:29:16,040
and get the number 13 set up

2528
01:29:16,330 --> 01:29:20,209
and then take the wand of D referencing and just.

2529
01:29:21,729 --> 01:29:22,419
Oh hey,

2530
01:29:22,549 --> 01:29:23,740
that didn't work.

2531
01:29:24,229 --> 01:29:24,430
Say,

2532
01:29:24,520 --> 01:29:24,899
uh,

2533
01:29:24,910 --> 01:29:25,270
Binky,

2534
01:29:25,370 --> 01:29:28,109
I don't think dereferencing Y is a good idea because,

2535
01:29:28,149 --> 01:29:28,540
uh,

2536
01:29:28,750 --> 01:29:28,870
you know,

2537
01:29:29,069 --> 01:29:32,700
setting up the pointee is a separate step and uh I don't think we ever did it.

2538
01:29:33,450 --> 01:29:33,459
Hm,

2539
01:29:33,470 --> 01:29:34,290
good point.

2540
01:29:34,669 --> 01:29:34,830
Yeah,

2541
01:29:35,109 --> 01:29:35,270
we,

2542
01:29:35,350 --> 01:29:39,069
we allocated the pointer Y but we never set it to point to a pointee.

2543
01:29:40,189 --> 01:29:41,259
Very observant.

2544
01:29:41,740 --> 01:29:41,759
Eh,

2545
01:29:41,870 --> 01:29:42,470
you're looking good there,

2546
01:29:42,549 --> 01:29:43,220
Binkie.

2547
01:29:43,470 --> 01:29:46,299
Can you fix it so that Y points to the same pointee as X?

2548
01:29:46,549 --> 01:29:46,830
Sure,

2549
01:29:46,990 --> 01:29:49,459
I'll use my magic wand of pointer assignment.

2550
01:29:49,790 --> 01:29:51,740
Is that gonna be a problem like before?

2551
01:29:52,029 --> 01:29:52,149
No,

2552
01:29:52,270 --> 01:29:53,700
this doesn't touch the pointees.

2553
01:29:53,830 --> 01:29:56,580
It just changes one pointer to point to the same thing as another.

2554
01:29:57,290 --> 01:29:57,629
Oh,

2555
01:29:57,720 --> 01:29:58,390
I see.

2556
01:29:58,520 --> 01:30:00,819
Now Y points to the same place as X.

2557
01:30:01,279 --> 01:30:01,439
So,

2558
01:30:01,600 --> 01:30:01,839
so wait,

2559
01:30:01,959 --> 01:30:02,890
now Y is fixed,

2560
01:30:02,959 --> 01:30:03,870
it has a pointee.

2561
01:30:04,200 --> 01:30:07,229
So you can try the wand of dereferencing again to send the 13 over.

2562
01:30:08,600 --> 01:30:09,270
OK,

2563
01:30:09,359 --> 01:30:10,109
here goes.

2564
01:30:11,149 --> 01:30:11,359
Hey,

2565
01:30:11,470 --> 01:30:12,109
look at that.

2566
01:30:12,390 --> 01:30:13,930
Now dereferencing works on Y,

2567
01:30:14,069 --> 01:30:16,180
and because the pointers are sharing that one pointee,

2568
01:30:16,390 --> 01:30:17,720
they both see the 13.

2569
01:30:18,189 --> 01:30:18,379
Yeah,

2570
01:30:18,509 --> 01:30:18,910
sharing,

2571
01:30:19,029 --> 01:30:19,149
uh,

2572
01:30:19,229 --> 01:30:19,700
whatever.

2573
01:30:19,950 --> 01:30:21,660
So are we gonna switch places now?

2574
01:30:21,830 --> 01:30:22,350
Oh look,

2575
01:30:22,470 --> 01:30:23,629
we're out of time.

2576
01:30:24,729 --> 01:30:26,680
I can only imagine how long that took Nick,

2577
01:30:26,839 --> 01:30:31,359
but the key detail was that bad things happened to Binki when we did this line of code,

2578
01:30:31,390 --> 01:30:34,470
de-referencing an invalid pointer that had no

2579
01:30:34,799 --> 01:30:35,799
true value assigned.

2580
01:30:35,839 --> 01:30:36,919
It was just some garbage value.

2581
01:30:37,000 --> 01:30:37,910
Now what's the solution?

2582
01:30:38,040 --> 01:30:38,120
Well,

2583
01:30:38,200 --> 01:30:38,919
as Nick proposed,

2584
01:30:39,120 --> 01:30:40,109
just don't do that

2585
01:30:40,319 --> 01:30:44,160
and instead at least do something sensible like assign X equal toy,

2586
01:30:44,399 --> 01:30:46,240
not to make a copy of anything per se,

2587
01:30:46,279 --> 01:30:49,680
but to literally point X at the same location in memory.

2588
01:30:50,082 --> 01:30:52,321
To pointy at the same location in memory as X,

2589
01:30:52,461 --> 01:30:54,972
then a line like this is perfectly valid.

2590
01:30:54,981 --> 01:30:56,412
You can go to that address,

2591
01:30:56,582 --> 01:30:58,651
which happens to be the same as the 42,

2592
01:30:58,821 --> 01:31:00,932
and that's why in the claymation form

2593
01:31:01,262 --> 01:31:03,812
we saw that the 42 became a 13 instead.

2594
01:31:03,901 --> 01:31:04,182
So again,

2595
01:31:04,262 --> 01:31:05,051
at the end of the day,

2596
01:31:05,182 --> 01:31:08,062
this is only demonstrative of these basic building

2597
01:31:08,062 --> 01:31:09,771
blocks that we now have at our disposal,

2598
01:31:09,981 --> 01:31:13,662
but also how easy it is to do things incorrectly.

2599
01:31:13,782 --> 01:31:14,742
So this is one of those with great.

2600
01:31:15,043 --> 01:31:16,744
Power comes great responsibility.

2601
01:31:16,883 --> 01:31:20,724
C is one of the languages that is incredibly high performing.

2602
01:31:20,804 --> 01:31:23,403
It's so close to the hardware that you have so much control

2603
01:31:23,403 --> 01:31:26,003
over the memory and operation that you can write really good,

2604
01:31:26,094 --> 01:31:26,804
really fast code.

2605
01:31:26,844 --> 01:31:28,514
And that's why even all these decades later,

2606
01:31:28,604 --> 01:31:31,713
it's among the most omnipresent programming languages in the world.

2607
01:31:31,923 --> 01:31:32,483
At the same time,

2608
01:31:32,494 --> 01:31:36,324
you can really screw things up and so many of today's software that

2609
01:31:36,324 --> 01:31:39,764
are hacked in some way or crashed for some reason is often.

2610
01:31:39,916 --> 01:31:43,625
Humans have just missed some simple mistake like this

2611
01:31:43,905 --> 01:31:45,585
that happens to relate to memory,

2612
01:31:45,666 --> 01:31:47,545
so more modern languages that we'll soon see like

2613
01:31:47,545 --> 01:31:49,815
Python and if in high school you study Java,

2614
01:31:50,275 --> 01:31:53,235
you don't have this much control over the computer's memory.

2615
01:31:53,266 --> 01:31:57,786
There's many more defenses put in place to protect you and me from ourselves,

2616
01:31:58,025 --> 01:31:58,735
so to speak,

2617
01:31:58,866 --> 01:32:01,375
but you pay the price by some of those languages tend to be

2618
01:32:01,625 --> 01:32:04,496
uh less uh slower and less performance,

2619
01:32:04,625 --> 01:32:04,826
yeah.

2620
01:32:06,589 --> 01:32:06,850
My

2621
01:32:07,600 --> 01:32:07,689
I

2622
01:32:10,120 --> 01:32:10,680
What?

2623
01:32:11,950 --> 01:32:12,660
Like like

2624
01:32:16,450 --> 01:32:16,689
difference

2625
01:32:19,220 --> 01:32:21,020
What is the difference here that we're now playing with memory?

2626
01:32:21,140 --> 01:32:22,740
This will become clear this week and next,

2627
01:32:22,819 --> 01:32:24,259
and in fact some of the examples on which

2628
01:32:24,259 --> 01:32:27,020
will end today will motivate needing to have finer

2629
01:32:27,020 --> 01:32:29,109
grain control over what's going on inside of the

2630
01:32:29,109 --> 01:32:31,100
computer when you want to deal with files,

2631
01:32:31,250 --> 01:32:31,660
for instance,

2632
01:32:31,740 --> 01:32:32,419
you're going to need to know a

2633
01:32:32,419 --> 01:32:34,419
little something about memory addresses and where things

2634
01:32:34,419 --> 01:32:39,029
are when you want to build structures in memory beyond the complexity of an array.

2635
01:32:39,180 --> 01:32:39,459
In fact,

2636
01:32:39,500 --> 01:32:40,580
next week we're going to start building.

2637
01:32:40,709 --> 01:32:43,790
Two dimensional structures in the computer's memory to

2638
01:32:43,790 --> 01:32:45,729
represent the equivalent of like a family tree

2639
01:32:45,729 --> 01:32:50,290
for instance or trees more generally that can store data in a more efficient way.

2640
01:32:50,459 --> 01:32:52,100
Up until now all we have is arrays,

2641
01:32:52,169 --> 01:32:54,609
and with arrays you can achieve something like binary search,

2642
01:32:54,660 --> 01:32:57,140
but we're going to see there are things you can't do with arrays,

2643
01:32:57,339 --> 01:32:58,569
especially if speed is important.

2644
01:32:58,870 --> 01:33:01,950
I was saying like for example if you were to ask me to do this like last week.

2645
01:33:02,680 --> 01:33:03,270
I'll be like

2646
01:33:03,600 --> 01:33:05,859
X equals 13 or something.

2647
01:33:07,600 --> 01:33:07,839
Correct.

2648
01:33:08,319 --> 01:33:08,799
So last week,

2649
01:33:08,839 --> 01:33:12,609
if you just said in X equals 13 or in Y equals 42 or whatnot,

2650
01:33:12,839 --> 01:33:13,509
totally fine.

2651
01:33:13,520 --> 01:33:16,600
And again this program sole purpose in life is to demonstrate

2652
01:33:16,600 --> 01:33:19,149
how you can make mistakes in and of itself is not useful

2653
01:33:19,359 --> 01:33:19,669
here,

2654
01:33:19,720 --> 01:33:21,029
but it's representative

2655
01:33:21,279 --> 01:33:23,509
of how we're gonna start using this syntax,

2656
01:33:23,919 --> 01:33:26,029
not only in this week's problem sets but next week

2657
01:33:26,240 --> 01:33:26,750
as well.

2658
01:33:28,029 --> 01:33:28,390
All right,

2659
01:33:28,660 --> 01:33:32,990
so with that claim made that we can

2660
01:33:33,310 --> 01:33:34,350
do a lot of damage,

2661
01:33:34,430 --> 01:33:37,189
let's consider how pointers and knowledge of memory

2662
01:33:37,189 --> 01:33:39,500
addresses can actually solve some useful problems.

2663
01:33:39,629 --> 01:33:39,750
Um,

2664
01:33:39,790 --> 01:33:43,109
can we get one volunteer to come on up and help pour a drink?

2665
01:33:43,189 --> 01:33:43,939
Come on up.

2666
01:33:44,379 --> 01:33:44,799
All right,

2667
01:33:45,029 --> 01:33:45,859
what is your

2668
01:33:46,950 --> 01:33:47,350
name?

2669
01:33:51,379 --> 01:33:51,890
From on over

2670
01:33:54,020 --> 01:33:55,450
If you want to say a quick hello to the group.

2671
01:33:55,660 --> 01:33:56,529
I'm Olivia.

2672
01:33:56,700 --> 01:33:56,899
OK,

2673
01:33:56,930 --> 01:33:57,169
and,

2674
01:33:57,339 --> 01:33:58,450
and a little something about yourself.

2675
01:33:58,580 --> 01:33:58,890
Oh,

2676
01:33:59,540 --> 01:34:00,229
I live in Canada.

2677
01:34:00,500 --> 01:34:00,740
OK,

2678
01:34:00,859 --> 01:34:01,189
welcome.

2679
01:34:01,200 --> 01:34:01,209
Well,

2680
01:34:01,299 --> 01:34:01,810
come on over here,

2681
01:34:01,819 --> 01:34:02,370
Olivia,

2682
01:34:02,620 --> 01:34:03,410
and we have,

2683
01:34:03,580 --> 01:34:03,799
um,

2684
01:34:03,879 --> 01:34:04,500
2 glasses,

2685
01:34:04,580 --> 01:34:04,660
well,

2686
01:34:04,740 --> 01:34:05,540
really 3 glasses.

2687
01:34:05,620 --> 01:34:07,890
So we have these fancy ray bands that have cameras built

2688
01:34:07,890 --> 01:34:10,209
in whereby we can sort of capture your point of view.

2689
01:34:10,500 --> 01:34:11,140
If you're comfortable,

2690
01:34:11,160 --> 01:34:11,740
we'll put these on.

2691
01:34:11,779 --> 01:34:12,850
There's no lenses in them.

2692
01:34:13,100 --> 01:34:14,870
The white light will mean we're recording,

2693
01:34:14,950 --> 01:34:16,580
hopefully a memorable moment.

2694
01:34:19,649 --> 01:34:21,040
This battery too is dead.

2695
01:34:21,330 --> 01:34:21,450
All right,

2696
01:34:21,490 --> 01:34:22,689
we don't have a backup for the backup,

2697
01:34:22,729 --> 01:34:24,549
so we're gonna pretend that this part never happens,

2698
01:34:24,569 --> 01:34:24,839
so.

2699
01:34:26,229 --> 01:34:26,549
Olivia,

2700
01:34:26,629 --> 01:34:28,189
we have 2 glasses here for you,

2701
01:34:28,229 --> 01:34:31,270
and I'm gonna go ahead and pour some colored liquid into both.

2702
01:34:31,310 --> 01:34:33,459
So we've got some blue liquid here into this glass.

2703
01:34:34,270 --> 01:34:34,470
All right,

2704
01:34:34,589 --> 01:34:35,979
so we'll fill this up here.

2705
01:34:37,649 --> 01:34:41,180
And then in this one we're gonna go ahead and pour this orange liquid,

2706
01:34:41,799 --> 01:34:43,819
and at this point in the story I'm going to exclaim,

2707
01:34:43,879 --> 01:34:44,330
oh no,

2708
01:34:44,520 --> 01:34:48,529
I accidentally put the wrong liquid in the wrong glass so I got this backwards.

2709
01:34:48,640 --> 01:34:50,890
So what I'd like you to do is swap

2710
01:34:51,109 --> 01:34:54,520
the values in these glasses so that the blue goes into that glass and

2711
01:34:54,520 --> 01:34:58,959
the the orange goes into this glass without mixing it without mixing it.

2712
01:34:59,080 --> 01:35:00,160
So what you're hesitating.

2713
01:35:00,200 --> 01:35:00,569
Why?

2714
01:35:01,000 --> 01:35:01,350
Well,

2715
01:35:01,479 --> 01:35:02,279
it would be hard to do.

2716
01:35:02,470 --> 01:35:05,100
Unless you can like oh it would be like

2717
01:35:05,100 --> 01:35:08,649
hard to do um without mixing the two because like

2718
01:35:08,899 --> 01:35:10,859
you don't have anywhere to put the other one.

2719
01:35:10,979 --> 01:35:11,220
Of course.

2720
01:35:11,299 --> 01:35:13,540
So in the real world this is not really solvable unless

2721
01:35:13,540 --> 01:35:15,770
for instance we have a temporary variable if you will,

2722
01:35:15,779 --> 01:35:17,310
like an empty glass in which to do this.

2723
01:35:17,339 --> 01:35:20,209
So here is your third variable if you want to go ahead now

2724
01:35:20,209 --> 01:35:22,370
and get the blue into that one and the orange into that one,

2725
01:35:22,859 --> 01:35:23,100
yeah.

2726
01:35:25,609 --> 01:35:26,089
No pressure.

2727
01:35:28,740 --> 01:35:28,970
All right,

2728
01:35:29,049 --> 01:35:30,220
so we're putting

2729
01:35:30,609 --> 01:35:33,000
one value into the temporary variable,

2730
01:35:33,410 --> 01:35:34,959
we're putting the other value

2731
01:35:35,649 --> 01:35:36,859
into the original value.

2732
01:35:40,200 --> 01:35:40,680
OK,

2733
01:35:40,729 --> 01:35:42,200
and now you're probably gonna

2734
01:35:42,450 --> 01:35:42,930
take,

2735
01:35:43,529 --> 01:35:43,649
yep,

2736
01:35:43,729 --> 01:35:45,490
I'm guessing the temporary value,

2737
01:35:45,529 --> 01:35:47,160
put it into the original variable.

2738
01:35:51,500 --> 01:35:52,609
And that that was very well done.

2739
01:35:52,649 --> 01:35:55,049
If maybe we can give Olivia a round of applause for just that.

2740
01:35:55,129 --> 01:35:55,620
Thank you.

2741
01:35:58,080 --> 01:35:59,609
Little partying before you're here too.

2742
01:35:59,819 --> 01:36:00,330
So.

2743
01:36:01,000 --> 01:36:03,439
The goal here really being to create a memorable moment of like,

2744
01:36:03,620 --> 01:36:05,140
oh remember the time Olivia tried to swap two

2745
01:36:05,140 --> 01:36:07,350
values she needed a temporary variable is the takeaway.

2746
01:36:07,430 --> 01:36:08,200
So why is that?

2747
01:36:08,229 --> 01:36:08,270
Well,

2748
01:36:08,370 --> 01:36:08,669
in code,

2749
01:36:08,750 --> 01:36:10,939
if we wanted to do the same principle,

2750
01:36:10,990 --> 01:36:13,060
we're going to need somewhere temporary to put one

2751
01:36:13,060 --> 01:36:15,100
of those values before we can make this happen.

2752
01:36:15,390 --> 01:36:18,270
The catch is though that if we don't do this intelligently,

2753
01:36:18,310 --> 01:36:20,629
like it's just not going to work in C unless

2754
01:36:20,629 --> 01:36:22,589
we take advantage of some of these new capabilities.

2755
01:36:22,629 --> 01:36:23,180
So in fact,

2756
01:36:23,259 --> 01:36:26,589
I'm going to go over to VS code here and I'm going to open up a program called.

2757
01:36:26,735 --> 01:36:29,686
Swap.c that I wrote in advance whose purpose in

2758
01:36:29,686 --> 01:36:33,226
life is simply to swap two variables values.

2759
01:36:33,326 --> 01:36:33,686
So

2760
01:36:34,125 --> 01:36:36,815
I've got standard IO.h at the top so I can use print F.

2761
01:36:37,085 --> 01:36:39,166
I've got the prototype for a swap function which

2762
01:36:39,166 --> 01:36:41,286
is might as well be Olivia in this case that's

2763
01:36:41,286 --> 01:36:44,326
going to take two inputs A and B or two

2764
01:36:44,326 --> 01:36:47,355
glasses and swap their values ultimately is its purpose.

2765
01:36:47,605 --> 01:36:48,315
Inside of Maine though,

2766
01:36:48,326 --> 01:36:48,925
I'm going to do this.

2767
01:36:49,005 --> 01:36:52,366
I'm going to set two variables X and Y equal to 1 and 2 respective.

2768
01:36:52,472 --> 01:36:56,142
I'm then just as a point of clarification going to

2769
01:36:56,142 --> 01:36:57,921
print out the value of X is such and such,

2770
01:36:58,262 --> 01:36:59,361
Y is such and such.

2771
01:36:59,702 --> 01:37:01,622
Then I'm going to call the swap function,

2772
01:37:01,731 --> 01:37:04,771
AKA Olivia to swap the values X and Y.

2773
01:37:04,941 --> 01:37:07,162
Then I'm going to print out X is this and why is

2774
01:37:07,162 --> 01:37:09,972
this so that hopefully I'll see that they've indeed been swapped.

2775
01:37:10,182 --> 01:37:13,142
At the bottom of this file we have the actual swap function,

2776
01:37:13,151 --> 01:37:14,301
and as you might expect,

2777
01:37:14,312 --> 01:37:15,782
it takes two inputs A and B,

2778
01:37:15,821 --> 01:37:16,742
both of which are integers,

2779
01:37:16,821 --> 01:37:18,102
so I could have called them anything I want.

2780
01:37:18,419 --> 01:37:22,759
The first thing this function does is it grabs an empty glass called temp,

2781
01:37:23,209 --> 01:37:25,720
puts a or the blue liquid into it.

2782
01:37:26,129 --> 01:37:28,879
Then we put into a the value of B.

2783
01:37:29,089 --> 01:37:31,209
So we've sort of lost the value of a at this point

2784
01:37:31,209 --> 01:37:33,330
except that we did make a copy of it into temp.

2785
01:37:33,700 --> 01:37:36,919
And then lastly we put into B the temporary variable

2786
01:37:36,919 --> 01:37:39,430
and at the end the temp variable is empty,

2787
01:37:39,439 --> 01:37:41,549
although technically it still has a copy of the value,

2788
01:37:41,629 --> 01:37:45,580
but it's no longer useful because the job is done and A has become B and B has become A.

2789
01:37:45,720 --> 01:37:48,040
So I dare say this is like the literal translation of

2790
01:37:48,040 --> 01:37:51,549
what Olivia just did and I like the logic of it.

2791
01:37:51,879 --> 01:37:52,790
However,

2792
01:37:53,040 --> 01:37:55,149
when I actually run this program,

2793
01:37:55,759 --> 01:37:56,799
something goes awry.

2794
01:37:57,009 --> 01:37:59,470
So let me go ahead and do make swap.

2795
01:38:00,310 --> 01:38:01,390
slash swap

2796
01:38:01,640 --> 01:38:02,910
and I'll maximize my window.

2797
01:38:03,040 --> 01:38:04,799
I should see hopefully that X is 1,

2798
01:38:04,839 --> 01:38:05,450
Y is 2,

2799
01:38:05,459 --> 01:38:06,839
and then X is 2,

2800
01:38:06,859 --> 01:38:07,799
and Y is 1.

2801
01:38:09,390 --> 01:38:10,279
But no,

2802
01:38:10,529 --> 01:38:10,700
like,

2803
01:38:10,729 --> 01:38:12,040
even though I literally

2804
01:38:12,410 --> 01:38:14,879
translated into code what Olivia did,

2805
01:38:15,129 --> 01:38:18,049
this didn't actually seem to work.

2806
01:38:18,359 --> 01:38:19,390
And why is that?

2807
01:38:19,509 --> 01:38:19,609
Well,

2808
01:38:19,669 --> 01:38:21,939
it turns out that this version of the program

2809
01:38:22,350 --> 01:38:23,390
is not right,

2810
01:38:23,549 --> 01:38:23,870
in fact,

2811
01:38:24,029 --> 01:38:25,430
because of issues of scope,

2812
01:38:25,470 --> 01:38:26,709
and we've talked about scope before,

2813
01:38:26,830 --> 01:38:28,830
generally in the context of like where variable lives.

2814
01:38:28,870 --> 01:38:31,109
We've said that a variable only exists in like the

2815
01:38:31,109 --> 01:38:33,759
most recent curly braces that you opened up for it,

2816
01:38:33,910 --> 01:38:34,580
and that was true.

2817
01:38:34,709 --> 01:38:37,700
It's just sort of a colloquial way of describing what scope is,

2818
01:38:37,859 --> 01:38:41,979
but scope comes into play here because it turns out that A and B

2819
01:38:42,270 --> 01:38:45,620
insofar as they are the arguments or parameters for the swap function,

2820
01:38:45,990 --> 01:38:46,229
they.

2821
01:38:46,305 --> 01:38:50,564
Have a different scope than X and Y and that still follows the same definition.

2822
01:38:50,615 --> 01:38:53,564
They're inside of different curly braces than X and Y are,

2823
01:38:53,975 --> 01:38:57,524
so it seems that I may very well be swapping A and B,

2824
01:38:57,694 --> 01:38:59,924
but I'm not having any impact

2825
01:39:00,134 --> 01:39:01,544
on X and Y.

2826
01:39:01,654 --> 01:39:02,294
So why is that?

2827
01:39:02,365 --> 01:39:02,415
Well,

2828
01:39:02,484 --> 01:39:03,174
in C,

2829
01:39:03,254 --> 01:39:04,084
all this time,

2830
01:39:04,254 --> 01:39:06,174
any time you pass in arguments to a function,

2831
01:39:06,334 --> 01:39:08,564
you are passing in those arguments by value,

2832
01:39:08,615 --> 01:39:08,975
so to speak.

2833
01:39:09,015 --> 01:39:11,495
You're literally passing in copies of the

2834
01:39:11,495 --> 01:39:14,095
variables to the function you are calling.

2835
01:39:14,410 --> 01:39:15,799
So what does this mean?

2836
01:39:15,839 --> 01:39:15,919
Well,

2837
01:39:16,080 --> 01:39:16,759
more concretely,

2838
01:39:16,799 --> 01:39:20,879
if like this is a photograph of a chunk of memory inside of the computer and we sort of

2839
01:39:20,879 --> 01:39:24,830
zoom in as we've done before and we abstract away all of the bytes from top to bottom,

2840
01:39:25,089 --> 01:39:27,279
what's really happening inside of the computer's memory?

2841
01:39:27,759 --> 01:39:33,540
Is that we're using some of it for X and Y and some other memory for A and B,

2842
01:39:33,870 --> 01:39:35,390
but how is that in fact happening?

2843
01:39:35,470 --> 01:39:35,529
Well,

2844
01:39:35,589 --> 01:39:37,939
it turns out to a question that came up before the break,

2845
01:39:38,229 --> 01:39:41,779
memory in a computer is actually assigned in a somewhat deliberate fashion.

2846
01:39:42,069 --> 01:39:44,229
And generally if we think of this rectangle

2847
01:39:44,229 --> 01:39:46,339
as representing my computer's whole chunk of memory,

2848
01:39:46,709 --> 01:39:49,629
generally what happens when you run a program with something

2849
01:39:49,629 --> 01:39:51,750
or on a Mac or PC by double clicking.

2850
01:39:51,865 --> 01:39:53,535
Or on a phone by single tapping,

2851
01:39:53,694 --> 01:39:58,134
what happens is all of the zeros and ones that were compiled by the company

2852
01:39:58,134 --> 01:40:02,015
or person who made that program are loaded into the top of the computer's memory,

2853
01:40:02,095 --> 01:40:02,564
so to speak.

2854
01:40:02,694 --> 01:40:03,694
This is just an artist's rendition.

2855
01:40:03,734 --> 01:40:05,254
There's no notion of top or bottom per se,

2856
01:40:05,455 --> 01:40:09,205
but it's loaded into this chunk of memory at the very edge of the computer's memory,

2857
01:40:09,375 --> 01:40:10,375
AKA machine code.

2858
01:40:10,455 --> 01:40:12,685
The zeros and ones that compose the actual program,

2859
01:40:12,814 --> 01:40:13,845
that's where they go.

2860
01:40:13,964 --> 01:40:15,895
So they're copied from the hard drive or the SS.

2861
01:40:16,359 --> 01:40:18,339
whatever you know it as the persistent storage,

2862
01:40:18,479 --> 01:40:21,200
and it's put there in the computer's RAM or random access memory,

2863
01:40:21,240 --> 01:40:23,669
which is the faster memory where programs and files live

2864
01:40:23,919 --> 01:40:25,109
while you are using them.

2865
01:40:25,479 --> 01:40:26,029
Meanwhile,

2866
01:40:26,200 --> 01:40:29,950
if your program or the program you're using has any global variables,

2867
01:40:30,040 --> 01:40:32,589
global in the sense that they're defined outside of Maine

2868
01:40:32,589 --> 01:40:35,270
and not inside of Maine or inside of other functions,

2869
01:40:35,439 --> 01:40:37,439
they end up right below that machine code

2870
01:40:37,439 --> 01:40:39,790
by convention just so they're accessible everywhere.

2871
01:40:40,205 --> 01:40:40,814
Meanwhile,

2872
01:40:40,984 --> 01:40:43,754
there's this big chunk of memory below that called the heap.

2873
01:40:44,024 --> 01:40:48,825
The heap is the chunk of memory that Mao uses to allocate memory for you.

2874
01:40:48,915 --> 01:40:50,145
So the first time you call Mao,

2875
01:40:50,424 --> 01:40:52,095
it's going to give you probably this chunk of memory.

2876
01:40:52,104 --> 01:40:52,654
The second time,

2877
01:40:52,665 --> 01:40:53,064
this chunk,

2878
01:40:53,145 --> 01:40:53,595
the 3rd time,

2879
01:40:53,625 --> 01:40:53,995
this chunk,

2880
01:40:54,004 --> 01:40:54,475
and this chunk,

2881
01:40:54,484 --> 01:40:55,134
and so forth,

2882
01:40:55,345 --> 01:40:56,665
back to back to back in memory.

2883
01:40:56,705 --> 01:40:58,854
But Malloch is going to manage all of that for you.

2884
01:40:58,984 --> 01:41:00,634
You don't have to worry about where it's coming from,

2885
01:41:00,705 --> 01:41:04,024
but it's coming more generally from this big heap area.

2886
01:41:04,729 --> 01:41:08,279
But it turns out that the way computers are designed is that

2887
01:41:08,500 --> 01:41:12,549
the heap of course sort of grows and therefore downward again even though there's no

2888
01:41:12,549 --> 01:41:15,970
notion of up down inside of the computer but it grows in this direction.

2889
01:41:16,310 --> 01:41:17,990
But it'd be nice to make use of this

2890
01:41:17,990 --> 01:41:21,009
other area of memory and that's what's called the stack

2891
01:41:21,270 --> 01:41:23,700
and the stack is the area of memory that's used

2892
01:41:23,700 --> 01:41:27,060
any time you create local variables or call functions.

2893
01:41:27,229 --> 01:41:27,740
So again,

2894
01:41:28,000 --> 01:41:29,910
Mao uses memory from up here

2895
01:41:30,270 --> 01:41:30,819
and

2896
01:41:31,109 --> 01:41:34,069
functions and variables use memory down here just because the.

2897
01:41:34,220 --> 01:41:37,799
What humans in a room decided years ago is how the computer's memory would be used.

2898
01:41:38,009 --> 01:41:38,250
Therefore,

2899
01:41:38,290 --> 01:41:39,970
the stack grows sort of vertically,

2900
01:41:40,209 --> 01:41:42,850
much like stacking trays in a cafeteria or the dining hall.

2901
01:41:42,890 --> 01:41:45,439
They go from bottom to top in this model.

2902
01:41:45,779 --> 01:41:46,120
All right,

2903
01:41:46,410 --> 01:41:46,459
well,

2904
01:41:46,490 --> 01:41:48,330
let's consider for the moment just how the stack is

2905
01:41:48,330 --> 01:41:50,410
used because we're using a main function in this program.

2906
01:41:50,490 --> 01:41:52,200
We're using a swap function in this program,

2907
01:41:52,290 --> 01:41:55,640
so I claim that those functions are going to use memory down here.

2908
01:41:55,930 --> 01:41:56,009
Well,

2909
01:41:56,129 --> 01:42:01,359
how are they going to use it and how is this in fact bad for our current goal?

2910
01:42:01,609 --> 01:42:01,959
Well,

2911
01:42:02,129 --> 01:42:03,979
when you call the main function.

2912
01:42:04,189 --> 01:42:06,089
It uses this chunk of memory here,

2913
01:42:06,129 --> 01:42:07,830
specifically if Maine has any

2914
01:42:08,299 --> 01:42:11,620
arguments like command line arguments or if Maine has any local variables,

2915
01:42:11,740 --> 01:42:13,649
they end up down here in memory.

2916
01:42:13,899 --> 01:42:14,259
Meanwhile,

2917
01:42:14,339 --> 01:42:15,500
when Maine calls swap,

2918
01:42:15,620 --> 01:42:18,160
swap gets the next available chunk of memory above it,

2919
01:42:18,220 --> 01:42:18,689
so to speak,

2920
01:42:18,740 --> 01:42:19,370
in memory,

2921
01:42:19,500 --> 01:42:22,490
and any of its arguments or local variables end up there.

2922
01:42:23,100 --> 01:42:23,549
So

2923
01:42:23,859 --> 01:42:24,100
when,

2924
01:42:24,660 --> 01:42:26,020
when Swap is done executing,

2925
01:42:26,140 --> 01:42:28,220
it's as though that memory disappears even though

2926
01:42:28,220 --> 01:42:29,609
the zeros and ones are still there,

2927
01:42:29,779 --> 01:42:30,979
but the computer can now reuse.

2928
01:42:31,060 --> 01:42:34,490
That same chunk of memory later ergo garbage values when

2929
01:42:34,490 --> 01:42:37,359
functions are being called going up and down conceptually,

2930
01:42:37,529 --> 01:42:40,529
that's why you're getting remnants of previous values in the computer's memory.

2931
01:42:40,729 --> 01:42:42,200
But let's focus on main for a moment.

2932
01:42:42,290 --> 01:42:43,330
In Maine in this program,

2933
01:42:43,410 --> 01:42:47,439
recall that I declared two variables X and Y X getting the value 1,

2934
01:42:47,649 --> 01:42:50,439
Y getting the value 2 per these two lines of code.

2935
01:42:50,649 --> 01:42:52,279
Then I called the swap function.

2936
01:42:52,450 --> 01:42:55,160
So swap is going to get its own chunk of memory,

2937
01:42:55,310 --> 01:42:57,810
more technically called a frame of memory.

2938
01:42:58,069 --> 01:43:03,020
And inside of that frame it has two arguments A and B and a local variable called temp.

2939
01:43:03,100 --> 01:43:04,529
So I'll draw them as such.

2940
01:43:04,899 --> 01:43:06,450
When you actually call swap,

2941
01:43:06,620 --> 01:43:07,700
passing in X and Y,

2942
01:43:07,779 --> 01:43:09,839
X and Y are passed in by value,

2943
01:43:09,939 --> 01:43:11,450
that is to say copy.

2944
01:43:11,859 --> 01:43:15,850
So A becomes a copy of X and B becomes a copy of Y.

2945
01:43:16,100 --> 01:43:17,299
So when this line of code.

2946
01:43:17,790 --> 01:43:20,990
Or rather this prototype for swap just makes clear

2947
01:43:20,990 --> 01:43:22,770
that it takes two arguments A and B,

2948
01:43:22,830 --> 01:43:24,700
both of which are integers in that same order.

2949
01:43:24,870 --> 01:43:25,379
So X.

2950
01:43:25,640 --> 01:43:26,100
Y

2951
01:43:26,879 --> 01:43:28,520
lines up with a B.

2952
01:43:28,830 --> 01:43:34,959
So what happens then inside of the swap function if A is a copy of X and B is a copy of Y?

2953
01:43:35,129 --> 01:43:35,399
Well,

2954
01:43:35,509 --> 01:43:37,939
at the moment it's equal to 1 and 2 respectively,

2955
01:43:38,149 --> 01:43:38,580
but

2956
01:43:38,990 --> 01:43:42,020
consider this first line of code in temp gets A.

2957
01:43:42,270 --> 01:43:44,189
So temp takes on the value of a.

2958
01:43:44,930 --> 01:43:46,839
Next line of code A gets B.

2959
01:43:47,089 --> 01:43:50,160
So A gets the value of B,

2960
01:43:50,529 --> 01:43:50,669
sorry,

2961
01:43:50,729 --> 01:43:51,600
which just happened.

2962
01:43:51,890 --> 01:43:52,500
Meanwhile,

2963
01:43:52,810 --> 01:43:54,279
B gets the value of temp,

2964
01:43:54,810 --> 01:43:55,620
so B

2965
01:43:55,890 --> 01:43:56,930
gets the value of T.

2966
01:43:57,209 --> 01:43:58,729
Now temp still has a copy of one,

2967
01:43:58,770 --> 01:44:01,089
so it's not quite analogous to the liquid

2968
01:44:01,089 --> 01:44:03,359
because we're that glass is clearly now empty,

2969
01:44:03,609 --> 01:44:05,930
but it does contain remnants of what it once did.

2970
01:44:06,009 --> 01:44:09,290
But the key here is that A and B have successfully been swapped.

2971
01:44:09,799 --> 01:44:12,160
If I were to print out A and B,

2972
01:44:12,250 --> 01:44:14,000
I would see that they've been swapped.

2973
01:44:14,169 --> 01:44:16,399
But what has obviously not been swapped in this story,

2974
01:44:16,689 --> 01:44:20,529
no one has touched X or Y because when swap returns,

2975
01:44:20,770 --> 01:44:23,029
especially if I don't even print out anything in swap,

2976
01:44:23,250 --> 01:44:24,259
X and Y

2977
01:44:24,569 --> 01:44:25,560
are unchanged.

2978
01:44:25,689 --> 01:44:26,450
So A and B,

2979
01:44:26,490 --> 01:44:27,879
the copies were swapped

2980
01:44:28,250 --> 01:44:29,609
but not the original values,

2981
01:44:29,620 --> 01:44:32,020
and that's the essence of the problem here with this

2982
01:44:32,209 --> 01:44:37,200
this simple example of swapping values because I was passing by value.

2983
01:44:37,370 --> 01:44:38,770
But as of today we now.

2984
01:44:38,904 --> 01:44:41,854
Have a solution to this problem because previously to today if

2985
01:44:41,854 --> 01:44:44,004
I asked you to write a function that swaps two values,

2986
01:44:44,095 --> 01:44:46,294
you could not physically do it in code because you

2987
01:44:46,294 --> 01:44:48,884
had no way of expressing the solution to this problem.

2988
01:44:49,055 --> 01:44:50,935
But now we have the ability to pass by reference,

2989
01:44:50,975 --> 01:44:55,044
that is use pointers and addresses more generally to tell the function

2990
01:44:55,174 --> 01:44:57,334
how to go to an address and do something there,

2991
01:44:57,415 --> 01:44:59,705
how to go to another address and do something there.

2992
01:44:59,935 --> 01:45:01,645
How do I express this syntactically?

2993
01:45:01,984 --> 01:45:03,535
It's going to look a little scary at first glance,

2994
01:45:03,615 --> 01:45:06,375
but it's just an application of today's new building blocks.

2995
01:45:06,495 --> 01:45:08,044
This bad version of the program.

2996
01:45:08,490 --> 01:45:12,080
Where A and B are both integers just needs to change

2997
01:45:12,410 --> 01:45:13,040
to be

2998
01:45:13,479 --> 01:45:15,009
addresses of integers.

2999
01:45:15,169 --> 01:45:20,129
So give the function a sort of treasure map that leads it to the actual X and Y by

3000
01:45:20,129 --> 01:45:23,330
saying that A is now not going to be an in per se but the address of an N.

3001
01:45:23,729 --> 01:45:26,759
B is going to be the address of an in and now to use those

3002
01:45:26,759 --> 01:45:32,609
values you can say the following in temp gets whatever is at location A.

3003
01:45:33,740 --> 01:45:36,770
Go to location A and put whatever's at location B.

3004
01:45:37,339 --> 01:45:40,330
Go to location B and put in the temp value.

3005
01:45:40,500 --> 01:45:44,250
And here is a perfect example of where this use and overuse

3006
01:45:44,250 --> 01:45:47,770
of the star or asterisk operator is just like cognitively confusing,

3007
01:45:47,779 --> 01:45:48,100
frankly,

3008
01:45:48,220 --> 01:45:49,959
because we use star for multiplication,

3009
01:45:50,060 --> 01:45:51,370
we use it for declaring a pointer,

3010
01:45:51,379 --> 01:45:53,509
we use it for de-referencing a pointer ideally.

3011
01:45:53,654 --> 01:45:55,564
Years ago would have come up with another symbol on

3012
01:45:55,564 --> 01:45:58,444
the US English keyboard to represent these different ideas,

3013
01:45:58,524 --> 01:45:59,805
but this is where we're at.

3014
01:45:59,964 --> 01:46:02,725
We're using the star for different things in different contexts.

3015
01:46:02,845 --> 01:46:04,634
So this just tells the computer

3016
01:46:04,845 --> 01:46:07,484
that A is going to be a pointer an address of an ant.

3017
01:46:07,765 --> 01:46:10,084
This tells the computer that B is going to be the address of an ant.

3018
01:46:10,899 --> 01:46:11,770
This star,

3019
01:46:12,060 --> 01:46:15,410
when there's no data type to the left of it means go to that address,

3020
01:46:15,660 --> 01:46:17,850
as does every other example

3021
01:46:18,140 --> 01:46:18,640
thereof.

3022
01:46:19,169 --> 01:46:22,259
So what's happening this time if we actually look at the diagram again,

3023
01:46:22,339 --> 01:46:24,129
X and Y are still 1 and 2 respectively.

3024
01:46:24,259 --> 01:46:25,290
Swap gets called,

3025
01:46:25,459 --> 01:46:27,709
it gets now the values

3026
01:46:28,100 --> 01:46:29,649
of the address of X

3027
01:46:29,979 --> 01:46:30,939
and the address of.

3028
01:46:31,500 --> 01:46:35,529
So pictorally we might draw that as following A is pointing to X,

3029
01:46:35,779 --> 01:46:37,020
B is pointing to 2.

3030
01:46:37,060 --> 01:46:40,049
I mean technically it's like OX 123 and OX12 whatever,

3031
01:46:40,299 --> 01:46:40,859
but who cares?

3032
01:46:40,899 --> 01:46:44,529
We're just going to abstract it away now with actual arrows or pointers.

3033
01:46:44,740 --> 01:46:47,609
The beauty of this now then is if we look at the swap function,

3034
01:46:47,859 --> 01:46:49,819
in temp gets star A.

3035
01:46:49,979 --> 01:46:52,580
That means started A and Go there sort of shoots and

3036
01:46:52,580 --> 01:46:55,959
ladder style familiar with the game and you find the value 1

3037
01:46:56,259 --> 01:46:59,529
so you put the value 1 inside of temp which is why it's there now.

3038
01:46:59,979 --> 01:47:00,339
Meanwhile,

3039
01:47:00,379 --> 01:47:02,859
this next line of code go to A's address,

3040
01:47:02,979 --> 01:47:05,689
go to B's address and copy the latter to the former.

3041
01:47:05,939 --> 01:47:07,720
So this means go to A,

3042
01:47:07,979 --> 01:47:09,410
this means go to B,

3043
01:47:09,740 --> 01:47:10,750
where you find the 2,

3044
01:47:10,859 --> 01:47:11,819
so put the 2.

3045
01:47:12,560 --> 01:47:13,569
Where A is pointing.

3046
01:47:13,720 --> 01:47:14,350
Lastly,

3047
01:47:14,609 --> 01:47:16,410
go to B and put temp there so that's easy.

3048
01:47:16,640 --> 01:47:17,310
Go to B

3049
01:47:17,520 --> 01:47:18,359
and point temp,

3050
01:47:18,520 --> 01:47:19,839
which is why we now have the 1.

3051
01:47:20,060 --> 01:47:23,589
And the beauty of this now is that when swap is done executing,

3052
01:47:23,799 --> 01:47:24,359
this memory,

3053
01:47:24,399 --> 01:47:26,950
this frame sort of goes away conceptually,

3054
01:47:26,959 --> 01:47:28,589
even though the zeros and ones are still there,

3055
01:47:28,680 --> 01:47:30,149
but it's done being used,

3056
01:47:30,160 --> 01:47:32,529
but we have now mutated the actual values

3057
01:47:32,919 --> 01:47:37,879
of X and Y by giving them a proverbial treasure map of the addresses of X and Y,

3058
01:47:38,359 --> 01:47:40,870
not copies of the values themselves.

3059
01:47:42,600 --> 01:47:45,000
So hopefully this is the beginning of an answer to like why is

3060
01:47:45,000 --> 01:47:49,069
this stuff useful you can now solve a whole new class of problems

3061
01:47:49,319 --> 01:47:50,350
and even more next week.

3062
01:47:50,439 --> 01:47:51,799
Other questions

3063
01:47:52,220 --> 01:47:53,200
they want to need the syntax,

3064
01:47:53,279 --> 01:47:54,430
pictures or the like.

3065
01:47:57,500 --> 01:47:59,830
This is good use of pointers now instead of bad.

3066
01:48:00,149 --> 01:48:00,390
All right,

3067
01:48:00,629 --> 01:48:03,540
so with that new capability,

3068
01:48:04,149 --> 01:48:04,859
let us

3069
01:48:05,149 --> 01:48:06,459
consider here.

3070
01:48:08,470 --> 01:48:09,100
How

3071
01:48:09,350 --> 01:48:14,279
things can still go wrong and why indeed with this power comes that responsibility.

3072
01:48:14,310 --> 01:48:14,620
Well,

3073
01:48:14,830 --> 01:48:16,859
if you consider now the bad version of the code

3074
01:48:16,859 --> 01:48:18,910
is fixable via this good version of the code,

3075
01:48:18,990 --> 01:48:22,220
we've still left a big glaring problem in the diagram itself,

3076
01:48:22,589 --> 01:48:25,790
designing something that grows this way against something that grows this way,

3077
01:48:25,830 --> 01:48:27,109
like this is not going to end well.

3078
01:48:27,189 --> 01:48:27,419
Why?

3079
01:48:27,589 --> 01:48:28,640
Because the more you call Mao,

3080
01:48:28,950 --> 01:48:30,149
the more memory that gets used here.

3081
01:48:30,444 --> 01:48:31,825
The more functions you call,

3082
01:48:31,984 --> 01:48:33,214
the more memory that gets used here,

3083
01:48:33,225 --> 01:48:33,935
and at some point,

3084
01:48:34,064 --> 01:48:37,854
like they will collide because the computer only has a finite amount of memory.

3085
01:48:38,345 --> 01:48:40,285
So how do you avoid this situation?

3086
01:48:40,575 --> 01:48:41,654
Like you kind of don't.

3087
01:48:41,745 --> 01:48:44,185
Like you honestly just make sure that you minimize how

3088
01:48:44,185 --> 01:48:46,625
much memory you're using by calling Malock only as much

3089
01:48:46,625 --> 01:48:48,584
as you need to and not calling for a million

3090
01:48:48,584 --> 01:48:50,404
bytes of memory just because you might need them.

3091
01:48:50,464 --> 01:48:52,145
You only allocate what memory you need.

3092
01:48:52,419 --> 01:48:55,140
And you try not to call functions again and again and

3093
01:48:55,140 --> 01:48:57,859
again and again and again and again without them finally returning.

3094
01:48:57,930 --> 01:49:01,089
So if you ever did something recursive a couple of weeks ago where

3095
01:49:01,089 --> 01:49:04,560
you accidentally maybe called a function that never had a base case,

3096
01:49:04,850 --> 01:49:07,279
never divided and conquered and actually shrunk the problem,

3097
01:49:07,490 --> 01:49:08,160
you could

3098
01:49:08,450 --> 01:49:11,520
overflow the stack or equivalently heap

3099
01:49:11,930 --> 01:49:14,759
by just using too many frames of memory.

3100
01:49:14,899 --> 01:49:15,569
So it's just a mistake.

3101
01:49:15,812 --> 01:49:18,283
in the programmer for the programmers themselves.

3102
01:49:18,453 --> 01:49:19,973
So if you've ever heard these phrases now,

3103
01:49:20,033 --> 01:49:22,573
which some of you might have heap overflow or stack overflow,

3104
01:49:22,772 --> 01:49:25,013
there's a very popular website called Stack Overflow,

3105
01:49:25,083 --> 01:49:27,252
and this is the etymology thereof like Stack Overflow

3106
01:49:27,252 --> 01:49:32,022
refers to this representative big problem with computers' memories if

3107
01:49:32,413 --> 01:49:35,692
you're not mindful of how you're using the computer's memory,

3108
01:49:35,732 --> 01:49:38,933
and this is just the way it is if you've got finite amount.

3109
01:49:39,065 --> 01:49:41,846
Of anything that resource can eventually run out,

3110
01:49:42,056 --> 01:49:45,846
at which point the program will crash or something else might very well go wrong.

3111
01:49:46,016 --> 01:49:46,295
In fact,

3112
01:49:46,315 --> 01:49:47,246
this is a general,

3113
01:49:47,335 --> 01:49:50,295
more specific examples of what are called buffer overflows.

3114
01:49:50,416 --> 01:49:54,125
A buffer overflow is generally just a chunk of memory like an array

3115
01:49:54,375 --> 01:49:59,416
that actually just gets overflowed with too many values like using allocating

3116
01:49:59,416 --> 01:50:02,255
a small array and trying to put too many numbers therein.

3117
01:50:02,529 --> 01:50:03,979
There's problems that,

3118
01:50:04,069 --> 01:50:04,149
um,

3119
01:50:04,270 --> 01:50:06,370
and in fact you can see this very simply if

3120
01:50:06,370 --> 01:50:08,109
we take off those last of our training wheels.

3121
01:50:08,149 --> 01:50:08,629
So for instance,

3122
01:50:08,709 --> 01:50:10,959
these are the functions in the CS 50 library,

3123
01:50:11,109 --> 01:50:11,430
get in,

3124
01:50:11,509 --> 01:50:12,029
get string,

3125
01:50:12,069 --> 01:50:12,819
and so forth,

3126
01:50:13,319 --> 01:50:13,500
um,

3127
01:50:13,830 --> 01:50:16,109
they're harder to take off these training

3128
01:50:16,109 --> 01:50:18,020
it's harder to take off these training wheels

3129
01:50:18,549 --> 01:50:23,180
because C does not fundamentally make it that easy to manage memory

3130
01:50:23,790 --> 01:50:24,350
yourself so.

3131
01:50:24,484 --> 01:50:25,035
For instance,

3132
01:50:25,154 --> 01:50:27,115
let's focus for just a moment on get in.

3133
01:50:27,354 --> 01:50:28,595
I'm going to go over to

3134
01:50:28,955 --> 01:50:30,665
VS code here in just a second,

3135
01:50:30,875 --> 01:50:33,354
and let's go ahead and create our very simple program called

3136
01:50:33,354 --> 01:50:36,115
Get.c whose purpose in life is to just get an integer,

3137
01:50:36,194 --> 01:50:37,794
much like CS 50's own function.

3138
01:50:37,955 --> 01:50:39,154
So in get.C,

3139
01:50:39,595 --> 01:50:40,504
I'm going to propose

3140
01:50:40,794 --> 01:50:44,345
that we write a program that does a little something

3141
01:50:45,075 --> 01:50:46,145
like this,

3142
01:50:47,404 --> 01:50:47,424
uh,

3143
01:50:47,435 --> 01:50:48,584
include CS50.

3144
01:50:48,834 --> 01:50:49,384
H,

3145
01:50:50,035 --> 01:50:51,884
include standardio.h,

3146
01:50:51,995 --> 01:50:53,595
and then inside of Maine.

3147
01:50:54,060 --> 01:50:56,569
Let's go ahead and declare an inn,

3148
01:50:57,540 --> 01:50:58,979
set it equal to get in,

3149
01:50:59,060 --> 01:51:01,209
and we'll just ask the user for the value of N.

3150
01:51:01,500 --> 01:51:03,169
Then let's go ahead and print out

3151
01:51:03,500 --> 01:51:07,879
N's value verbatim back by just doing quote unquote N.

3152
01:51:09,339 --> 01:51:11,779
This program is simply using the get in function or in

3153
01:51:11,779 --> 01:51:13,259
order to get it in and store it in N.

3154
01:51:13,379 --> 01:51:14,169
So let's run it,

3155
01:51:14,339 --> 01:51:15,770
make get.get,

3156
01:51:15,939 --> 01:51:17,339
type in a number like 50

3157
01:51:17,779 --> 01:51:18,330
seems to work.

3158
01:51:18,379 --> 01:51:18,890
And yes,

3159
01:51:18,979 --> 01:51:20,209
I think this program is correct,

3160
01:51:20,290 --> 01:51:23,339
even though it is using the CS50 training wheel of get in.

3161
01:51:23,890 --> 01:51:25,839
Let's stop using GetI though.

3162
01:51:25,970 --> 01:51:27,689
It turns out that you don't have to use

3163
01:51:27,689 --> 01:51:30,520
GetI if you instead use a function called scanF,

3164
01:51:30,729 --> 01:51:32,189
which scans formatted input,

3165
01:51:32,209 --> 01:51:35,729
which just means read something from the keyboard into memory.

3166
01:51:36,000 --> 01:51:37,810
This is essentially what

3167
01:51:38,109 --> 01:51:40,080
get string and get into using,

3168
01:51:40,149 --> 01:51:42,270
although that too is a bit of an oversimplification,

3169
01:51:42,310 --> 01:51:43,200
but let's use it.

3170
01:51:43,620 --> 01:51:44,259
Here now

3171
01:51:44,549 --> 01:51:48,839
is an opportunity to get rid of the training wheel of the CS 50 library altogether

3172
01:51:49,109 --> 01:51:49,819
and down here,

3173
01:51:49,870 --> 01:51:50,549
let's do this.

3174
01:51:50,569 --> 01:51:51,790
Instead of using get in,

3175
01:51:51,870 --> 01:51:55,220
let's declare a variable N but not give it a value yet.

3176
01:51:55,509 --> 01:51:57,140
Let's now print out

3177
01:51:57,390 --> 01:51:59,720
just a little prompt just to tell the human what we want.

3178
01:51:59,790 --> 01:52:01,950
We want them to type in a value for N.

3179
01:52:02,370 --> 01:52:04,140
And now let's use this new function called

3180
01:52:04,140 --> 01:52:07,040
scanF and say scan from the user's keyboard in

3181
01:52:07,270 --> 01:52:08,100
integer,

3182
01:52:08,629 --> 01:52:09,819
represented by percent I,

3183
01:52:09,830 --> 01:52:11,740
our old friend and format code,

3184
01:52:12,109 --> 01:52:15,509
and please put the integer that the human types in.

3185
01:52:17,009 --> 01:52:19,020
In the variable n.

3186
01:52:19,790 --> 01:52:21,209
This is slightly buggy though,

3187
01:52:21,540 --> 01:52:24,100
because if I want a function like scanF to be able to

3188
01:52:24,100 --> 01:52:27,290
change the value of a variable just like the swap function,

3189
01:52:27,620 --> 01:52:30,700
I can't just pass in N.

3190
01:52:31,140 --> 01:52:34,609
I need to pass in the address of N here.

3191
01:52:34,859 --> 01:52:35,410
In fact,

3192
01:52:35,580 --> 01:52:36,930
let's take a moment now

3193
01:52:37,180 --> 01:52:38,299
to go into.

3194
01:52:38,620 --> 01:52:39,569
The swap function,

3195
01:52:39,580 --> 01:52:42,169
which we knew to be buggy before and actually

3196
01:52:42,169 --> 01:52:43,850
updated to match what we saw on the slides.

3197
01:52:44,009 --> 01:52:46,609
I claim that the problem is that we're passing in originally

3198
01:52:46,609 --> 01:52:49,399
X and Y is 1 and 2 into the swap function,

3199
01:52:49,569 --> 01:52:51,439
but therefore we're passing in copies.

3200
01:52:51,649 --> 01:52:54,129
But what if we change the swap function to take indeed

3201
01:52:54,129 --> 01:52:56,169
the address of an N and the address of an in?

3202
01:52:56,569 --> 01:53:00,359
Let me change my prototype accordingly because that too must be changed.

3203
01:53:00,689 --> 01:53:02,080
Then when I

3204
01:53:02,410 --> 01:53:06,000
change this function to take in those pointers,

3205
01:53:06,129 --> 01:53:08,250
I need to change my code to de-reference them.

3206
01:53:08,629 --> 01:53:10,470
But there's one last thing I need to do.

3207
01:53:10,640 --> 01:53:13,439
I'm still on this line of swap passing in X and Y,

3208
01:53:13,520 --> 01:53:15,910
which is literally the values X and Y.

3209
01:53:16,120 --> 01:53:18,669
If I want to pass in the address of X and the address of Y,

3210
01:53:18,720 --> 01:53:20,310
what other operator do I now need?

3211
01:53:22,609 --> 01:53:26,500
The ampersand X and the ampersand Y

3212
01:53:26,680 --> 01:53:28,859
to pass in sort of the treasure map,

3213
01:53:28,879 --> 01:53:29,990
the pointer to

3214
01:53:30,319 --> 01:53:32,120
those two variables locations.

3215
01:53:32,200 --> 01:53:33,950
So if I open up my terminal window now,

3216
01:53:34,160 --> 01:53:37,160
do make swap on this version swap,

3217
01:53:37,200 --> 01:53:38,149
cross my fingers,

3218
01:53:38,439 --> 01:53:43,279
now this new and improved version of swap as claimed does actually swap the values,

3219
01:53:43,319 --> 01:53:47,279
the key being swap now has access not to X and Y per se,

3220
01:53:47,520 --> 01:53:50,319
but to the addresses of X and Y.

3221
01:53:50,770 --> 01:53:53,759
So if we now close out swap and go back to get

3222
01:53:54,089 --> 01:53:56,370
here is the same principle applied to ScanF.

3223
01:53:56,410 --> 01:53:58,890
If ScanF exists and it comes with C,

3224
01:53:59,129 --> 01:54:01,209
its purpose in life is to scan an integer

3225
01:54:01,209 --> 01:54:03,399
from the keyboard and put it somewhere you want.

3226
01:54:03,609 --> 01:54:05,569
You can't just give it the variable name because it's going

3227
01:54:05,569 --> 01:54:08,319
to get a copy of whatever garbage value is in there.

3228
01:54:08,490 --> 01:54:09,399
You have to say

3229
01:54:09,729 --> 01:54:12,419
put this answer in the address

3230
01:54:12,729 --> 01:54:15,060
at the address of N itself.

3231
01:54:15,580 --> 01:54:16,399
So lastly,

3232
01:54:16,520 --> 01:54:16,810
after this,

3233
01:54:16,879 --> 01:54:20,910
let me go ahead and print out and colon and then percent I again as a format code

3234
01:54:22,740 --> 01:54:23,240
backslash NN.

3235
01:54:23,979 --> 01:54:25,740
This line is just my prompt because I just want

3236
01:54:25,740 --> 01:54:27,450
the human to know what they're being asked for.

3237
01:54:27,740 --> 01:54:31,140
This line is printing out and colon and the actual value.

3238
01:54:31,220 --> 01:54:35,220
So the only interesting part here is that I'm declaring a variable called N,

3239
01:54:35,259 --> 01:54:36,850
but I'm not giving it a value myself,

3240
01:54:37,060 --> 01:54:40,770
but I'm using scan F instead of get in to scan,

3241
01:54:40,819 --> 01:54:41,259
so to speak,

3242
01:54:41,270 --> 01:54:42,569
an integer from the keyboard

3243
01:54:42,740 --> 01:54:47,790
and put it at the address of N so that scanF has access to that value.

3244
01:54:48,350 --> 01:54:53,470
So if I now do make get without any CS 50 library.get,

3245
01:54:53,549 --> 01:54:55,009
let's type in the number 50.

3246
01:54:55,359 --> 01:54:57,399
I indeed see the number spit back at me.

3247
01:54:57,509 --> 01:54:58,430
And just to be clear,

3248
01:54:58,680 --> 01:55:01,709
printF uses these format codes of percent I and so forth.

3249
01:55:01,919 --> 01:55:04,120
ScanF uses essentially the same format code.

3250
01:55:04,240 --> 01:55:06,080
So that's why I'm using percent I in both places,

3251
01:55:06,160 --> 01:55:09,759
both functions for their documentation are designed to do just that.

3252
01:55:10,140 --> 01:55:10,950
So this is great.

3253
01:55:11,089 --> 01:55:12,370
We've gotten rid of get in.

3254
01:55:13,009 --> 01:55:15,209
Catch is that getting rid of get string is much,

3255
01:55:15,370 --> 01:55:16,120
much harder.

3256
01:55:16,290 --> 01:55:16,569
Why?

3257
01:55:16,649 --> 01:55:16,700
Well,

3258
01:55:16,770 --> 01:55:18,520
let's try another example.

3259
01:55:18,810 --> 01:55:22,270
Let's go ahead and try to get a string from the user instead of just an inch.

3260
01:55:22,330 --> 01:55:23,600
So we'll call it strings,

3261
01:55:23,609 --> 01:55:24,319
but wait a minute.

3262
01:55:24,680 --> 01:55:26,609
CS 50 library is not included,

3263
01:55:26,680 --> 01:55:28,729
so we need to use the actual thing that this is.

3264
01:55:28,810 --> 01:55:31,979
So chartar S means give me a variable that's going to store

3265
01:55:32,290 --> 01:55:32,959
a string.

3266
01:55:33,169 --> 01:55:36,009
Let's go ahead and print out that prompt just to prompt the user for S.

3267
01:55:36,620 --> 01:55:37,569
Just for clarity,

3268
01:55:37,819 --> 01:55:40,589
now let's use scan F and scan a

3269
01:55:40,810 --> 01:55:44,810
string with percent S and put it at location S.

3270
01:55:45,180 --> 01:55:47,620
Then let's go ahead and print out just a reminder that

3271
01:55:47,620 --> 01:55:50,379
the value of S is now that passing in S.

3272
01:55:50,700 --> 01:55:52,689
Now there's something a little bit different here.

3273
01:55:53,100 --> 01:55:58,120
Notice that I've deliberately not used an ampersand before this S Y,

3274
01:55:58,859 --> 01:56:00,750
even though I did before the N,

3275
01:56:00,979 --> 01:56:01,259
yeah.

3276
01:56:03,229 --> 01:56:04,129
the first character.

3277
01:56:06,600 --> 01:56:06,799
Yeah,

3278
01:56:07,000 --> 01:56:09,919
so I want to pass in the address of the string,

3279
01:56:10,080 --> 01:56:10,410
which is,

3280
01:56:10,439 --> 01:56:10,830
if I may,

3281
01:56:10,899 --> 01:56:12,000
like already S.

3282
01:56:12,160 --> 01:56:16,509
like S is by definition the address of some string that is what a charge star is,

3283
01:56:16,680 --> 01:56:18,709
or rather it's the address of a character,

3284
01:56:18,879 --> 01:56:21,390
but we know already that if you lead it to the first character,

3285
01:56:21,810 --> 01:56:24,509
whatever function can find the end of it thanks to the null character,

3286
01:56:24,939 --> 01:56:25,720
except that.

3287
01:56:26,040 --> 01:56:27,580
That's not going to be wholly true here,

3288
01:56:27,750 --> 01:56:30,660
but I don't want to do Ampersand here because if S is an address,

3289
01:56:30,870 --> 01:56:33,109
doing Ampersand S would be the address of an address,

3290
01:56:33,220 --> 01:56:35,540
which is actually a thing called a pointer to a pointer,

3291
01:56:35,750 --> 01:56:37,020
but none of that today.

3292
01:56:37,450 --> 01:56:39,790
But it's going to be correct as written here.

3293
01:56:40,140 --> 01:56:41,000
N was an integer,

3294
01:56:41,040 --> 01:56:42,270
so I needed the address of it.

3295
01:56:42,479 --> 01:56:44,229
S is already a pointer.

3296
01:56:44,399 --> 01:56:45,200
By definition,

3297
01:56:45,209 --> 01:56:46,229
it's a charge star,

3298
01:56:46,479 --> 01:56:48,229
so I don't use the ampersand here.

3299
01:56:48,520 --> 01:56:56,120
The problem is this If I now do make getget and let's type in a word like about high.

3300
01:56:57,100 --> 01:56:57,359
OK,

3301
01:56:57,399 --> 01:56:58,220
it did work.

3302
01:56:58,439 --> 01:57:00,350
Let me try something even bigger,

3303
01:57:00,439 --> 01:57:00,990
like,

3304
01:57:01,520 --> 01:57:02,189
hi,

3305
01:57:02,419 --> 01:57:04,350
let's just hold this down a lot.

3306
01:57:04,600 --> 01:57:04,759
Uh,

3307
01:57:04,839 --> 01:57:05,470
let's do,

3308
01:57:05,479 --> 01:57:06,629
how about this,

3309
01:57:07,319 --> 01:57:08,399
really long string,

3310
01:57:08,560 --> 01:57:09,080
oh come on.

3311
01:57:10,870 --> 01:57:13,160
Let's type in a really long string.

3312
01:57:15,089 --> 01:57:16,580
Hi.

3313
01:57:18,700 --> 01:57:20,759
And it's always a gamble to see if I've done this long enough,

3314
01:57:20,810 --> 01:57:21,209
but.

3315
01:57:22,270 --> 01:57:22,700
OK.

3316
01:57:23,419 --> 01:57:24,479
It didn't break.

3317
01:57:24,609 --> 01:57:25,040
OK,

3318
01:57:25,169 --> 01:57:26,640
you'd like to think that this is correct,

3319
01:57:26,850 --> 01:57:28,089
but let's go ahead and do this.

3320
01:57:28,129 --> 01:57:33,060
Valgrind of getge enter.

3321
01:57:33,370 --> 01:57:34,879
Let me maximize my screen.

3322
01:57:35,259 --> 01:57:35,500
Oh,

3323
01:57:35,970 --> 01:57:38,649
and let me go ahead and type in a value for S while Valgrind is running.

3324
01:57:38,689 --> 01:57:39,859
I'm going to type in high,

3325
01:57:41,250 --> 01:57:42,259
and now.

3326
01:57:42,859 --> 01:57:42,870
Well,

3327
01:57:44,049 --> 01:57:47,120
let's actually scroll down to the scroll up to the top of this.

3328
01:57:47,330 --> 01:57:49,870
A lot of error seems to have happened here.

3329
01:57:50,129 --> 01:57:52,970
Use of uninitialized value of size 8,

3330
01:57:53,009 --> 01:57:54,890
use of uninitialized value of size 8,

3331
01:57:54,930 --> 01:57:59,520
like a lot of stuff is going wrong here apparently on it looks like maybe line 4,

3332
01:57:59,609 --> 01:58:01,020
which is quite early in the program,

3333
01:58:01,049 --> 01:58:01,640
and in fact,

3334
01:58:01,810 --> 01:58:03,850
well actually that's not it line.

3335
01:58:05,430 --> 01:58:07,919
Multiple lines of code here we're having issues with,

3336
01:58:07,950 --> 01:58:08,649
but why?

3337
01:58:08,750 --> 01:58:08,790
Well,

3338
01:58:08,870 --> 01:58:11,180
let's focus on the code here alone for a moment.

3339
01:58:11,470 --> 01:58:12,899
Line 5 is giving me what?

3340
01:58:13,350 --> 01:58:14,430
A variable called S?

3341
01:58:14,549 --> 01:58:15,899
That's the address of a char,

3342
01:58:16,149 --> 01:58:17,740
but what is S right now?

3343
01:58:17,870 --> 01:58:19,379
Like what value is in there?

3344
01:58:20,899 --> 01:58:23,600
It's a garbage value because there's no equal sign involved.

3345
01:58:23,770 --> 01:58:25,129
I'm just saying give me space,

3346
01:58:25,169 --> 01:58:26,520
like give me 8 bytes,

3347
01:58:26,569 --> 01:58:29,040
64 bits to store the address of a character,

3348
01:58:29,129 --> 01:58:31,640
but if I don't use the equal sign and actually put anything there,

3349
01:58:31,970 --> 01:58:33,759
it is in fact just some garbage value.

3350
01:58:33,890 --> 01:58:34,970
The print F is uninteresting,

3351
01:58:35,009 --> 01:58:36,850
it's just printing out S colon scan.

3352
01:58:37,100 --> 01:58:37,910
Though is saying

3353
01:58:38,359 --> 01:58:42,669
go to this address and store the characters that the human typed in,

3354
01:58:42,879 --> 01:58:45,319
but that means like following the wiggly line that we drew on

3355
01:58:45,319 --> 01:58:47,799
the screen before because we have no idea where S is pointing.

3356
01:58:47,839 --> 01:58:48,470
It might be there,

3357
01:58:48,520 --> 01:58:48,680
there,

3358
01:58:48,799 --> 01:58:48,970
there,

3359
01:58:49,080 --> 01:58:49,470
there,

3360
01:58:49,680 --> 01:58:53,310
you're putting the string at a bogus location in memory.

3361
01:58:53,600 --> 01:58:55,520
You haven't actually allocated memory,

3362
01:58:55,560 --> 01:58:56,830
so when you then try to print it,

3363
01:58:56,919 --> 01:58:59,160
you're just trusting that you're going to memory again.

3364
01:58:59,549 --> 01:59:00,649
That you control.

3365
01:59:00,819 --> 01:59:02,180
So what is the solution here?

3366
01:59:02,259 --> 01:59:02,339
Well,

3367
01:59:02,419 --> 01:59:04,339
there's a few different ways we could solve this.

3368
01:59:04,419 --> 01:59:05,770
We could do something like this,

3369
01:59:06,140 --> 01:59:11,899
actually allocate space for like 4 bytes so that the human can safely type in.

3370
01:59:12,220 --> 01:59:12,229
Uh,

3371
01:59:13,569 --> 01:59:17,839
so the human can safely type in high with room for the null character.

3372
01:59:18,009 --> 01:59:21,569
We could changes to actually be an array of size 4 because we can

3373
01:59:21,569 --> 01:59:25,290
treat arrays as though they are addresses and addresses as though they are arrays.

3374
01:59:25,330 --> 01:59:28,160
It turns out that syntactic sugar really goes in both directions.

3375
01:59:28,250 --> 01:59:30,279
This too would solve that problem,

3376
01:59:30,450 --> 01:59:31,290
or better still,

3377
01:59:31,410 --> 01:59:33,569
we wouldn't use scanF at all because.

3378
01:59:33,709 --> 01:59:36,020
How do I know how many characters the human's going to type in?

3379
01:59:36,040 --> 01:59:38,129
Like this was a question two that came up during break.

3380
01:59:38,339 --> 01:59:38,470
Well,

3381
01:59:38,660 --> 01:59:41,529
hi will fit in 4 bytes with the null character.

3382
01:59:41,819 --> 01:59:43,009
by will not.

3383
01:59:43,379 --> 01:59:44,479
So maybe I need 5.

3384
01:59:44,540 --> 01:59:44,620
Well,

3385
01:59:44,700 --> 01:59:45,870
what if they type in a longer word?

3386
01:59:45,970 --> 01:59:46,490
6?

3387
01:59:46,540 --> 01:59:46,620
Well,

3388
01:59:46,660 --> 01:59:47,580
maybe the longer word,

3389
01:59:47,620 --> 01:59:47,939
7,

3390
01:59:48,020 --> 01:59:48,189
well,

3391
01:59:48,209 --> 01:59:52,689
maybe 100 or maybe 1000 or 10,000 or 100,000 or a million.

3392
01:59:52,700 --> 01:59:55,060
Like at some point you've got to draw a line in the sand.

3393
01:59:55,410 --> 01:59:57,720
And say you can't type in something longer than this,

3394
01:59:57,740 --> 01:59:59,689
and you see this in applications all the time like on the

3395
01:59:59,689 --> 02:00:02,520
web you can only type in so many characters sometimes into forms,

3396
02:00:02,560 --> 02:00:03,709
and that's for various reasons.

3397
02:00:03,750 --> 02:00:04,299
Among them

3398
02:00:04,600 --> 02:00:05,350
is this

3399
02:00:05,799 --> 02:00:10,600
Get string though will handle almost an infinite number of characters because the

3400
02:00:10,600 --> 02:00:13,950
way we implemented get string is to take baby steps through the input.

3401
02:00:14,160 --> 02:00:17,240
When you type in a word on the keyboard or even a paragraph on the keyboard,

3402
02:00:17,350 --> 02:00:20,680
we get strings implementers call Mao essentially a.

3403
02:00:20,833 --> 02:00:24,303
and again and again and again just asking for one more bite if we need it,

3404
02:00:24,382 --> 02:00:25,252
one more bite if we need it,

3405
02:00:25,263 --> 02:00:28,073
one more bite so that you don't have to worry about doing that.

3406
02:00:28,263 --> 02:00:30,342
The problem is if you were to write code yourself

3407
02:00:30,342 --> 02:00:33,573
without the CS 50 library or someone else's equivalent library,

3408
02:00:33,942 --> 02:00:37,542
you have to decide like how many bytes do you want to allow,

3409
02:00:37,583 --> 02:00:39,663
and you have to trust that the human is not going to

3410
02:00:39,663 --> 02:00:44,112
mess around and type in more values than you actually expect.

3411
02:00:44,382 --> 02:00:46,192
So what's happening with all of these examples.

3412
02:00:46,255 --> 02:00:47,155
Thus far is that

3413
02:00:47,445 --> 02:00:50,886
if you think of your memory as kind of a minefield of garbage values wasn't

3414
02:00:50,886 --> 02:00:55,076
a problem when we declared N to have a value of 50 because we told

3415
02:00:55,686 --> 02:00:58,925
ScanF to go to that address and put the number 50 there,

3416
02:00:58,965 --> 02:00:59,726
and it fits.

3417
02:00:59,806 --> 02:01:02,275
That's fine because an in is always 4 bytes in this case.

3418
02:01:02,445 --> 02:01:04,125
Who knows how many times the human is going

3419
02:01:04,125 --> 02:01:05,875
to hit the keyboard when typing in a string?

3420
02:01:06,045 --> 02:01:08,956
Could be 3 or 4 or a million or anything else.

3421
02:01:09,286 --> 02:01:09,695
So

3422
02:01:10,125 --> 02:01:11,565
when we declares here.

3423
02:01:11,979 --> 02:01:13,290
To be a pointer,

3424
02:01:13,299 --> 02:01:15,299
it takes up 8 bits for the Oscars to

3425
02:01:15,299 --> 02:01:19,419
the Oscars the grouch here whereby that's 8 garbage

3426
02:01:19,419 --> 02:01:22,910
values that collectively represent that address at the moment

3427
02:01:22,910 --> 02:01:24,930
because we've not assigned it to any other value.

3428
02:01:25,299 --> 02:01:27,410
So if we try to tell ScanF,

3429
02:01:27,660 --> 02:01:30,970
go to this address and store high or anything else there,

3430
02:01:31,140 --> 02:01:33,020
like who knows where it's going to end up in memory,

3431
02:01:33,100 --> 02:01:34,339
hence the squiggly line again.

3432
02:01:34,529 --> 02:01:35,870
And the program will quite

3433
02:01:36,040 --> 02:01:36,810
often crash.

3434
02:01:36,899 --> 02:01:39,020
I didn't get it because I didn't type in long enough of a string,

3435
02:01:39,080 --> 02:01:40,040
but it would eventually,

3436
02:01:40,080 --> 02:01:41,220
if I tried hard enough,

3437
02:01:41,640 --> 02:01:44,640
crash because you're touching memory that you yourself did not

3438
02:01:44,640 --> 02:01:49,509
allocate as an array via Mao or some other mechanism.

3439
02:01:49,680 --> 02:01:50,950
So what is the solution?

3440
02:01:51,359 --> 02:01:51,680
Honestly,

3441
02:01:51,779 --> 02:01:54,240
like don't use C for user input like

3442
02:01:54,240 --> 02:01:57,040
this unless you're prepared to implement that complexity.

3443
02:01:57,459 --> 02:01:59,540
use the CS 50 library or some other library.

3444
02:01:59,740 --> 02:02:02,459
This too is why in 2 weeks we're going to switch to Python because Python

3445
02:02:02,459 --> 02:02:07,330
makes life so much easier when it comes to basic things like getting user input,

3446
02:02:07,540 --> 02:02:09,350
as do many other modern languages,

3447
02:02:09,379 --> 02:02:09,740
but

3448
02:02:10,379 --> 02:02:13,020
those languages just have code that other humans

3449
02:02:13,020 --> 02:02:15,620
have written to solve these problems for you.

3450
02:02:15,629 --> 02:02:16,950
So these problems exist,

3451
02:02:17,180 --> 02:02:19,700
but they'll be abstracted away for you.

3452
02:02:20,540 --> 02:02:21,089
All right.

3453
02:02:21,290 --> 02:02:23,569
Let's tie this now together with where we began,

3454
02:02:23,649 --> 02:02:25,060
which was to convey

3455
02:02:25,379 --> 02:02:26,160
ultimately

3456
02:02:26,500 --> 02:02:28,370
that we want to have

3457
02:02:29,009 --> 02:02:29,169
Uh,

3458
02:02:29,240 --> 02:02:31,529
the ability now to actually access files,

3459
02:02:31,569 --> 02:02:35,459
and we introduce now a topic called FiO IO for input and output.

3460
02:02:35,689 --> 02:02:38,200
A file is just a bunch of bytes that are stored on disk,

3461
02:02:38,250 --> 02:02:39,680
where disc might mean a hard drive,

3462
02:02:39,729 --> 02:02:42,520
the thing that spins around with a platter with lots of zeros and ones on it,

3463
02:02:42,689 --> 02:02:43,370
or an SSD,

3464
02:02:43,410 --> 02:02:44,410
a solid state drive,

3465
02:02:44,490 --> 02:02:48,580
which is no moving parts nowadays and generally where our data is stored long term,

3466
02:02:48,770 --> 02:02:49,660
whereas RAM,

3467
02:02:49,770 --> 02:02:50,850
random access memory.

3468
02:02:51,065 --> 02:02:53,496
all the yellow pictures we've been drawing is volatile.

3469
02:02:53,706 --> 02:02:54,366
That is to say,

3470
02:02:54,386 --> 02:02:55,186
when you lose power,

3471
02:02:55,266 --> 02:02:56,025
the battery dies,

3472
02:02:56,105 --> 02:02:58,826
you lose everything in RAM on a hard drive or

3473
02:02:58,826 --> 02:03:02,065
a solid state drive that's persistent storage or non-volatile storage,

3474
02:03:02,076 --> 02:03:03,416
which means when the power goes out,

3475
02:03:03,666 --> 02:03:06,735
thankfully you don't lose all of your documents and essays and so forth,

3476
02:03:06,746 --> 02:03:09,576
whether it's on your Mac or PC or somewhere in the cloud.

3477
02:03:09,746 --> 02:03:12,866
But we haven't yet seen any code via which you yourselves can create files.

3478
02:03:13,202 --> 02:03:14,631
like literally every program we've written,

3479
02:03:14,722 --> 02:03:18,032
even the phonebook example last time when I typed in names and numbers,

3480
02:03:18,202 --> 02:03:21,751
they got deleted as soon as the program quit and ended.

3481
02:03:22,001 --> 02:03:23,041
So with FileIO though,

3482
02:03:23,051 --> 02:03:25,412
we have the ability now to start creating,

3483
02:03:25,682 --> 02:03:26,271
saving,

3484
02:03:26,481 --> 02:03:26,952
editing,

3485
02:03:27,082 --> 02:03:28,122
deleting files,

3486
02:03:28,242 --> 02:03:31,082
much like you would from the File menu of Google Docs,

3487
02:03:31,131 --> 02:03:31,921
Microsoft Word,

3488
02:03:31,961 --> 02:03:32,631
or the like.

3489
02:03:32,841 --> 02:03:35,001
Here are just some of the functions that come with.

3490
02:03:35,330 --> 02:03:36,720
The programming language C

3491
02:03:36,959 --> 02:03:38,439
that allow you to open files,

3492
02:03:38,680 --> 02:03:39,740
aka F open,

3493
02:03:39,959 --> 02:03:40,600
close files,

3494
02:03:40,759 --> 02:03:41,959
aka F close,

3495
02:03:42,160 --> 02:03:43,049
print to a file,

3496
02:03:43,080 --> 02:03:44,009
scan from a file,

3497
02:03:44,080 --> 02:03:44,720
read a file,

3498
02:03:44,759 --> 02:03:45,439
write to a file,

3499
02:03:45,520 --> 02:03:46,479
lots of different functions,

3500
02:03:46,560 --> 02:03:48,149
some of which we'll explore this coming week.

3501
02:03:48,319 --> 02:03:50,270
But why don't we first use them to solve a problem

3502
02:03:50,560 --> 02:03:51,640
here in VS code.

3503
02:03:51,680 --> 02:03:53,439
So let me go ahead and close get.c.

3504
02:03:54,009 --> 02:03:56,209
Let's go ahead and open up a new program

3505
02:03:56,209 --> 02:04:00,259
called Phonebook.c but implement a persistent version of it ultimately

3506
02:04:00,490 --> 02:04:04,410
that doesn't just get deleted from memory when the program quits.

3507
02:04:04,569 --> 02:04:07,049
Let's go ahead and only because it will make life easier,

3508
02:04:07,129 --> 02:04:09,399
let's include the CS 50 library still for this.

3509
02:04:09,649 --> 02:04:11,620
Let's include standard IO.H for this,

3510
02:04:11,689 --> 02:04:12,799
and let's include

3511
02:04:13,160 --> 02:04:13,560
string.

3512
02:04:13,770 --> 02:04:15,189
H for this.

3513
02:04:15,529 --> 02:04:16,720
Then inside of Maine,

3514
02:04:16,930 --> 02:04:18,129
no command line arguments.

3515
02:04:18,330 --> 02:04:19,529
Let's go ahead and.

3516
02:04:20,509 --> 02:04:23,399
Open a file called phonebook.csv.

3517
02:04:23,529 --> 02:04:25,950
CSV stands for comma separated values.

3518
02:04:26,000 --> 02:04:27,459
Many of you have probably used them in the real world.

3519
02:04:27,490 --> 02:04:29,470
They're like very lightweight spreadsheets where

3520
02:04:29,470 --> 02:04:30,910
things are effectively stored in rows

3521
02:04:30,910 --> 02:04:34,629
and columns where the columns are represented by just commas between values,

3522
02:04:34,669 --> 02:04:36,060
and we'll see this in just a moment.

3523
02:04:36,390 --> 02:04:38,930
How do you open a new file called phonebook.

3524
02:04:39,149 --> 02:04:39,859
CSV?

3525
02:04:40,149 --> 02:04:40,270
Well,

3526
02:04:40,430 --> 02:04:41,580
I'm going to do file,

3527
02:04:42,310 --> 02:04:44,729
file equals F open.

3528
02:04:45,299 --> 02:04:50,640
Phonebook.csv and then I'm going to do quote unquote W for right.

3529
02:04:50,890 --> 02:04:52,049
So what's going on here?

3530
02:04:52,089 --> 02:04:54,109
F open is opening a file,

3531
02:04:54,169 --> 02:04:55,399
whether or not it exists yet,

3532
02:04:55,609 --> 02:04:56,299
called phonebook.

3533
02:04:56,490 --> 02:04:57,180
CSV,

3534
02:04:57,450 --> 02:05:01,020
and it's opening it in such a way that I will be allowed to write to it,

3535
02:05:01,049 --> 02:05:03,250
hence the quote unquote W per the documentation.

3536
02:05:03,290 --> 02:05:05,209
It means I can write to this file and not just read it.

3537
02:05:05,740 --> 02:05:09,120
The return value is going to be stored in a variable called file,

3538
02:05:09,290 --> 02:05:10,640
all lower case by convention,

3539
02:05:10,890 --> 02:05:13,830
but that file is technically a

3540
02:05:14,140 --> 02:05:14,930
struct

3541
02:05:15,410 --> 02:05:16,850
called file in all caps.

3542
02:05:16,890 --> 02:05:17,520
It's a little weird.

3543
02:05:17,549 --> 02:05:19,600
It's among the few things that is fully capitalized in C.

3544
02:05:19,649 --> 02:05:21,290
It doesn't mean it's a constant or anything like that.

3545
02:05:21,330 --> 02:05:23,279
It's just how someone implemented it years ago.

3546
02:05:23,529 --> 02:05:24,089
This is giving me.

3547
02:05:24,225 --> 02:05:27,845
A pointer to essentially the contents of that file.

3548
02:05:27,854 --> 02:05:28,765
It's a bit of a white lie,

3549
02:05:28,935 --> 02:05:32,685
technically giving you a pointer to a chunk of memory that represents that file,

3550
02:05:32,915 --> 02:05:36,325
but for all intents and purposes it's a pointer to the file for now.

3551
02:05:36,535 --> 02:05:39,814
Now let's go ahead and ask the user for a name and number to add to this phone book.

3552
02:05:39,895 --> 02:05:42,765
Let's do chart star name equals get string,

3553
02:05:43,924 --> 02:05:46,845
quote unquote name to prompt the human for that chart star number.

3554
02:05:46,895 --> 02:05:48,055
Let's prompt them for that.

3555
02:05:48,500 --> 02:05:50,740
And do it with this,

3556
02:05:50,990 --> 02:05:52,500
and I could be using the string data type,

3557
02:05:52,509 --> 02:05:53,990
but I'm trying to at least remove what

3558
02:05:53,990 --> 02:05:56,060
training wheels we don't technically need anymore.

3559
02:05:56,350 --> 02:05:58,859
And now that we've got a name and number in variables,

3560
02:05:58,910 --> 02:06:00,819
let's print them to the file.

3561
02:06:00,830 --> 02:06:01,109
That is,

3562
02:06:01,149 --> 02:06:05,250
let's save them to the file instead of print F we're going to use F printF.

3563
02:06:05,629 --> 02:06:07,870
We're going to specify what file we want to

3564
02:06:07,870 --> 02:06:10,359
print to in case we have multiple ones open.

3565
02:06:10,790 --> 02:06:11,140
What.

3566
02:06:11,759 --> 02:06:16,149
Do I want to print a string followed by a string followed by a new line,

3567
02:06:16,180 --> 02:06:16,689
ergo,

3568
02:06:16,759 --> 02:06:18,310
comma separated values,

3569
02:06:18,319 --> 02:06:19,750
one after the other per line,

3570
02:06:20,040 --> 02:06:22,669
then I'm gonna pass in the value's name

3571
02:06:22,919 --> 02:06:24,549
and number respectively,

3572
02:06:24,919 --> 02:06:26,839
and now I'm gonna go ahead and.

3573
02:06:28,120 --> 02:06:31,080
Do F close to close that file

3574
02:06:31,410 --> 02:06:33,089
so that it's effectively saved.

3575
02:06:33,410 --> 02:06:33,649
All right,

3576
02:06:33,770 --> 02:06:37,060
so let me go ahead and demonstrate first that phonebook.csv

3577
02:06:37,529 --> 02:06:38,399
does not really exist.

3578
02:06:38,490 --> 02:06:39,410
It's empty initially.

3579
02:06:39,529 --> 02:06:42,279
Let me go ahead and switch it over to the right here so we can see both at the same time.

3580
02:06:42,490 --> 02:06:44,799
I'm now going to do make phonebook enter,

3581
02:06:45,129 --> 02:06:45,879
so far so good,

3582
02:06:46,689 --> 02:06:47,359
phonebook,

3583
02:06:47,569 --> 02:06:48,899
and let me go ahead and type in,

3584
02:06:48,930 --> 02:06:49,870
for instance,

3585
02:06:50,000 --> 02:06:50,470
uh,

3586
02:06:50,490 --> 02:06:51,080
let's see,

3587
02:06:51,129 --> 02:06:52,049
uh my name.

3588
02:06:52,470 --> 02:06:58,390
617-495 1000 and watch the top right of your screen as the program

3589
02:06:58,680 --> 02:07:00,549
F writes to it and F closes

3590
02:07:00,839 --> 02:07:01,759
the contents.

3591
02:07:01,959 --> 02:07:02,470
All good.

3592
02:07:02,640 --> 02:07:02,720
All right,

3593
02:07:02,759 --> 02:07:05,720
let's run it again because maybe like the iOS app or the Android app,

3594
02:07:05,759 --> 02:07:07,830
I'm adding new friends to my phone book here,

3595
02:07:07,879 --> 02:07:11,399
so I'm going to do slash phonebook and I'm going to go ahead and 00.

3596
02:07:12,069 --> 02:07:13,390
Top right just

3597
02:07:13,689 --> 02:07:14,689
got turned blank.

3598
02:07:14,759 --> 02:07:14,850
Well,

3599
02:07:14,959 --> 02:07:15,439
let's try this.

3600
02:07:15,560 --> 02:07:19,350
Kelly 617495-1000 enter.

3601
02:07:19,720 --> 02:07:19,930
OK,

3602
02:07:20,080 --> 02:07:20,830
she's back.

3603
02:07:21,120 --> 02:07:21,870
Let me run it again.

3604
02:07:22,120 --> 02:07:23,520
slash phonebook gone.

3605
02:07:24,310 --> 02:07:24,470
Well,

3606
02:07:24,509 --> 02:07:25,580
what's going on here?

3607
02:07:27,899 --> 02:07:28,859
It's not persisting,

3608
02:07:28,890 --> 02:07:30,640
at least as long as I would like.

3609
02:07:31,089 --> 02:07:36,370
It seems to be the case that like writing to a file means literally rewrite the file.

3610
02:07:36,450 --> 02:07:37,459
So if you use W,

3611
02:07:37,850 --> 02:07:39,129
you're going to write to the file,

3612
02:07:39,169 --> 02:07:40,759
but literally starting at the first bite.

3613
02:07:40,970 --> 02:07:43,439
If you want to be smart about it and a pen to the file,

3614
02:07:43,569 --> 02:07:43,689
well,

3615
02:07:43,770 --> 02:07:45,140
per the documentation for F open,

3616
02:07:45,290 --> 02:07:47,089
you instead use quote unquote a for a pen.

3617
02:07:47,254 --> 02:07:49,484
Instead of quote unquote W for right,

3618
02:07:49,604 --> 02:07:51,515
and this is a convention in other languages too.

3619
02:07:51,685 --> 02:07:51,765
All right,

3620
02:07:51,845 --> 02:07:52,595
let's start this over.

3621
02:07:52,685 --> 02:07:54,325
Let me go ahead and recompile this program,

3622
02:07:54,404 --> 02:07:55,194
make phonebook.

3623
02:07:55,475 --> 02:07:56,924
Now let me do phonebook.

3624
02:07:56,964 --> 02:07:58,125
I'll type in my name again 1st,

3625
02:07:58,134 --> 02:08:00,475
617-495-1000.

3626
02:08:00,564 --> 02:08:03,475
Enter so far so good phonebook.

3627
02:08:04,044 --> 02:08:04,935
So far so good.

3628
02:08:05,205 --> 02:08:08,765
Kelly 617495-1000 E.

3629
02:08:09,250 --> 02:08:10,569
And now we're on our way.

3630
02:08:10,759 --> 02:08:11,000
In fact,

3631
02:08:11,080 --> 02:08:12,319
I can close this file.

3632
02:08:12,439 --> 02:08:13,589
I can close this file.

3633
02:08:13,640 --> 02:08:15,899
I can then open up Phonebook.csv,

3634
02:08:16,100 --> 02:08:17,149
and indeed

3635
02:08:17,399 --> 02:08:18,069
it has

3636
02:08:18,240 --> 02:08:19,069
persisted.

3637
02:08:19,240 --> 02:08:19,569
And in fact,

3638
02:08:19,640 --> 02:08:22,290
if I downloaded this file onto my Mac or my PC,

3639
02:08:22,359 --> 02:08:24,000
I could then right click it or double click on it

3640
02:08:24,000 --> 02:08:26,549
and probably open it in Microsoft Excel or Apple Numbers.

3641
02:08:26,600 --> 02:08:30,169
I could import it into Google Sheets or any number of other spreadsheet tools

3642
02:08:30,560 --> 02:08:34,080
because now I am persisting and writing files of my own.

3643
02:08:35,009 --> 02:08:37,689
Questions on any of the techniques.

3644
02:08:38,419 --> 02:08:39,750
We just tried out here.

3645
02:08:42,020 --> 02:08:43,370
If we really want to be nitpicky,

3646
02:08:43,490 --> 02:08:45,850
like technically I should fix one bug or

3647
02:08:45,850 --> 02:08:48,180
missed opportunity if I open up Phonebook.c.

3648
02:08:48,609 --> 02:08:53,839
I'm going to propose that as with any use of pointers and addresses more generally,

3649
02:08:54,169 --> 02:08:55,439
here too something could be wrong,

3650
02:08:55,529 --> 02:08:59,640
like maybe I'm just out of space and so FO can't physically open the file for me.

3651
02:08:59,904 --> 02:09:02,535
Here too I should check if file equals equals null.

3652
02:09:02,575 --> 02:09:02,774
OK,

3653
02:09:02,865 --> 02:09:03,325
fine.

3654
02:09:03,575 --> 02:09:06,814
Return 1 and then maybe at the very bottom here I return 0 to make clear,

3655
02:09:06,924 --> 02:09:06,995
nope,

3656
02:09:07,095 --> 02:09:07,194
nope,

3657
02:09:07,294 --> 02:09:08,205
if I get this far,

3658
02:09:08,535 --> 02:09:09,165
all is well.

3659
02:09:09,254 --> 02:09:09,615
So in short,

3660
02:09:09,625 --> 02:09:11,845
any time you are dealing now with pointers,

3661
02:09:11,895 --> 02:09:14,404
you should be checking the return values to see

3662
02:09:14,774 --> 02:09:15,165
if

3663
02:09:15,375 --> 02:09:17,245
all in fact went well,

3664
02:09:17,415 --> 02:09:17,645
yeah.

3665
02:09:23,040 --> 02:09:23,529
Yes,

3666
02:09:23,979 --> 02:09:27,049
everything we are using is part of Stanio.H,

3667
02:09:27,120 --> 02:09:31,290
which is wonderfully useful now because it has not just printF but F printF

3668
02:09:31,740 --> 02:09:33,009
and so forth as well.

3669
02:09:33,810 --> 02:09:34,209
Good questions,

3670
02:09:34,299 --> 02:09:34,560
yeah.

3671
02:09:35,439 --> 02:09:35,930
I don't

3672
02:09:41,660 --> 02:09:41,970
Yes,

3673
02:09:42,129 --> 02:09:44,959
so we have how are pointers used in this code?

3674
02:09:45,209 --> 02:09:47,770
The short answer is you have to use pointers

3675
02:09:47,770 --> 02:09:50,290
because this is how C designed files to work.

3676
02:09:50,330 --> 02:09:52,919
So we couldn't really introduce you all to files,

3677
02:09:53,250 --> 02:09:55,479
file IO in week 1 or 2 or 3

3678
02:09:56,040 --> 02:09:56,529
because we had to,

3679
02:09:56,609 --> 02:09:59,290
we'd have to introduce like this stupid little character to you and you'd be like,

3680
02:09:59,319 --> 02:09:59,810
what does this mean?

3681
02:09:59,850 --> 02:10:00,810
It's not multiplication.

3682
02:10:01,410 --> 02:10:05,049
Because the way file IO works is that when you open a file,

3683
02:10:05,069 --> 02:10:08,279
you are essentially handed the address of that file in memory.

3684
02:10:08,450 --> 02:10:09,509
That's an oversimplification.

3685
02:10:09,569 --> 02:10:11,930
You're technically handed the address of a data structure

3686
02:10:11,930 --> 02:10:15,069
in memory that references the file actually on disk,

3687
02:10:15,259 --> 02:10:16,410
but for all intents and purposes.

3688
02:10:16,470 --> 02:10:17,089
I said,

3689
02:10:17,459 --> 02:10:20,129
this gives you a pointer to the contents of the file,

3690
02:10:20,140 --> 02:10:21,930
and if you want to write to the file,

3691
02:10:22,060 --> 02:10:24,660
you need to then do a use F print F.

3692
02:10:24,700 --> 02:10:28,049
In this case tell it what file to write to so you can go there

3693
02:10:28,299 --> 02:10:31,729
and then store something like this string with these values plugged in.

3694
02:10:31,939 --> 02:10:32,419
So in short,

3695
02:10:32,459 --> 02:10:35,459
in C without pointers you just can't do file IO

3696
02:10:35,459 --> 02:10:37,740
unless it's abstracted away for you by some library.

3697
02:10:38,759 --> 02:10:39,350
Good question.

3698
02:10:39,390 --> 02:10:40,140
Other questions

3699
02:10:40,350 --> 02:10:41,000
on file.

3700
02:10:41,910 --> 02:10:42,649
I owe

3701
02:10:44,700 --> 02:10:45,009
All right,

3702
02:10:45,089 --> 02:10:45,200
well,

3703
02:10:45,209 --> 02:10:49,129
let me do one other example here that's a little reminiscent of things we see all the

3704
02:10:49,129 --> 02:10:51,089
time on our phones and laptops and desktops

3705
02:10:51,089 --> 02:10:53,129
like these progress bars for like video players,

3706
02:10:53,169 --> 02:10:55,569
and you're all probably generally familiar with the term like buffering,

3707
02:10:55,580 --> 02:10:57,240
if only because YouTube and other apps,

3708
02:10:57,370 --> 02:10:59,609
when they are slow or you have a slow internet connection,

3709
02:10:59,689 --> 02:11:00,680
they might say buffering.

3710
02:11:01,689 --> 02:11:01,729
Well,

3711
02:11:01,810 --> 02:11:02,560
what does that mean?

3712
02:11:02,689 --> 02:11:02,729
Well,

3713
02:11:02,810 --> 02:11:04,290
a buffer is just a chunk of memory.

3714
02:11:04,370 --> 02:11:04,959
More specifically,

3715
02:11:05,009 --> 02:11:06,240
it's often an array

3716
02:11:06,529 --> 02:11:09,169
that is only a finite size that stores bytes of stuff.

3717
02:11:09,473 --> 02:11:10,623
Context of a video player,

3718
02:11:10,703 --> 02:11:11,042
for instance,

3719
02:11:11,103 --> 02:11:12,783
this red line here which represents you're that

3720
02:11:12,783 --> 02:11:14,333
way through that much through the video,

3721
02:11:14,663 --> 02:11:17,312
it's an array that stores like the next few bytes of a video

3722
02:11:17,312 --> 02:11:19,853
and ideally if you have a fast enough connection when you hit play,

3723
02:11:20,062 --> 02:11:23,692
those bytes keep getting downloaded and added to the buffer and hopefully

3724
02:11:23,902 --> 02:11:25,792
you don't finish watching the bytes that have

3725
02:11:25,792 --> 02:11:28,493
been downloaded before more bytes have been downloaded.

3726
02:11:28,583 --> 02:11:30,663
So a buffer is just a chunk of memory or

3727
02:11:30,663 --> 02:11:33,592
more specifically an array in a language like C.

3728
02:11:33,783 --> 02:11:33,902
Well,

3729
02:11:33,942 --> 02:11:36,795
just Demonstrate how else you can do things with file IO.

3730
02:11:36,916 --> 02:11:38,065
Let me propose that

3731
02:11:38,275 --> 02:11:40,145
we write a simple little program

3732
02:11:40,355 --> 02:11:43,596
that is our own implementation of the CP program,

3733
02:11:43,636 --> 02:11:46,636
the copy program that we've used a few times already that allows

3734
02:11:46,636 --> 02:11:50,605
you in your terminal window to copy one file to another,

3735
02:11:50,996 --> 02:11:55,925
likening it to this idea of a progress bar where byte by bye you want to do something,

3736
02:11:56,235 --> 02:11:56,985
namely in this case,

3737
02:11:57,116 --> 02:11:57,556
copy it,

3738
02:11:57,636 --> 02:11:58,875
not watch it instead.

3739
02:11:59,189 --> 02:12:02,740
So let me go in VS code and code up a program called CP.C,

3740
02:12:02,779 --> 02:12:07,450
and in this program I'm going to go ahead and include standardio.h at the top.

3741
02:12:07,740 --> 02:12:10,540
I'm going to then give myself a main function that

3742
02:12:10,540 --> 02:12:15,609
this time does take finally a command line argument via InargC

3743
02:12:15,979 --> 02:12:17,810
and our old friend string

3744
02:12:19,060 --> 02:12:20,279
RGV,

3745
02:12:20,620 --> 02:12:21,850
which today

3746
02:12:22,189 --> 02:12:25,859
We can now reveal to be also just a char star.

3747
02:12:26,069 --> 02:12:26,649
In fact,

3748
02:12:27,390 --> 02:12:27,819
this

3749
02:12:27,990 --> 02:12:30,910
is how we can now technically write the Declaration for Maine cause

3750
02:12:30,910 --> 02:12:33,629
string no longer exists without the CS 50 library per se.

3751
02:12:33,890 --> 02:12:36,430
So that's really what's been going on this whole time.

3752
02:12:36,620 --> 02:12:37,750
Now let me go ahead and do this.

3753
02:12:37,919 --> 02:12:39,180
I want to be able to write

3754
02:12:39,509 --> 02:12:43,120
a program that takes two command line arguments actually the name of the file

3755
02:12:43,120 --> 02:12:46,549
to copy and the name of the new file to create from it.

3756
02:12:46,839 --> 02:12:49,959
So let's go ahead and create a file using the same syntax

3757
02:12:49,959 --> 02:12:53,910
as before called SRC for short source as is a convention,

3758
02:12:54,120 --> 02:12:56,439
and let's open a file using

3759
02:12:57,220 --> 02:12:57,660
Uh,

3760
02:12:57,779 --> 02:13:00,540
the file name RV1,

3761
02:13:00,600 --> 02:13:01,779
so the first word,

3762
02:13:01,859 --> 02:13:03,000
the human types,

3763
02:13:03,089 --> 02:13:07,100
and let's go ahead and open it in read mode because

3764
02:13:07,100 --> 02:13:09,810
I want to read the source and write to the destination.

3765
02:13:09,979 --> 02:13:10,850
My next file,

3766
02:13:11,100 --> 02:13:13,459
filetar DST destination for short,

3767
02:13:13,540 --> 02:13:16,890
will be F open of RV2

3768
02:13:18,700 --> 02:13:19,299
right.

3769
02:13:19,580 --> 02:13:23,180
Now Y 1 and 2 and not 0 and 1 and 0 is the name of the program,

3770
02:13:23,220 --> 02:13:24,209
which is not interesting.

3771
02:13:24,299 --> 02:13:26,500
1 and 2 will contain the next two words.

3772
02:13:26,604 --> 02:13:27,805
The human types.

3773
02:13:27,995 --> 02:13:30,504
Now let me propose that I want to copy this file

3774
02:13:30,904 --> 02:13:33,154
from source to destination byte by byte,

3775
02:13:33,314 --> 02:13:36,395
similar in spirit to a buffer like this where you're just grabbing from the

3776
02:13:36,395 --> 02:13:39,225
internet one bite of the video at a time so as to watch it.

3777
02:13:39,294 --> 02:13:39,745
In this case,

3778
02:13:39,794 --> 02:13:40,825
I want to copy it.

3779
02:13:41,035 --> 02:13:42,075
So how can I do this?

3780
02:13:42,115 --> 02:13:42,424
Well,

3781
02:13:42,714 --> 02:13:45,334
we don't have a data type per se for representing

3782
02:13:45,595 --> 02:13:46,145
a bit,

3783
02:13:46,575 --> 02:13:47,294
8 bits.

3784
02:13:47,395 --> 02:13:47,694
However,

3785
02:13:47,734 --> 02:13:49,805
a common convention is to actually use our new

3786
02:13:49,805 --> 02:13:53,665
friend typedef and simply declare byte to be something significant

3787
02:13:54,035 --> 02:13:54,834
or something specific.

3788
02:13:54,915 --> 02:13:55,995
So let me declare a type.

3789
02:13:56,509 --> 02:13:56,870
Uh,

3790
02:13:56,950 --> 02:13:59,660
called byte and what is a byte going to be?

3791
02:13:59,970 --> 02:14:00,109
Well,

3792
02:14:00,430 --> 02:14:04,859
ideally it's just a char because a char we know is 1 bite or 8 bits,

3793
02:14:04,870 --> 02:14:07,950
but recall that chars can be treated as integers

3794
02:14:07,950 --> 02:14:10,299
and integers of course can be positive and negative.

3795
02:14:10,509 --> 02:14:12,140
So even though this is a little esoteric,

3796
02:14:12,430 --> 02:14:12,950
technically.

3797
02:14:13,064 --> 02:14:16,625
I want to define a bye to be what we'll call an unsigned char,

3798
02:14:16,654 --> 02:14:18,725
which is probably a keyword you haven't yet seen,

3799
02:14:18,895 --> 02:14:21,104
but it just tells the compiler that this char,

3800
02:14:21,415 --> 02:14:23,245
that is this sequence of 8 bits,

3801
02:14:23,294 --> 02:14:25,415
cannot be interpreted as a negative number because

3802
02:14:25,415 --> 02:14:26,814
I am not doing anything with math.

3803
02:14:26,865 --> 02:14:29,694
These are just raw bytes or 8 bits.

3804
02:14:30,000 --> 02:14:35,040
So now down here I can give myself a bye and I'll call it B for short,

3805
02:14:35,209 --> 02:14:37,209
and now I'm going to write a loop similar in

3806
02:14:37,209 --> 02:14:39,399
spirit to what YouTube and other players are probably doing,

3807
02:14:39,490 --> 02:14:41,080
which is iterates over a file

3808
02:14:41,419 --> 02:14:42,319
byte by bite,

3809
02:14:42,640 --> 02:14:44,459
making in our case a copy thereof.

3810
02:14:44,649 --> 02:14:45,560
So while

3811
02:14:45,930 --> 02:14:48,200
I am reading from this file

3812
02:14:48,870 --> 02:14:50,160
into this byte,

3813
02:14:50,569 --> 02:14:52,290
the size of one byte,

3814
02:14:52,529 --> 02:14:53,680
one at a time

3815
02:14:54,129 --> 02:14:55,560
into this destination.

3816
02:14:56,459 --> 02:14:57,870
Go ahead and check

3817
02:14:58,200 --> 02:14:59,520
that I've read at least one.

3818
02:14:59,560 --> 02:15:03,609
So while the return value of a new function called Fread is not equal to 0,

3819
02:15:03,959 --> 02:15:05,069
go ahead and

3820
02:15:06,200 --> 02:15:06,330
Oops,

3821
02:15:06,479 --> 02:15:07,060
sorry.

3822
02:15:08,470 --> 02:15:08,479
So,

3823
02:15:08,520 --> 02:15:10,359
go ahead and call F right,

3824
02:15:10,600 --> 02:15:11,479
another new function.

3825
02:15:12,049 --> 02:15:14,169
Going to that address of the bytes,

3826
02:15:14,290 --> 02:15:15,479
grabbing the size of it,

3827
02:15:15,560 --> 02:15:16,609
which happens to be one,

3828
02:15:16,649 --> 02:15:18,399
but I'll use size of for consistency,

3829
02:15:18,439 --> 02:15:21,009
grab one such bye and write it to destination.

3830
02:15:21,020 --> 02:15:23,250
This is a huge mouthful admittedly,

3831
02:15:23,259 --> 02:15:26,660
the last thing of which I need to do is close the destination

3832
02:15:27,049 --> 02:15:27,879
so as to save it,

3833
02:15:28,129 --> 02:15:29,330
close the original file,

3834
02:15:29,410 --> 02:15:30,120
the source,

3835
02:15:30,640 --> 02:15:30,799
um,

3836
02:15:30,970 --> 02:15:31,439
but

3837
02:15:31,770 --> 02:15:32,689
this huge mouthful,

3838
02:15:32,729 --> 02:15:34,450
which you'll get more familiar with the next

3839
02:15:34,450 --> 02:15:37,040
problem set is essentially saying on line 12,

3840
02:15:37,410 --> 02:15:40,279
while I can read one byte at a time.

3841
02:15:40,890 --> 02:15:42,430
Write on line 14,

3842
02:15:42,569 --> 02:15:43,720
that bye to the file,

3843
02:15:43,970 --> 02:15:47,089
implementing essentially this idea of the red progress bar going bye

3844
02:15:47,089 --> 02:15:49,120
to byte to byte reading one bite at a time,

3845
02:15:49,330 --> 02:15:50,919
reading from one file the source,

3846
02:15:51,290 --> 02:15:52,419
writing to the other,

3847
02:15:52,970 --> 02:15:53,810
the destination.

3848
02:15:53,970 --> 02:15:54,490
And here too,

3849
02:15:54,569 --> 02:15:55,430
to your question earlier,

3850
02:15:55,490 --> 02:15:57,350
like why why pointers,

3851
02:15:57,729 --> 02:15:59,169
this is the way file IO is done.

3852
02:15:59,209 --> 02:16:00,520
You have to be able to express,

3853
02:16:00,689 --> 02:16:01,779
go to this address,

3854
02:16:01,850 --> 02:16:07,370
go to this file if you want to get data from it or to it and a minor refinement to.

3855
02:16:08,069 --> 02:16:09,589
Technically when you open in files,

3856
02:16:09,669 --> 02:16:11,589
if you know they're binary files that is zeros

3857
02:16:11,589 --> 02:16:13,819
and ones and not Ay or Unicode text files,

3858
02:16:13,990 --> 02:16:15,680
you can technically tell F open,

3859
02:16:16,029 --> 02:16:18,870
write and read in binary mode so there's

3860
02:16:18,870 --> 02:16:22,479
no mistaking the bits for something other than raw

3861
02:16:22,790 --> 02:16:23,299
data,

3862
02:16:23,509 --> 02:16:24,700
an image or otherwise.

3863
02:16:25,100 --> 02:16:25,319
All right,

3864
02:16:25,569 --> 02:16:29,830
so if I go ahead now and do make CP it's so far.

3865
02:16:30,020 --> 02:16:30,609
Piles.

3866
02:16:30,729 --> 02:16:31,700
Let's try this out.

3867
02:16:31,850 --> 02:16:34,589
So here again is phonebook.csv.

3868
02:16:35,000 --> 02:16:35,620
Whoops here,

3869
02:16:36,089 --> 02:16:36,929
that's phonebook.c.

3870
02:16:37,080 --> 02:16:37,929
Here again is phonebook.

3871
02:16:38,129 --> 02:16:39,169
CSV with two of us,

3872
02:16:39,410 --> 02:16:40,240
David and Kelly.

3873
02:16:40,410 --> 02:16:43,410
Let's try to make a copy of this file as follows.slash CP.

3874
02:16:43,490 --> 02:16:45,089
So this is my version of the copy program,

3875
02:16:45,209 --> 02:16:46,879
not the one that comes with the system.

3876
02:16:47,129 --> 02:16:52,200
Let's copy phonebook.csv into copy.csv.

3877
02:16:52,610 --> 02:16:53,169
Enter.

3878
02:16:53,450 --> 02:16:54,410
Let's open now

3879
02:16:54,769 --> 02:16:56,169
the copy of.

3880
02:16:57,009 --> 02:16:58,468
The CSV enter

3881
02:16:58,860 --> 02:16:59,519
and voila,

3882
02:16:59,620 --> 02:17:00,209
thank God,

3883
02:17:00,259 --> 02:17:01,849
like it actually worked.

3884
02:17:01,980 --> 02:17:07,110
I have made a 4 byte copy of this file using syntax that was not available to us

3885
02:17:07,660 --> 02:17:08,450
until today.

3886
02:17:08,919 --> 02:17:10,709
So who cares and what's the motivation?

3887
02:17:10,830 --> 02:17:10,870
Well,

3888
02:17:10,910 --> 02:17:14,429
it's a lot more fun to treat not just text files and these tiny little examples,

3889
02:17:14,509 --> 02:17:16,509
but to actually play with real world examples.

3890
02:17:16,589 --> 02:17:20,150
And in the next problem set among the things you'll do is experiment with BMP files,

3891
02:17:20,509 --> 02:17:21,388
bit mapped files,

3892
02:17:21,429 --> 02:17:24,709
which essentially just means a grid of pixels top to bottom,

3893
02:17:24,790 --> 02:17:25,308
left to right,

3894
02:17:25,589 --> 02:17:29,709
much like our cat that our volunteers atlas of Star created for us with

3895
02:17:29,709 --> 02:17:35,468
a bitmap file you'll store in files literal sequences of pixels or dots,

3896
02:17:35,549 --> 02:17:37,830
each of which is going to be represented with a specific color,

3897
02:17:37,910 --> 02:17:38,509
a red value.

3898
02:17:38,611 --> 02:17:40,161
A green value and a blue value.

3899
02:17:40,241 --> 02:17:41,441
And among the things you'll be able to do

3900
02:17:41,441 --> 02:17:43,600
given such beautiful photos as this is the Week's Bridge

3901
02:17:43,600 --> 02:17:45,639
down by the Charles River is actually make your

3902
02:17:45,639 --> 02:17:49,191
own Instagram-like filters to apply to photos like this,

3903
02:17:49,639 --> 02:17:53,290
understanding now as you do or soon will understand to

3904
02:17:53,290 --> 02:17:55,559
be able to iterate over the file top to bottom,

3905
02:17:55,639 --> 02:17:57,879
left to right over each of the bytes they're in

3906
02:17:58,120 --> 02:18:00,521
and somehow mutate the bytes to look a little bit different.

3907
02:18:00,600 --> 02:18:01,991
So if this is the original photo,

3908
02:18:02,161 --> 02:18:04,941
you might be able to make it all grayscale by changing the R's,

3909
02:18:04,959 --> 02:18:05,389
the G's,

3910
02:18:05,401 --> 02:18:08,161
and the B's to smaller values somehow that are.

3911
02:18:08,303 --> 02:18:11,013
Simpler values that are just black and white and gray tones.

3912
02:18:11,093 --> 02:18:12,933
You might take that same photo as input and give it

3913
02:18:12,933 --> 02:18:15,683
more of a sepia tone like an old school photograph instead.

3914
02:18:15,893 --> 02:18:18,574
You might actually reflect it like actually put

3915
02:18:18,574 --> 02:18:20,534
these bits over here and these bytes over here

3916
02:18:20,534 --> 02:18:25,602
so as to create the inverse of the image by reflecting it over the vertical axis here,

3917
02:18:25,814 --> 02:18:28,263
or you might even blur the image like this.

3918
02:18:28,574 --> 02:18:30,013
This is kind of a common feature in a lot

3919
02:18:30,013 --> 02:18:32,352
of photo editing programs to either blur or de blur.

3920
02:18:32,414 --> 02:18:32,454
Well,

3921
02:18:32,534 --> 02:18:34,534
you can sort of do a little bit of math and

3922
02:18:34,534 --> 02:18:37,893
make every pixel a little fuzzier by kind of cloud.

3923
02:18:37,995 --> 02:18:41,174
In what the human is actually seeing or feeling more comfortable,

3924
02:18:41,424 --> 02:18:43,106
you can actually write code now that you

3925
02:18:43,106 --> 02:18:45,465
know how to manipulate files and addresses thereof

3926
02:18:45,706 --> 02:18:47,856
and actually do edge detection and find

3927
02:18:47,856 --> 02:18:49,825
the salient characteristics of something like the

3928
02:18:49,825 --> 02:18:51,816
bridge to distinguish it from the sky

3929
02:18:51,816 --> 02:18:54,776
and actually find filter-like edges like these.

3930
02:18:54,946 --> 02:18:57,406
So those are just some of the problems that you're going to solve over the

3931
02:18:57,406 --> 02:19:00,305
coming weeks problems set in manipulating ultimately

3932
02:19:00,305 --> 02:19:02,286
files like these as well as JPEGs,

3933
02:19:02,295 --> 02:19:04,286
and the last thing we thought we'd end on is a

3934
02:19:04,286 --> 02:19:06,305
sort of computer science joke which for better or for worse,

3935
02:19:06,344 --> 02:19:07,536
you're now getting more and more.

3936
02:19:08,539 --> 02:19:09,718
Able to interpret,

3937
02:19:09,878 --> 02:19:13,128
so I'll leave you dramatically with this here famous joke.

3938
02:19:16,258 --> 02:19:16,727
Oh,

3939
02:19:17,638 --> 02:19:18,789
That's more laughter than usual.

3940
02:19:18,958 --> 02:19:19,119
All right,

3941
02:19:19,279 --> 02:19:20,239
that's it for week 4.

3942
02:19:20,279 --> 02:19:21,428
We will see you next time.