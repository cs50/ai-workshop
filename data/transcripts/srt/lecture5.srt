0
00:00:43,200 --> 00:00:43,209
All

1
00:00:45,389 --> 00:00:45,970
right,

2
00:00:46,270 --> 00:00:48,310
this is CS 50,

3
00:00:48,500 --> 00:00:50,299
and this is week 5 already,

4
00:00:50,709 --> 00:00:52,950
wherein we will focus today on data structures,

5
00:00:53,029 --> 00:00:56,340
which is a topic we touched on a little bit in in simple form,

6
00:00:56,509 --> 00:00:58,500
but today we'll dive all the more deeply and

7
00:00:58,790 --> 00:00:59,830
for better or for worse,

8
00:00:59,909 --> 00:01:01,930
this is our last week on C.

9
00:01:02,400 --> 00:01:02,409
Uh,

10
00:01:02,549 --> 00:01:02,869
next week,

11
00:01:02,880 --> 00:01:03,069
of course,

12
00:01:03,110 --> 00:01:04,260
we transition to Python,

13
00:01:04,269 --> 00:01:06,269
which is a so-called higher level programming language,

14
00:01:06,279 --> 00:01:06,779
which is really,

15
00:01:06,830 --> 00:01:07,269
frankly,

16
00:01:07,389 --> 00:01:08,769
just going to make our lives a lot easier.

17
00:01:08,830 --> 00:01:10,930
We're going to be able to solve a lot of the same problems,

18
00:01:10,989 --> 00:01:13,735
but so much more quickly as Humans,

19
00:01:13,855 --> 00:01:18,415
but not necessarily as we'll see as fast when we run the code as the

20
00:01:18,415 --> 00:01:21,855
computer might have if we were still using a lower level language like C.

21
00:01:21,944 --> 00:01:24,125
So indeed thematic over this week and next is going

22
00:01:24,125 --> 00:01:26,694
to be the theme that we've seen before of trade-offs.

23
00:01:26,775 --> 00:01:27,805
But before we get there,

24
00:01:28,004 --> 00:01:31,214
why don't we focus on a couple of data

25
00:01:31,214 --> 00:01:33,845
structures that you might encounter in the real world,

26
00:01:34,415 --> 00:01:35,285
namely

27
00:01:35,644 --> 00:01:36,855
stacks and cues.

28
00:01:36,955 --> 00:01:40,315
Let's learn some facts about both of these if we could dim

29
00:01:40,455 --> 00:01:41,805
the lights dramatically.

30
00:01:46,639 --> 00:01:49,309
Once upon a time there was a guy named Jack.

31
00:01:49,519 --> 00:01:50,930
When it came to making friends,

32
00:01:51,160 --> 00:01:52,629
Jack did not have the knack.

33
00:01:52,959 --> 00:01:55,709
So Jack went to talk to the most popular guy he knew.

34
00:01:55,839 --> 00:01:57,269
He went up to Lou and asked,

35
00:01:57,360 --> 00:01:58,279
What do I do?

36
00:01:58,519 --> 00:02:00,870
Lou saw that his friend was really distressed.

37
00:02:01,120 --> 00:02:01,379
Well,

38
00:02:01,559 --> 00:02:02,239
Lou began,

39
00:02:02,400 --> 00:02:03,440
Just look how you're dressed.

40
00:02:03,559 --> 00:02:05,910
Don't you have any clothes with a different look?

41
00:02:06,209 --> 00:02:06,480
Yes,

42
00:02:06,639 --> 00:02:07,169
said Jack,

43
00:02:07,319 --> 00:02:08,229
I sure do.

44
00:02:08,479 --> 00:02:10,669
Come to my house and I'll show them to you.

45
00:02:10,960 --> 00:02:12,070
So they went off the jacks,

46
00:02:12,100 --> 00:02:16,720
and Jack showed Lou the box where he kept all his shirts and his pants and his socks.

47
00:02:16,880 --> 00:02:17,320
Lou said,

48
00:02:17,440 --> 00:02:19,669
I see you have all your clothes in a pile.

49
00:02:19,960 --> 00:02:22,229
Why don't you wear some others once in a while?

50
00:02:22,559 --> 00:02:23,110
Jack said,

51
00:02:23,279 --> 00:02:23,399
Well,

52
00:02:23,559 --> 00:02:25,429
when I remove clothes and socks,

53
00:02:25,639 --> 00:02:28,110
I washed them and put them away in the box.

54
00:02:28,399 --> 00:02:30,669
Then comes the next morning and up I hop.

55
00:02:30,839 --> 00:02:33,509
I go to the box and get my clothes off the top.

56
00:02:34,050 --> 00:02:36,479
Lou quickly realized the problem with Jack.

57
00:02:36,690 --> 00:02:37,490
He kept clothes,

58
00:02:37,610 --> 00:02:38,029
CDs,

59
00:02:38,050 --> 00:02:39,399
and books in a stack.

60
00:02:39,729 --> 00:02:41,889
When he reached for something to read or to wear,

61
00:02:42,050 --> 00:02:44,360
he chose the top book or underwear.

62
00:02:44,729 --> 00:02:45,490
Then when he was done,

63
00:02:45,570 --> 00:02:46,800
he would put it right back.

64
00:02:47,089 --> 00:02:49,279
Back it would go on top of the stack.

65
00:02:49,610 --> 00:02:50,449
I know the solution,

66
00:02:50,570 --> 00:02:51,820
said a triumphant Lou.

67
00:02:52,169 --> 00:02:54,360
You need to learn to start using a cue.

68
00:02:54,770 --> 00:02:55,289
Lou took Jack.

69
00:02:55,539 --> 00:02:57,300
clothes and hung them in a closet,

70
00:02:57,460 --> 00:02:58,740
and when he had emptied the box,

71
00:02:58,830 --> 00:02:59,899
he just tossed it.

72
00:03:00,350 --> 00:03:00,789
Then he said,

73
00:03:00,910 --> 00:03:01,029
Now,

74
00:03:01,149 --> 00:03:01,470
Jack,

75
00:03:01,550 --> 00:03:02,539
at the end of the day,

76
00:03:02,789 --> 00:03:05,300
put your clothes on the left when you put them away.

77
00:03:05,589 --> 00:03:07,779
Then tomorrow morning when you see the sun shine,

78
00:03:08,070 --> 00:03:09,309
get your clothes from the right,

79
00:03:09,470 --> 00:03:10,820
from the end of the line.

80
00:03:11,029 --> 00:03:11,710
Don't you see,

81
00:03:11,789 --> 00:03:12,350
said Lou,

82
00:03:12,470 --> 00:03:13,740
it will be so nice.

83
00:03:13,990 --> 00:03:16,800
You'll wear everything once before you wear something twice.

84
00:03:17,279 --> 00:03:20,039
And with everything in queues in his closet and shelf,

85
00:03:20,339 --> 00:03:22,619
Jack started to feel quite sure of himself,

86
00:03:22,740 --> 00:03:25,449
all thanks to Lou and his wonderful Q.

87
00:03:27,169 --> 00:03:27,529
All right,

88
00:03:27,649 --> 00:03:29,649
our thanks to Professor Shannon Duvall at Elon

89
00:03:29,649 --> 00:03:31,729
University who kindly put together that animation,

90
00:03:31,809 --> 00:03:33,169
and it's meant to paint a picture of a couple

91
00:03:33,169 --> 00:03:35,559
of things that we've all encountered in the real world,

92
00:03:35,690 --> 00:03:39,440
but more technically what we just saw were what are known as abstract data types,

93
00:03:39,449 --> 00:03:40,000
whereby

94
00:03:40,130 --> 00:03:41,639
there are data structures in some sense,

95
00:03:41,669 --> 00:03:43,449
but it's really about the design thereof,

96
00:03:43,570 --> 00:03:46,490
what characteristics or features or functionality these

97
00:03:46,490 --> 00:03:49,419
structures offer irrespective of how they are implemented

98
00:03:49,610 --> 00:03:51,809
in terms of lower level implementation details,

99
00:03:51,889 --> 00:03:53,050
which is to say you can implement,

100
00:03:53,059 --> 00:03:53,759
as we'll see,

101
00:03:53,929 --> 00:03:55,649
cues and stacks in any number.

102
00:03:55,777 --> 00:03:58,848
Ways which are going to have real world implications for how you can

103
00:03:58,848 --> 00:04:01,078
actually use them and what kinds of problems you can solve with them.

104
00:04:01,167 --> 00:04:03,287
So let's consider for instance queues in the first place.

105
00:04:03,367 --> 00:04:05,798
So a queue is something you sort of experience all the time.

106
00:04:05,807 --> 00:04:07,087
Any time you go to a store,

107
00:04:07,477 --> 00:04:07,488
uh,

108
00:04:07,688 --> 00:04:11,848
go to some event for which you have to line up in a so-called queue,

109
00:04:11,968 --> 00:04:14,917
you'd ideally like there to be some fairness property about that queue,

110
00:04:14,927 --> 00:04:16,517
such that if you got in line first,

111
00:04:16,608 --> 00:04:17,808
you get into the store first.

112
00:04:17,846 --> 00:04:20,458
You get to check out first or some other such goal.

113
00:04:20,608 --> 00:04:20,937
Meanwhile,

114
00:04:21,007 --> 00:04:24,247
the person who got there last actually is at the end of the line.

115
00:04:24,526 --> 00:04:28,115
is at the end of the line and therefore gets served or enters in at the end.

116
00:04:28,335 --> 00:04:32,765
So queues have what computer scientists would say is a FIFO property first in,

117
00:04:32,925 --> 00:04:33,756
first out.

118
00:04:33,966 --> 00:04:34,205
That is,

119
00:04:34,216 --> 00:04:35,246
if you're the first person in line,

120
00:04:35,325 --> 00:04:36,846
you're the first person to get out of line.

121
00:04:36,925 --> 00:04:39,656
And for many problems that is a good solution,

122
00:04:39,686 --> 00:04:41,196
certainly if you're concerned with fairness.

123
00:04:41,686 --> 00:04:42,955
But more technically,

124
00:04:43,205 --> 00:04:45,756
AQ has what we'll call two operations NQ,

125
00:04:45,885 --> 00:04:47,756
which is a fancy way of saying getting in line,

126
00:04:47,966 --> 00:04:48,526
and DQ,

127
00:04:48,566 --> 00:04:51,355
a fancy way of saying getting out of the line from the front of it.

128
00:04:51,485 --> 00:04:52,876
But those two operations,

129
00:04:52,925 --> 00:04:54,153
if Think about it in code.

130
00:04:54,204 --> 00:04:56,634
Could it be implemented with different actual

131
00:04:57,044 --> 00:04:57,773
details?

132
00:04:57,803 --> 00:04:59,093
And by that I mean this.

133
00:04:59,204 --> 00:05:02,834
Here is one way that we could go about implementing in C code,

134
00:05:02,924 --> 00:05:07,264
a queue for a bunch of people or persons who want to line up for something.

135
00:05:07,324 --> 00:05:08,033
So for instance,

136
00:05:08,123 --> 00:05:10,523
we'll decree that this queue can hold no more than 50 people,

137
00:05:10,604 --> 00:05:12,033
like that's the physical capacity,

138
00:05:12,204 --> 00:05:13,194
and then we define

139
00:05:13,403 --> 00:05:14,044
a structure,

140
00:05:14,084 --> 00:05:17,563
which we've done a couple of times in the past whereby this structure has

141
00:05:17,563 --> 00:05:21,843
not only an array of persons that we'll call people and that will be.

142
00:05:21,932 --> 00:05:23,562
As big as is the capacity,

143
00:05:23,682 --> 00:05:27,391
so this is an array of size 50 for 50 such persons.

144
00:05:27,402 --> 00:05:30,041
And then we're going to propose that we also keep track in

145
00:05:30,041 --> 00:05:33,641
this implementation of a queue of the current size of the queue.

146
00:05:33,682 --> 00:05:35,402
So we're going to make a distinction between the capacity,

147
00:05:35,481 --> 00:05:37,971
like how many total people can be there and the size,

148
00:05:37,981 --> 00:05:41,082
like actually how many people are in line at that moment in time so

149
00:05:41,082 --> 00:05:43,911
that you know which of the spots in the array are effectively empty,

150
00:05:43,951 --> 00:05:45,471
and we're going to call that whole structure

151
00:05:45,682 --> 00:05:46,471
a queue.

152
00:05:46,772 --> 00:05:50,481
Now the catch with this particular implementation and code of a queue.

153
00:05:50,869 --> 00:05:52,010
Is what?

154
00:05:52,329 --> 00:05:54,820
There is inherent in it a limitation,

155
00:05:55,220 --> 00:05:57,100
something you just kind of have to deal with and I see you nodding.

156
00:05:57,109 --> 00:05:58,570
What what's your instinct for this?

157
00:06:00,179 --> 00:06:00,549
For example,

158
00:06:00,600 --> 00:06:01,309
like if you have like.

159
00:06:02,390 --> 00:06:02,660
OK,

160
00:06:02,700 --> 00:06:02,779
well,

161
00:06:02,820 --> 00:06:06,410
I think you hit the nail on the head in that it's only for 50 students or 50 people,

162
00:06:06,540 --> 00:06:09,369
which means if a 51st person wants to get into line,

163
00:06:09,500 --> 00:06:12,500
you literally have no means of remembering them in this data structure.

164
00:06:12,579 --> 00:06:13,540
So how do you solve that?

165
00:06:13,700 --> 00:06:13,820
Well,

166
00:06:13,910 --> 00:06:20,179
we could just recompile our code after changing the 50 to like 51 or maybe 500 or 5000,

167
00:06:20,220 --> 00:06:21,890
but there there's this trade-off because

168
00:06:22,100 --> 00:06:24,739
you could still be undershooting the total number of people trying to

169
00:06:24,739 --> 00:06:28,010
get into maybe a big concert in the case of an extreme,

170
00:06:28,299 --> 00:06:29,720
but at the same time,

171
00:06:29,783 --> 00:06:33,174
If you over allocate memory using 5000 locations in memory,

172
00:06:33,414 --> 00:06:34,723
what if only a few people show up?

173
00:06:34,773 --> 00:06:36,144
Now you're just wasting memory.

174
00:06:36,174 --> 00:06:37,574
And certainly at the end of the day you only

175
00:06:37,574 --> 00:06:39,463
have a finite amount of memory in the computer,

176
00:06:39,694 --> 00:06:43,223
so you kind of have to decide a priori like before compiling your code,

177
00:06:43,454 --> 00:06:45,174
how big is this structure going to be,

178
00:06:45,253 --> 00:06:46,484
how much space you're going to waste,

179
00:06:46,493 --> 00:06:48,574
and in the end it's all sort of stupid.

180
00:06:48,584 --> 00:06:50,243
It would be ideal if instead

181
00:06:50,414 --> 00:06:53,533
we could just grow the queue as needed and shrink it,

182
00:06:53,773 --> 00:06:55,533
essentially asking the operating system as we

183
00:06:55,533 --> 00:06:56,984
started doing last week for more memory.

184
00:06:57,178 --> 00:06:59,627
Giving it back if we don't actually need that memory,

185
00:06:59,847 --> 00:07:04,088
which is to say can't really do an array in this static sense,

186
00:07:04,167 --> 00:07:07,108
and by static I mean we're literally deciding in advance at

187
00:07:07,108 --> 00:07:10,157
compilation time how big this thing is going to be.

188
00:07:10,287 --> 00:07:10,847
As an aside,

189
00:07:10,888 --> 00:07:14,208
this is also a bit annoying for implementing a queue because you have

190
00:07:14,208 --> 00:07:17,067
to somehow keep track of who is at the head of the queue,

191
00:07:17,127 --> 00:07:17,928
the front of the queue,

192
00:07:18,088 --> 00:07:19,838
because as you start plucking people off,

193
00:07:20,007 --> 00:07:22,088
you need to remember who's the next person effectively,

194
00:07:22,127 --> 00:07:24,278
but there are ways in code that we could solve this.

195
00:07:24,571 --> 00:07:27,522
So let's consider an alternative to a cue which gives us very different properties,

196
00:07:27,622 --> 00:07:28,321
namely a stack,

197
00:07:28,361 --> 00:07:30,552
and we saw that in the animation whereby

198
00:07:30,921 --> 00:07:35,481
Jack used a stack to put his clothes into a box so that every time he got dressed,

199
00:07:35,522 --> 00:07:37,451
he sort of took the sweater from the top,

200
00:07:37,562 --> 00:07:38,032
from the top,

201
00:07:38,082 --> 00:07:38,522
from the top,

202
00:07:38,601 --> 00:07:41,231
and might never wear anything other than black as a result.

203
00:07:41,272 --> 00:07:44,511
If he does a wash before he actually reaches the blue in the red sweater there.

204
00:07:44,802 --> 00:07:45,731
So a stack,

205
00:07:45,802 --> 00:07:46,791
as we've just seen,

206
00:07:46,962 --> 00:07:49,752
has a LIFO property to it last in,

207
00:07:49,981 --> 00:07:50,691
first out.

208
00:07:50,881 --> 00:07:51,842
So if I do a load of law.

209
00:07:52,156 --> 00:07:54,305
and I plop some more sweaters on this stack.

210
00:07:54,476 --> 00:07:54,555
Well,

211
00:07:54,635 --> 00:07:58,316
I'm presumably going to use the last sweater that went in first as opposed to

212
00:07:58,316 --> 00:08:00,996
trying to create a mess and like you know pull the bottommost sweater out,

213
00:08:01,075 --> 00:08:03,996
which is just going to be a little more effort than

214
00:08:03,996 --> 00:08:06,105
it would be otherwise from just taking it from the top.

215
00:08:06,316 --> 00:08:09,196
So sometimes last in first out doesn't give you maybe

216
00:08:09,196 --> 00:08:12,186
this fairness property you might want for other problems,

217
00:08:12,276 --> 00:08:13,716
but it does give you an efficiency,

218
00:08:13,876 --> 00:08:14,675
a convenience,

219
00:08:14,686 --> 00:08:15,045
certainly.

220
00:08:15,115 --> 00:08:16,545
So maybe that might be compelling.

221
00:08:16,675 --> 00:08:18,335
And stacks are actually everywhere too.

222
00:08:18,395 --> 00:08:19,235
If you've checked your Gmail.

223
00:08:19,470 --> 00:08:20,059
Recently,

224
00:08:20,190 --> 00:08:22,779
odds are you've opened up gmail.com or Outlook.com,

225
00:08:22,790 --> 00:08:23,980
and you've looked at your inbox,

226
00:08:24,070 --> 00:08:26,869
and where does the new mail by default end up at the top,

227
00:08:27,029 --> 00:08:27,399
at the top,

228
00:08:27,510 --> 00:08:27,910
at the top.

229
00:08:27,989 --> 00:08:31,589
And I dare say all of us are guilty of sort of neglecting emails that fall

230
00:08:31,589 --> 00:08:35,960
below the breaker onto the next page and sort of focusing only on the last in

231
00:08:36,140 --> 00:08:38,140
and therefore replying to it first out,

232
00:08:38,349 --> 00:08:40,619
which isn't great maybe for the senders of those emails,

233
00:08:40,630 --> 00:08:44,630
but it's just how those user interfaces are implemented

234
00:08:44,630 --> 00:08:46,630
quite often unless you override those default settings.

235
00:08:47,023 --> 00:08:48,533
So how might we implement

236
00:08:48,783 --> 00:08:49,263
a stack?

237
00:08:49,343 --> 00:08:49,383
Well,

238
00:08:49,424 --> 00:08:52,354
we need to implement more technically two fundamental operations.

239
00:08:52,424 --> 00:08:55,653
The analogs of NQ and DQ in the world of stacks are called push,

240
00:08:55,864 --> 00:08:57,934
which means push something onto the top of the stack,

241
00:08:58,104 --> 00:08:58,664
and pop,

242
00:08:58,744 --> 00:09:02,304
which means remove something from the top of the stack also.

243
00:09:02,343 --> 00:09:05,703
And the team in the cafeterias and dining halls on campus do this all day long.

244
00:09:05,823 --> 00:09:08,703
Any of the cafeterias or dining halls that have stacks of trays,

245
00:09:08,744 --> 00:09:09,213
of course,

246
00:09:09,343 --> 00:09:11,383
you put the first tray at the bottom and then the

247
00:09:11,383 --> 00:09:12,783
next tray and the next tray in the next tray,

248
00:09:12,794 --> 00:09:14,083
and which tray do all of you.

249
00:09:14,148 --> 00:09:14,737
Pick up well,

250
00:09:14,978 --> 00:09:16,367
presumably the one on the very top,

251
00:09:16,418 --> 00:09:18,177
because it's even harder to grab the bottommost tray

252
00:09:18,177 --> 00:09:20,208
than it would be for something like a sweater.

253
00:09:20,338 --> 00:09:20,888
As a result,

254
00:09:20,937 --> 00:09:24,458
there's maybe undesirable properties like maybe no one ever gets to the nasty tray

255
00:09:24,458 --> 00:09:28,578
at the very bottom of the stack because we're constantly replenishing the top ones.

256
00:09:28,617 --> 00:09:32,377
But thanks to gravity like that just happens to be the most appropriate data

257
00:09:32,377 --> 00:09:36,447
structure in the real world for distributing things like trays in a cafeteria.

258
00:09:36,658 --> 00:09:39,288
So how might we implement that idea in code?

259
00:09:39,418 --> 00:09:39,497
Well,

260
00:09:39,578 --> 00:09:39,937
funny enough,

261
00:09:39,947 --> 00:09:41,418
we can pretty much use the exact.

262
00:09:41,541 --> 00:09:42,002
Same

263
00:09:42,411 --> 00:09:45,171
structure we could just rename Q to stack because at the

264
00:09:45,171 --> 00:09:47,221
end of the day we need to keep track of some number

265
00:09:47,452 --> 00:09:50,611
of people and maybe people's a weird sort of analog here,

266
00:09:50,622 --> 00:09:52,961
but we kept everything else the same so why not that?

267
00:09:52,971 --> 00:09:56,331
But the size is also something we still need to remember and it

268
00:09:56,331 --> 00:09:58,921
turns out it's a little easier to implement a stack in this way

269
00:09:59,171 --> 00:10:01,771
because you can always remove it from the end of the array,

270
00:10:01,851 --> 00:10:02,822
end of the array,

271
00:10:03,012 --> 00:10:05,252
and the first thing that went into the stack,

272
00:10:05,331 --> 00:10:06,291
the first in,

273
00:10:06,611 --> 00:10:08,101
can always stay at location 0,

274
00:10:08,211 --> 00:10:08,812
for instance.

275
00:10:08,945 --> 00:10:10,966
But ultimately we could implement it in this way,

276
00:10:11,046 --> 00:10:12,486
but we have the same darn limitation.

277
00:10:12,645 --> 00:10:14,486
You can still only put 50 sweaters,

278
00:10:14,565 --> 00:10:15,205
50 trays,

279
00:10:15,286 --> 00:10:18,765
50 people into that stack data structure.

280
00:10:18,846 --> 00:10:21,236
So this is just one implementation approach.

281
00:10:21,406 --> 00:10:25,036
But that doesn't mean that's necessarily a limitation of stacks and cues.

282
00:10:25,245 --> 00:10:27,635
They're abstract in the sense that we could do better.

283
00:10:27,806 --> 00:10:29,726
We could maybe start to manage our own memory,

284
00:10:29,786 --> 00:10:32,906
move away from statically defining the total size of this array,

285
00:10:33,046 --> 00:10:34,966
and just start allocating and de-allocating.

286
00:10:35,005 --> 00:10:36,205
That is growing and shrinking.

287
00:10:36,520 --> 00:10:38,090
The data structure instead,

288
00:10:38,270 --> 00:10:40,030
which is to say we can make these abstract

289
00:10:40,030 --> 00:10:44,219
data types much less abstract with actual implementations.

290
00:10:44,369 --> 00:10:47,109
Let's consider a data structure that we saw an abstract data type

291
00:10:47,109 --> 00:10:50,109
that we saw early on that we didn't necessarily give this name.

292
00:10:50,150 --> 00:10:52,820
A dictionary is yet another abstract data type

293
00:10:52,820 --> 00:10:54,510
that's sort of everywhere in the world,

294
00:10:54,669 --> 00:10:58,340
literally in the world of dictionaries containing words and their definitions,

295
00:10:58,419 --> 00:11:01,109
and you can think of a dictionary really in the abstract if you were

296
00:11:01,109 --> 00:11:03,950
to draw this on the chalkboard as really just a two column table.

297
00:11:04,033 --> 00:11:07,013
Whereby on the left is the word and on the right is the definition.

298
00:11:07,023 --> 00:11:07,943
If it's a physical book,

299
00:11:08,064 --> 00:11:11,614
it's essentially the same thing with lots of columns of words on the left,

300
00:11:11,664 --> 00:11:12,403
often bold faced,

301
00:11:12,424 --> 00:11:14,294
and then the definitions right next to them.

302
00:11:14,664 --> 00:11:16,934
You can also see this in the context of like a phone book,

303
00:11:17,064 --> 00:11:18,874
which is where we began the course in week zero,

304
00:11:18,934 --> 00:11:21,263
where it's essentially a dictionary of names

305
00:11:21,263 --> 00:11:23,934
and numbers instead of words and definitions,

306
00:11:23,973 --> 00:11:25,943
and a computer scientist would generalize the

307
00:11:25,943 --> 00:11:28,304
notion of a dictionary further and just call

308
00:11:28,304 --> 00:11:31,424
the thing on the left a key and the thing on the right a value.

309
00:11:31,547 --> 00:11:34,617
You and these things are omnipresent in computing

310
00:11:34,617 --> 00:11:35,658
and you're going to start to see them

311
00:11:35,658 --> 00:11:39,528
all the more today and next week and beyond in that if you just want to associate

312
00:11:39,857 --> 00:11:42,127
some piece of data with another piece of data,

313
00:11:42,257 --> 00:11:44,468
a so-called key value pair,

314
00:11:44,658 --> 00:11:47,127
a dictionary is going to be your go to

315
00:11:47,418 --> 00:11:48,168
data type.

316
00:11:48,377 --> 00:11:50,418
But even these two we can implement in

317
00:11:50,418 --> 00:11:52,778
different ways for reasons that we've already seen,

318
00:11:52,817 --> 00:11:56,768
like maybe there's only a finite size to this dictionary if we're using an array.

319
00:11:56,778 --> 00:11:58,047
Maybe we can do better than that,

320
00:11:58,257 --> 00:11:59,411
and maybe a The dictionary,

321
00:11:59,432 --> 00:12:00,291
if implemented one way,

322
00:12:00,302 --> 00:12:01,041
is going to be fast.

323
00:12:01,171 --> 00:12:03,202
Maybe if implemented in another way it's going to be slow.

324
00:12:03,411 --> 00:12:07,091
So we'll consider these other design possibilities today too in the

325
00:12:07,091 --> 00:12:10,122
context of phone books and other data structures as well.

326
00:12:10,171 --> 00:12:10,841
After all,

327
00:12:11,091 --> 00:12:15,611
if you have an iPhone or an Android phone and Apple or Google only decided

328
00:12:15,611 --> 00:12:19,601
that you can have 50 friends because they implemented the Contacts app in an array,

329
00:12:19,731 --> 00:12:22,012
I mean that would be an annoying limitation.

330
00:12:22,101 --> 00:12:26,411
So presumably they've done things a little more dynamically as we'll do today.

331
00:12:26,575 --> 00:12:29,926
So let's focus on the first of the data structures we saw back in week 2,

332
00:12:29,935 --> 00:12:33,276
that is an array which we recall was just a chunk of memory

333
00:12:33,276 --> 00:12:36,046
where you can store values in it back to back to back,

334
00:12:36,085 --> 00:12:37,606
and that was the fundamental definition.

335
00:12:37,645 --> 00:12:40,116
The values are back to back to back or contiguous in memory,

336
00:12:40,366 --> 00:12:41,085
and as we've seen,

337
00:12:41,205 --> 00:12:44,245
we generally have to decide in advance the size of an array.

338
00:12:44,315 --> 00:12:44,916
So for instance,

339
00:12:44,966 --> 00:12:47,406
if we want to store 3 values like 12,

340
00:12:47,445 --> 00:12:47,885
and 3,

341
00:12:47,935 --> 00:12:50,995
it might look pictorally like this or in code,

342
00:12:51,085 --> 00:12:54,005
let's go ahead and implement this same idea and take a moment.

343
00:12:54,159 --> 00:12:58,049
Whip up our very first program here and we'll call it say Li.c.

344
00:12:58,359 --> 00:12:59,119
And in this program,

345
00:12:59,159 --> 00:13:01,599
let's just do something demonstrative of how you could

346
00:13:01,599 --> 00:13:04,309
use arrays to store 3 things in memory.

347
00:13:04,520 --> 00:13:06,070
It's quite simply the numbers 123,

348
00:13:06,080 --> 00:13:08,159
but you can imagine it being 3 people's names,

349
00:13:08,239 --> 00:13:08,960
3 sweaters,

350
00:13:09,039 --> 00:13:09,750
3 people,

351
00:13:09,770 --> 00:13:11,830
or any other piece of data as well.

352
00:13:12,039 --> 00:13:16,270
So I'm going to go ahead and at the top of lists.c include standardio.h.

353
00:13:16,599 --> 00:13:18,119
I'm going to then do in main void,

354
00:13:18,200 --> 00:13:19,640
so no command line arguments.

355
00:13:19,799 --> 00:13:21,520
Then I'm going to go ahead and give myself in a red.

356
00:13:21,604 --> 00:13:25,044
A of integers of size 3 called list,

357
00:13:25,234 --> 00:13:27,943
and that's how we've done that from week 2 onward.

358
00:13:28,153 --> 00:13:29,414
Then just for the sake of discussion,

359
00:13:29,434 --> 00:13:31,643
I'm going to hard code some representative values.

360
00:13:31,713 --> 00:13:35,064
So the first value will be at location 0 because the rays are 0 indexed.

361
00:13:35,273 --> 00:13:36,874
Then I'm going to do the second value,

362
00:13:36,914 --> 00:13:37,723
which will be 2,

363
00:13:37,914 --> 00:13:40,823
and then the third value which will be at location 2,

364
00:13:40,833 --> 00:13:42,544
but the value will be 3.

365
00:13:42,833 --> 00:13:45,354
Now just to prove that we've stored this correctly in memory,

366
00:13:45,393 --> 00:13:49,023
let's just do a quick 4 loop 4 in to I equals equals 0.

367
00:13:49,380 --> 00:13:49,580
Uh,

368
00:13:49,590 --> 00:13:51,010
I is less than

369
00:13:51,260 --> 00:13:51,849
3,

370
00:13:52,099 --> 00:13:53,349
I plus plus.

371
00:13:54,179 --> 00:13:55,729
And then inside of this for loop,

372
00:13:55,770 --> 00:14:00,520
I'm just going to do a quick print F of percent I backslash N printing out the value

373
00:14:00,809 --> 00:14:02,799
of list at location I.

374
00:14:02,890 --> 00:14:04,440
So it's not a useful program per se,

375
00:14:04,609 --> 00:14:05,900
but it gives us an array to play with.

376
00:14:05,929 --> 00:14:07,119
It prints out what's in it,

377
00:14:07,150 --> 00:14:09,049
so hopefully we will see 12.

378
00:14:09,289 --> 00:14:10,229
And 3 on the screen.

379
00:14:10,320 --> 00:14:11,929
So let me make this list program

380
00:14:13,280 --> 00:14:14,869
list enter and voila,

381
00:14:14,919 --> 00:14:15,989
we're on our way going.

382
00:14:16,219 --> 00:14:16,409
All right,

383
00:14:16,599 --> 00:14:17,830
but what if now

384
00:14:18,200 --> 00:14:19,260
we actually want to

385
00:14:19,640 --> 00:14:21,239
uh change that design and be like,

386
00:14:21,320 --> 00:14:21,679
oh shoot,

387
00:14:21,760 --> 00:14:26,239
I now have a 4th number that I want to store or just bought a 4th sweater or a

388
00:14:26,239 --> 00:14:29,200
4th person wants to get in line or I want to add a 4th brand to my contacts,

389
00:14:29,280 --> 00:14:30,549
whatever the scenario might be,

390
00:14:30,679 --> 00:14:35,320
it stands to reason that ideally you would plop that 4th value right here in memory.

391
00:14:35,520 --> 00:14:36,830
That everything remains contiguous.

392
00:14:36,869 --> 00:14:37,979
You're still using an array.

393
00:14:38,109 --> 00:14:40,400
Your code doesn't really have to change except for the length.

394
00:14:40,469 --> 00:14:42,500
All for all intents and purposes,

395
00:14:42,510 --> 00:14:45,780
it's the same implementation using just a bit more memory.

396
00:14:45,989 --> 00:14:49,020
But recall that when you declare an array of a fixed size,

397
00:14:49,349 --> 00:14:50,619
you only are getting

398
00:14:51,070 --> 00:14:53,070
promised that chunk of memory,

399
00:14:53,150 --> 00:14:54,989
not necessarily more memory to the right,

400
00:14:55,150 --> 00:14:55,510
to the left,

401
00:14:55,599 --> 00:14:57,030
above or below conceptually,

402
00:14:57,109 --> 00:14:59,299
because recall in the context of your whole computer,

403
00:14:59,429 --> 00:15:00,989
you've got this canvas of memory,

404
00:15:01,150 --> 00:15:03,859
all of which Represent here bytes and there could be a

405
00:15:03,859 --> 00:15:06,969
whole bunch of actual values or garbage values in memory.

406
00:15:07,059 --> 00:15:11,289
So in a more complicated program that 123 sure might end up here,

407
00:15:11,419 --> 00:15:13,890
but if I also had created a string in this program,

408
00:15:14,059 --> 00:15:18,460
H E L 00 world might have also ended up right next to it in memory,

409
00:15:18,539 --> 00:15:21,179
which means I can't just plop the four here because then

410
00:15:21,179 --> 00:15:23,419
if I'm still using that string elsewhere in my program,

411
00:15:23,460 --> 00:15:25,380
now it's going to say hello world instead

412
00:15:25,380 --> 00:15:27,900
of hello world because you're just claiming.

413
00:15:27,979 --> 00:15:29,770
The H that bye as your own,

414
00:15:29,809 --> 00:15:32,239
which does not in fact belong to your array.

415
00:15:32,489 --> 00:15:35,929
Of course it looks like there's plenty of other memory I could use

416
00:15:35,929 --> 00:15:39,640
here because these garbage values represented by Oscar are not being used.

417
00:15:39,729 --> 00:15:40,719
They've been used in the past,

418
00:15:40,809 --> 00:15:44,159
but we treat garbage values as memory we could reuse certainly.

419
00:15:44,450 --> 00:15:46,909
So wouldn't it be nice to maybe just plop the 123,

420
00:15:46,929 --> 00:15:49,849
and 4 in this chunk of memory over here?

421
00:15:49,960 --> 00:15:51,260
And I can totally do that.

422
00:15:51,289 --> 00:15:52,849
But of course if I want to do that,

423
00:15:52,929 --> 00:15:54,130
I've got to copy the first.

424
00:15:54,219 --> 00:15:58,200
3 values over and then put the 4th 1 there and then presumably

425
00:15:58,200 --> 00:16:01,510
give back to the operating system the memory I no longer need.

426
00:16:01,719 --> 00:16:06,669
So that in fact when using arrays is a perfectly valid solution

427
00:16:06,830 --> 00:16:10,039
and I think we can go ahead and do this in our same program.

428
00:16:10,119 --> 00:16:11,950
So let me go back to VS code here

429
00:16:11,950 --> 00:16:16,700
and instead of statically allocating memory for this array,

430
00:16:16,840 --> 00:16:18,549
and by static I mean literally hard coding,

431
00:16:18,849 --> 00:16:20,469
coding the number 3 here

432
00:16:20,799 --> 00:16:22,119
in a way that is permanent.

433
00:16:22,419 --> 00:16:23,440
Effectively,

434
00:16:23,690 --> 00:16:25,359
let me go ahead and do this instead.

435
00:16:25,450 --> 00:16:26,679
At the top of my code,

436
00:16:26,890 --> 00:16:31,239
let me delete the static allocation of that that array before,

437
00:16:31,489 --> 00:16:32,640
and now let me

438
00:16:33,250 --> 00:16:35,090
leverage my understanding,

439
00:16:35,200 --> 00:16:39,479
if still preliminary of pointers and memory management from this past week for

440
00:16:39,479 --> 00:16:43,520
to just dynamically allocate a guess at how much memory I need initially.

441
00:16:43,729 --> 00:16:48,104
So I'm going to go ahead and Use Malloch and allocate space for 3 integers,

442
00:16:48,145 --> 00:16:50,085
but integers take up a few bytes,

443
00:16:50,224 --> 00:16:51,465
and it usually is 4,

444
00:16:51,505 --> 00:16:52,304
but just for good measure,

445
00:16:52,315 --> 00:16:57,174
I'm going to say times whatever the size of an in is is the total number of bytes I want.

446
00:16:57,304 --> 00:16:59,674
So presumably it's going to be 3 times 4 equals 12,

447
00:16:59,734 --> 00:17:00,934
but I'm generalizing it.

448
00:17:01,184 --> 00:17:05,385
But then recall that Mao returns the address of that chunk of memory,

449
00:17:05,405 --> 00:17:06,625
the address of the first byte.

450
00:17:07,030 --> 00:17:11,479
So if I want to create an array effectively called list,

451
00:17:11,650 --> 00:17:13,880
I can't just do in list

452
00:17:14,209 --> 00:17:15,319
like this yet,

453
00:17:15,530 --> 00:17:17,020
but what I could say is that all right,

454
00:17:17,030 --> 00:17:17,719
now

455
00:17:18,050 --> 00:17:22,160
my list variable is actually going to be the address of an integer

456
00:17:22,368 --> 00:17:25,540
and set Mao's return value equal to that.

457
00:17:25,770 --> 00:17:26,618
So in code here,

458
00:17:26,650 --> 00:17:28,520
what I've done is I'm asking on the right hand side,

459
00:17:28,530 --> 00:17:29,400
the operating system,

460
00:17:29,530 --> 00:17:32,739
please give me 12 contiguous bytes in memory.

461
00:17:33,050 --> 00:17:33,449
All of those.

462
00:17:33,623 --> 00:17:36,432
Of course it can be numerically addressed like OX123,

463
00:17:36,442 --> 00:17:36,973
124,

464
00:17:36,983 --> 00:17:37,572
125.

465
00:17:37,583 --> 00:17:39,243
We've had that story before.

466
00:17:39,652 --> 00:17:40,572
Mallock by definition,

467
00:17:40,762 --> 00:17:42,662
returns the address of the first such byte,

468
00:17:42,772 --> 00:17:45,963
and it's on me to remember that I allocated 12 if need be.

469
00:17:46,133 --> 00:17:48,873
So I'm just storing the address of that first bye

470
00:17:49,133 --> 00:17:50,243
in a pointer

471
00:17:50,412 --> 00:17:51,662
called List.

472
00:17:51,932 --> 00:17:53,532
But recall from last week

473
00:17:53,853 --> 00:17:57,322
there's this functional equivalence we saw between

474
00:17:57,772 --> 00:18:00,213
treating a pointer as an array and

475
00:18:00,416 --> 00:18:01,965
Sometimes even treating an array

476
00:18:02,316 --> 00:18:03,365
like a pointer,

477
00:18:03,436 --> 00:18:06,456
the C language sort of lets us do this,

478
00:18:06,515 --> 00:18:07,336
this conversion,

479
00:18:07,345 --> 00:18:07,845
if you will.

480
00:18:08,015 --> 00:18:11,965
So what I could do here now is quite the same syntax as before.

481
00:18:12,176 --> 00:18:15,326
I could say Libra 0

482
00:18:15,536 --> 00:18:16,135
gets 1,

483
00:18:16,215 --> 00:18:17,666
Libra 1 gets 2,

484
00:18:17,735 --> 00:18:19,686
Libra 2 gets 3.

485
00:18:19,816 --> 00:18:24,156
And even though I have this fancy new line inspired by week 4,

486
00:18:24,255 --> 00:18:26,735
the syntax thereafter can be exactly the same.

487
00:18:27,569 --> 00:18:28,119
Why

488
00:18:28,290 --> 00:18:32,079
we'll recall that these three lines here using square bracket notation

489
00:18:32,079 --> 00:18:35,119
is just syntactic sugar for the stuff we learned last week.

490
00:18:35,400 --> 00:18:36,180
Specifically,

491
00:18:36,489 --> 00:18:38,920
I could instead of doing list 0,

492
00:18:39,089 --> 00:18:41,760
I could much more arcanely say go to

493
00:18:42,089 --> 00:18:45,530
that address in list and put the number 1 there,

494
00:18:45,550 --> 00:18:46,079
please.

495
00:18:46,250 --> 00:18:47,119
I can say

496
00:18:47,489 --> 00:18:49,680
go to the address list

497
00:18:50,010 --> 00:18:50,729
plus 1.

498
00:18:50,854 --> 00:18:52,714
And put the value 2 there.

499
00:18:52,875 --> 00:18:56,594
I could then say finally go to the address at list + 2

500
00:18:56,805 --> 00:18:58,435
and put the number 3 there,

501
00:18:58,685 --> 00:19:02,114
but this looks ridiculous and even sort of an experienced

502
00:19:02,114 --> 00:19:03,805
programmer might not be inclined to do this if with

503
00:19:03,805 --> 00:19:07,045
using fewer keystrokes and more readable code they could just

504
00:19:07,045 --> 00:19:09,045
do instead what I did the first time around,

505
00:19:09,125 --> 00:19:10,994
which is functionally the same,

506
00:19:11,204 --> 00:19:14,255
and just treat that chunk of memory as though it's an array.

507
00:19:14,510 --> 00:19:17,170
And the computer will essentially do

508
00:19:17,170 --> 00:19:19,510
the requisite pointer arithmetic to figure out

509
00:19:19,739 --> 00:19:21,010
where to put 12,

510
00:19:21,099 --> 00:19:21,770
and 3.

511
00:19:21,939 --> 00:19:24,780
So even though this is still kind of fresh hot off the press from last week,

512
00:19:24,859 --> 00:19:27,530
it's exactly the same as we tinkered with last week.

513
00:19:28,420 --> 00:19:33,050
So suppose now that some time passes and I realize

514
00:19:33,050 --> 00:19:34,739
for the sake of the story that oh shoot,

515
00:19:34,819 --> 00:19:37,170
I need more than 3 integers.

516
00:19:37,180 --> 00:19:40,650
I need space for 4 so as to achieve this picture in memory.

517
00:19:40,859 --> 00:19:40,939
Well,

518
00:19:41,060 --> 00:19:42,979
I could of course just like delete all that code,

519
00:19:43,060 --> 00:19:44,020
change the 3 to a 4,

520
00:19:44,060 --> 00:19:45,020
redo the whole thing,

521
00:19:45,140 --> 00:19:46,099
recompile the code,

522
00:19:46,180 --> 00:19:46,739
rerun it,

523
00:19:46,750 --> 00:19:47,239
but

524
00:19:47,540 --> 00:19:49,449
let me propose that we write our code in a way

525
00:19:49,449 --> 00:19:52,859
that allows us to change our mind while the program is running

526
00:19:53,140 --> 00:19:54,569
how much memory we actually need.

527
00:19:54,589 --> 00:19:55,300
And case in point,

528
00:19:55,339 --> 00:19:56,140
if you meet someone new,

529
00:19:56,219 --> 00:19:57,569
you want to add them to your phone,

530
00:19:57,739 --> 00:19:57,810
well,

531
00:19:57,819 --> 00:19:57,979
you.

532
00:19:58,064 --> 00:20:01,214
Obviously don't want to have to wait for Apple to recompile the Contacts app,

533
00:20:01,295 --> 00:20:03,484
reboot your phone just to add one more person.

534
00:20:03,655 --> 00:20:06,765
You want the program just to ask the operating system for

535
00:20:07,094 --> 00:20:08,915
more memory for that new person.

536
00:20:09,094 --> 00:20:09,704
So in this case,

537
00:20:09,814 --> 00:20:11,844
let's just pretend that some time passes and

538
00:20:12,135 --> 00:20:14,295
now I want to go ahead and actually change my

539
00:20:14,295 --> 00:20:18,444
mind and instead allocate space for 4 integers instead.

540
00:20:18,655 --> 00:20:20,564
While I could do something like this,

541
00:20:20,614 --> 00:20:27,724
I could just say literally list equals Mao of 4 times size of in.

542
00:20:28,750 --> 00:20:29,459
Semicolon.

543
00:20:29,550 --> 00:20:34,099
I don't need to redeclare list on line 13 because it already exists from line 5,

544
00:20:34,510 --> 00:20:35,989
but this is bad.

545
00:20:36,920 --> 00:20:40,310
Because what have I done wrong here in line 13?

546
00:20:41,000 --> 00:20:41,800
I've made a poor decision,

547
00:20:41,839 --> 00:20:41,920
yeah,

548
00:20:42,000 --> 00:20:42,439
in front.

549
00:20:46,579 --> 00:20:46,589
Yeah,

550
00:20:47,589 --> 00:20:49,310
I'm wasting all of the memory I had from

551
00:20:49,310 --> 00:20:52,540
line 5 because I'm essentially forgetting where it is.

552
00:20:52,589 --> 00:20:55,869
If the list pointer is literally a pointer,

553
00:20:55,910 --> 00:20:57,709
like a foam finger pointing somewhere in memory,

554
00:20:57,790 --> 00:21:00,619
what I'm really doing is saying point it over here now,

555
00:21:00,910 --> 00:21:04,099
but I've completely lost track of those other 3 integers in memory,

556
00:21:04,109 --> 00:21:06,670
and that's what we described last week as a memory leak which you could

557
00:21:06,670 --> 00:21:09,589
find with Valgrind and if you didn't find it or fix it in code,

558
00:21:09,719 --> 00:21:12,540
eventually the computer and the program would slow down over time.

559
00:21:12,630 --> 00:21:14,189
So this is probably bad.

560
00:21:14,270 --> 00:21:14,829
It's not good.

561
00:21:14,912 --> 00:21:16,983
To just unilaterally change your mind and say no,

562
00:21:17,022 --> 00:21:17,103
no,

563
00:21:17,142 --> 00:21:17,223
no,

564
00:21:17,542 --> 00:21:18,262
forget about that memory.

565
00:21:18,302 --> 00:21:19,302
Give me a new chunk of memory,

566
00:21:19,463 --> 00:21:23,863
especially if you want to copy the old memory into the new just like I did a bit

567
00:21:23,863 --> 00:21:29,172
ago when trying to get the 123 into the bigger chunk of memory that can fit 1234.

568
00:21:29,422 --> 00:21:30,453
So how might I do this?

569
00:21:30,493 --> 00:21:30,583
Well,

570
00:21:30,662 --> 00:21:32,652
a temporary variable is kind of our go to solution.

571
00:21:32,662 --> 00:21:35,373
Anytime we need to remember something in addition to

572
00:21:36,223 --> 00:21:37,772
something we already have in mind.

573
00:21:37,983 --> 00:21:42,383
So let me just give myself a temporary variable called TMP by convention for short.

574
00:21:42,696 --> 00:21:45,845
And set the return value of this mala call to that,

575
00:21:46,095 --> 00:21:48,635
and then what I could do is something like this,

576
00:21:48,855 --> 00:21:50,645
much like my print statement earlier,

577
00:21:50,895 --> 00:21:54,296
I could do another 4 loop and say 4 into I equals 0.

578
00:21:54,375 --> 00:21:56,286
I is less than 3,

579
00:21:56,595 --> 00:21:57,536
I plus plus,

580
00:21:57,576 --> 00:21:59,446
and then in this 4 loop I could say

581
00:21:59,725 --> 00:22:03,776
treat that new chunk of memory as an array like we can

582
00:22:03,776 --> 00:22:07,906
set the I location equal to the IF location in list.

583
00:22:08,255 --> 00:22:09,965
So these lines here.

584
00:22:10,760 --> 00:22:11,489
Copy

585
00:22:11,760 --> 00:22:14,439
old list into new list.

586
00:22:14,479 --> 00:22:16,660
It copies those first three values,

587
00:22:16,719 --> 00:22:20,030
and then what I bet I could do at the bottom here is then just manually,

588
00:22:20,199 --> 00:22:22,229
I can say go to the 4th location,

589
00:22:22,329 --> 00:22:27,469
which when you zero index is technically bracket 3 and set that equal to the number 4.

590
00:22:27,800 --> 00:22:29,630
So these lines here.

591
00:22:29,834 --> 00:22:30,505
Copy the 1,

592
00:22:30,545 --> 00:22:30,814
the 2,

593
00:22:30,864 --> 00:22:35,094
and the 3 using a loop and then line 20 here at the moment just adds the fourth value.

594
00:22:35,224 --> 00:22:37,625
And again this is a stupid sort of way to write

595
00:22:37,625 --> 00:22:39,935
code in that if you want to put the 4 there,

596
00:22:39,944 --> 00:22:40,944
you should have just done it earlier.

597
00:22:40,984 --> 00:22:43,814
I'm just pretending that some time has indeed passed in the program and

598
00:22:44,025 --> 00:22:47,025
I've changed my mind along the way and I want to let the user

599
00:22:47,385 --> 00:22:49,214
add some value to memory.

600
00:22:49,744 --> 00:22:50,194
OK,

601
00:22:50,425 --> 00:22:52,295
but before we proceed further,

602
00:22:52,505 --> 00:22:55,425
I dare say that there are some

603
00:22:56,250 --> 00:22:58,010
Other mistakes we should clean up.

604
00:22:58,170 --> 00:23:01,650
One of the lessons I preached last week was that any time you use Mallock,

605
00:23:02,170 --> 00:23:05,160
what should you do or check for?

606
00:23:06,719 --> 00:23:07,829
You should always what?

607
00:23:08,119 --> 00:23:09,040
You should always free.

608
00:23:09,119 --> 00:23:11,359
So here I'm clearly not freeing any memory,

609
00:23:11,439 --> 00:23:12,339
so I should definitely do that.

610
00:23:12,359 --> 00:23:14,630
And there was one other rule of thumb with memory.

611
00:23:14,839 --> 00:23:16,589
What should you always do

612
00:23:17,280 --> 00:23:17,959
when using male?

613
00:23:18,040 --> 00:23:18,239
Yeah.

614
00:23:20,349 --> 00:23:21,890
Check to see if null came back,

615
00:23:21,969 --> 00:23:23,680
which just means something is wrong,

616
00:23:23,729 --> 00:23:25,839
like it's out of memory or something else went wrong,

617
00:23:25,890 --> 00:23:26,890
and if you don't do that,

618
00:23:26,930 --> 00:23:30,560
your program may very well crash with one of those segmentation faults that we saw,

619
00:23:30,810 --> 00:23:31,000
uh,

620
00:23:31,010 --> 00:23:31,839
briefly in the past.

621
00:23:31,930 --> 00:23:34,199
So it makes the code a lot more bloated,

622
00:23:34,250 --> 00:23:35,089
but it is good practice.

623
00:23:35,170 --> 00:23:39,400
So let's just check if the list pointer I get back contains null,

624
00:23:39,609 --> 00:23:41,079
there's no point continuing on.

625
00:23:41,130 --> 00:23:42,260
Let's just go ahead and immediately.

626
00:23:42,435 --> 00:23:46,734
Return one because something has indeed gone wrong and then down here

627
00:23:46,984 --> 00:23:47,944
under Maoc again,

628
00:23:48,064 --> 00:23:48,854
let's do the same.

629
00:23:48,905 --> 00:23:51,854
If the temporary pointer also contains null,

630
00:23:52,145 --> 00:23:56,255
now let's go ahead and similarly return one or any other non-zero value.

631
00:23:56,305 --> 00:23:59,135
But here's the subtlety and let me combine your two ideas.

632
00:23:59,385 --> 00:24:04,954
If I immediately return one on line 20 after the second Mallock call fails,

633
00:24:05,224 --> 00:24:07,055
what should I still go back and do

634
00:24:07,625 --> 00:24:08,224
first?

635
00:24:09,979 --> 00:24:10,130
Yeah,

636
00:24:10,209 --> 00:24:11,609
you want to elaborate on your first instinct?

637
00:24:14,660 --> 00:24:14,890
Yeah,

638
00:24:14,969 --> 00:24:17,329
I want to still free the first chunk of memory

639
00:24:17,329 --> 00:24:19,920
because if we execute line 5 and all is well,

640
00:24:20,130 --> 00:24:21,689
which means that line 678,

641
00:24:21,699 --> 00:24:24,109
and 9 don't apply like it's not in fact nulled.

642
00:24:24,209 --> 00:24:25,760
We got back a legitimate value,

643
00:24:25,920 --> 00:24:30,219
that means we have a chunk of memory given to us for 3 integers,

644
00:24:30,290 --> 00:24:33,439
which means it still exists down here at line 19 and 20.

645
00:24:33,729 --> 00:24:38,680
So if I'm ready now to abort this program and return one to signify error,

646
00:24:38,849 --> 00:24:40,130
I first want to free.

647
00:24:40,189 --> 00:24:42,569
That original list and say to the operating system,

648
00:24:42,890 --> 00:24:43,930
Here's your memory back.

649
00:24:44,119 --> 00:24:44,250
Now,

650
00:24:44,260 --> 00:24:44,819
as an aside,

651
00:24:44,910 --> 00:24:45,489
strictly speaking,

652
00:24:45,540 --> 00:24:48,219
this is not necessary because the moment the program itself quits,

653
00:24:48,380 --> 00:24:51,979
the computer is just going to give back the memory to the operating system.

654
00:24:52,020 --> 00:24:53,060
So when programs quit,

655
00:24:53,219 --> 00:24:54,849
the memory leaks sort of go away,

656
00:24:54,979 --> 00:24:58,060
but your code is still buggy and generally we're running software

657
00:24:58,060 --> 00:25:00,219
that doesn't run for a split second but for minutes,

658
00:25:00,339 --> 00:25:00,739
hours,

659
00:25:00,930 --> 00:25:01,489
days,

660
00:25:01,819 --> 00:25:02,569
continually,

661
00:25:02,739 --> 00:25:05,540
in which case it's best practice to squash these memory.

662
00:25:05,839 --> 00:25:10,380
bugs now check for null free any memory so that you never indeed encounter

663
00:25:10,550 --> 00:25:11,709
these kinds of leaks.

664
00:25:11,939 --> 00:25:12,030
All right,

665
00:25:12,189 --> 00:25:14,099
so let's forge ahead a little bit more

666
00:25:14,349 --> 00:25:18,260
and let me propose that after we have done the copy,

667
00:25:18,469 --> 00:25:22,420
we now want to similarly free the original list.

668
00:25:22,630 --> 00:25:23,050
However,

669
00:25:23,189 --> 00:25:25,609
what I think we're going to want to do first is,

670
00:25:25,869 --> 00:25:28,939
after freeing the original list is remember

671
00:25:29,150 --> 00:25:31,199
that the new list is effectively.

672
00:25:32,250 --> 00:25:34,599
That which we allocated the second time around.

673
00:25:34,969 --> 00:25:36,689
So even though this program's getting a little long,

674
00:25:36,890 --> 00:25:38,579
notice that what I've just done is I've said,

675
00:25:38,750 --> 00:25:38,969
OK,

676
00:25:39,250 --> 00:25:42,250
store in the list variable the address of this new chunk of

677
00:25:42,250 --> 00:25:46,479
memory so that list now with a foam finger is effectively pointing here

678
00:25:47,050 --> 00:25:47,930
instead of up here.

679
00:25:47,969 --> 00:25:52,959
But before that I made sure to free what my finger was pointing at

680
00:25:53,489 --> 00:25:55,650
originally the list pointer.

681
00:25:56,349 --> 00:25:56,589
All right,

682
00:25:56,829 --> 00:25:57,189
lastly,

683
00:25:57,310 --> 00:25:59,180
let's just scroll down to the bottom of the code here.

684
00:25:59,349 --> 00:26:02,589
I can manually change the 3 to a 4 just to demonstrate that I've stored

685
00:26:02,589 --> 00:26:05,069
all 4 values in here and then at the very end of the program,

686
00:26:05,150 --> 00:26:08,219
I think I have to free the list again because now the list

687
00:26:08,219 --> 00:26:10,989
is pointing all the foam finger to the bigger chunk of memory,

688
00:26:11,000 --> 00:26:11,189
the one.

689
00:26:11,354 --> 00:26:15,364
234 and then I can go ahead and return 0 at the very end

690
00:26:15,814 --> 00:26:17,405
because all is hopefully

691
00:26:17,574 --> 00:26:18,564
well at this point.

692
00:26:18,895 --> 00:26:22,285
Let me go ahead and open my terminal window again and make this version of list.

693
00:26:22,655 --> 00:26:24,045
I made a lot of mistakes here,

694
00:26:24,055 --> 00:26:24,545
it seems.

695
00:26:24,655 --> 00:26:26,444
Let's scroll up to the very first

696
00:26:26,974 --> 00:26:29,614
call to undeclared library function mao.

697
00:26:31,869 --> 00:26:34,390
What have I apparently done wrong?

698
00:26:35,239 --> 00:26:36,219
Or forgotten

699
00:26:37,130 --> 00:26:37,689
What have I done wrong?

700
00:26:37,729 --> 00:26:37,810
Yeah,

701
00:26:37,969 --> 00:26:38,479
you back.

702
00:26:40,640 --> 00:26:40,869
Yeah,

703
00:26:40,989 --> 00:26:43,630
so in standard lib.h is where Mao is actually declared.

704
00:26:43,709 --> 00:26:44,939
So let's just add that quickly.

705
00:26:45,469 --> 00:26:47,880
Let's go ahead and include standard lib.h.

706
00:26:47,949 --> 00:26:49,439
In addition to standardio.h.

707
00:26:49,839 --> 00:26:50,979
Let me clear my terminal window,

708
00:26:51,109 --> 00:26:51,630
rerun,

709
00:26:51,829 --> 00:26:52,900
make list.

710
00:26:53,109 --> 00:26:55,920
Enter now we're good.list and phew,

711
00:26:55,989 --> 00:26:57,859
we see 1234.

712
00:26:58,069 --> 00:26:58,310
OK,

713
00:26:58,469 --> 00:26:59,979
so at this point in the story,

714
00:27:00,150 --> 00:27:02,199
all we've done is write a dopey little

715
00:27:02,199 --> 00:27:05,180
program that allocates memory for 3 integers 12,

716
00:27:05,189 --> 00:27:05,780
and 3,

717
00:27:06,010 --> 00:27:08,109
then changes our mind and allocates more memory.

718
00:27:08,371 --> 00:27:09,371
4 integers,

719
00:27:09,452 --> 00:27:12,572
freeing the original chunk of memory after copying the 1st 3

720
00:27:12,572 --> 00:27:16,362
integers into the new memory and adding that 4th value.

721
00:27:16,531 --> 00:27:17,972
But this is kind of a lot of hoops to

722
00:27:17,972 --> 00:27:20,411
jump through and let me propose one refinement here.

723
00:27:20,491 --> 00:27:21,921
So if back in VS code,

724
00:27:22,121 --> 00:27:23,732
we go back into list.c here,

725
00:27:23,741 --> 00:27:24,602
it turns out

726
00:27:24,891 --> 00:27:28,322
that at least this loop isn't strictly necessary,

727
00:27:28,531 --> 00:27:31,602
not to mention the fact that we already have another loop for just printing the list.

728
00:27:31,812 --> 00:27:35,082
If I want to more cleverly reallocate memory,

729
00:27:35,251 --> 00:27:35,741
it turns out.

730
00:27:35,803 --> 00:27:37,114
That there's another function that we didn't

731
00:27:37,114 --> 00:27:39,884
talk about last week but is in Stanlib.H2

732
00:27:40,154 --> 00:27:41,504
called Reallock,

733
00:27:41,713 --> 00:27:41,894
which,

734
00:27:41,984 --> 00:27:45,354
as the name kind of suggests it reallocates memory but a little smarter

735
00:27:45,673 --> 00:27:50,104
in that it will try to grow your existing chunk of memory if it can,

736
00:27:50,274 --> 00:27:51,793
which is going to be super efficient because then you

737
00:27:51,793 --> 00:27:53,433
can just plop the 4 at the very end.

738
00:27:53,443 --> 00:27:56,713
Or if there just isn't room there because maybe someone else

739
00:27:56,713 --> 00:27:59,663
put Hello world right there in memory elsewhere in your program,

740
00:27:59,874 --> 00:28:01,833
it's going to do all of the copying for you.

741
00:28:01,913 --> 00:28:03,323
So what you get back ultimately.

742
00:28:03,385 --> 00:28:09,086
A pointer to the new chunk of memory containing all of the original data as well.

743
00:28:09,416 --> 00:28:09,806
However,

744
00:28:09,895 --> 00:28:11,885
we're still going to have to check for null.

745
00:28:12,135 --> 00:28:14,086
We're still going to want to free the original

746
00:28:14,086 --> 00:28:16,326
list if something goes wrong and then return one.

747
00:28:16,576 --> 00:28:19,426
We're still going to want to add the 4th value because Realo

748
00:28:19,426 --> 00:28:21,845
has no idea what more we want to put in the list,

749
00:28:21,995 --> 00:28:25,135
but I can in fact delete my other 4 loop whose

750
00:28:25,135 --> 00:28:28,086
purpose in life was just to copy all of those integers

751
00:28:28,456 --> 00:28:30,245
from old into

752
00:28:30,495 --> 00:28:30,816
new.

753
00:28:31,349 --> 00:28:31,369
All right,

754
00:28:32,260 --> 00:28:33,050
that was a lot.

755
00:28:33,300 --> 00:28:35,010
Let me pause for any questions.

756
00:28:35,579 --> 00:28:39,140
How does realo know that it should reallocate the memory in least?

757
00:28:39,420 --> 00:28:40,609
shouldn't you tell like

758
00:28:41,020 --> 00:28:42,660
if you have a lot of mas before?

759
00:28:46,069 --> 00:28:46,719
Very good question.

760
00:28:46,760 --> 00:28:48,719
That's because I wrote a bug that we didn't trip

761
00:28:48,719 --> 00:28:50,510
over because I didn't compile this version of the code.

762
00:28:50,640 --> 00:28:53,449
So the question is how does Reallock know what toreallock?

763
00:28:53,520 --> 00:28:53,680
Well,

764
00:28:53,920 --> 00:28:54,829
according to the documentation,

765
00:28:54,920 --> 00:28:55,869
which I forgot to read,

766
00:28:56,040 --> 00:28:57,489
you need to tell Reallock

767
00:28:58,000 --> 00:29:02,109
what the address is of the chunk of memory that you do want to relock.

768
00:29:02,160 --> 00:29:03,719
So the first argument to re-allock,

769
00:29:03,770 --> 00:29:04,599
which I did admit.

770
00:29:04,946 --> 00:29:07,385
forget until a moment ago is to put

771
00:29:07,586 --> 00:29:09,995
the address of the chunk of memory that you already

772
00:29:09,995 --> 00:29:12,345
mallocked earlier so that it knows to go there,

773
00:29:12,595 --> 00:29:15,715
see if there's indeed some garbage values it can reclaim at the end of

774
00:29:15,715 --> 00:29:19,345
that chunk of memory or if it has to wholesale move things elsewhere in memory

775
00:29:19,515 --> 00:29:22,345
to give you 4 times the size of the end this time

776
00:29:22,796 --> 00:29:23,985
instead of just 3.

777
00:29:24,115 --> 00:29:24,645
But still,

778
00:29:24,755 --> 00:29:25,076
things can go.

779
00:29:25,161 --> 00:29:25,582
Wrong.

780
00:29:25,592 --> 00:29:27,271
Like you still want to check for this null

781
00:29:27,271 --> 00:29:29,102
value because reallock might not be able to give

782
00:29:29,102 --> 00:29:31,432
you enough memory or your memory could just be

783
00:29:31,432 --> 00:29:33,751
so fragmented that even though you want 4 bytes,

784
00:29:33,832 --> 00:29:35,192
maybe there's 3 bytes over here,

785
00:29:35,271 --> 00:29:36,031
2 bytes over here,

786
00:29:36,151 --> 00:29:37,222
1 bye over here.

787
00:29:37,391 --> 00:29:39,312
If there aren't 4 contiguous bytes,

788
00:29:39,432 --> 00:29:40,521
real lock 2

789
00:29:40,871 --> 00:29:43,822
could fail and it will return null to signify as much.

790
00:29:43,911 --> 00:29:45,871
Other questions on any of this?

791
00:29:48,949 --> 00:29:52,650
Why do we still need the temp variable for the same reasons as before?

792
00:29:52,770 --> 00:29:58,040
Because if we just say list equals real lock and something does go wrong,

793
00:29:58,140 --> 00:30:00,500
real lock by definition will return null

794
00:30:00,939 --> 00:30:02,489
but not touch the original memory,

795
00:30:02,699 --> 00:30:07,250
which case we have now lost track of where that original chunk of memory is,

796
00:30:07,420 --> 00:30:09,449
so we can never go back to it to print it,

797
00:30:09,459 --> 00:30:10,010
to change it,

798
00:30:10,020 --> 00:30:10,770
to free it.

799
00:30:10,979 --> 00:30:13,290
So we have to use this temporary variable here.

800
00:30:13,540 --> 00:30:14,329
Good question.

801
00:30:14,619 --> 00:30:15,060
Other questions,

802
00:30:15,099 --> 00:30:15,380
yeah.

803
00:30:19,900 --> 00:30:23,500
Is there a reason that we free list instead of temp?

804
00:30:23,719 --> 00:30:24,030
Uh,

805
00:30:24,280 --> 00:30:24,910
so let me,

806
00:30:25,040 --> 00:30:26,400
so down here or further down?

807
00:30:27,410 --> 00:30:27,729
OK,

808
00:30:27,969 --> 00:30:28,839
so further down,

809
00:30:28,930 --> 00:30:31,119
let me scroll down to where we came from.

810
00:30:31,729 --> 00:30:33,040
So here,

811
00:30:33,449 --> 00:30:36,449
after we've added this 4th value to temp,

812
00:30:36,890 --> 00:30:39,569
I've gone ahead and freed a list which at this point in

813
00:30:39,569 --> 00:30:42,569
the story is still pointing to the original chunk of memory,

814
00:30:42,599 --> 00:30:44,050
the 123.

815
00:30:44,060 --> 00:30:45,760
Then I am updating.

816
00:30:46,609 --> 00:30:47,160
List

817
00:30:47,410 --> 00:30:49,589
as a variable to point to the new chunk of memory.

818
00:30:49,770 --> 00:30:52,750
Then I'm doing my thing by printing out all of the integers therein.

819
00:30:53,000 --> 00:30:55,890
Then I am freeing what list is then pointing to.

820
00:30:55,930 --> 00:31:00,400
So I'm not technically freeing the same address in memory multiple times

821
00:31:00,739 --> 00:31:04,569
because I'm in the intervening time moving what list is pointing to.

822
00:31:08,140 --> 00:31:10,930
Absolutely,

823
00:31:11,140 --> 00:31:11,530
yes,

824
00:31:11,619 --> 00:31:13,729
it would be correct to go ahead down here

825
00:31:13,939 --> 00:31:15,979
and just say temp because temp is still in scope.

826
00:31:16,020 --> 00:31:17,449
It's still pointing at the same thing.

827
00:31:17,660 --> 00:31:20,819
I would just argue that that's semantically wrong because at this point

828
00:31:20,819 --> 00:31:24,180
in the code really list is the variable you care about.

829
00:31:24,300 --> 00:31:27,010
Temp was really meant to be a throwaway temporary variable,

830
00:31:27,180 --> 00:31:31,729
and you're asking for trouble if you use a temporary variable later than

831
00:31:32,020 --> 00:31:32,229
you,

832
00:31:32,260 --> 00:31:32,739
the programmer,

833
00:31:32,750 --> 00:31:33,189
intended.

834
00:31:33,260 --> 00:31:34,380
And if a colleague did that too,

835
00:31:34,500 --> 00:31:36,819
who knows what you've done with the temporary bolt in the meantime.

836
00:31:37,689 --> 00:31:38,680
Good questions.

837
00:31:38,969 --> 00:31:39,089
Yeah,

838
00:31:39,170 --> 00:31:39,650
in front.

839
00:31:41,699 --> 00:31:42,199
Always

840
00:31:42,489 --> 00:31:42,699
goes

841
00:31:43,780 --> 00:31:44,349
I like memories

842
00:31:46,729 --> 00:31:47,060
Correct.

843
00:31:47,109 --> 00:31:49,099
Reallock will try to give you more memory in the

844
00:31:49,099 --> 00:31:51,439
same location as before if there's room at the end.

845
00:31:56,920 --> 00:32:00,380
So reallock will do two potential things for you.

846
00:32:00,500 --> 00:32:02,729
So if the computer's memory looks like this,

847
00:32:02,859 --> 00:32:04,489
you're sort of out of luck because

848
00:32:05,000 --> 00:32:06,890
Reallock can't give you this bye.

849
00:32:07,099 --> 00:32:07,410
However,

850
00:32:07,459 --> 00:32:09,449
if it finds 4 bytes down here,

851
00:32:09,540 --> 00:32:10,209
for instance,

852
00:32:10,420 --> 00:32:13,530
Realo will not only allocate those 4 bytes for you,

853
00:32:13,780 --> 00:32:16,420
it will then copy the data for you over to it,

854
00:32:16,430 --> 00:32:18,060
which is wonderful because it just means we don't need

855
00:32:18,060 --> 00:32:20,020
an extra 4 loop all the time we do this.

856
00:32:22,000 --> 00:32:22,189
Yeah,

857
00:32:22,270 --> 00:32:22,859
in front.

858
00:32:27,319 --> 00:32:28,829
How does it know how much data to,

859
00:32:30,130 --> 00:32:30,140
uh,

860
00:32:30,160 --> 00:32:30,839
because how much,

861
00:32:31,000 --> 00:32:31,239
how does,

862
00:32:31,599 --> 00:32:35,540
how does Real know how much data to copy because the operating system,

863
00:32:35,560 --> 00:32:37,430
and you can think of it as the standard library,

864
00:32:37,560 --> 00:32:42,630
STDLIB.H keeps track of what memory has been allocated

865
00:32:43,280 --> 00:32:44,469
for you in the past.

866
00:32:44,719 --> 00:32:46,239
So when you pass in that same address,

867
00:32:46,319 --> 00:32:48,030
it knows it has essentially a lookup table,

868
00:32:48,119 --> 00:32:48,920
a dictionary if you will,

869
00:32:49,000 --> 00:32:51,319
that tells it what memory has been allocated already,

870
00:32:51,359 --> 00:32:52,550
so you don't have to worry about that.

871
00:32:53,560 --> 00:32:53,790
Yeah,

872
00:32:53,930 --> 00:32:54,500
in front.

873
00:33:01,300 --> 00:33:01,770
Good question.

874
00:33:01,810 --> 00:33:02,890
In other programming languages,

875
00:33:02,969 --> 00:33:04,969
you don't always have to declare the length of an array.

876
00:33:05,089 --> 00:33:06,880
Case in point Python coming next week.

877
00:33:07,250 --> 00:33:10,650
That is because someone else who invented that programming language

878
00:33:10,650 --> 00:33:12,250
wrote all of this kind of code for you.

879
00:33:12,290 --> 00:33:13,650
And indeed that's one of the goals with our

880
00:33:13,650 --> 00:33:16,130
transition between weeks 5 and 6 is to demonstrate

881
00:33:16,130 --> 00:33:18,449
that all of these problems are still being solved

882
00:33:18,449 --> 00:33:20,250
just not by you and not by me anymore.

883
00:33:20,290 --> 00:33:21,050
We're standing on the shoulder.

884
00:33:21,175 --> 00:33:23,964
Of other smart people who have invented not just new code

885
00:33:23,964 --> 00:33:27,084
but like a new language and a new compiler or as we'll

886
00:33:27,084 --> 00:33:29,405
see an interpreter for it so that we can hide all of

887
00:33:29,405 --> 00:33:31,994
these lower level details because honestly as you can see already,

888
00:33:32,064 --> 00:33:35,364
like this is an annoying number of lines of code just to have a conversation about

889
00:33:35,364 --> 00:33:40,285
the numbers 1234 in Python we could reduce this code to like two lines of code,

890
00:33:40,364 --> 00:33:41,275
one line of code.

891
00:33:41,805 --> 00:33:42,584
It's going to be fine.

892
00:33:42,925 --> 00:33:43,385
All right,

893
00:33:43,645 --> 00:33:44,604
so with that said,

894
00:33:45,630 --> 00:33:48,239
among the goals here was to demonstrate that there are a

895
00:33:48,239 --> 00:33:50,829
bunch of ways in which we can implement these data types,

896
00:33:50,839 --> 00:33:53,489
but let's talk more concretely about what we'll call data structures,

897
00:33:53,560 --> 00:33:56,079
which are concrete definitions of how you use the

898
00:33:56,079 --> 00:33:57,949
computer's memory to lay stuff out in memory,

899
00:33:58,000 --> 00:33:59,079
and using data structures,

900
00:33:59,119 --> 00:34:02,839
you can implement stacks and cues and dictionaries and all of these other things.

901
00:34:02,920 --> 00:34:06,400
So we're going to put into your toolkit today a whole bunch of canonical

902
00:34:06,400 --> 00:34:08,639
data structures that like every computer scientist

903
00:34:08,639 --> 00:34:10,489
does and should know that you want.

904
00:34:10,810 --> 00:34:12,909
Necessarily implement all of the time yourself,

905
00:34:13,120 --> 00:34:17,070
but when you use some feature of Python or Java or C++ or some other language,

906
00:34:17,270 --> 00:34:19,149
you are choosing among typically

907
00:34:19,360 --> 00:34:22,080
implementations of these data structures that someone else has written the

908
00:34:22,080 --> 00:34:25,520
code for so that you can just benefit from the functionality and

909
00:34:25,520 --> 00:34:28,478
the features thereof like that FIFO property we talked about or

910
00:34:28,478 --> 00:34:31,550
LIFO without having to get into the weeds too much yourself.

911
00:34:31,800 --> 00:34:33,310
So when it comes to

912
00:34:33,679 --> 00:34:34,958
data structures,

913
00:34:35,159 --> 00:34:36,478
let's consider that.

914
00:34:37,040 --> 00:34:40,489
We have at our disposal now a few new pieces of syntax and C,

915
00:34:40,500 --> 00:34:42,129
and we're going to add just one more today.

916
00:34:42,340 --> 00:34:44,659
We saw last week that we have the struct keyword,

917
00:34:44,679 --> 00:34:45,899
and we've seen that for a few weeks now.

918
00:34:45,958 --> 00:34:47,250
Whenever we want to invent

919
00:34:47,500 --> 00:34:49,050
our own data structure,

920
00:34:49,219 --> 00:34:50,610
we can use literally struct.

921
00:34:50,780 --> 00:34:53,540
We saw in the past that you can use the dot operator

922
00:34:53,540 --> 00:34:57,129
to actually go inside of a structure to get at a person's name

923
00:34:57,379 --> 00:34:58,250
or their number,

924
00:34:58,459 --> 00:35:00,750
and we saw last week the star operator.

925
00:35:00,812 --> 00:35:02,433
For dereferencing a pointer,

926
00:35:02,443 --> 00:35:06,232
de-referencing an address to actually go somewhere like inside of a structure.

927
00:35:06,522 --> 00:35:08,443
Wonderfully today we're going to see that you

928
00:35:08,443 --> 00:35:11,072
can actually in some cases combine the dot

929
00:35:11,072 --> 00:35:13,482
and the asterisk into a single operator with

930
00:35:13,482 --> 00:35:15,722
two characters that literally looks like an arrow,

931
00:35:15,732 --> 00:35:20,002
and that will help reflect the yellow and black drawings that we've done over the

932
00:35:20,002 --> 00:35:22,792
past couple of weeks where we have an arrow on the screen pointing somewhere.

933
00:35:23,083 --> 00:35:24,613
This literal arrow.

934
00:35:24,686 --> 00:35:27,095
Code is going to line up with that same concept.

935
00:35:27,305 --> 00:35:30,545
So let's introduce the first of our alternatives to arrays.

936
00:35:30,666 --> 00:35:32,815
An array again is a contiguous chunk of memory

937
00:35:32,815 --> 00:35:34,936
where the values are back to back to back.

938
00:35:35,186 --> 00:35:38,095
Among the upsides so fast because like all of the data is right there.

939
00:35:38,145 --> 00:35:41,145
We've seen since week 0 you can do binary search and just jump

940
00:35:41,145 --> 00:35:44,266
around randomly by just doing simple arithmetic to go to the middle,

941
00:35:44,305 --> 00:35:45,105
the middle of the middle,

942
00:35:45,345 --> 00:35:48,385
by just dividing by 2 a couple of times and rounding as needed.

943
00:35:48,750 --> 00:35:49,649
The problem with the arrays,

944
00:35:49,729 --> 00:35:50,320
to be clear,

945
00:35:50,530 --> 00:35:52,709
is that they are statically,

946
00:35:54,050 --> 00:35:57,120
they are statically allocated to be a specific size,

947
00:35:57,129 --> 00:35:57,840
maybe 3,

948
00:35:58,010 --> 00:35:58,610
maybe 4,

949
00:35:58,649 --> 00:36:00,090
but it is a finite value,

950
00:36:00,129 --> 00:36:02,090
which is problematic because look at all of the code we

951
00:36:02,090 --> 00:36:05,520
had to write just to resize these things again and again.

952
00:36:05,750 --> 00:36:05,850
Well,

953
00:36:05,889 --> 00:36:07,300
what if we sort of try to

954
00:36:07,489 --> 00:36:08,239
preempt

955
00:36:08,449 --> 00:36:09,600
that kind of pain

956
00:36:09,889 --> 00:36:10,360
and

957
00:36:10,689 --> 00:36:14,570
try to just build up a list by linking it together no matter where.

958
00:36:14,625 --> 00:36:17,084
the values actually are in memory and move away

959
00:36:17,084 --> 00:36:19,054
from this constraint that everything has to be contiguous.

960
00:36:19,135 --> 00:36:19,455
After all,

961
00:36:19,534 --> 00:36:20,685
as I said a moment ago,

962
00:36:21,044 --> 00:36:22,814
if the computer has plenty of memory here,

963
00:36:22,925 --> 00:36:23,185
here,

964
00:36:23,294 --> 00:36:23,564
here,

965
00:36:23,655 --> 00:36:24,125
here,

966
00:36:24,495 --> 00:36:27,284
that collectively is more than enough memory,

967
00:36:27,455 --> 00:36:31,435
but none of those individual chunks is quite as big as you need for an array,

968
00:36:31,614 --> 00:36:31,695
well,

969
00:36:31,774 --> 00:36:31,995
heck,

970
00:36:32,054 --> 00:36:35,965
let's at least try to leverage all of the available memory and stitch together

971
00:36:35,965 --> 00:36:38,375
the data structure as opposed to really

972
00:36:38,375 --> 00:36:40,385
holding firm this constraint that the array.

973
00:36:40,659 --> 00:36:42,530
Be back to back to back and contiguous.

974
00:36:42,729 --> 00:36:47,290
So a linked list is something you can now build using that syntax from last week and

975
00:36:47,290 --> 00:36:51,030
a bit more today in your same canvas of memory so that for the sake of discussion,

976
00:36:51,290 --> 00:36:51,899
suppose that

977
00:36:52,330 --> 00:36:55,360
we want to store first in our list the number one.

978
00:36:55,489 --> 00:36:55,530
Well,

979
00:36:55,570 --> 00:36:57,810
we all know already that it might very well exist at

980
00:36:57,810 --> 00:37:00,570
an address like OX 123 for the sake of discussion,

981
00:37:00,649 --> 00:37:01,719
but it's somewhere there.

982
00:37:02,024 --> 00:37:04,254
Suppose that you want to store a second value in memory,

983
00:37:04,415 --> 00:37:07,175
but you didn't think about it initially and so you weren't smart enough to put

984
00:37:07,175 --> 00:37:10,135
it like right next to the 1 and then the next value next to that.

985
00:37:10,175 --> 00:37:10,524
But

986
00:37:10,735 --> 00:37:14,054
you know somehow from Mao or similar functions that you could put the

987
00:37:14,054 --> 00:37:18,364
number 2 over here at addressOX 456 for the sake of discussion.

988
00:37:18,495 --> 00:37:19,205
And similarly,

989
00:37:19,215 --> 00:37:23,254
there's room for the number 3 over here at say address OX 789.

990
00:37:23,620 --> 00:37:26,699
So already we have a list of values in memory,

991
00:37:26,860 --> 00:37:29,129
but because they are not continuous,

992
00:37:29,340 --> 00:37:32,060
you can't just do some trivial plus plus trick to go from

993
00:37:32,060 --> 00:37:35,510
one to the other because they're differing numbers of bytes apart.

994
00:37:35,580 --> 00:37:37,949
They're not just back to back one bye.

995
00:37:38,500 --> 00:37:40,620
So what if we try to solve that problem?

996
00:37:40,979 --> 00:37:42,199
In the following way,

997
00:37:42,530 --> 00:37:44,040
instead of just using one byte

998
00:37:44,290 --> 00:37:45,389
for each of these values,

999
00:37:45,449 --> 00:37:48,580
let me waste a little bit of memory or spend a little bit of memory

1000
00:37:48,810 --> 00:37:51,610
and have some metadata associated with our data.

1001
00:37:51,669 --> 00:37:53,959
So data is value or values you care about.

1002
00:37:54,250 --> 00:37:56,679
Metadata is data that helps you maintain

1003
00:37:56,850 --> 00:37:58,239
the data you care about.

1004
00:37:58,419 --> 00:38:01,760
So let me propose that we use two chunks of memory for every value,

1005
00:38:02,040 --> 00:38:04,209
such that the top of each of those chunks represents.

1006
00:38:04,272 --> 00:38:06,292
Actual Verro you we care about 12,

1007
00:38:06,302 --> 00:38:07,413
and 3 respectively,

1008
00:38:07,702 --> 00:38:09,173
and you can perhaps see where this is going.

1009
00:38:09,383 --> 00:38:12,812
The second chunk of memory that I've allocated to each of these values

1010
00:38:13,183 --> 00:38:14,333
could perhaps be

1011
00:38:14,583 --> 00:38:16,373
a pointer to the next one,

1012
00:38:16,583 --> 00:38:18,143
a pointer to the next one.

1013
00:38:18,183 --> 00:38:19,012
And if this is the end,

1014
00:38:19,062 --> 00:38:20,663
we can put our old friend OX 0,

1015
00:38:20,702 --> 00:38:21,772
aka null,

1016
00:38:21,943 --> 00:38:25,482
and just treat that as the end of the list implicitly.

1017
00:38:25,702 --> 00:38:27,512
So even though these things could be any

1018
00:38:27,815 --> 00:38:33,535
in memory by just storing with each value the address of the next value in memory,

1019
00:38:33,635 --> 00:38:35,956
creating effectively a treasure map or bread crumbs,

1020
00:38:35,996 --> 00:38:37,666
however you want to think of it metaphorically,

1021
00:38:37,875 --> 00:38:39,946
we can get from one node

1022
00:38:40,236 --> 00:38:40,785
to the other.

1023
00:38:40,795 --> 00:38:43,385
And indeed that's going to be a term of art we start using a node,

1024
00:38:43,516 --> 00:38:48,035
it's just a generic structure that contains data and metadata usually like the

1025
00:38:48,035 --> 00:38:50,716
number you care about and a pointer to the next such node.

1026
00:38:51,280 --> 00:38:51,429
Um,

1027
00:38:51,479 --> 00:38:52,719
these are not to scale as an aside.

1028
00:38:52,800 --> 00:38:53,800
This is typically 4 bytes.

1029
00:38:53,840 --> 00:38:54,199
A pointer,

1030
00:38:54,209 --> 00:38:54,719
as we've discussed,

1031
00:38:54,770 --> 00:38:55,919
is technically 8 bytes,

1032
00:38:56,080 --> 00:38:59,350
but it just looks prettier to draw them as simple squares on the screen.

1033
00:38:59,800 --> 00:39:00,879
So what does this really mean?

1034
00:39:00,919 --> 00:39:01,000
Well,

1035
00:39:01,080 --> 00:39:02,340
who really cares about OX1,

1036
00:39:02,350 --> 00:39:04,040
23456789?

1037
00:39:04,159 --> 00:39:07,800
We can really think of this actually as being more of a picture with arrows,

1038
00:39:07,919 --> 00:39:10,520
but to keep track of this list of three values,

1039
00:39:10,679 --> 00:39:14,669
I do propose that we're going to need one additional value over here,

1040
00:39:14,679 --> 00:39:16,320
and it's deliberately just a single square.

1041
00:39:16,709 --> 00:39:19,330
Because to keep track of this list of three values,

1042
00:39:19,350 --> 00:39:21,060
I'm going to use just one variable

1043
00:39:21,270 --> 00:39:22,590
called say list

1044
00:39:22,909 --> 00:39:24,709
and store in that variable

1045
00:39:24,989 --> 00:39:26,860
a pointer as we defined it last week,

1046
00:39:26,989 --> 00:39:28,189
the address of the first node.

1047
00:39:28,310 --> 00:39:28,659
Why?

1048
00:39:28,790 --> 00:39:31,000
Because the first node can then get me to the second.

1049
00:39:31,030 --> 00:39:33,100
The second node can then get me to the 3rd,

1050
00:39:33,550 --> 00:39:34,500
and so forth.

1051
00:39:34,969 --> 00:39:36,040
So what's the upside now?

1052
00:39:36,080 --> 00:39:38,179
If I want a 4th value somewhere on the screen,

1053
00:39:38,280 --> 00:39:39,770
I could put it here,

1054
00:39:39,850 --> 00:39:39,949
here,

1055
00:39:40,030 --> 00:39:40,340
here,

1056
00:39:40,469 --> 00:39:40,659
here,

1057
00:39:40,719 --> 00:39:44,070
wherever there's enough room and just make sure that I

1058
00:39:44,070 --> 00:39:46,040
update the arrow to point to that next chunk,

1059
00:39:46,280 --> 00:39:47,560
update the arrow to point to the next chunk.

1060
00:39:47,679 --> 00:39:48,830
There's no copying of data.

1061
00:39:48,870 --> 00:39:49,229
12,

1062
00:39:49,239 --> 00:39:51,840
and 3 can stay there now forever until the program quits,

1063
00:39:51,850 --> 00:39:53,189
and we do actually free it,

1064
00:39:53,320 --> 00:39:54,409
but we can just keep adding,

1065
00:39:54,600 --> 00:39:54,840
adding,

1066
00:39:54,909 --> 00:39:55,159
adding,

1067
00:39:55,199 --> 00:39:56,070
or growing

1068
00:39:56,479 --> 00:39:57,459
this data structure

1069
00:39:57,600 --> 00:39:58,469
in memory.

1070
00:39:58,989 --> 00:39:59,760
So that

1071
00:39:59,909 --> 00:40:01,780
is what the world knows as

1072
00:40:02,149 --> 00:40:05,209
a linked list in Python to which you were essentially

1073
00:40:05,209 --> 00:40:08,229
alluding a list in Python is indeed a linked list.

1074
00:40:08,270 --> 00:40:10,030
Other languages call these vectors,

1075
00:40:10,149 --> 00:40:13,659
but they are essentially arrays that can be grown and shrunken

1076
00:40:14,040 --> 00:40:14,820
automatically,

1077
00:40:15,030 --> 00:40:17,659
effectively without you having to worry quite as much about it.

1078
00:40:17,870 --> 00:40:19,709
So how does the code for implementing something?

1079
00:40:19,770 --> 00:40:20,350
This work.

1080
00:40:20,360 --> 00:40:20,669
Well,

1081
00:40:20,879 --> 00:40:24,919
let me propose that we have this familiar friend of a person which we

1082
00:40:24,919 --> 00:40:29,030
claimed in past weeks has a name and a number associated with them.

1083
00:40:29,159 --> 00:40:33,550
We know from last week that strings are not technically a thing in C as a keyword,

1084
00:40:33,760 --> 00:40:35,040
so that's technically just char,

1085
00:40:35,050 --> 00:40:35,550
star,

1086
00:40:35,780 --> 00:40:36,560
name and number,

1087
00:40:36,600 --> 00:40:37,870
but same idea otherwise,

1088
00:40:38,040 --> 00:40:40,520
and this is what we defined in the past as a person.

1089
00:40:40,850 --> 00:40:42,800
So this is a structure we've seen before.

1090
00:40:42,879 --> 00:40:45,719
I now need to implement the code equivalent of these rectangles,

1091
00:40:45,800 --> 00:40:47,110
each of which has an integer,

1092
00:40:47,320 --> 00:40:50,189
and then a pointer to the next such value.

1093
00:40:50,399 --> 00:40:53,129
So let me propose that we delete what's inside this structure,

1094
00:40:53,320 --> 00:40:55,080
change the name from person to node,

1095
00:40:55,129 --> 00:40:58,120
which again is a generic term for a container of values,

1096
00:40:58,199 --> 00:41:01,469
and let me propose that inside of this new node structure

1097
00:41:01,469 --> 00:41:04,000
we put literally an in for the number we care about.

1098
00:41:04,159 --> 00:41:06,310
There's going to be my 123 or 4,

1099
00:41:06,560 --> 00:41:07,030
and then,

1100
00:41:07,080 --> 00:41:08,590
and this is a little bit

1101
00:41:09,120 --> 00:41:09,600
new.

1102
00:41:10,310 --> 00:41:13,560
Let's include in this structure a pointer

1103
00:41:14,040 --> 00:41:14,979
to the next

1104
00:41:15,229 --> 00:41:16,280
such node.

1105
00:41:16,649 --> 00:41:18,439
It's a pointer in the sense that it's an arrow.

1106
00:41:18,479 --> 00:41:19,840
It's the address of the next node,

1107
00:41:19,919 --> 00:41:21,750
so that's why we say node star.

1108
00:41:21,919 --> 00:41:23,110
I could call it anything I want,

1109
00:41:23,159 --> 00:41:25,280
but semantically calling it next makes perfect

1110
00:41:25,280 --> 00:41:26,790
sense because it's the next such node.

1111
00:41:26,959 --> 00:41:29,679
But this isn't quite right for annoying technical reasons.

1112
00:41:29,719 --> 00:41:31,590
I need to do one other thing here.

1113
00:41:31,879 --> 00:41:32,959
I need to technically,

1114
00:41:33,070 --> 00:41:34,330
and we've not done this before,

1115
00:41:34,560 --> 00:41:35,590
put the name,

1116
00:41:35,919 --> 00:41:38,080
give a temporary name to the structure,

1117
00:41:38,120 --> 00:41:38,750
if you will.

1118
00:41:38,959 --> 00:41:40,719
So literally say struct node here,

1119
00:41:40,800 --> 00:41:42,290
even though I've already said node here.

1120
00:41:42,439 --> 00:41:42,870
Why?

1121
00:41:43,209 --> 00:41:47,199
Because I technically need to change this line to say struct node star.

1122
00:41:47,649 --> 00:41:48,330
Long story short,

1123
00:41:48,449 --> 00:41:49,219
why is this necessary?

1124
00:41:49,320 --> 00:41:52,530
We'll recall in the past C and the compiler reads your code top to bottom,

1125
00:41:52,610 --> 00:41:53,360
left to right.

1126
00:41:53,570 --> 00:41:53,689
Well,

1127
00:41:53,810 --> 00:41:55,560
if we in a previous version of this code,

1128
00:41:55,729 --> 00:41:57,280
we use the word node here,

1129
00:41:57,449 --> 00:42:00,320
but the compiler never sees the word node until down here.

1130
00:42:00,449 --> 00:42:03,179
Like it's just not going to compile because the word literally doesn't exist.

1131
00:42:03,250 --> 00:42:04,479
We saw this with functions in the past,

1132
00:42:04,530 --> 00:42:05,090
so with the solution.

1133
00:42:05,169 --> 00:42:09,389
To that was to put the prototype higher up in the file and then it would compile OK.

1134
00:42:09,560 --> 00:42:13,189
You can think of this as somewhat analogous whereby if I give this structure

1135
00:42:13,439 --> 00:42:15,389
a name on this first line,

1136
00:42:15,560 --> 00:42:17,350
even if it's redundant to this one,

1137
00:42:17,600 --> 00:42:19,989
then I can say struck node inside of these

1138
00:42:19,989 --> 00:42:23,629
curly braces because the compiler has already seen the word

1139
00:42:23,919 --> 00:42:24,989
node there.

1140
00:42:25,320 --> 00:42:27,120
So just you have to do it this way.

1141
00:42:27,469 --> 00:42:29,850
So now that we have this in code,

1142
00:42:30,219 --> 00:42:34,770
we can kind of start playing around with actually storing these things

1143
00:42:35,060 --> 00:42:35,879
in memory.

1144
00:42:35,979 --> 00:42:37,489
So let me propose that

1145
00:42:37,820 --> 00:42:40,500
we go ahead and do this by transitioning back to BS

1146
00:42:40,500 --> 00:42:44,389
code here and let's instead of using our array-based implementation,

1147
00:42:44,580 --> 00:42:46,419
let's implement the first of our link lists,

1148
00:42:46,429 --> 00:42:47,629
and I'm going to be a bit

1149
00:42:48,139 --> 00:42:48,649
extreme and

1150
00:42:49,050 --> 00:42:51,239
pretty much everything inside of Maine.

1151
00:42:51,409 --> 00:42:54,290
I am for convenience now going to include the CS 50 library,

1152
00:42:54,370 --> 00:42:56,090
not so much for the Charar thing,

1153
00:42:56,129 --> 00:42:56,520
but

1154
00:42:56,850 --> 00:42:57,159
because,

1155
00:42:57,169 --> 00:42:58,080
as we discussed last week,

1156
00:42:58,090 --> 00:43:02,209
it's still useful for getting ins and getting strings and other things which unless

1157
00:43:02,209 --> 00:43:05,800
you use ScanF are much harder and more annoying to get and see.

1158
00:43:06,010 --> 00:43:08,530
So let's go ahead and do this outside of Maine,

1159
00:43:08,770 --> 00:43:09,850
let's go ahead and invent.

1160
00:43:10,320 --> 00:43:11,149
this node

1161
00:43:11,600 --> 00:43:12,830
called struck node here.

1162
00:43:12,959 --> 00:43:17,189
Then inside of my curly braces we'll give every such node a number and

1163
00:43:17,479 --> 00:43:19,550
every such node a pointer

1164
00:43:19,840 --> 00:43:21,360
to the next such node,

1165
00:43:21,370 --> 00:43:24,229
and we'll call this whole thing node by convention.

1166
00:43:24,479 --> 00:43:25,479
Then inside of Main,

1167
00:43:25,600 --> 00:43:27,669
let's go ahead and do this one step at a time.

1168
00:43:27,879 --> 00:43:31,040
Let me propose that to create a linked list initially it's empty.

1169
00:43:31,320 --> 00:43:33,510
So how do I represent an empty linked list?

1170
00:43:33,550 --> 00:43:33,959
Well,

1171
00:43:34,149 --> 00:43:36,979
I could call the variable list and set it equal to null,

1172
00:43:37,229 --> 00:43:40,189
but what is the data type for a linked list?

1173
00:43:40,469 --> 00:43:40,590
Well,

1174
00:43:40,790 --> 00:43:42,780
per the picture that we had up earlier,

1175
00:43:42,989 --> 00:43:46,350
insofar as all we need is a single pointer.

1176
00:43:46,584 --> 00:43:50,854
At far left here to represent the address of the first node in the list.

1177
00:43:51,104 --> 00:43:52,895
I dare say all we need to say

1178
00:43:53,104 --> 00:43:55,655
is that our list is of type node star.

1179
00:43:55,864 --> 00:43:56,304
That is to say,

1180
00:43:56,385 --> 00:43:57,195
what is the link list?

1181
00:43:57,225 --> 00:43:57,304
Well,

1182
00:43:57,344 --> 00:43:58,104
it's by definition,

1183
00:43:58,145 --> 00:44:01,375
the address of the first node in the list.

1184
00:44:02,929 --> 00:44:04,879
So that's the first subtlety here.

1185
00:44:05,169 --> 00:44:08,169
So that gives me a picture with no other nodes.

1186
00:44:08,209 --> 00:44:10,679
It just gives me a single pointer initialized to null.

1187
00:44:10,899 --> 00:44:13,959
Now let's go ahead and for parity with the previous example,

1188
00:44:14,129 --> 00:44:15,729
just do something 3 times.

1189
00:44:15,810 --> 00:44:19,159
So in this 4 loop structured exactly as before,

1190
00:44:19,419 --> 00:44:21,209
let's go ahead and allocate.

1191
00:44:21,290 --> 00:44:21,989
New node.

1192
00:44:22,280 --> 00:44:24,830
Ask the user for a number to put inside of it,

1193
00:44:25,159 --> 00:44:27,919
and then start stitching things together so as to

1194
00:44:27,919 --> 00:44:30,510
achieve a picture in memory quite like this.

1195
00:44:30,840 --> 00:44:31,719
So how am I going to do this?

1196
00:44:31,879 --> 00:44:31,939
Well,

1197
00:44:32,060 --> 00:44:33,600
first I need to allocate a new node.

1198
00:44:33,679 --> 00:44:34,469
How do I do that?

1199
00:44:34,639 --> 00:44:34,679
Well,

1200
00:44:34,760 --> 00:44:38,550
I can use our new friend Mallock and allocate the size of

1201
00:44:38,959 --> 00:44:39,870
a node.

1202
00:44:40,360 --> 00:44:43,790
I want to store the address of this chunk of memory somewhere,

1203
00:44:44,000 --> 00:44:46,350
and what I'm going to propose is that we have a temporary variable,

1204
00:44:46,360 --> 00:44:47,810
and I'll call this in.

1205
00:44:48,179 --> 00:44:50,320
Which whose type is that

1206
00:44:50,649 --> 00:44:52,100
of a node star.

1207
00:44:52,409 --> 00:44:53,560
So what am I doing here?

1208
00:44:53,729 --> 00:44:56,239
I'm trying to build up this list in memory

1209
00:44:56,610 --> 00:44:57,280
so that

1210
00:44:57,530 --> 00:44:59,379
I first have a pointer

1211
00:44:59,810 --> 00:45:00,840
to the list.

1212
00:45:01,010 --> 00:45:03,760
I first have a pointer that is null pointing nowhere.

1213
00:45:03,889 --> 00:45:05,080
No list exists.

1214
00:45:05,290 --> 00:45:08,399
I then want to go ahead and create one new node,

1215
00:45:09,080 --> 00:45:10,169
store value in it.

1216
00:45:10,550 --> 00:45:13,290
And then point my list at that node.

1217
00:45:13,500 --> 00:45:14,810
Then I want to do it again

1218
00:45:15,060 --> 00:45:17,209
and again a total of 3 times.

1219
00:45:17,419 --> 00:45:18,489
So how do we do this?

1220
00:45:18,620 --> 00:45:20,979
We allocate space for the size of a node,

1221
00:45:21,100 --> 00:45:22,729
however many bytes that's going to be.

1222
00:45:22,840 --> 00:45:26,659
It's probably going to be 12 because it's 4 for the end and 8 for the pointer,

1223
00:45:26,699 --> 00:45:27,439
but who cares?

1224
00:45:27,520 --> 00:45:29,510
size of will answer that question for me.

1225
00:45:29,699 --> 00:45:32,250
I'm going to store the address of this chunk of memory

1226
00:45:32,739 --> 00:45:35,570
inside of a temporary variable called N for node,

1227
00:45:35,860 --> 00:45:37,929
and that's why it has to be node star,

1228
00:45:38,139 --> 00:45:40,139
because it's going to be pointing to.

1229
00:45:40,429 --> 00:45:41,560
An actual node.

1230
00:45:41,699 --> 00:45:42,979
I'm gonna do my quick sanity check.

1231
00:45:43,060 --> 00:45:45,129
So if N equals equals null,

1232
00:45:45,379 --> 00:45:46,659
we can't proceed further.

1233
00:45:46,699 --> 00:45:48,889
I'm going to go ahead and just return one right now.

1234
00:45:49,020 --> 00:45:50,899
So that's just sort of boilerplate code you should be

1235
00:45:50,899 --> 00:45:53,149
in the habit of doing any time you're using Malock.

1236
00:45:53,379 --> 00:45:54,610
But if all goes well,

1237
00:45:54,899 --> 00:45:55,780
let's do this.

1238
00:45:56,030 --> 00:45:57,489
Let's go to

1239
00:45:57,820 --> 00:45:59,300
the address in N.

1240
00:46:00,010 --> 00:46:02,229
And then go inside of that node

1241
00:46:02,479 --> 00:46:05,719
and change its number to be whatever the human wants it to be

1242
00:46:05,719 --> 00:46:08,790
by using get in and just prompt the human for their favorite number.

1243
00:46:09,199 --> 00:46:15,040
Then let's go to that same node and update the next field to equal for now

1244
00:46:15,040 --> 00:46:18,810
null because all I want to do is allocate one new node with that number.

1245
00:46:18,850 --> 00:46:19,360
That's it.

1246
00:46:20,699 --> 00:46:21,310
Then

1247
00:46:21,560 --> 00:46:23,709
I'm gonna need to stitch this together further.

1248
00:46:24,320 --> 00:46:27,350
So I'll propose that all we need to do,

1249
00:46:27,639 --> 00:46:28,949
and let's clean this up first,

1250
00:46:29,199 --> 00:46:33,580
is now make sure that we string these nodes together.

1251
00:46:34,000 --> 00:46:36,389
This syntax isn't quite right because technically,

1252
00:46:36,639 --> 00:46:40,399
because of precedents I need to oops I need to.

1253
00:46:41,340 --> 00:46:41,629
Uh,

1254
00:46:41,739 --> 00:46:44,129
de-reference N and then go inside of it.

1255
00:46:44,379 --> 00:46:46,939
I need to de-reference N and then go inside of it.

1256
00:46:47,060 --> 00:46:47,610
However,

1257
00:46:47,860 --> 00:46:48,419
this syntax,

1258
00:46:48,500 --> 00:46:51,570
if it's looking a little overwhelming and you have no idea now what's going on,

1259
00:46:51,899 --> 00:46:54,209
thankfully in C there's much simpler syntax,

1260
00:46:54,300 --> 00:46:55,209
which is this

1261
00:46:55,659 --> 00:46:58,409
go to the node and go inside it to get the number.

1262
00:46:58,739 --> 00:47:01,050
Go to the node and go inside it to get next.

1263
00:47:01,149 --> 00:47:01,540
So the.

1264
00:47:01,679 --> 00:47:04,010
The arrow notation that I promised we would now have

1265
00:47:04,219 --> 00:47:05,250
is the same thing

1266
00:47:05,459 --> 00:47:06,929
as using the star operator,

1267
00:47:06,939 --> 00:47:08,209
the Dreference operator,

1268
00:47:08,379 --> 00:47:09,340
parenthesizing it,

1269
00:47:09,379 --> 00:47:10,479
then the dot operator,

1270
00:47:10,500 --> 00:47:12,649
which is just a pain in the neck to write out all the time.

1271
00:47:12,780 --> 00:47:16,989
I dare say narrow number and narrow next is just much simpler.

1272
00:47:17,080 --> 00:47:18,820
It says go to N and point at

1273
00:47:18,939 --> 00:47:22,050
the number field or the next field respectively.

1274
00:47:22,580 --> 00:47:23,209
All right,

1275
00:47:23,899 --> 00:47:24,370
so

1276
00:47:24,540 --> 00:47:26,020
the last thing I'm going to propose we do,

1277
00:47:26,030 --> 00:47:28,929
and then we'll make this much more clear in picture form as this,

1278
00:47:29,179 --> 00:47:30,939
let's go ahead and prepended.

1279
00:47:32,030 --> 00:47:35,899
The node to the list and by prepent I mean insert it at the beginning,

1280
00:47:36,020 --> 00:47:36,969
insert it at the beginning,

1281
00:47:37,139 --> 00:47:38,929
insert it at the beginning again and again.

1282
00:47:39,179 --> 00:47:40,090
I'm going to say

1283
00:47:40,209 --> 00:47:40,629
n

1284
00:47:40,830 --> 00:47:42,489
next equals list,

1285
00:47:42,780 --> 00:47:45,169
then update the list to set equal

1286
00:47:45,500 --> 00:47:46,169
to n.

1287
00:47:46,459 --> 00:47:47,850
And then after all of this mess,

1288
00:47:47,899 --> 00:47:49,250
I'm going to return 0.

1289
00:47:49,500 --> 00:47:49,739
OK,

1290
00:47:49,820 --> 00:47:50,979
this was a huge amount of code,

1291
00:47:51,060 --> 00:47:52,179
but let me give you a quick recap,

1292
00:47:52,300 --> 00:47:53,580
then we'll paint a picture.

1293
00:47:54,340 --> 00:47:55,969
Here is my list initially,

1294
00:47:56,139 --> 00:47:57,699
so the foam finger is pointing to null,

1295
00:47:57,780 --> 00:47:59,500
which means the list is of size 0.

1296
00:47:59,540 --> 00:48:00,209
There's nothing there.

1297
00:48:00,290 --> 00:48:02,330
Then I asked the computer to do this 3 times.

1298
00:48:02,540 --> 00:48:04,290
Give me enough memory for a new node.

1299
00:48:04,620 --> 00:48:04,909
Then,

1300
00:48:05,060 --> 00:48:06,389
after checking that it's not null,

1301
00:48:06,780 --> 00:48:08,770
put the user's favorite number in it

1302
00:48:09,100 --> 00:48:11,850
and update the next field for the moment to null.

1303
00:48:12,379 --> 00:48:13,060
Then lastly,

1304
00:48:13,179 --> 00:48:16,810
go ahead and prepend this brand new node to the existing list,

1305
00:48:16,820 --> 00:48:17,330
and by pre

1306
00:48:17,620 --> 00:48:18,979
prepended I mean put it at the front.

1307
00:48:19,540 --> 00:48:19,929
So

1308
00:48:20,060 --> 00:48:22,969
N at this moment is pointing to that new node,

1309
00:48:23,179 --> 00:48:23,629
and I'm saying,

1310
00:48:23,699 --> 00:48:24,209
you know what,

1311
00:48:24,560 --> 00:48:26,729
whatever the current list is,

1312
00:48:26,899 --> 00:48:28,050
empty or otherwise,

1313
00:48:28,500 --> 00:48:30,370
set the next pointer

1314
00:48:30,739 --> 00:48:31,929
equal to the list,

1315
00:48:32,100 --> 00:48:33,449
whatever that list is,

1316
00:48:33,620 --> 00:48:36,020
and then change the list to point at this new node.

1317
00:48:36,639 --> 00:48:39,540
So now let's do this more carefully step by step

1318
00:48:39,790 --> 00:48:41,060
in picture form.

1319
00:48:41,270 --> 00:48:42,989
So I'm going to propose that we go

1320
00:48:42,989 --> 00:48:45,669
through some of these representative lines as follows.

1321
00:48:45,790 --> 00:48:47,550
Here is the first line of code,

1322
00:48:47,590 --> 00:48:48,939
even without the assignment.

1323
00:48:49,149 --> 00:48:51,340
If you just allocate a variable called list

1324
00:48:51,590 --> 00:48:52,939
that's a pointer to a node,

1325
00:48:53,070 --> 00:48:55,820
what you essentially have is a box of memory that looks like this.

1326
00:48:55,860 --> 00:48:58,135
It's a Garbage value though because there's no assignment operator,

1327
00:48:58,175 --> 00:48:59,925
so who knows what's inside of this pointer.

1328
00:49:00,094 --> 00:49:03,054
That is why in my actual code I set it equal to null,

1329
00:49:03,294 --> 00:49:05,814
which effectively creates in memory the same box but gets rid

1330
00:49:05,814 --> 00:49:08,375
of Oscar the Grouch and puts the null value there.

1331
00:49:08,455 --> 00:49:10,125
So we know it's not a garbage value,

1332
00:49:10,165 --> 00:49:12,354
it's a pointer known as null.

1333
00:49:12,574 --> 00:49:15,495
So that's what that very first line of code did in the computer's memory.

1334
00:49:15,820 --> 00:49:17,280
The next thing I wanted to do

1335
00:49:17,489 --> 00:49:20,169
was allocate enough memory for a node,

1336
00:49:20,510 --> 00:49:22,169
not a node star for a whole node.

1337
00:49:22,209 --> 00:49:24,399
I want that whole chunk of a rectangle

1338
00:49:24,689 --> 00:49:25,760
given to me in memory.

1339
00:49:26,050 --> 00:49:28,520
That's going to return to me the address of the first byte thereof,

1340
00:49:28,689 --> 00:49:30,840
and I'm going to store that in a temporary variable called N.

1341
00:49:31,010 --> 00:49:32,100
So at this point in the story,

1342
00:49:32,169 --> 00:49:32,570
N

1343
00:49:32,929 --> 00:49:34,429
is going to be a pointer of its own,

1344
00:49:34,689 --> 00:49:36,129
another box that initially.

1345
00:49:36,340 --> 00:49:37,449
It is going to be a garbage value,

1346
00:49:37,489 --> 00:49:39,800
but because I am using the assignment operator,

1347
00:49:40,050 --> 00:49:41,520
it's going to point to

1348
00:49:41,850 --> 00:49:43,929
that chunk of memory which Mao,

1349
00:49:44,169 --> 00:49:44,879
if successful,

1350
00:49:44,969 --> 00:49:47,600
presumably allocated for me in the computer's memory.

1351
00:49:47,850 --> 00:49:49,479
So N for all intents and purposes,

1352
00:49:49,489 --> 00:49:50,090
points

1353
00:49:50,570 --> 00:49:52,350
at that same chunk.

1354
00:49:52,689 --> 00:49:55,449
These values are still garbage values because it's just a chunk of memory.

1355
00:49:55,489 --> 00:49:56,770
Who knows what it's been used before.

1356
00:49:57,290 --> 00:50:00,929
But that's why after this line of code I took care to get

1357
00:50:00,929 --> 00:50:04,199
an in from the user and then initialize the next pointer to null.

1358
00:50:04,449 --> 00:50:04,929
So for instance,

1359
00:50:04,969 --> 00:50:05,879
for the sake of discussion,

1360
00:50:05,949 --> 00:50:07,610
let's get rid of get in for the picture and

1361
00:50:07,610 --> 00:50:10,280
just say the human typed in the number 1 initially.

1362
00:50:10,449 --> 00:50:10,570
Well,

1363
00:50:10,580 --> 00:50:11,530
that's equivalent

1364
00:50:11,929 --> 00:50:17,129
to putting the 1 in the number field by first going to the address of inn.

1365
00:50:17,649 --> 00:50:21,729
And then dereferencing it using the star and the dot notation respectively.

1366
00:50:21,840 --> 00:50:26,989
So that means follow the arrow and then change number to the value 1.

1367
00:50:27,199 --> 00:50:28,389
Then the next line of code.

1368
00:50:28,919 --> 00:50:29,459
Or rather,

1369
00:50:29,540 --> 00:50:32,570
or equivalently you can just do the same thing and thankfully now C

1370
00:50:32,570 --> 00:50:35,929
syntax lines up with what the pictures look like we've been drawing.

1371
00:50:36,179 --> 00:50:36,719
Go to N,

1372
00:50:37,239 --> 00:50:39,169
follow the arrow to the number field.

1373
00:50:39,280 --> 00:50:41,389
That's literally what the syntax is telling me.

1374
00:50:41,679 --> 00:50:42,080
Meanwhile,

1375
00:50:42,199 --> 00:50:45,330
if I use that same syntax again for narrow next,

1376
00:50:45,560 --> 00:50:46,610
set it equal to null,

1377
00:50:46,830 --> 00:50:47,879
that's like saying go to N,

1378
00:50:48,280 --> 00:50:49,000
follow the arrow,

1379
00:50:49,010 --> 00:50:51,250
and change the next field in this case to null,

1380
00:50:51,320 --> 00:50:53,159
or we'll just blank it out to be clear.

1381
00:50:53,689 --> 00:50:56,709
So at this point in the story we have allocated the node,

1382
00:50:56,919 --> 00:50:59,350
we have stored 1 and null there.

1383
00:50:59,639 --> 00:51:00,669
List is still null.

1384
00:51:00,879 --> 00:51:01,949
N is pointing to this,

1385
00:51:02,040 --> 00:51:05,320
but the whole point of this exercise is to add this node to the list.

1386
00:51:05,399 --> 00:51:07,469
So we need to somehow update this value,

1387
00:51:07,719 --> 00:51:11,469
which is why ultimately I'm going to do something like list equals n.

1388
00:51:11,719 --> 00:51:13,810
Now that seems a little weird semantically,

1389
00:51:13,879 --> 00:51:15,320
but recall that N is a point.

1390
00:51:15,629 --> 00:51:16,780
That is the address

1391
00:51:17,090 --> 00:51:19,580
pointing at OX 123 or wherever that is.

1392
00:51:19,909 --> 00:51:22,139
So to point list at the same node,

1393
00:51:22,250 --> 00:51:25,070
it's equivalent to setting list equal to N

1394
00:51:25,310 --> 00:51:28,340
because then we'll effectively have an arrow identical

1395
00:51:28,709 --> 00:51:30,979
from list pointing at that new node.

1396
00:51:31,110 --> 00:51:33,260
And at this point I don't even care what N is anymore.

1397
00:51:33,270 --> 00:51:35,060
It was always meant to be a temporary value.

1398
00:51:35,350 --> 00:51:37,020
This now is my list.

1399
00:51:37,310 --> 00:51:41,360
So even though I did it in code already preemptively in a loop,

1400
00:51:41,610 --> 00:51:45,300
the first iteration for that loop literally created this in memory.

1401
00:51:46,229 --> 00:51:47,139
Let me pause

1402
00:51:47,439 --> 00:51:49,370
before we go through numbers 2 and 3

1403
00:51:49,830 --> 00:51:50,820
for any questions.

1404
00:51:52,639 --> 00:51:54,360
Because the VS code version looks scary,

1405
00:51:54,399 --> 00:51:56,389
this is perhaps a little more bite sized.

1406
00:51:58,169 --> 00:51:58,179
No,

1407
00:51:58,840 --> 00:51:59,790
OK,

1408
00:52:00,000 --> 00:52:04,310
so how about we do this twice more for 2 and 3 respectively.

1409
00:52:04,520 --> 00:52:05,350
So again,

1410
00:52:05,360 --> 00:52:07,610
inside of our loop we're back to this line which asks the

1411
00:52:07,610 --> 00:52:09,909
operating system for enough memory for the size of a node,

1412
00:52:10,159 --> 00:52:13,320
stores that address temporarily in a variable called N.

1413
00:52:13,760 --> 00:52:16,070
So here's our friend Oscar brought back onto the screen.

1414
00:52:16,320 --> 00:52:18,110
Maybe the new chunk of memory is over there.

1415
00:52:18,239 --> 00:52:21,389
This effectively points N at that chunk of memory.

1416
00:52:21,639 --> 00:52:24,199
The next line of code inside of that loop that's relevant is this,

1417
00:52:24,280 --> 00:52:27,159
and we'll get rid of get in to just pretend that I literally typed in 2.

1418
00:52:27,969 --> 00:52:29,979
We're going to go to this version of N,

1419
00:52:30,290 --> 00:52:31,199
follow the arrow,

1420
00:52:31,409 --> 00:52:32,600
go to the number field,

1421
00:52:32,610 --> 00:52:33,919
and set that equal to 2.

1422
00:52:34,090 --> 00:52:35,810
The next line of code we start at the end,

1423
00:52:36,010 --> 00:52:36,840
follow the arrow,

1424
00:52:37,010 --> 00:52:39,199
change the next field to null,

1425
00:52:39,449 --> 00:52:41,520
and then same lines as before,

1426
00:52:41,770 --> 00:52:43,340
we now need to update.

1427
00:52:44,554 --> 00:52:45,554
equaling n,

1428
00:52:45,635 --> 00:52:47,344
but something's about to go wrong here.

1429
00:52:47,594 --> 00:52:50,754
If I update list to point to the same node

1430
00:52:51,074 --> 00:52:52,395
that N is pointing at,

1431
00:52:52,514 --> 00:52:53,735
watch what happens.

1432
00:52:53,875 --> 00:52:55,864
I set list equal to that,

1433
00:52:56,485 --> 00:52:57,405
and because it's temporary,

1434
00:52:57,495 --> 00:52:59,004
might as well go away at this point,

1435
00:52:59,114 --> 00:52:59,514
but.

1436
00:53:01,000 --> 00:53:03,669
What have I done wrong logically here?

1437
00:53:04,659 --> 00:53:05,340
Yeah.

1438
00:53:07,149 --> 00:53:07,340
Yeah,

1439
00:53:07,389 --> 00:53:09,409
I lost the arrow to the original node.

1440
00:53:09,459 --> 00:53:13,020
I have orphaned the first node because now nothing

1441
00:53:13,020 --> 00:53:15,060
in my code is actually pointing at it.

1442
00:53:15,139 --> 00:53:18,770
I've got in duplication two pointers pointing at this chunk of memory,

1443
00:53:18,939 --> 00:53:19,459
so this thing,

1444
00:53:19,570 --> 00:53:21,570
even though we obviously as humans can still see it,

1445
00:53:21,739 --> 00:53:23,500
we have lost track and code of where it is,

1446
00:53:23,540 --> 00:53:25,129
which means that is the definition of a me.

1447
00:53:25,459 --> 00:53:25,760
leak.

1448
00:53:25,800 --> 00:53:27,639
I can never get that back or give it back

1449
00:53:27,639 --> 00:53:30,360
to the operating system until the program itself finally quits.

1450
00:53:30,479 --> 00:53:34,270
So I think I need to be a little smarter and not do this line quite like this yet.

1451
00:53:34,639 --> 00:53:35,750
I think what I want to do,

1452
00:53:35,760 --> 00:53:36,639
and I've rewound,

1453
00:53:36,840 --> 00:53:41,189
so list is still pointing to the original list and is pointing to only the new node.

1454
00:53:41,399 --> 00:53:43,320
What I think we need to do is something like this.

1455
00:53:43,830 --> 00:53:47,360
And this is why the code was fairly non-obvious in VS code at first.

1456
00:53:47,699 --> 00:53:48,489
Go to N,

1457
00:53:48,979 --> 00:53:49,969
follow the arrow,

1458
00:53:50,139 --> 00:53:51,100
go to the next field,

1459
00:53:51,179 --> 00:53:54,729
and here's the cleverness point this pointer

1460
00:53:55,139 --> 00:53:57,110
to the existing list's value.

1461
00:53:57,219 --> 00:53:59,169
So if the existing list is pointing here,

1462
00:53:59,379 --> 00:53:59,899
that just means,

1463
00:53:59,939 --> 00:54:00,139
hey,

1464
00:54:00,219 --> 00:54:02,409
point this to the exact same thing

1465
00:54:02,820 --> 00:54:03,929
because now

1466
00:54:04,300 --> 00:54:06,620
I can safely update the list.

1467
00:54:07,080 --> 00:54:09,020
To point at the same thing as n,

1468
00:54:09,189 --> 00:54:10,709
so its arrow now points here,

1469
00:54:10,750 --> 00:54:12,459
but even when I get rid of N,

1470
00:54:12,870 --> 00:54:16,260
I wonderfully have the whole thing stitched together.

1471
00:54:16,469 --> 00:54:18,750
And the metaphor I often think of is like around Christmas

1472
00:54:18,750 --> 00:54:21,060
time and olden times when people would like stitch popcorn together.

1473
00:54:21,110 --> 00:54:22,550
That's what you're kind of doing with a thread here.

1474
00:54:22,560 --> 00:54:25,830
You're trying to stitch together these nodes or popcorn kernels,

1475
00:54:25,870 --> 00:54:26,459
if you will,

1476
00:54:26,709 --> 00:54:28,820
such that one can lead you to the next,

1477
00:54:28,909 --> 00:54:29,790
can lead you to the next,

1478
00:54:29,899 --> 00:54:30,939
can lead you to the next,

1479
00:54:31,070 --> 00:54:33,310
but you can never let go of part of that strand.

1480
00:54:33,790 --> 00:54:35,070
In the process.

1481
00:54:35,419 --> 00:54:39,459
So here now we have a list which is great because notice we haven't touched the 1,

1482
00:54:39,500 --> 00:54:40,489
but we've added the 2.

1483
00:54:40,620 --> 00:54:42,100
We can go ahead in a moment and add the 3,

1484
00:54:42,179 --> 00:54:43,649
but you can perhaps see where this is going.

1485
00:54:43,820 --> 00:54:45,899
I'm kind of doing it backwards by accident,

1486
00:54:45,979 --> 00:54:47,090
but we'll get there soon.

1487
00:54:47,300 --> 00:54:49,530
So now let's allocate a new node,

1488
00:54:49,699 --> 00:54:51,780
run through in our mind's eye all of those same steps.

1489
00:54:51,820 --> 00:54:54,889
I'm going to hopefully end up with a list that now looks like this.

1490
00:54:55,020 --> 00:54:56,790
And even though it's kind of long and stringy,

1491
00:54:56,939 --> 00:54:58,729
these values could be anywhere in memory,

1492
00:54:58,780 --> 00:55:00,459
but because of these various pointers,

1493
00:55:00,520 --> 00:55:01,889
I can jump from one.

1494
00:55:02,750 --> 00:55:03,340
to the other,

1495
00:55:03,469 --> 00:55:06,100
making more efficient use of everything

1496
00:55:06,669 --> 00:55:08,419
inside of the computer's own memory.

1497
00:55:08,979 --> 00:55:09,110
All right,

1498
00:55:09,229 --> 00:55:10,820
but of course we've got this symptom

1499
00:55:10,989 --> 00:55:14,590
that didn't really intend whereby the whole darn thing is backwards,

1500
00:55:14,750 --> 00:55:17,419
but I think that's kind of OK for now.

1501
00:55:17,620 --> 00:55:21,310
But I'd like to propose that we consider how we can now maybe traverse this thing

1502
00:55:21,510 --> 00:55:23,790
and actually print out the values in memory.

1503
00:55:23,870 --> 00:55:25,229
So let me go ahead and

1504
00:55:25,709 --> 00:55:27,000
do this.

1505
00:55:27,429 --> 00:55:30,330
Let's go ahead and how about

1506
00:55:31,040 --> 00:55:31,929
Let's say,

1507
00:55:32,090 --> 00:55:33,550
let's go back to VS code here.

1508
00:55:33,800 --> 00:55:34,959
So at this point in the story,

1509
00:55:35,000 --> 00:55:37,550
we've got the same code that implements that same idea,

1510
00:55:37,629 --> 00:55:41,000
except I'm using Get in just so that I can dynamically type in the 1,

1511
00:55:41,040 --> 00:55:41,300
the 2,

1512
00:55:41,360 --> 00:55:44,429
and the 3 without having to hard code it into the actual code.

1513
00:55:44,639 --> 00:55:46,909
Suppose that after doing this exercise,

1514
00:55:46,919 --> 00:55:47,260
I

1515
00:55:47,655 --> 00:55:49,524
want to do something interesting like

1516
00:55:49,774 --> 00:55:50,925
print the numbers.

1517
00:55:50,935 --> 00:55:51,054
Well,

1518
00:55:51,094 --> 00:55:52,844
we don't have that code yet

1519
00:55:53,094 --> 00:55:54,524
in this version of my

1520
00:55:54,975 --> 00:55:55,324
program.

1521
00:55:55,495 --> 00:55:56,405
So let's bring that back.

1522
00:55:56,495 --> 00:55:59,665
Last time I did this just using a for loop and array notation,

1523
00:55:59,895 --> 00:56:01,084
and I think I can do that,

1524
00:56:01,094 --> 00:56:02,685
but let me propose first

1525
00:56:03,054 --> 00:56:03,645
that

1526
00:56:03,840 --> 00:56:06,270
I implement this idea pictorally.

1527
00:56:06,399 --> 00:56:07,399
Here's the same diagram.

1528
00:56:07,469 --> 00:56:09,100
This is what exists in the computer's memory.

1529
00:56:09,270 --> 00:56:11,510
If I want to go ahead and print out these numbers,

1530
00:56:11,550 --> 00:56:13,219
albeit in reverse order,

1531
00:56:13,530 --> 00:56:17,229
let me propose that we can do this by giving ourselves another temporary variable.

1532
00:56:17,239 --> 00:56:19,219
We'll call it PTR pointer for short,

1533
00:56:19,469 --> 00:56:21,850
and that's like having another foam finger that points at

1534
00:56:22,050 --> 00:56:23,030
The start of the list.

1535
00:56:23,080 --> 00:56:24,270
So it's not pointing at list,

1536
00:56:24,399 --> 00:56:26,909
it points at whatever list is pointing at,

1537
00:56:27,080 --> 00:56:28,030
which means here.

1538
00:56:28,320 --> 00:56:30,909
Then I can print out the 3 pretty easily so long

1539
00:56:30,909 --> 00:56:33,169
as I next update pointer to point to the 2,

1540
00:56:33,399 --> 00:56:33,949
print it out,

1541
00:56:34,159 --> 00:56:35,330
then point it to the 1,

1542
00:56:35,389 --> 00:56:36,040
print it out,

1543
00:56:36,199 --> 00:56:37,199
and eventually I'm going to realize,

1544
00:56:37,290 --> 00:56:37,429
oh,

1545
00:56:37,439 --> 00:56:39,239
I'm out of nodes because the end of this.

1546
00:56:39,479 --> 00:56:40,429
List is null.

1547
00:56:40,639 --> 00:56:43,469
So that's the idea I want to implement now logically in code,

1548
00:56:43,760 --> 00:56:46,229
create a temporary variable called pointer,

1549
00:56:46,439 --> 00:56:48,870
set it equal to whatever the list itself is.

1550
00:56:49,199 --> 00:56:50,149
Print out the value,

1551
00:56:50,439 --> 00:56:51,120
update the pointer,

1552
00:56:51,129 --> 00:56:51,929
print out the value,

1553
00:56:52,199 --> 00:56:52,770
update the pointer.

1554
00:56:52,840 --> 00:56:53,520
Print out the value,

1555
00:56:53,760 --> 00:56:54,469
update the pointer,

1556
00:56:54,719 --> 00:56:55,590
realize it's null,

1557
00:56:55,689 --> 00:56:56,520
and stop.

1558
00:56:56,949 --> 00:57:02,159
So in code it's a relatively small loop even though the syntax is still pretty new

1559
00:57:02,419 --> 00:57:04,729
since we've only just started playing with memory since last week.

1560
00:57:04,780 --> 00:57:06,780
But what I'm going to do is exactly what I proposed.

1561
00:57:06,860 --> 00:57:08,260
I'm going to create a new pointer

1562
00:57:08,820 --> 00:57:11,969
called PTR and set it equal to the list itself.

1563
00:57:12,179 --> 00:57:14,659
That's like having another foam finger temporarily pointing

1564
00:57:14,659 --> 00:57:16,510
at the first element in the list.

1565
00:57:16,780 --> 00:57:21,530
Then what I'm going to do is say while that temporary variable is not null,

1566
00:57:21,870 --> 00:57:22,820
go ahead.

1567
00:57:22,935 --> 00:57:24,175
And traverse

1568
00:57:24,445 --> 00:57:25,314
the list.

1569
00:57:25,524 --> 00:57:26,284
What do I mean by that?

1570
00:57:26,445 --> 00:57:26,495
Well,

1571
00:57:26,564 --> 00:57:28,885
let's go ahead and print out the current element in

1572
00:57:28,885 --> 00:57:32,655
the list by using percent I backslash N and printing out

1573
00:57:32,925 --> 00:57:34,794
whatever the pointer is pointing at,

1574
00:57:35,334 --> 00:57:37,155
specifically its number field.

1575
00:57:37,324 --> 00:57:39,754
So that is follow the arrow and print out the number.

1576
00:57:40,084 --> 00:57:40,514
Then

1577
00:57:40,925 --> 00:57:43,044
inside of this loop I'm going to update

1578
00:57:43,044 --> 00:57:45,514
after doing that my temporary variable called pointer

1579
00:57:45,764 --> 00:57:48,814
to be equal to pointer arrow next.

1580
00:57:49,139 --> 00:57:51,439
And that will have the effect with just those

1581
00:57:51,439 --> 00:57:56,189
few lines of code of implementing precisely this idea.

1582
00:57:56,360 --> 00:57:58,949
I first set pointer equal to the list,

1583
00:57:59,120 --> 00:58:00,870
which happens to point here first.

1584
00:58:01,080 --> 00:58:03,310
I then do my print F and then I update

1585
00:58:03,600 --> 00:58:04,669
the next field.

1586
00:58:04,979 --> 00:58:05,239
I rather,

1587
00:58:05,320 --> 00:58:08,510
I update pointer to be the value of pointer.

1588
00:58:08,879 --> 00:58:10,669
Follow the arrow next.

1589
00:58:10,959 --> 00:58:12,709
So if this is OX123,

1590
00:58:12,719 --> 00:58:13,239
for instance,

1591
00:58:13,360 --> 00:58:14,860
that is what is now in,

1592
00:58:15,239 --> 00:58:15,360
sorry,

1593
00:58:15,439 --> 00:58:17,469
if this is OX 456,

1594
00:58:17,679 --> 00:58:18,560
that is what's now in.

1595
00:58:19,090 --> 00:58:22,189
So the arrow effectively looks there in my for loop.

1596
00:58:22,229 --> 00:58:23,939
I print out with percent I this number,

1597
00:58:24,030 --> 00:58:24,620
and then

1598
00:58:24,870 --> 00:58:25,939
I go to the next field,

1599
00:58:26,189 --> 00:58:27,179
follow the arrow,

1600
00:58:27,350 --> 00:58:27,899
and then

1601
00:58:28,149 --> 00:58:29,379
set it equal to

1602
00:58:29,760 --> 00:58:30,239
rather

1603
00:58:30,790 --> 00:58:32,149
whatever this pointer is here,

1604
00:58:32,189 --> 00:58:33,500
OX 789,

1605
00:58:33,909 --> 00:58:35,000
set it equal to

1606
00:58:35,139 --> 00:58:36,100
the pointer there.

1607
00:58:36,350 --> 00:58:38,070
So I effectively move the arrow there.

1608
00:58:38,149 --> 00:58:42,669
Then lastly I update PTR to point to the value of this next field,

1609
00:58:42,709 --> 00:58:43,459
which is null,

1610
00:58:43,830 --> 00:58:45,909
which means effectively pointer itself is null,

1611
00:58:45,949 --> 00:58:48,270
which means the 4 loop cleverly.

1612
00:58:49,070 --> 00:58:54,530
Stops now because I was supposed to do this whole loop while pointer is not null,

1613
00:58:54,750 --> 00:58:56,659
but pointer is now null.

1614
00:58:56,939 --> 00:58:57,830
And just as an aside,

1615
00:58:57,909 --> 00:59:00,500
if you prefer the semantics of a 4 loop,

1616
00:59:00,550 --> 00:59:02,260
there's nothing new here per se.

1617
00:59:02,469 --> 00:59:05,399
I can do this exact same thing using a 4 loop

1618
00:59:05,709 --> 00:59:06,560
simply as follows,

1619
00:59:06,590 --> 00:59:08,760
and it's a little tighter to implement less follows.

1620
00:59:08,830 --> 00:59:09,899
I can say 4.

1621
00:59:10,189 --> 00:59:13,050
Instead of I equals 0 in that old approach,

1622
00:59:13,179 --> 00:59:15,919
I can actually use pointers in a 4 loop like this

1623
00:59:15,919 --> 00:59:19,810
for node star pointer equals the start of the list.

1624
00:59:20,179 --> 00:59:23,169
Keep doing something so long as pointer does not equal null,

1625
00:59:23,300 --> 00:59:24,939
and on each iteration of this loop,

1626
00:59:25,159 --> 00:59:26,000
update the pointer

1627
00:59:26,260 --> 00:59:29,889
to equal whatever the pointer's own next field is.

1628
00:59:30,020 --> 00:59:31,649
And then inside of this 4 loop,

1629
00:59:31,699 --> 00:59:34,669
print out using percent I backslash N,

1630
00:59:34,899 --> 00:59:36,300
the current pointer's number.

1631
00:59:36,620 --> 00:59:38,080
Field semicolon.

1632
00:59:38,300 --> 00:59:41,419
So here is where again we see the equivalent of 4 loops and wild loops.

1633
00:59:41,459 --> 00:59:42,100
What you can do with one,

1634
00:59:42,110 --> 00:59:43,010
you can do with the other.

1635
00:59:43,260 --> 00:59:45,540
This is a little more elegant in that you can express a

1636
00:59:45,540 --> 00:59:48,810
whole lot of logic in one line of the 4 loop.

1637
00:59:49,100 --> 00:59:49,620
Frankly,

1638
00:59:49,719 --> 00:59:52,870
I do think the first version is nonetheless more readable.

1639
00:59:53,020 --> 00:59:53,780
So let me undo,

1640
00:59:53,820 --> 00:59:54,060
undo,

1641
00:59:54,100 --> 00:59:54,300
undo,

1642
00:59:54,379 --> 00:59:56,790
undo everything I just did on the course's website.

1643
00:59:56,820 --> 00:59:58,189
You'll see both of these versions.

1644
00:59:58,340 --> 01:00:01,620
This one's a little more pedantic as to what it's doing step

1645
01:00:01,850 --> 01:00:02,379
by step.

1646
01:00:03,379 --> 01:00:03,659
OK,

1647
01:00:03,800 --> 01:00:04,739
that too is a lot.

1648
01:00:05,020 --> 01:00:07,090
Let me pause here to see if there are.

1649
01:00:08,189 --> 01:00:09,169
Any questions?

1650
01:00:11,790 --> 01:00:13,250
And if you're feeling like that fire hose,

1651
01:00:13,300 --> 01:00:15,620
like this is why we transitioned to Python where

1652
01:00:15,620 --> 01:00:17,409
all of this now gets swept under the rug,

1653
01:00:17,459 --> 01:00:17,810
but

1654
01:00:18,060 --> 01:00:18,899
it's still happening,

1655
01:00:18,979 --> 01:00:20,649
just not by us in a week.

1656
01:00:20,860 --> 01:00:21,260
Questions,

1657
01:00:21,340 --> 01:00:21,659
yeah.

1658
01:00:27,500 --> 01:00:27,810
Yeah,

1659
01:00:27,969 --> 01:00:28,689
really good question.

1660
01:00:28,770 --> 01:00:29,639
So we,

1661
01:00:30,250 --> 01:00:32,010
here I've been preaching like we don't want to lose memory.

1662
01:00:32,050 --> 01:00:33,199
We don't want to leak memory,

1663
01:00:33,290 --> 01:00:36,179
and here I am fairly extravagantly now spending twice

1664
01:00:36,179 --> 01:00:38,399
as much memory to maintain this data structure,

1665
01:00:38,600 --> 01:00:41,969
that's going to be among the themes with all of the data structures we talk about.

1666
01:00:42,010 --> 01:00:44,770
If we want to gain some benefit like

1667
01:00:44,770 --> 01:00:47,090
dynamic growth and shrinking of the data structure,

1668
01:00:47,169 --> 01:00:48,360
you've got to give me something,

1669
01:00:48,489 --> 01:00:51,840
and what you've got to give me in this case is the ability to use more space.

1670
01:00:52,250 --> 01:00:54,370
In a bit today and after a break in particular we're

1671
01:00:54,370 --> 01:00:57,304
going to we'd really like these algorithms to be faster.

1672
01:00:57,455 --> 01:00:57,524
Well,

1673
01:00:57,534 --> 01:00:58,044
that's fine,

1674
01:00:58,175 --> 01:01:00,044
but you're going to have to give me something in return.

1675
01:01:00,175 --> 01:01:02,655
You're going to have to spend more space to make the code faster.

1676
01:01:02,665 --> 01:01:05,774
And so time and space and financial cost and human

1677
01:01:05,774 --> 01:01:08,814
time and any number of other resources are all things that

1678
01:01:08,814 --> 01:01:11,334
you need to evaluate as a programmer or a manager and

1679
01:01:11,334 --> 01:01:14,225
decide which is least and or most important to you.

1680
01:01:14,254 --> 01:01:14,965
And right now

1681
01:01:15,294 --> 01:01:17,014
I don't care about space as much as I care

1682
01:01:17,014 --> 01:01:19,604
about the dynamism that I'm trying to solve first.

1683
01:01:19,935 --> 01:01:20,844
Other questions

1684
01:01:21,135 --> 01:01:21,524
on here,

1685
01:01:21,534 --> 01:01:21,784
yeah.

1686
01:01:24,010 --> 01:01:24,239
this point.

1687
01:01:27,389 --> 01:01:27,889
Yes,

1688
01:01:28,060 --> 01:01:29,780
why am I using Pointer instead of N?

1689
01:01:29,860 --> 01:01:30,260
I,

1690
01:01:30,340 --> 01:01:30,770
well,

1691
01:01:31,300 --> 01:01:31,500
yes,

1692
01:01:31,580 --> 01:01:33,060
I could reusen at this point.

1693
01:01:33,179 --> 01:01:35,739
I deliberately chose to use Pointer for two reasons.

1694
01:01:35,750 --> 01:01:35,909
One,

1695
01:01:35,979 --> 01:01:37,929
I'm using it for different reasons here.

1696
01:01:38,889 --> 01:01:39,219
Two,

1697
01:01:39,620 --> 01:01:42,860
it's not necessarily the best idea to use one variable here for

1698
01:01:42,860 --> 01:01:45,810
a specific purpose and then reuse the name down here besides,

1699
01:01:45,820 --> 01:01:47,590
it's out of scope at this point anyway.

1700
01:01:48,209 --> 01:01:49,620
So it just makes me feel better that

1701
01:01:49,620 --> 01:01:51,449
I have different variables doing different things,

1702
01:01:51,500 --> 01:01:53,580
but it would not break if I did it your way.

1703
01:01:54,139 --> 01:01:54,889
Other questions.

1704
01:01:56,459 --> 01:01:56,649
Yeah,

1705
01:01:56,729 --> 01:01:57,399
and back.

1706
01:01:59,830 --> 01:02:00,750
Are pointers temporary,

1707
01:02:00,790 --> 01:02:02,949
not necessarily like the linked list we are building

1708
01:02:02,949 --> 01:02:06,189
up in memory exists because we are using pointers

1709
01:02:06,189 --> 01:02:08,520
to build this data structure and to keep it

1710
01:02:08,520 --> 01:02:10,810
intact for as long as the program is running.

1711
01:02:11,030 --> 01:02:14,820
My temporary variables N and pointer PTR in this case,

1712
01:02:15,030 --> 01:02:15,979
those are ephemeral,

1713
01:02:15,989 --> 01:02:18,750
and I'm only using them to kind of stitch things together temporarily.

1714
01:02:20,239 --> 01:02:21,169
A good question.

1715
01:02:21,669 --> 01:02:21,800
All right,

1716
01:02:21,959 --> 01:02:23,879
so let's now motivate why we're spending so much

1717
01:02:23,879 --> 01:02:26,179
time sort of stitching these things together so carefully.

1718
01:02:26,320 --> 01:02:26,439
Well,

1719
01:02:26,479 --> 01:02:30,040
here's our little cheat sheet of common but not exhaustive running times.

1720
01:02:30,080 --> 01:02:32,639
Let's consider what the running time is for some fairly basic

1721
01:02:32,639 --> 01:02:35,449
stick operations like inserting a number into a linked list,

1722
01:02:35,719 --> 01:02:38,629
maybe searching for a number in the link list or traversing it,

1723
01:02:39,159 --> 01:02:42,040
and also deleting ultimately numbers in a linked list.

1724
01:02:42,080 --> 01:02:44,270
So here is my list initially,

1725
01:02:44,320 --> 01:02:45,030
completely empty,

1726
01:02:45,040 --> 01:02:46,919
and suppose I go ahead and insert the one.

1727
01:02:47,360 --> 01:02:48,540
Then I insert the 2,

1728
01:02:48,760 --> 01:02:51,270
then I insert the 3 using code like we just wrote.

1729
01:02:51,600 --> 01:02:53,750
I love this approach because even though

1730
01:02:54,040 --> 01:02:55,830
it looks a little scary at first,

1731
01:02:55,959 --> 01:02:59,850
this is probably the simplest way to implement insertion into a linked list.

1732
01:02:59,919 --> 01:03:00,310
Why?

1733
01:03:00,600 --> 01:03:03,239
Because I'm just constantly prepending the next element,

1734
01:03:03,360 --> 01:03:03,879
prepending,

1735
01:03:03,919 --> 01:03:04,510
prepending,

1736
01:03:04,719 --> 01:03:07,735
which means All of my hard work is just here at the beginning of the list.

1737
01:03:07,814 --> 01:03:10,084
So even if this thing has 1000 elements in it,

1738
01:03:10,294 --> 01:03:12,375
I'm only manipulating some pointers all the

1739
01:03:12,375 --> 01:03:14,125
way over here pictorialally at the left,

1740
01:03:14,294 --> 01:03:16,165
which means it's pretty darn fast.

1741
01:03:16,455 --> 01:03:18,485
So given that definition in this picture,

1742
01:03:18,655 --> 01:03:20,774
what would you say the big O running time is of

1743
01:03:20,774 --> 01:03:25,945
insertion into a link list when using my current implementation?

1744
01:03:26,709 --> 01:03:27,540
Big goal of one.

1745
01:03:27,620 --> 01:03:27,939
Why?

1746
01:03:28,100 --> 01:03:28,139
Well,

1747
01:03:28,179 --> 01:03:29,379
it's not literally one step,

1748
01:03:29,419 --> 01:03:31,899
but it is a constant number of steps because if

1749
01:03:31,899 --> 01:03:34,030
we literally counted the lines of code I was executing,

1750
01:03:34,060 --> 01:03:37,530
it's a few steps to sort of 0.1 thing up here,

1751
01:03:37,699 --> 01:03:38,850
point the other thing down here,

1752
01:03:38,899 --> 01:03:40,530
then update the third and boom,

1753
01:03:40,860 --> 01:03:41,570
we're done.

1754
01:03:41,899 --> 01:03:42,719
In particular,

1755
01:03:42,860 --> 01:03:46,090
what my current code does not care about is the whole length of this list.

1756
01:03:46,139 --> 01:03:46,419
Why?

1757
01:03:46,739 --> 01:03:49,889
Because I'm never traversing the whole thing for the insertion part.

1758
01:03:50,060 --> 01:03:51,810
I am obviously for the printing part,

1759
01:03:51,939 --> 01:03:55,489
but for the insertion I'm just prepending again and again.

1760
01:03:55,659 --> 01:03:57,300
The downside though of this approach is that

1761
01:03:57,300 --> 01:03:58,899
the whole darn thing is coming out backwards.

1762
01:03:58,979 --> 01:04:02,219
I'm not doing anything with regard to the ordering of these elements,

1763
01:04:02,340 --> 01:04:05,439
which means what's the running time of search going to be,

1764
01:04:05,479 --> 01:04:06,429
for instance?

1765
01:04:06,790 --> 01:04:09,629
If I tell you search for like the number one,

1766
01:04:09,699 --> 01:04:10,459
find it for me.

1767
01:04:11,709 --> 01:04:13,620
What's the running time gonna be there in Big O?

1768
01:04:15,429 --> 01:04:15,870
They go of,

1769
01:04:15,909 --> 01:04:16,219
yeah.

1770
01:04:17,100 --> 01:04:19,620
Big event because in the worst case it's going to be all

1771
01:04:19,620 --> 01:04:21,889
the way at the end and we've seen this scenario before,

1772
01:04:21,969 --> 01:04:23,560
so it's big O of end for

1773
01:04:24,050 --> 01:04:24,760
searching.

1774
01:04:24,969 --> 01:04:27,570
It's definitely big O event for traversing or printing,

1775
01:04:27,649 --> 01:04:29,729
but that goes without saying if you want to print every element,

1776
01:04:29,830 --> 01:04:32,110
obviously you have to touch every one of the N elements.

1777
01:04:32,209 --> 01:04:33,209
But what about deletion?

1778
01:04:33,479 --> 01:04:36,090
Suppose I want to delete an element that's going to be in big O of.

1779
01:04:38,250 --> 01:04:38,550
Also,

1780
01:04:38,629 --> 01:04:39,110
and why?

1781
01:04:39,189 --> 01:04:39,590
Because again,

1782
01:04:39,639 --> 01:04:42,020
in the worst case it could be all the way at the end.

1783
01:04:42,199 --> 01:04:45,659
So only insertion as currently implemented is big O of one

1784
01:04:46,229 --> 01:04:46,820
because

1785
01:04:47,310 --> 01:04:50,629
we are exercising full control over where the new

1786
01:04:50,629 --> 01:04:53,610
elements go irrespective of what the actual values are.

1787
01:04:53,909 --> 01:04:56,429
So things could escalate quickly here if we

1788
01:04:56,429 --> 01:04:58,469
do actually want to start keeping things,

1789
01:04:58,550 --> 01:04:58,780
say,

1790
01:04:58,790 --> 01:04:59,139
in

1791
01:04:59,590 --> 01:05:00,870
sordid order because we.

1792
01:05:00,949 --> 01:05:04,610
No longer just naively plop things at the very beginning of the list.

1793
01:05:04,820 --> 01:05:08,820
I think we need to start being a little more careful as to where we put things.

1794
01:05:08,939 --> 01:05:09,570
So in fact,

1795
01:05:09,780 --> 01:05:10,500
even though

1796
01:05:10,939 --> 01:05:13,250
we're doing OK on Insert right now,

1797
01:05:13,379 --> 01:05:17,250
we still have big O of N for the searching and for the deletion,

1798
01:05:17,300 --> 01:05:18,449
which we won't do in code,

1799
01:05:18,979 --> 01:05:21,209
as well as of course for traversal.

1800
01:05:21,540 --> 01:05:23,699
So how else might we go about building this list?

1801
01:05:23,780 --> 01:05:23,840
Well,

1802
01:05:24,129 --> 01:05:27,570
let me propose that we could maybe append to the end of the list.

1803
01:05:27,649 --> 01:05:29,360
Let's try that and see if it gets us anywhere better.

1804
01:05:29,530 --> 01:05:30,850
So here's my list initially,

1805
01:05:31,090 --> 01:05:31,610
completely empty,

1806
01:05:31,699 --> 01:05:32,520
aka null.

1807
01:05:32,729 --> 01:05:35,080
I go ahead and insert the number 1 as before,

1808
01:05:35,250 --> 01:05:38,820
but now in this algorithm I'm going to insert the number 2 and the number 3.

1809
01:05:38,969 --> 01:05:43,129
So this is great because now by chance it ended up beautifully in order,

1810
01:05:43,250 --> 01:05:45,090
but that's because I chose the numbers 123,

1811
01:05:45,129 --> 01:05:46,449
but we'll come back to that detail.

1812
01:05:47,100 --> 01:05:51,560
Let's consider now what the running time is of this algorithm of insertion

1813
01:05:51,830 --> 01:05:53,459
using a pending to the list.

1814
01:05:53,550 --> 01:05:57,219
What's the big O not big running time of insertion now?

1815
01:05:59,429 --> 01:06:00,110
Big old even end.

1816
01:06:00,189 --> 01:06:03,510
So it's sort of strictly worse because now it's always going at the end.

1817
01:06:03,629 --> 01:06:05,189
Now I could be a little smart about it.

1818
01:06:05,389 --> 01:06:08,469
I could just allocate another pointer and just always have

1819
01:06:08,469 --> 01:06:10,699
another pointer pointing at the end of the list,

1820
01:06:10,739 --> 01:06:13,060
just as I have a pointer pointing to the start of the list.

1821
01:06:13,189 --> 01:06:15,590
That's totally fine if you're willing to spend one more pointer,

1822
01:06:15,629 --> 01:06:16,739
which is a drop in the bucket,

1823
01:06:16,909 --> 01:06:18,060
a legitimate solution,

1824
01:06:18,229 --> 01:06:19,429
but where I'd like to go with this.

1825
01:06:19,489 --> 01:06:21,590
Let's maintain sorted order

1826
01:06:21,929 --> 01:06:22,870
no matter

1827
01:06:23,080 --> 01:06:25,120
the order in which the numbers are inserted,

1828
01:06:25,199 --> 01:06:27,959
whether it's 1233212 13,

1829
01:06:28,010 --> 01:06:28,989
3312,

1830
01:06:29,120 --> 01:06:30,889
whatever order the human types in the numbers,

1831
01:06:31,000 --> 01:06:34,629
I want to build the structure out such that they always end up in sorted order

1832
01:06:34,879 --> 01:06:37,280
just so that my contacts in my iPhone or

1833
01:06:37,280 --> 01:06:39,719
my Android phone for instance are sorted as intended.

1834
01:06:40,219 --> 01:06:42,090
So how do we go about doing that?

1835
01:06:42,169 --> 01:06:42,290
Well,

1836
01:06:42,409 --> 01:06:44,139
here we're still dealing with some big O.

1837
01:06:44,610 --> 01:06:45,169
Let's try this.

1838
01:06:45,209 --> 01:06:46,719
Here's my list initially empty.

1839
01:06:47,050 --> 01:06:47,530
Now we,

1840
01:06:47,629 --> 01:06:49,770
the user inserts person number 2 1st,

1841
01:06:49,810 --> 01:06:50,679
so it ends up there.

1842
01:06:50,850 --> 01:06:51,929
Then they insert number 1.

1843
01:06:51,969 --> 01:06:53,159
I'd like it to go there.

1844
01:06:53,409 --> 01:06:54,719
Person number 4,

1845
01:06:54,729 --> 01:06:55,530
it goes over there,

1846
01:06:55,610 --> 01:06:56,959
and then person number 3,

1847
01:06:57,209 --> 01:06:58,209
it ends up here.

1848
01:06:58,840 --> 01:07:00,639
Even though it's sort of obvious with a piece

1849
01:07:00,639 --> 01:07:02,830
of paper and pencil how to stitch this together,

1850
01:07:03,120 --> 01:07:06,989
this is now an annoying number of logical steps because there are so many

1851
01:07:06,989 --> 01:07:10,360
opportunities where I could screw up and orphan one or more of these nodes.

1852
01:07:10,520 --> 01:07:11,510
But let's consider

1853
01:07:11,750 --> 01:07:14,510
the scenarios that we encounter we might encounter.

1854
01:07:14,719 --> 01:07:17,360
Maybe we get lucky and it's like an empty list and

1855
01:07:17,360 --> 01:07:19,399
we just have to insert one new node that is trivial.

1856
01:07:19,409 --> 01:07:20,199
We've done that already.

1857
01:07:20,350 --> 01:07:21,879
The 2 was super easy to implement.

1858
01:07:22,409 --> 01:07:23,159
The one

1859
01:07:23,439 --> 01:07:26,040
could be really easy to implement too because that involves the

1860
01:07:26,040 --> 01:07:29,070
pre-pending scenario and we've seen that prepending is super simple.

1861
01:07:29,320 --> 01:07:31,310
So there's only two other scenarios to consider

1862
01:07:31,520 --> 01:07:32,040
app pending,

1863
01:07:32,050 --> 01:07:34,110
if it's a really big number and ends up at the end,

1864
01:07:34,189 --> 01:07:36,199
and we've talked about but haven't seen code for that.

1865
01:07:36,360 --> 01:07:36,929
The annoying one,

1866
01:07:36,959 --> 01:07:39,669
I dare say is going to be when the new number belongs in the middle.

1867
01:07:39,810 --> 01:07:41,600
But I propose to think through it this way

1868
01:07:41,600 --> 01:07:43,709
because now you just have 4 problems to solve,

1869
01:07:43,800 --> 01:07:45,070
not just one massive.

1870
01:07:45,310 --> 01:07:46,469
Ill-defined problem.

1871
01:07:46,620 --> 01:07:50,250
You've got scenarios in which you want to insert a new node into an empty list.

1872
01:07:50,419 --> 01:07:52,979
You want to prepend the new node into the beginning of the list,

1873
01:07:53,030 --> 01:07:54,290
append it to the end of the list,

1874
01:07:54,300 --> 01:07:55,780
or somewhere in the middle.

1875
01:07:55,860 --> 01:07:57,209
So that's like 4

1876
01:07:58,100 --> 01:07:59,909
blocks of code in my program.

1877
01:07:59,979 --> 01:08:04,010
I can now sort of take the proverbial baby steps and implement this bit by bit.

1878
01:08:04,100 --> 01:08:04,889
And to do this,

1879
01:08:05,100 --> 01:08:07,699
let me propose that in a moment I'll switch over to VS code,

1880
01:08:07,739 --> 01:08:08,169
but

1881
01:08:08,479 --> 01:08:08,679
Uh,

1882
01:08:08,780 --> 01:08:09,979
sort of Julia Child style,

1883
01:08:10,040 --> 01:08:13,350
I'm going to open up a pre-made version of the program

1884
01:08:13,600 --> 01:08:16,310
that actually gives us a working solution,

1885
01:08:16,379 --> 01:08:16,959
albeit

1886
01:08:17,200 --> 01:08:18,540
initially with some bugs.

1887
01:08:18,640 --> 01:08:20,560
So here we have out of the oven,

1888
01:08:20,879 --> 01:08:23,799
this version of List.c at the.

1889
01:08:23,934 --> 01:08:24,832
Top of the file.

1890
01:08:25,243 --> 01:08:26,832
I've got my same includes as before.

1891
01:08:26,962 --> 01:08:29,273
I've got my same structure as before here.

1892
01:08:29,483 --> 01:08:31,073
I've again got in main void.

1893
01:08:31,243 --> 01:08:32,823
I've got the beginning of my list here,

1894
01:08:32,923 --> 01:08:33,962
setting it equal to null,

1895
01:08:34,002 --> 01:08:35,474
and then for the sake of discussion,

1896
01:08:35,604 --> 01:08:38,313
I'm going to insert 3 values for this example,

1897
01:08:38,354 --> 01:08:38,792
12,

1898
01:08:38,804 --> 01:08:39,403
and 3.

1899
01:08:39,919 --> 01:08:40,359
By

1900
01:08:40,640 --> 01:08:42,830
allocating enough room for a node,

1901
01:08:43,200 --> 01:08:44,490
setting it equal to N,

1902
01:08:44,959 --> 01:08:47,160
then I'm going to make sure a sanity check that N is not null,

1903
01:08:47,200 --> 01:08:49,640
and then I'm going to actually populate this

1904
01:08:49,640 --> 01:08:52,160
with the human's first choice of values.

1905
01:08:52,240 --> 01:08:53,270
So let me scroll down,

1906
01:08:53,560 --> 01:08:54,080
but as such,

1907
01:08:54,160 --> 01:08:56,240
there's nothing too new just yet.

1908
01:08:57,707 --> 01:08:58,499
Here we have

1909
01:08:58,788 --> 01:09:02,059
the lines of code in which I'm getting in it from the user,

1910
01:09:02,508 --> 01:09:04,377
setting next equal to null,

1911
01:09:04,627 --> 01:09:07,587
and then I'm pre-pending no matter what per our

1912
01:09:07,587 --> 01:09:09,148
earlier version that we did on the fly.

1913
01:09:09,419 --> 01:09:12,370
This new node to the list and then updating the list to

1914
01:09:12,370 --> 01:09:14,569
point to it and then down here I'm printing the numbers.

1915
01:09:14,609 --> 01:09:15,879
So this is where we left off,

1916
01:09:15,970 --> 01:09:17,970
but this is a pre-made version that's nicely commented.

1917
01:09:18,009 --> 01:09:19,779
It's on the course's website for reference.

1918
01:09:19,970 --> 01:09:22,970
What I'm not doing now is intelligently prepending,

1919
01:09:23,009 --> 01:09:23,759
appending,

1920
01:09:23,930 --> 01:09:25,640
or plopping the code in the middle.

1921
01:09:25,930 --> 01:09:27,000
So how do we do that?

1922
01:09:27,129 --> 01:09:29,129
Let's take a look at this version of the code.

1923
01:09:29,169 --> 01:09:31,529
So everything thus far is the same.

1924
01:09:31,868 --> 01:09:35,258
And if I scroll down besides the new comments,

1925
01:09:35,377 --> 01:09:39,457
you'll see that now I'm starting to make some decisions after I

1926
01:09:39,457 --> 01:09:43,627
have allocated the new node and populated its number and next field.

1927
01:09:43,979 --> 01:09:44,538
As an aside,

1928
01:09:44,618 --> 01:09:48,008
I don't strictly need to initialize the next field to null because eventually,

1929
01:09:48,099 --> 01:09:49,528
as we've done in every past example,

1930
01:09:49,618 --> 01:09:51,648
I've updated that next field anyway.

1931
01:09:51,898 --> 01:09:52,207
However,

1932
01:09:52,448 --> 01:09:54,378
because this one might now end up at the end

1933
01:09:54,378 --> 01:09:57,179
of the list and I just want to program defensively,

1934
01:09:57,298 --> 01:10:01,188
initializing pointers to null before you're ready to assign their value.

1935
01:10:01,459 --> 01:10:03,120
is a good thing in general.

1936
01:10:03,330 --> 01:10:05,700
So here's the first of the questions I'm going to ask myself.

1937
01:10:05,770 --> 01:10:10,399
If the list into which I am inserting this new node is empty,

1938
01:10:10,589 --> 01:10:11,919
so it's the beginning of the story,

1939
01:10:12,209 --> 01:10:12,979
super easy,

1940
01:10:13,129 --> 01:10:16,569
just set the list equal to the address of that new node,

1941
01:10:16,609 --> 01:10:17,399
and we're done.

1942
01:10:17,569 --> 01:10:19,580
That's what happened when we inserted a bit ago,

1943
01:10:19,649 --> 01:10:20,890
the number 2 for the.

1944
01:10:20,975 --> 01:10:21,895
Very first time.

1945
01:10:22,115 --> 01:10:24,595
So indeed what has just happened here is that now

1946
01:10:24,595 --> 01:10:28,484
the list previously empty contains only a node containing 2.

1947
01:10:28,794 --> 01:10:29,145
However,

1948
01:10:29,274 --> 01:10:30,955
thereafter there was another scenario.

1949
01:10:31,075 --> 01:10:34,464
So when we moved on in our story and added the number 1 to the list,

1950
01:10:34,674 --> 01:10:36,274
well that happened to end up at the beginning,

1951
01:10:36,375 --> 01:10:38,035
but it could also end up at the end or in the middle.

1952
01:10:38,115 --> 01:10:40,464
So let's break down those scenarios here too.

1953
01:10:40,915 --> 01:10:41,625
So here,

1954
01:10:41,834 --> 01:10:44,145
if it is not the case that the list is empty

1955
01:10:44,435 --> 01:10:45,504
in that if condition,

1956
01:10:45,674 --> 01:10:47,754
we're going to end up here now in the Eps.

1957
01:10:48,410 --> 01:10:49,390
What do I want to do here?

1958
01:10:49,490 --> 01:10:49,540
Well,

1959
01:10:49,609 --> 01:10:53,209
let's go ahead and for now in this simplified version append it

1960
01:10:53,209 --> 01:10:55,319
to the end of the list so we can see that code.

1961
01:10:55,529 --> 01:10:56,410
How do I do this?

1962
01:10:56,529 --> 01:10:56,609
Well,

1963
01:10:56,689 --> 01:10:57,689
I'm using a 4 loop,

1964
01:10:57,850 --> 01:10:59,200
much like the one I had before,

1965
01:10:59,450 --> 01:11:03,520
which just allows me to traverse the existing list whether it has one node or many,

1966
01:11:03,810 --> 01:11:05,680
and I'm going to ask a question.

1967
01:11:05,729 --> 01:11:11,319
If following the current nodes pointer field next field leads me to null.

1968
01:11:11,859 --> 01:11:13,399
AKA the end of the list.

1969
01:11:13,490 --> 01:11:13,870
OK,

1970
01:11:14,129 --> 01:11:16,359
let's go ahead and update the end of the list

1971
01:11:16,609 --> 01:11:19,080
to actually equal the new node.

1972
01:11:19,410 --> 01:11:19,930
So in other words,

1973
01:11:19,970 --> 01:11:20,930
if I'm sort of following,

1974
01:11:21,049 --> 01:11:21,330
following,

1975
01:11:21,450 --> 01:11:24,919
following all of the arrows and I reach a node whose next field is null,

1976
01:11:25,180 --> 01:11:25,779
no problem,

1977
01:11:26,040 --> 01:11:27,520
update that next field to point

1978
01:11:27,890 --> 01:11:29,970
to the new node I want to insert,

1979
01:11:30,009 --> 01:11:31,490
irrespective of the values.

1980
01:11:31,950 --> 01:11:34,009
I just want to append this node no matter what,

1981
01:11:34,020 --> 01:11:35,770
and then I want to break out of the code.

1982
01:11:35,939 --> 01:11:37,689
Then at the bottom of this version of the program,

1983
01:11:37,700 --> 01:11:40,660
it's all quite the same printing out the numbers using the 4

1984
01:11:40,660 --> 01:11:43,140
loop version of my code from before instead of the Y loop,

1985
01:11:43,180 --> 01:11:43,979
but they're equivalent.

1986
01:11:44,140 --> 01:11:47,060
But what I did do in advance in baking this version of the

1987
01:11:47,060 --> 01:11:51,890
program is also go through the motions of freeing every one of the nodes

1988
01:11:52,180 --> 01:11:52,580
afterward,

1989
01:11:52,660 --> 01:11:53,779
but we'll come back to that.

1990
01:11:54,149 --> 01:11:55,299
So this version of the code,

1991
01:11:55,339 --> 01:11:56,290
just to be clear,

1992
01:11:56,580 --> 01:11:59,330
only appends nodes to the list.

1993
01:11:59,339 --> 01:12:01,120
It's still not treating things in order,

1994
01:12:01,180 --> 01:12:03,770
but we've now seen two of the scenarios plucked off.

1995
01:12:03,779 --> 01:12:05,089
The list is empty

1996
01:12:05,339 --> 01:12:06,490
or it has numbers,

1997
01:12:06,500 --> 01:12:08,089
and we want to put something at the end.

1998
01:12:08,299 --> 01:12:10,370
So let me propose now that I take

1999
01:12:10,620 --> 01:12:12,850
out of our distribution code

2000
01:12:13,259 --> 01:12:15,490
another version of this program that

2001
01:12:15,660 --> 01:12:17,220
does that and a bit more.

2002
01:12:17,339 --> 01:12:19,529
I'm going to go ahead and open up in just a moment,

2003
01:12:19,819 --> 01:12:23,740
a new and improved version of lists.c and now.

2004
01:12:24,100 --> 01:12:25,910
It looks almost the same at the top,

2005
01:12:26,270 --> 01:12:27,160
scrolling down,

2006
01:12:27,240 --> 01:12:28,080
scrolling down,

2007
01:12:28,160 --> 01:12:29,160
scrolling down.

2008
01:12:29,470 --> 01:12:31,029
Here's some now familiar code.

2009
01:12:31,100 --> 01:12:32,229
If the list is empty,

2010
01:12:32,279 --> 01:12:34,790
do that simple thing as before and just prepend it,

2011
01:12:35,430 --> 01:12:37,430
or rather just set it equal to the list.

2012
01:12:37,720 --> 01:12:40,470
But here is now where we're adding some inequality.

2013
01:12:40,680 --> 01:12:42,430
So if the number in question

2014
01:12:42,879 --> 01:12:45,109
belongs at the beginning of the list,

2015
01:12:45,319 --> 01:12:46,430
so if the number

2016
01:12:47,000 --> 01:12:48,200
in the new node N

2017
01:12:48,839 --> 01:12:49,890
is less than.

2018
01:12:50,319 --> 01:12:51,310
The number

2019
01:12:51,580 --> 01:12:53,270
in the current list,

2020
01:12:53,419 --> 01:12:55,950
which is presumed to be the first node at the moment,

2021
01:12:56,259 --> 01:12:56,720
then

2022
01:12:57,020 --> 01:12:59,850
go ahead and update the new node's next field

2023
01:13:00,140 --> 01:13:02,569
to point at the existing list

2024
01:13:02,899 --> 01:13:05,490
and then update the list to point at this new node,

2025
01:13:05,700 --> 01:13:08,509
thereby giving us from 2 in the list

2026
01:13:08,859 --> 01:13:11,270
to 1 and 2 in the list.

2027
01:13:11,540 --> 01:13:11,939
To be clear,

2028
01:13:12,020 --> 01:13:13,339
if I go back to VS code here,

2029
01:13:13,419 --> 01:13:17,509
what's happened here is because 1 is less than 2.

2030
01:13:18,229 --> 01:13:19,700
Of course I'm going to update

2031
01:13:19,899 --> 01:13:22,379
the new nodes next field to point to the list.

2032
01:13:22,450 --> 01:13:23,220
What does this mean?

2033
01:13:23,390 --> 01:13:23,430
Well,

2034
01:13:23,509 --> 01:13:25,750
the new node at this point in the story is the new

2035
01:13:25,750 --> 01:13:28,339
node for the number one because that's the second thing we're inserting.

2036
01:13:28,589 --> 01:13:29,660
I'm going to update

2037
01:13:29,910 --> 01:13:30,600
its

2038
01:13:30,830 --> 01:13:31,580
next field

2039
01:13:31,750 --> 01:13:35,890
to be whatever the list a moment ago was already pointing at.

2040
01:13:36,029 --> 01:13:37,459
So this is the after effect,

2041
01:13:37,680 --> 01:13:41,500
but a moment ago list was pointing at only the 2.

2042
01:13:41,709 --> 01:13:44,629
So now the next field of the 1 points at the 2.

2043
01:13:44,950 --> 01:13:46,709
And then lastly here in this line,

2044
01:13:46,839 --> 01:13:48,359
I update the list pointer

2045
01:13:48,640 --> 01:13:51,129
to be the address of that new node.

2046
01:13:51,470 --> 01:13:53,450
And here's where I'll wave my hand a little

2047
01:13:53,450 --> 01:13:55,339
bit today because it starts to escalate quickly.

2048
01:13:55,350 --> 01:13:58,810
It's useful and it might very well be useful for problems at 5 in particular,

2049
01:13:58,939 --> 01:14:02,689
but I think more healthily reviewed step by step at a slower pace.

2050
01:14:03,299 --> 01:14:04,770
Here is where I'm asking myself,

2051
01:14:04,899 --> 01:14:05,180
all right,

2052
01:14:05,259 --> 01:14:07,259
if it's not the only element in the list and

2053
01:14:07,259 --> 01:14:09,890
it doesn't belong at the beginning of the list,

2054
01:14:10,060 --> 01:14:10,259
well,

2055
01:14:10,299 --> 01:14:12,330
it belongs somewhere later in the list,

2056
01:14:12,339 --> 01:14:14,299
which gives me two final scenarios.

2057
01:14:14,459 --> 01:14:16,180
Let's figure out which scenario we're in.

2058
01:14:16,339 --> 01:14:18,649
Let's use this 4 loop to iterate over all of the as

2059
01:14:18,660 --> 01:14:20,620
as many of the notes in the list as we need to.

2060
01:14:21,229 --> 01:14:23,220
If we get all the way to the end,

2061
01:14:23,790 --> 01:14:25,879
because our pointer variable now equals null,

2062
01:14:26,149 --> 01:14:27,270
it's like following the arrows,

2063
01:14:27,350 --> 01:14:28,069
following the arrows,

2064
01:14:28,109 --> 01:14:29,859
and maybe we're trying to insert the number 5.

2065
01:14:30,109 --> 01:14:31,229
I've already hit the number 4.

2066
01:14:31,270 --> 01:14:32,029
I've hit null.

2067
01:14:32,189 --> 01:14:33,540
5 belongs at the end.

2068
01:14:33,750 --> 01:14:36,939
So here we have our promised append code,

2069
01:14:36,990 --> 01:14:38,589
which is exactly the same as before,

2070
01:14:38,629 --> 01:14:40,200
but now I'm doing it conditionally

2071
01:14:40,549 --> 01:14:43,680
if I've indeed found my way to the end of the list.

2072
01:14:43,870 --> 01:14:44,509
And then lastly,

2073
01:14:44,589 --> 01:14:45,990
let me scroll down just a little bit.

2074
01:14:46,629 --> 01:14:50,549
If it's not the case that the list is empty and it's not the case that the new

2075
01:14:50,549 --> 01:14:52,430
node belongs at the beginning and it's not the

2076
01:14:52,430 --> 01:14:54,299
case that the new node belongs at the end,

2077
01:14:54,509 --> 01:14:58,669
I'm just somewhere in the middle of the list because the new number I'm inserting

2078
01:14:58,950 --> 01:15:00,089
is less than

2079
01:15:00,379 --> 01:15:02,220
the one I'm looking at here,

2080
01:15:02,430 --> 01:15:03,799
and it's OK to use two arrows,

2081
01:15:03,870 --> 01:15:05,580
but I'll wave my hands at that for now.

2082
01:15:05,870 --> 01:15:07,140
These 3 lines,

2083
01:15:07,350 --> 01:15:09,950
2 pointer manipulations and a break is what's going

2084
01:15:09,950 --> 01:15:13,669
to stitch together that 3 in between the two.

2085
01:15:14,149 --> 01:15:15,009
And the 4.

2086
01:15:15,180 --> 01:15:17,220
And let me propose for lecture's sake take this on

2087
01:15:17,220 --> 01:15:20,529
faith that this collectively does stitch things together properly,

2088
01:15:20,700 --> 01:15:21,259
but I do think,

2089
01:15:21,270 --> 01:15:22,459
as you'll see in Problem set 5,

2090
01:15:22,500 --> 01:15:25,890
it's a much better exercise to think through a little more carefully step by step

2091
01:15:26,240 --> 01:15:29,580
because there's just a lot of fine tuning of these

2092
01:15:29,580 --> 01:15:32,410
pointers together and the order of operations does matter.

2093
01:15:32,620 --> 01:15:33,970
But at the very end of this program,

2094
01:15:34,140 --> 01:15:35,525
notice this is Kind of mindless,

2095
01:15:35,565 --> 01:15:37,976
even though the syntax is undoubtedly less familiar.

2096
01:15:38,286 --> 01:15:41,036
Here is how just like traversing the whole list to print it out,

2097
01:15:41,246 --> 01:15:44,076
we can similarly do one more pass over the linked list

2098
01:15:44,326 --> 01:15:44,715
and

2099
01:15:45,085 --> 01:15:48,166
free every one of the nodes.

2100
01:15:48,326 --> 01:15:51,795
But notice it's not quite as simple as just saying free the whole list.

2101
01:15:52,125 --> 01:15:53,456
Free is not that smart.

2102
01:15:53,686 --> 01:15:55,235
Mao is not that smart,

2103
01:15:55,246 --> 01:15:58,301
and Even though you have called Mallock 123 times,

2104
01:15:58,551 --> 01:16:00,142
you have to really call free.

2105
01:16:00,352 --> 01:16:02,702
You have to call free 123 times.

2106
01:16:02,791 --> 01:16:05,992
You can't just pass at the beginning of the link list and say you figure out what to

2107
01:16:05,992 --> 01:16:07,711
delete because it has no idea what a linked

2108
01:16:07,711 --> 01:16:10,231
list is or what your data structure actually is.

2109
01:16:10,432 --> 01:16:10,841
So

2110
01:16:11,111 --> 01:16:13,861
the reason that this loop is a little complicated

2111
01:16:13,861 --> 01:16:16,242
is that what I'm doing with these three lines

2112
01:16:16,662 --> 01:16:18,671
is essentially traversing my list.

2113
01:16:20,149 --> 01:16:25,279
And making sure that I have a pointer that when I'm ready to delete the 31,

2114
01:16:25,410 --> 01:16:27,049
I have a pointer pointing at the 2,

2115
01:16:27,060 --> 01:16:28,560
and then I free the 1.

2116
01:16:28,689 --> 01:16:30,410
I update my pointer to point at the 3,

2117
01:16:30,450 --> 01:16:31,879
and then I delete the 2.

2118
01:16:32,049 --> 01:16:33,729
I update my pointer to point at the 4,

2119
01:16:33,810 --> 01:16:35,080
then I delete the 3,

2120
01:16:35,290 --> 01:16:36,500
and then I delete the 4.

2121
01:16:36,649 --> 01:16:39,109
So there's a bit of trickery involved

2122
01:16:39,290 --> 01:16:41,839
in making sure you don't orphan things

2123
01:16:42,129 --> 01:16:42,569
step

2124
01:16:42,689 --> 01:16:43,330
by step.

2125
01:16:44,649 --> 01:16:44,660
OK,

2126
01:16:45,520 --> 01:16:46,430
that was a lot.

2127
01:16:46,759 --> 01:16:47,790
Let me pause here.

2128
01:16:48,750 --> 01:16:49,540
To see

2129
01:16:50,189 --> 01:16:51,879
If there are in fact any questions,

2130
01:16:52,569 --> 01:16:55,120
even though we're deliberately waving our hands at some of those

2131
01:16:55,450 --> 01:16:56,209
details.

2132
01:16:58,540 --> 01:16:59,859
Questions on this.

2133
01:17:00,790 --> 01:17:00,910
Now,

2134
01:17:01,000 --> 01:17:03,100
let me add one final flourish.

2135
01:17:03,430 --> 01:17:05,629
If we were to really quibble over this,

2136
01:17:05,709 --> 01:17:05,830
I mean,

2137
01:17:05,910 --> 01:17:06,149
my God,

2138
01:17:06,189 --> 01:17:10,220
we're up to 80 lines of code already just to implement the numbers 1234,

2139
01:17:10,790 --> 01:17:11,140
but

2140
01:17:11,350 --> 01:17:14,299
there are some subtle bugs in here at the moment.

2141
01:17:14,470 --> 01:17:15,740
So for instance,

2142
01:17:16,089 --> 01:17:17,109
suppose that

2143
01:17:17,589 --> 01:17:20,779
something goes wrong with Mao inside of this for loop here,

2144
01:17:21,109 --> 01:17:23,100
and suppose that it's not your first iteration,

2145
01:17:23,229 --> 01:17:26,310
something goes wrong on maybe the second or the third iteration.

2146
01:17:27,060 --> 01:17:28,390
Why is this

2147
01:17:28,640 --> 01:17:32,149
error check suddenly bad as I've implemented it?

2148
01:17:34,520 --> 01:17:34,850
Yeah.

2149
01:17:36,899 --> 01:17:39,160
I didn't free the memory from the previous iteration,

2150
01:17:39,209 --> 01:17:39,970
so this is where like,

2151
01:17:40,009 --> 01:17:40,359
oh,

2152
01:17:40,370 --> 01:17:43,250
like memory management starts to get really annoying because if

2153
01:17:43,250 --> 01:17:44,729
you do want to practice what I've been preaching,

2154
01:17:44,750 --> 01:17:48,160
which is free any memory you've allocated and you've already allocated one,

2155
01:17:48,250 --> 01:17:52,799
maybe two nodes because Mao is again failing maybe at the last iteration here,

2156
01:17:53,009 --> 01:17:55,089
you have to somehow go back and free all of that,

2157
01:17:55,100 --> 01:17:55,919
and that's fine.

2158
01:17:56,129 --> 01:17:59,290
Like we have code at the bottom of my file here which

2159
01:17:59,290 --> 01:18:02,490
could traverse through the existing list and just free it all.

2160
01:18:02,569 --> 01:18:04,229
So I could just copy paste that code,

2161
01:18:04,330 --> 01:18:04,649
put it in.

2162
01:18:04,725 --> 01:18:08,625
To my if condition and then run that code 2 to delete the whole list,

2163
01:18:08,754 --> 01:18:09,424
but at this point,

2164
01:18:09,504 --> 01:18:10,435
if you're copying and pasting,

2165
01:18:10,444 --> 01:18:11,734
you're probably doing something wrong.

2166
01:18:11,825 --> 01:18:15,705
And so let me propose as a final version of this just for your reference later

2167
01:18:15,955 --> 01:18:18,825
in the 9th and final in version 9 of this file here,

2168
01:18:18,915 --> 01:18:20,625
0 indexed what we have.

2169
01:18:20,834 --> 01:18:23,944
Give me one second to just make a quick copy and copy it over

2170
01:18:24,314 --> 01:18:26,984
in list 9.c. Our last version of this,

2171
01:18:27,075 --> 01:18:27,904
we have

2172
01:18:28,234 --> 01:18:29,314
the following

2173
01:18:29,595 --> 01:18:31,145
whereby now

2174
01:18:31,475 --> 01:18:32,435
in my function.

2175
01:18:32,939 --> 01:18:33,169
Uh,

2176
01:18:33,209 --> 01:18:34,339
in my main function,

2177
01:18:34,649 --> 01:18:37,000
I have the exact same code as before,

2178
01:18:37,189 --> 01:18:40,330
but I've taken the liberty of implementing an unload function

2179
01:18:40,330 --> 01:18:43,080
so that I can call it here as well as at

2180
01:18:43,410 --> 01:18:48,080
the bottom of this main function so I can unload it here or unload the list there,

2181
01:18:48,290 --> 01:18:51,959
and all I've done now is in good form in terms of design,

2182
01:18:52,209 --> 01:18:55,089
just implement the notion of deleting a linked list in its own function

2183
01:18:55,089 --> 01:18:58,209
so I can call any number of times from any number of places.

2184
01:18:58,220 --> 01:18:59,319
But just so you've seen

2185
01:18:59,939 --> 01:19:01,200
how I might do that there.

2186
01:19:01,939 --> 01:19:02,120
Alright,

2187
01:19:02,200 --> 01:19:03,270
so let's ask the question,

2188
01:19:03,459 --> 01:19:04,569
after all this,

2189
01:19:04,879 --> 01:19:08,850
what is the running time of inserting into a linked list?

2190
01:19:11,720 --> 01:19:12,470
They go of

2191
01:19:14,319 --> 01:19:14,790
Say a lot,

2192
01:19:15,240 --> 01:19:15,839
big of.

2193
01:19:16,810 --> 01:19:17,750
And damn it,

2194
01:19:17,830 --> 01:19:18,700
like that's no better.

2195
01:19:18,899 --> 01:19:18,990
All right,

2196
01:19:19,029 --> 01:19:21,259
what's the running time of searching a linked list?

2197
01:19:23,049 --> 01:19:23,689
Big old event,

2198
01:19:23,770 --> 01:19:24,169
damn it,

2199
01:19:24,290 --> 01:19:24,370
uh,

2200
01:19:24,419 --> 01:19:26,479
what's the running time of deleting from a linked list?

2201
01:19:27,419 --> 01:19:28,129
Big O of end.

2202
01:19:28,209 --> 01:19:30,049
So like everything is literally big O of ends.

2203
01:19:30,129 --> 01:19:31,799
So there's the price we've suddenly paid.

2204
01:19:32,089 --> 01:19:34,770
We have an hour after we started with arrays gotten to

2205
01:19:34,770 --> 01:19:38,029
the point where we can dynamically grow in a linked lists,

2206
01:19:38,049 --> 01:19:38,700
and I dare say,

2207
01:19:38,729 --> 01:19:40,290
even though we've not done it and won't do it today,

2208
01:19:40,569 --> 01:19:43,200
shrink the linked list by freeing things that we don't need.

2209
01:19:43,330 --> 01:19:45,729
So we have the dynamism and we can make more efficient use of

2210
01:19:45,729 --> 01:19:48,209
memory even if it's very fragmented and there's a few bytes here,

2211
01:19:48,290 --> 01:19:49,120
a few bytes there,

2212
01:19:49,250 --> 01:19:51,649
but we've paid this price because with the rays recall,

2213
01:19:51,850 --> 01:19:53,040
even our phone book example,

2214
01:19:53,169 --> 01:19:54,529
we at least had binary search,

2215
01:19:54,569 --> 01:19:55,129
the running time for.

2216
01:19:55,229 --> 01:19:57,899
Which was big O of log and so my God,

2217
01:19:58,020 --> 01:19:59,299
not only are we spending more space,

2218
01:19:59,339 --> 01:20:00,689
the darn thing is slower.

2219
01:20:01,060 --> 01:20:03,459
Surely this is not how our phone contacts are implemented.

2220
01:20:03,580 --> 01:20:06,299
Surely this is not how stacks and cues are always implemented.

2221
01:20:06,339 --> 01:20:07,290
And indeed it's not.

2222
01:20:07,459 --> 01:20:10,029
This is just going to be a stepping stone to now doing a sort

2223
01:20:10,029 --> 01:20:13,740
of mash up of data structures whereby we take the best features of arrays,

2224
01:20:13,770 --> 01:20:15,500
the best features of linked lists,

2225
01:20:15,660 --> 01:20:18,819
mash them together to get new and improved data structures,

2226
01:20:18,839 --> 01:20:19,899
but for that we're going to have to have some

2227
01:20:19,899 --> 01:20:21,700
cookies first and we'll come back in 10 minutes.

2228
01:20:21,779 --> 01:20:22,819
Cookies are now served.

2229
01:20:24,109 --> 01:20:24,120
All

2230
01:20:24,859 --> 01:20:25,049
right,

2231
01:20:25,259 --> 01:20:25,850
we are back.

2232
01:20:26,020 --> 01:20:28,100
So let's recap how we got here and why.

2233
01:20:28,180 --> 01:20:30,339
So we started with our old friend's arrays,

2234
01:20:30,419 --> 01:20:31,549
which we introduced in week 2,

2235
01:20:31,819 --> 01:20:34,370
and recalled that the whole appeal of arrays was that one,

2236
01:20:34,540 --> 01:20:35,410
as all things go,

2237
01:20:35,540 --> 01:20:36,729
like relatively simple,

2238
01:20:36,819 --> 01:20:37,990
certainly now in retrospect,

2239
01:20:38,140 --> 01:20:38,859
but more importantly,

2240
01:20:38,939 --> 01:20:40,529
they were really darned fast.

2241
01:20:40,740 --> 01:20:43,779
Like arrays insofar as they are stored back to back

2242
01:20:43,779 --> 01:20:46,299
contiguous in memory means that we could do very simple

2243
01:20:46,299 --> 01:20:49,379
arithmetic recall to like figure out the length of it

2244
01:20:49,379 --> 01:20:50,819
and then divide by 2 to get the middle,

2245
01:20:50,859 --> 01:20:51,979
divide by 2 again to get the.

2246
01:20:52,129 --> 01:20:53,350
of the middle and so forth.

2247
01:20:53,520 --> 01:20:55,750
And even though we might have to deal with a little bit of rounding,

2248
01:20:56,089 --> 01:20:59,879
arrays lent themselves to binary search and thus logarithmic time,

2249
01:20:59,959 --> 01:21:01,270
so big O of login.

2250
01:21:01,479 --> 01:21:04,240
But today I claim that the downside of arrays that that you have to

2251
01:21:04,240 --> 01:21:07,830
decide in advance how big you want it to be and if you guess wrong

2252
01:21:08,120 --> 01:21:08,950
and it's too small,

2253
01:21:09,080 --> 01:21:10,640
how much memory you ask for,

2254
01:21:10,720 --> 01:21:13,149
you then have to reallocate memory and that's fine.

2255
01:21:13,240 --> 01:21:15,229
It's solvable with Mao or reallock,

2256
01:21:15,399 --> 01:21:17,560
but it's going to take some amount of time to

2257
01:21:17,560 --> 01:21:20,040
copy all of the old memory into the new memory.

2258
01:21:20,410 --> 01:21:23,770
Whether you do it with a for loop or mount Realo does it for you.

2259
01:21:24,060 --> 01:21:24,419
Meanwhile,

2260
01:21:24,500 --> 01:21:26,020
we only did it with like 3 values,

2261
01:21:26,180 --> 01:21:26,790
maybe 4,

2262
01:21:26,979 --> 01:21:31,370
but imagine it being 3 million values that you now need to allocate more space for.

2263
01:21:31,500 --> 01:21:33,310
You're going to waste a huge amount of time copying

2264
01:21:33,310 --> 01:21:36,089
3 million values from the old location to the new.

2265
01:21:36,299 --> 01:21:38,689
And so that's just generally not very appealing.

2266
01:21:38,779 --> 01:21:43,140
And so that motivated a whole discussion of linked lists where by now we can

2267
01:21:43,140 --> 01:21:47,529
create a more dynamic data structure whereby we only allocate memory as we need it,

2268
01:21:47,589 --> 01:21:48,060
so we don't.

2269
01:21:48,169 --> 01:21:52,450
To worry about underestimating or overestimating and therefore wasting memory,

2270
01:21:52,479 --> 01:21:54,990
we can just go bit by bit for each new value.

2271
01:21:55,120 --> 01:21:56,040
We allocate another node,

2272
01:21:56,200 --> 01:21:56,919
another chunk of memory,

2273
01:21:56,959 --> 01:21:58,919
and the thing just grows and grows and grows.

2274
01:21:59,000 --> 01:22:00,750
But as we saw just before break,

2275
01:22:01,000 --> 01:22:01,839
the downside is,

2276
01:22:01,879 --> 01:22:04,240
even though we're avoiding the inefficiency of

2277
01:22:04,240 --> 01:22:06,200
having to move stuff around in memory,

2278
01:22:06,399 --> 01:22:10,040
once allocated to nodes can stay where they are and we just update our pointers,

2279
01:22:10,560 --> 01:22:12,399
all of our running times for searching,

2280
01:22:12,520 --> 01:22:13,640
inserting new elements,

2281
01:22:13,720 --> 01:22:16,040
deleting old elements would seem to be big.

2282
01:22:16,209 --> 01:22:17,060
O of N.

2283
01:22:17,500 --> 01:22:18,419
But why was that?

2284
01:22:18,540 --> 01:22:18,580
Well,

2285
01:22:18,660 --> 01:22:20,890
in the context of a linked list,

2286
01:22:21,100 --> 01:22:24,770
recall that it might look a little something like this whereby we

2287
01:22:24,770 --> 01:22:28,089
have a pointer called list pointing to maybe 4 values like this,

2288
01:22:28,339 --> 01:22:30,089
and suppose that we do want to

2289
01:22:31,180 --> 01:22:32,290
search for a value.

2290
01:22:32,419 --> 01:22:34,729
Now it's nice because in our latest version of this

2291
01:22:35,100 --> 01:22:35,609
linked list,

2292
01:22:35,620 --> 01:22:37,330
it was sorted from smallest to largest,

2293
01:22:37,339 --> 01:22:40,000
and that was always a precondition of doing binary search,

2294
01:22:40,160 --> 01:22:42,540
but even though it's obvious to our human eyes where the middle is,

2295
01:22:42,660 --> 01:22:44,060
it's like roughly over there.

2296
01:22:44,549 --> 01:22:46,259
How is the computer going to figure that out,

2297
01:22:46,270 --> 01:22:48,299
or how is your code that you write?

2298
01:22:48,509 --> 01:22:48,549
Well,

2299
01:22:48,629 --> 01:22:49,149
unfortunately,

2300
01:22:49,189 --> 01:22:51,629
the way we've stitched a link list together with these

2301
01:22:51,629 --> 01:22:53,500
pointers is if you want to find the middle,

2302
01:22:53,830 --> 01:22:54,500
you can,

2303
01:22:54,669 --> 01:22:56,120
but you've got to start at the beginning,

2304
01:22:56,390 --> 01:22:58,819
traverse the whole thing to figure out how long it is,

2305
01:22:59,069 --> 01:23:02,310
then do it again and stop halfway through once

2306
01:23:02,310 --> 01:23:04,339
you know what the halfway point roughly is.

2307
01:23:04,589 --> 01:23:06,529
Then if you want to search the middle of the middle,

2308
01:23:06,629 --> 01:23:06,879
you've.

2309
01:23:07,339 --> 01:23:08,939
got to do that whole process again.

2310
01:23:08,979 --> 01:23:11,290
And so now just to use binary search,

2311
01:23:11,379 --> 01:23:14,899
you need to spend big O of end steps just to even find the middle.

2312
01:23:15,020 --> 01:23:16,500
Now if your mind is kind of spinning and you're like,

2313
01:23:16,540 --> 01:23:16,660
Well,

2314
01:23:16,899 --> 01:23:19,080
maybe I could just kind of cheat and use a

2315
01:23:19,080 --> 01:23:21,169
pointer to always point to the middle of the list,

2316
01:23:21,379 --> 01:23:21,970
totally fine.

2317
01:23:22,020 --> 01:23:24,220
You can spend in some additional space to remember

2318
01:23:24,220 --> 01:23:25,419
the beginning in the middle of the list,

2319
01:23:25,459 --> 01:23:26,370
the end of the list,

2320
01:23:26,620 --> 01:23:27,850
but where does that stop?

2321
01:23:27,939 --> 01:23:30,240
What if with binary search you go not Just to the middle,

2322
01:23:30,290 --> 01:23:31,370
but the middle of the middle,

2323
01:23:31,450 --> 01:23:32,870
the middle of the middle of the middle,

2324
01:23:32,899 --> 01:23:33,169
the middle,

2325
01:23:33,250 --> 01:23:36,279
are you going to keep around a pointer to every element because if you do,

2326
01:23:36,450 --> 01:23:39,000
you're essentially back to an array if you've got one

2327
01:23:39,370 --> 01:23:41,160
location for every other location.

2328
01:23:41,209 --> 01:23:42,970
So it just kind of devolves into a mess even

2329
01:23:42,970 --> 01:23:45,729
though there's some minor optimizations we could in fact make.

2330
01:23:45,770 --> 01:23:46,009
In fact,

2331
01:23:46,089 --> 01:23:47,200
we didn't talk about it yet,

2332
01:23:47,410 --> 01:23:50,609
but one common alternative to a singly linked list,

2333
01:23:50,649 --> 01:23:51,839
which ours is,

2334
01:23:51,850 --> 01:23:52,209
it's.

2335
01:23:52,290 --> 01:23:54,350
With a single pointer from node to node,

2336
01:23:55,000 --> 01:23:56,959
computer scientists also like to talk about doubly

2337
01:23:56,959 --> 01:23:59,709
linked lists where there's arrows going both directions,

2338
01:23:59,919 --> 01:24:02,359
which actually would have simplified some of the last code

2339
01:24:02,359 --> 01:24:05,470
that we looked at because I don't have to look ahead

2340
01:24:05,669 --> 01:24:06,500
to figure out

2341
01:24:06,759 --> 01:24:09,759
what I want to free or what and where I want to insert some value,

2342
01:24:09,799 --> 01:24:12,149
but that too doesn't fundamentally change the speed,

2343
01:24:12,160 --> 01:24:14,799
it just makes your code a little easier to write.

2344
01:24:15,080 --> 01:24:15,790
So in short,

2345
01:24:15,910 --> 01:24:17,470
with Linklis we get dynamism.

2346
01:24:17,509 --> 01:24:20,379
We can now grow and shrink things without wasting time copying,

2347
01:24:20,509 --> 01:24:22,910
but we've lost hold of our binary search,

2348
01:24:22,950 --> 01:24:26,160
and that was very appealing as far back as week zero

2349
01:24:26,390 --> 01:24:28,520
when we wanted to do something quite quickly.

2350
01:24:28,910 --> 01:24:31,870
So let's see if we can't make some mashups now.

2351
01:24:32,029 --> 01:24:33,310
Take some arrays,

2352
01:24:33,470 --> 01:24:34,350
take some link lists,

2353
01:24:34,430 --> 01:24:38,089
literally mash them together into a sort of Frankenstein data structure and

2354
01:24:38,089 --> 01:24:41,020
see if we can't get some of the speed of arrays,

2355
01:24:41,149 --> 01:24:42,910
but the dynamism of link lists.

2356
01:24:42,970 --> 01:24:44,189
And so I give you trees.

2357
01:24:44,268 --> 01:24:47,217
If you think about it in your mind's eye what a family tree looks like,

2358
01:24:47,257 --> 01:24:48,937
where you typically have some parents and then

2359
01:24:48,937 --> 01:24:50,967
some children and some grandchildren and so forth,

2360
01:24:51,058 --> 01:24:52,777
it's this sort of tree-like structure,

2361
01:24:52,817 --> 01:24:55,527
even though by convention it's drawn top down instead

2362
01:24:55,527 --> 01:24:57,297
of bottom up like trees in the real world.

2363
01:24:57,317 --> 01:24:59,248
But the top of that family tree

2364
01:24:59,567 --> 01:25:01,217
we're going to call the root of the tree.

2365
01:25:01,297 --> 01:25:03,087
It just so happens to indeed grow down.

2366
01:25:03,297 --> 01:25:05,607
But a tree is a very common data structure

2367
01:25:05,897 --> 01:25:08,737
and it's interesting vis a vis arrays and linked lists in

2368
01:25:08,737 --> 01:25:11,297
that it's the first of our two dimensional data structures.

2369
01:25:11,377 --> 01:25:15,766
An array is effectively just a Single dimension along from left to right.

2370
01:25:15,925 --> 01:25:17,556
A link list is essentially the same,

2371
01:25:17,605 --> 01:25:18,925
even though in reality it might be up,

2372
01:25:18,965 --> 01:25:19,155
down,

2373
01:25:19,166 --> 01:25:20,056
left and right in memory.

2374
01:25:20,085 --> 01:25:22,846
It's still just one thing stitched together in a single dimension.

2375
01:25:22,905 --> 01:25:26,605
A tree adds now a second dimension and specifically useful for

2376
01:25:26,605 --> 01:25:30,036
us is what we're going to call binary search trees,

2377
01:25:30,166 --> 01:25:31,255
which is spoiler,

2378
01:25:31,286 --> 01:25:33,636
going to give us back the ability to use binary search,

2379
01:25:33,786 --> 01:25:35,295
but we're going to store the data

2380
01:25:35,525 --> 01:25:38,315
a little more cleverly than in arrays alone.

2381
01:25:38,335 --> 01:25:42,036
Instead of storing our data in one dimension in a binary search tree,

2382
01:25:42,166 --> 01:25:44,074
we're going to Store in effect in two different

2383
01:25:44,074 --> 01:25:46,144
dimensions and that's going to gain us some speed.

2384
01:25:46,394 --> 01:25:49,874
So here for instance is an array of 7 numbers as we might

2385
01:25:49,874 --> 01:25:53,793
have seen it back in week 2 when we first introduced arrays.

2386
01:25:53,954 --> 01:25:55,793
Let me draw our attention to the middle element

2387
01:25:56,034 --> 01:25:57,664
and then to the middle of the middles,

2388
01:25:57,673 --> 01:25:59,074
and then the middles of the middles of the

2389
01:25:59,074 --> 01:26:01,624
middles just by color coding them slightly differently.

2390
01:26:01,793 --> 01:26:04,284
If I were to run binary search on these numbers or the

2391
01:26:04,284 --> 01:26:06,503
lockers that we had on the stage a few weeks back,

2392
01:26:06,673 --> 01:26:07,713
I would jump to the middle,

2393
01:26:07,833 --> 01:26:08,764
then the middle of the middle,

2394
01:26:08,914 --> 01:26:09,863
and so forth.

2395
01:26:10,193 --> 01:26:11,753
The catch though is that implemented.

2396
01:26:11,832 --> 01:26:12,501
is an array,

2397
01:26:12,541 --> 01:26:14,892
it's not going to be very easy to add new values.

2398
01:26:14,901 --> 01:26:15,251
Why?

2399
01:26:15,461 --> 01:26:18,051
Because if I want to add the number 8 or 9 or 10,

2400
01:26:18,182 --> 01:26:20,611
I might get lucky and there might be room in memory here,

2401
01:26:20,832 --> 01:26:22,062
but I might get unlucky,

2402
01:26:22,142 --> 01:26:24,622
in which case then we've got to start jumping through those hoops of Mao

2403
01:26:24,622 --> 01:26:28,131
or reo and and copying all of this memory to a new location,

2404
01:26:28,222 --> 01:26:28,861
which is doable.

2405
01:26:28,961 --> 01:26:30,091
We solved it in code,

2406
01:26:30,262 --> 01:26:32,461
but it's going to be slow for larger data sets.

2407
01:26:32,501 --> 01:26:33,852
So can we avoid that?

2408
01:26:34,102 --> 01:26:34,222
Well,

2409
01:26:34,301 --> 01:26:37,432
maybe I deliberately color coded things like this because let me

2410
01:26:37,432 --> 01:26:40,892
propose that instead of storing these seven values in an array.

2411
01:26:41,500 --> 01:26:45,100
Let's store them in a family tree-like structure like this where I

2412
01:26:45,100 --> 01:26:47,770
just kind of exploded them vertically on the y axis here.

2413
01:26:47,979 --> 01:26:49,259
So now the middle element.

2414
01:26:49,680 --> 01:26:51,899
The 4s at the top of this tree.

2415
01:26:52,109 --> 01:26:52,509
The 4,

2416
01:26:52,589 --> 01:26:53,419
the 2 and the 6,

2417
01:26:53,430 --> 01:26:56,109
which were the middle elements after the middle,

2418
01:26:56,310 --> 01:26:58,220
are going to be to the left and right of the 4,

2419
01:26:58,229 --> 01:26:59,750
and then these leaf nodes,

2420
01:26:59,830 --> 01:27:00,270
so to speak,

2421
01:27:00,310 --> 01:27:02,870
we borrow a lot of vernacular from the world of actual trees.

2422
01:27:02,990 --> 01:27:05,939
These are leaves in the sense that they themselves have no children.

2423
01:27:06,109 --> 01:27:07,700
They're at the edge of the data structure,

2424
01:27:07,870 --> 01:27:10,180
are going to be the middles of the middles of the middles,

2425
01:27:10,189 --> 01:27:11,660
but all of the data is still there.

2426
01:27:11,870 --> 01:27:14,220
I've just exploded it from 1 to 2 dimensions,

2427
01:27:14,229 --> 01:27:17,259
and let me propose that now that we have this technique of using pointers,

2428
01:27:17,430 --> 01:27:18,509
which we use with.

2429
01:27:18,594 --> 01:27:19,023
C code,

2430
01:27:19,034 --> 01:27:21,813
but you can depict them pictorally with arrows.

2431
01:27:22,144 --> 01:27:25,644
Let me propose that we stitch together these seven values in memory

2432
01:27:25,943 --> 01:27:29,664
using a bunch of pointers whereby now each of these nodes drawn as a

2433
01:27:29,664 --> 01:27:34,813
single square for simplicity is going to have not only an integer associated with it

2434
01:27:35,104 --> 01:27:40,253
and not just one pointer but per these arrows as many as 2 arrows associated with it.

2435
01:27:40,423 --> 01:27:42,153
So our nodes are about to go

2436
01:27:42,503 --> 01:27:44,094
from data structures with 2 things,

2437
01:27:44,184 --> 01:27:47,434
a number and a pointer to 3 things a number.

2438
01:27:47,638 --> 01:27:52,248
And 2 pointers for the left and right child respectively.

2439
01:27:52,458 --> 01:27:56,368
And I dare say now that we have a two dimensional tree data structure,

2440
01:27:56,817 --> 01:27:59,837
consider how you might find a number therein.

2441
01:27:59,998 --> 01:28:01,647
Suppose I'm searching for the number 5.

2442
01:28:01,817 --> 01:28:01,978
Well,

2443
01:28:02,098 --> 01:28:03,817
I start at the root of the data structure and

2444
01:28:03,817 --> 01:28:05,928
even though our human eyes obviously know where we're going,

2445
01:28:06,178 --> 01:28:08,868
notice what's important about this binary search tree.

2446
01:28:09,058 --> 01:28:11,118
If I go to the root of the note of the tree,

2447
01:28:11,297 --> 01:28:13,567
I see the 44 is obviously less than 5.

2448
01:28:13,698 --> 01:28:14,567
What does this mean?

2449
01:28:14,848 --> 01:28:16,337
This means I can divide and.

2450
01:28:16,571 --> 01:28:17,921
the problem right off the bat.

2451
01:28:18,091 --> 01:28:20,441
I know that 5 is going to be to the right

2452
01:28:20,771 --> 01:28:21,762
of this node,

2453
01:28:22,012 --> 01:28:23,571
which means effectively if you think in your

2454
01:28:23,571 --> 01:28:25,642
mind's eye about snipping the branch there,

2455
01:28:25,852 --> 01:28:29,821
I have just halved the problem essentially like dividing the phone book in half.

2456
01:28:29,972 --> 01:28:30,321
Why?

2457
01:28:30,492 --> 01:28:33,501
Because I don't even waste time looking at this subtree,

2458
01:28:33,651 --> 01:28:35,611
the left child of the 4 element.

2459
01:28:36,012 --> 01:28:36,562
Meanwhile,

2460
01:28:36,731 --> 01:28:37,881
if I go from the root

2461
01:28:38,091 --> 01:28:40,041
to its right child here,

2462
01:28:40,251 --> 01:28:41,662
I see the number 6.5,

2463
01:28:41,691 --> 01:28:41,961
of course,

2464
01:28:41,972 --> 01:28:42,742
is less than 6,

2465
01:28:42,771 --> 01:28:45,251
so this is effectively like snipping off that child.

2466
01:28:45,886 --> 01:28:48,166
because I don't need to go further there because I know

2467
01:28:48,166 --> 01:28:50,395
a smaller element is going to be in this direction,

2468
01:28:50,516 --> 01:28:53,525
and that's the key property of a binary search tree.

2469
01:28:53,565 --> 01:28:56,755
It's not just a family tree with numbers all over the place.

2470
01:28:56,925 --> 01:28:58,545
They follow a certain pattern.

2471
01:28:58,806 --> 01:28:59,476
Every

2472
01:28:59,996 --> 01:29:04,645
element is going to be greater than its left child and less than

2473
01:29:04,846 --> 01:29:05,835
its right child,

2474
01:29:05,965 --> 01:29:07,806
assuming you don't have identical values,

2475
01:29:07,916 --> 01:29:10,675
and that property is actually a recursive one to

2476
01:29:10,675 --> 01:29:12,405
borrow terminology from a couple of weeks back,

2477
01:29:12,485 --> 01:29:14,085
recall that a recursive function is one.

2478
01:29:14,500 --> 01:29:18,450
That calls itself a recursive data structure like the pyramid in Mario

2479
01:29:18,450 --> 01:29:21,990
is a data structure that can be defined in terms of itself.

2480
01:29:22,180 --> 01:29:22,220
Well,

2481
01:29:22,299 --> 01:29:26,649
a binary search tree is a recursive property insofar as if it applies to this node,

2482
01:29:26,859 --> 01:29:28,100
it also applies to this note.

2483
01:29:28,220 --> 01:29:30,200
Case in 0.2 is greater than 1,

2484
01:29:30,339 --> 01:29:31,979
but it's also less than 3.

2485
01:29:32,100 --> 01:29:32,939
It's true over here.

2486
01:29:32,990 --> 01:29:34,529
6 is greater than 5,

2487
01:29:34,680 --> 01:29:35,569
but less than 7,

2488
01:29:35,580 --> 01:29:36,069
and it's technically.

2489
01:29:36,419 --> 01:29:38,740
True of the leaf nodes because the definition is at

2490
01:29:38,740 --> 01:29:41,810
least not violated there because they don't even have children

2491
01:29:42,419 --> 01:29:42,819
themselves.

2492
01:29:42,899 --> 01:29:45,370
So this is a binary search tree because of that pattern.

2493
01:29:45,580 --> 01:29:46,870
So this then invites the question,

2494
01:29:46,879 --> 01:29:46,939
Well,

2495
01:29:47,060 --> 01:29:51,450
how long does it take us to search for a value in a binary search tree?

2496
01:29:51,620 --> 01:29:51,680
Well,

2497
01:29:51,709 --> 01:29:52,779
if the number is 5,

2498
01:29:52,819 --> 01:29:54,799
it's going to take me 12 steps.

2499
01:29:54,899 --> 01:29:56,220
But if there's an elements here,

2500
01:29:56,339 --> 01:29:58,009
can someone want to generalize that

2501
01:29:58,379 --> 01:30:01,259
either mathematically or just instinctively big go of.

2502
01:30:02,799 --> 01:30:05,240
Logn and even if you're not quite sure how the math works

2503
01:30:05,240 --> 01:30:07,979
out any time you take a data set and you have it,

2504
01:30:08,040 --> 01:30:08,379
have it,

2505
01:30:08,439 --> 01:30:08,750
have it,

2506
01:30:08,759 --> 01:30:11,240
we're talking about log based 2 of N again and

2507
01:30:11,240 --> 01:30:13,479
indeed that's going to describe the height of this tree.

2508
01:30:13,520 --> 01:30:15,000
The height of this tree is essentially

2509
01:30:15,200 --> 01:30:18,709
log based 2 of N because if N is 7,

2510
01:30:18,919 --> 01:30:19,720
it's going to give me.

2511
01:30:20,770 --> 01:30:22,689
essentially 2 when we round appropriately.

2512
01:30:22,770 --> 01:30:25,959
If we round up if we've got 8 elements log based 2 of 82 to the 3,

2513
01:30:26,049 --> 01:30:26,700
so that means 3,

2514
01:30:26,770 --> 01:30:28,040
so 123,

2515
01:30:28,089 --> 01:30:30,799
it kind of works out even if I'm doing that a bit quickly.

2516
01:30:30,950 --> 01:30:33,399
The height of this tree is log base 2 of N,

2517
01:30:33,490 --> 01:30:35,450
AKA big O of log N.

2518
01:30:35,609 --> 01:30:37,009
How long does it take to insert?

2519
01:30:37,379 --> 01:30:39,770
I think it's going to take log in because I can insert over

2520
01:30:39,770 --> 01:30:42,959
here or over here or over here depending on where the number goes.

2521
01:30:43,350 --> 01:30:44,459
How long does it take to delete?

2522
01:30:44,490 --> 01:30:45,919
I'll claim it's going to take about the same.

2523
01:30:45,970 --> 01:30:46,609
So wow,

2524
01:30:46,689 --> 01:30:47,720
we're back in business.

2525
01:30:47,930 --> 01:30:49,379
I've got now the ability

2526
01:30:49,729 --> 01:30:53,319
to grow and shrink my data structure because if I want to insert the number 8,

2527
01:30:53,490 --> 01:30:54,250
it's going to go right there.

2528
01:30:54,330 --> 01:30:56,209
If I want to insert the number like 5.5,

2529
01:30:56,609 --> 01:30:57,970
I can see where I would put it.

2530
01:30:58,299 --> 01:31:01,009
It's going to be easy to add new nodes by just updating the

2531
01:31:01,009 --> 01:31:04,919
pointers without copying everything in memory like we had to for arrays,

2532
01:31:05,290 --> 01:31:05,759
but

2533
01:31:06,089 --> 01:31:07,600
there is a downside here.

2534
01:31:08,450 --> 01:31:09,720
I gotta concede something.

2535
01:31:09,810 --> 01:31:10,359
What am I,

2536
01:31:10,569 --> 01:31:11,919
what price am I paying?

2537
01:31:12,209 --> 01:31:15,520
What's the trade off here to gain that dynamism and that speed,

2538
01:31:18,279 --> 01:31:18,290
but.

2539
01:31:18,870 --> 01:31:19,109
Yeah,

2540
01:31:19,240 --> 01:31:21,990
I'm literally using 3 times as much memory now

2541
01:31:21,990 --> 01:31:24,229
because even though it's not depicted here explicitly,

2542
01:31:24,319 --> 01:31:29,120
each of these squares represents an integer and a pointer and another pointer,

2543
01:31:29,160 --> 01:31:30,080
so that's like 16,

2544
01:31:30,160 --> 01:31:32,759
that's like 20 bytes at this point of memory instead of

2545
01:31:32,759 --> 01:31:35,459
just 4 bytes for each of the integers in an array.

2546
01:31:35,680 --> 01:31:36,290
Nowadays though.

2547
01:31:36,464 --> 01:31:37,375
Space is pretty cheap.

2548
01:31:37,415 --> 01:31:39,015
We all have very large Dropbox folders,

2549
01:31:39,055 --> 01:31:39,845
iCloud folders,

2550
01:31:39,854 --> 01:31:40,254
and the like,

2551
01:31:40,334 --> 01:31:42,854
so it's not really a big deal to use that many more bytes.

2552
01:31:43,004 --> 01:31:44,535
Certainly not a big deal for 7 numbers,

2553
01:31:44,575 --> 01:31:46,015
but if it's 7 million numbers,

2554
01:31:46,084 --> 01:31:50,225
maybe this isn't the best data structure to use even if speed is important.

2555
01:31:50,345 --> 01:31:54,055
You've got to decide ultimately based on your actual use case what.

2556
01:31:54,580 --> 01:31:55,850
Matters more.

2557
01:31:56,100 --> 01:31:56,580
So in short,

2558
01:31:56,589 --> 01:31:59,850
a binary search tree you can kind of think of as an amalgam of,

2559
01:32:00,339 --> 01:32:02,930
or rather a variant of a linked list,

2560
01:32:03,299 --> 01:32:06,459
except that every node has as many as 2 pointers instead of one,

2561
01:32:06,500 --> 01:32:07,890
which is what gives us now this

2562
01:32:08,209 --> 01:32:09,490
this second dimension.

2563
01:32:09,620 --> 01:32:12,060
And in fact this translates pretty nicely to code.

2564
01:32:12,100 --> 01:32:12,529
In fact,

2565
01:32:12,700 --> 01:32:15,359
if we consider how we implemented in a linked list,

2566
01:32:15,379 --> 01:32:15,950
a node,

2567
01:32:16,140 --> 01:32:18,379
recall that it looked like this where you got a number in each

2568
01:32:18,379 --> 01:32:21,890
node and a pointer to the next element in the linked list.

2569
01:32:22,060 --> 01:32:22,100
Well,

2570
01:32:22,160 --> 01:32:22,299
I.

2571
01:32:22,413 --> 01:32:25,522
Think for a binary search tree we can sort of borrow this as inspiration,

2572
01:32:25,583 --> 01:32:28,192
make a little more room because we need two pointers instead of 1,

2573
01:32:28,362 --> 01:32:31,192
and I'm just going to call the left child the left pointer

2574
01:32:31,442 --> 01:32:32,312
and the right pointer,

2575
01:32:32,362 --> 01:32:34,712
but here is the 3 times as much space,

2576
01:32:34,842 --> 01:32:35,553
give or take,

2577
01:32:35,792 --> 01:32:38,402
because I now have 3 elements associated 2 pieces of

2578
01:32:38,402 --> 01:32:41,913
metadata and 1 piece of data that I actually care about

2579
01:32:42,283 --> 01:32:44,342
to stitch this thing here together.

2580
01:32:44,623 --> 01:32:44,763
All right,

2581
01:32:44,842 --> 01:32:44,962
well,

2582
01:32:45,002 --> 01:32:46,752
if this is the data structure there,

2583
01:32:46,922 --> 01:32:48,353
how could I implement this in code?

2584
01:32:48,362 --> 01:32:48,442
Well,

2585
01:32:48,562 --> 01:32:50,243
here's where recursion again comes into.

2586
01:32:50,395 --> 01:32:52,895
The fact that a binary search tree

2587
01:32:53,186 --> 01:32:56,496
is recursive in nature in that what you say about this node,

2588
01:32:56,866 --> 01:32:59,425
about it being greater than the left child and less than the right child can

2589
01:32:59,425 --> 01:33:02,116
be said of this node and this node and this node and this note,

2590
01:33:02,306 --> 01:33:05,386
you can leverage that beautifully in code like this.

2591
01:33:05,545 --> 01:33:09,025
So suppose I'm implementing a search function in C whose

2592
01:33:09,025 --> 01:33:10,746
purpose in life is just to say yes or no,

2593
01:33:10,905 --> 01:33:11,695
true or false,

2594
01:33:11,866 --> 01:33:14,175
the number you're looking for is in this tree,

2595
01:33:14,346 --> 01:33:16,465
which might be a useful thing to check in

2596
01:33:16,985 --> 01:33:18,226
in an algorithm.

2597
01:33:18,879 --> 01:33:22,549
Search is going to take two arguments I propose the number you're searching for

2598
01:33:22,839 --> 01:33:24,479
and a pointer to the tree,

2599
01:33:24,520 --> 01:33:27,040
that is the root of the tree initially.

2600
01:33:27,359 --> 01:33:30,040
So how do you actually traverse this thing in C code?

2601
01:33:30,049 --> 01:33:30,390
Well,

2602
01:33:30,600 --> 01:33:32,399
we can pluck off the easy case first,

2603
01:33:32,479 --> 01:33:33,000
the base case.

2604
01:33:33,040 --> 01:33:34,120
If the tree itself is null,

2605
01:33:34,200 --> 01:33:35,149
like if you hand me nothing,

2606
01:33:35,399 --> 01:33:36,540
I'll give you your answer right now,

2607
01:33:36,600 --> 01:33:37,180
false,

2608
01:33:37,279 --> 01:33:38,109
like there's no

2609
01:33:38,359 --> 01:33:40,279
number here if the tree is empty.

2610
01:33:40,319 --> 01:33:41,189
So that's easy.

2611
01:33:41,439 --> 01:33:42,109
Otherwise,

2612
01:33:42,160 --> 01:33:43,709
if the number you're looking for

2613
01:33:44,080 --> 01:33:45,120
is less than.

2614
01:33:45,245 --> 01:33:47,625
The number in the current node.

2615
01:33:47,794 --> 01:33:50,384
So tree is what's passed in a pointer to the root.

2616
01:33:50,555 --> 01:33:51,555
So if you follow the arrow,

2617
01:33:51,595 --> 01:33:54,504
you can get inside of that value and see its number.

2618
01:33:54,794 --> 01:33:56,435
If the number you're looking for is less than that,

2619
01:33:56,555 --> 01:33:57,064
OK,

2620
01:33:57,274 --> 01:34:01,495
you want to what snip off the right tree and dive down the left subtree.

2621
01:34:01,555 --> 01:34:01,984
So

2622
01:34:02,234 --> 01:34:03,225
you search

2623
01:34:03,555 --> 01:34:04,464
the tree's

2624
01:34:04,754 --> 01:34:06,625
left child for the same number.

2625
01:34:07,154 --> 01:34:09,865
Else if the number you're looking for is greater than that number,

2626
01:34:10,075 --> 01:34:10,984
you search.

2627
01:34:11,450 --> 01:34:12,330
For the trees,

2628
01:34:12,529 --> 01:34:12,729
right,

2629
01:34:12,770 --> 01:34:13,200
child,

2630
01:34:13,290 --> 01:34:14,240
for that same number.

2631
01:34:14,529 --> 01:34:16,500
And the 4th and final scenario is what?

2632
01:34:16,609 --> 01:34:16,810
Well,

2633
01:34:16,930 --> 01:34:20,859
if the number you're looking for equals the number in the current node,

2634
01:34:21,209 --> 01:34:22,000
you got it

2635
01:34:22,450 --> 01:34:23,160
return true.

2636
01:34:23,330 --> 01:34:26,209
And if you're uh recall some of our past design discussions,

2637
01:34:26,290 --> 01:34:29,359
this is sort of a waste of everyone's time to ask this question explicitly.

2638
01:34:29,529 --> 01:34:32,959
Let me tighten this up design wise because there's only 4 possible scenarios.

2639
01:34:32,970 --> 01:34:34,049
Either there's nothing there,

2640
01:34:34,109 --> 01:34:34,799
it's to the left,

2641
01:34:34,850 --> 01:34:35,490
it's to the right,

2642
01:34:35,589 --> 01:34:36,319
or you found it.

2643
01:34:36,450 --> 01:34:37,200
It's right there.

2644
01:34:37,689 --> 01:34:38,259
So

2645
01:34:38,740 --> 01:34:41,930
whether or not you agree at this point in your programming career,

2646
01:34:42,140 --> 01:34:46,419
like there is a beauty to this code that most programmers would claim is

2647
01:34:46,419 --> 01:34:48,700
here and that it's so relatively elegant

2648
01:34:48,700 --> 01:34:50,379
whereby you've defined what the function is.

2649
01:34:50,459 --> 01:34:53,220
You've got this base case which is arguably one of the clunkiest parts,

2650
01:34:53,259 --> 01:34:54,740
but the fact that you can just check a

2651
01:34:54,740 --> 01:34:58,250
value here and then traverse the exact same structure,

2652
01:34:58,379 --> 01:35:01,140
but a subset of it by traversing the left subtree or

2653
01:35:01,140 --> 01:35:04,459
the right subtree is like a beautiful application of recursion.

2654
01:35:04,750 --> 01:35:07,879
And it allows you to uh search for this thing no matter where it is

2655
01:35:08,169 --> 01:35:09,319
in the computer's memory.

2656
01:35:09,729 --> 01:35:12,560
Questions then on this idea of a binary search tree or this actual.

2657
01:35:13,500 --> 01:35:14,459
Code thereof.

2658
01:35:19,580 --> 01:35:20,319
Uh,

2659
01:35:20,439 --> 01:35:20,689
nope.

2660
01:35:20,759 --> 01:35:22,189
If the number is not there,

2661
01:35:22,279 --> 01:35:23,040
we recall.

2662
01:35:23,240 --> 01:35:25,750
So if we get all the way to the bottom of the tree,

2663
01:35:25,990 --> 01:35:27,839
such that now I'm at one of those leaf nodes,

2664
01:35:27,919 --> 01:35:29,470
and that's not the number I'm looking for,

2665
01:35:29,640 --> 01:35:31,149
such that there's no left child left,

2666
01:35:31,279 --> 01:35:32,350
no right child left,

2667
01:35:32,600 --> 01:35:35,830
this conditional is going to kick in and I'm going to return false.

2668
01:35:36,160 --> 01:35:37,799
But if I find it along the way,

2669
01:35:37,879 --> 01:35:41,129
whether it's at the top of the tree or somewhere in the middle or among the leaves,

2670
01:35:41,200 --> 01:35:42,470
I will eventually return

2671
01:35:42,799 --> 01:35:43,189
true.

2672
01:35:44,310 --> 01:35:45,009
Good question.

2673
01:35:45,140 --> 01:35:45,890
And to be clear,

2674
01:35:46,060 --> 01:35:47,419
even though I'm calling this a tree,

2675
01:35:47,580 --> 01:35:49,819
that's true certainly for the first time I call this function

2676
01:35:49,819 --> 01:35:52,569
because I'm passing in a pointer to the whole tree structure.

2677
01:35:52,859 --> 01:35:53,740
But if you think about it,

2678
01:35:53,819 --> 01:35:55,569
what's the left subtree and the right subtree,

2679
01:35:55,660 --> 01:35:56,859
it's just a smaller tree.

2680
01:35:56,879 --> 01:35:59,580
It's like a baby tree that's attached to this parent node,

2681
01:35:59,660 --> 01:36:00,250
so to speak,

2682
01:36:00,419 --> 01:36:04,779
so it's perfectly reasonable to just call the search function with that child

2683
01:36:04,779 --> 01:36:08,410
because it in turn has a whole subtree below it or the right child

2684
01:36:08,620 --> 01:36:10,009
which has the whole subtree

2685
01:36:10,459 --> 01:36:11,939
below it instead.

2686
01:36:12,640 --> 01:36:12,959
All right,

2687
01:36:13,200 --> 01:36:14,720
so I like this direction.

2688
01:36:14,839 --> 01:36:17,120
We've now kind of improved upon link list.

2689
01:36:17,200 --> 01:36:20,080
We've gained back some of our performance because we can

2690
01:36:20,080 --> 01:36:23,109
now find something with big O of log and time.

2691
01:36:23,359 --> 01:36:26,160
I don't love the fact that I'm using 3 times as much memory roughly.

2692
01:36:26,240 --> 01:36:29,229
That feels like kind of a high price to pay just to speed things back up.

2693
01:36:29,359 --> 01:36:31,720
But let's consider whether or not this thing is actually going to

2694
01:36:31,720 --> 01:36:34,029
work as the data structure gets bigger and bigger as well.

2695
01:36:34,089 --> 01:36:35,589
So it looks beautiful here as written,

2696
01:36:35,640 --> 01:36:36,000
and that's.

2697
01:36:36,137 --> 01:36:39,316
Deliberate because I drew the picture like this and it's got 7 elements in it.

2698
01:36:39,446 --> 01:36:41,086
But how did we get to 7 elements?

2699
01:36:41,126 --> 01:36:42,166
Let's start from the beginning.

2700
01:36:42,247 --> 01:36:45,236
Suppose that the tree is initially empty and suppose that

2701
01:36:45,486 --> 01:36:48,336
a human using get into or some other technique inserts

2702
01:36:48,336 --> 01:36:50,557
the first element into the list like the number 2,

2703
01:36:50,767 --> 01:36:53,716
and the goal is to maintain the binary search tree property,

2704
01:36:53,926 --> 01:36:56,526
which means you've got to have it greater than the left child,

2705
01:36:56,566 --> 01:36:57,716
less than the right child.

2706
01:36:57,847 --> 01:36:59,767
So suppose the human using get into or some other.

2707
01:36:59,894 --> 01:37:01,534
Technique next gives me the number 1.

2708
01:37:01,773 --> 01:37:02,284
No big deal.

2709
01:37:02,454 --> 01:37:03,173
I plop it right there.

2710
01:37:03,324 --> 01:37:04,083
Is the left child.

2711
01:37:04,224 --> 01:37:05,764
Suppose they give me the number 3 next,

2712
01:37:06,094 --> 01:37:06,613
no big deal.

2713
01:37:06,693 --> 01:37:07,644
It goes right there.

2714
01:37:07,854 --> 01:37:11,054
I have very deliberately manipulated this story to work

2715
01:37:11,054 --> 01:37:13,014
out beautifully such that the tree is smaller,

2716
01:37:13,213 --> 01:37:16,804
but it's still a binary search tree and nicely balanced,

2717
01:37:16,894 --> 01:37:17,563
so to speak.

2718
01:37:17,773 --> 01:37:18,684
But what if the user,

2719
01:37:18,693 --> 01:37:21,043
for whatever reason just gives me a more perverse

2720
01:37:21,043 --> 01:37:23,494
sequence of inputs like the worst case scenario.

2721
01:37:23,911 --> 01:37:27,130
to give me 3 elements and suppose they give me 1 1st.

2722
01:37:27,261 --> 01:37:27,541
OK,

2723
01:37:27,650 --> 01:37:28,451
that's the root.

2724
01:37:28,701 --> 01:37:29,770
Then they give me 2.

2725
01:37:29,980 --> 01:37:30,311
OK,

2726
01:37:30,541 --> 01:37:30,900
that's cool.

2727
01:37:30,980 --> 01:37:32,411
That's like the right child.

2728
01:37:32,741 --> 01:37:34,250
But what if they then give me 3?

2729
01:37:34,500 --> 01:37:34,621
Well,

2730
01:37:34,780 --> 01:37:36,661
to maintain that binary search property,

2731
01:37:36,741 --> 01:37:39,090
the 3 has to go over here.

2732
01:37:39,261 --> 01:37:41,261
Suppose perversely then they didn't give me 4,

2733
01:37:41,380 --> 01:37:41,891
then 5,

2734
01:37:42,020 --> 01:37:42,480
then 6.

2735
01:37:42,561 --> 01:37:44,530
Imagine in your mind's eye where this story is going.

2736
01:37:44,820 --> 01:37:47,181
What have I accidentally created in memory then?

2737
01:37:48,370 --> 01:37:51,330
A link list which is like bad for all the reasons we

2738
01:37:51,330 --> 01:37:53,729
discussed before the break because even though we're getting the dynamism,

2739
01:37:53,770 --> 01:37:56,299
it's devolving into big O of N.

2740
01:37:56,799 --> 01:37:59,049
So I've kind of manipulated the situation here

2741
01:37:59,049 --> 01:38:01,470
with their original example with 7 elements and

2742
01:38:01,470 --> 01:38:03,330
then 3 elements by making sure that they

2743
01:38:03,330 --> 01:38:06,319
were inserted in just the right order because unless

2744
01:38:06,649 --> 01:38:09,649
you are clever about how you build the tree in memory,

2745
01:38:09,660 --> 01:38:12,089
it could very well devolve from a tree.

2746
01:38:12,549 --> 01:38:16,520
In two dimensions into actually a linked list in one dimension.

2747
01:38:16,580 --> 01:38:18,770
And now this is just a long and stringy tree

2748
01:38:18,770 --> 01:38:22,009
that does not violate the binary search tree definition,

2749
01:38:22,180 --> 01:38:24,649
but it is surely not balanced in this case.

2750
01:38:24,859 --> 01:38:25,540
Now as an aside,

2751
01:38:25,580 --> 01:38:28,180
if you take higher level languages and data structures and algorithms,

2752
01:38:28,259 --> 01:38:32,089
there's many different alternatives to binary search trees

2753
01:38:32,299 --> 01:38:35,129
that actually have baked into the algorithms,

2754
01:38:35,240 --> 01:38:37,290
a little bit of rejiggering of the

2755
01:38:37,779 --> 01:38:39,160
structure so that really

2756
01:38:39,419 --> 01:38:40,870
as soon as you insert this 3.

2757
01:38:41,134 --> 01:38:43,575
You spend a little bit more time and clean the situation

2758
01:38:43,575 --> 01:38:45,975
up and essentially what you do is like pivot the thing around

2759
01:38:45,975 --> 01:38:49,415
this way so that 2 becomes the new root and then 1

2760
01:38:49,415 --> 01:38:52,044
hangs off of it and 3 still hangs off of it.

2761
01:38:52,214 --> 01:38:54,194
So with each insertion or deletion,

2762
01:38:54,334 --> 01:38:56,294
you rebalance the tree as needed,

2763
01:38:56,334 --> 01:38:58,004
which does cost you a bit more time,

2764
01:38:58,134 --> 01:39:01,694
but it avoids the thing devolving into big O of N

2765
01:39:01,935 --> 01:39:03,564
again and we won't do that in code,

2766
01:39:03,734 --> 01:39:05,274
so this is recoverable,

2767
01:39:05,535 --> 01:39:09,174
but not if you implement it naively as I did at least verbally.

2768
01:39:09,740 --> 01:39:10,799
In this story,

2769
01:39:11,640 --> 01:39:12,040
all right,

2770
01:39:12,250 --> 01:39:12,609
well,

2771
01:39:12,810 --> 01:39:13,799
can we do

2772
01:39:14,129 --> 01:39:14,970
better than that?

2773
01:39:15,049 --> 01:39:15,209
Well,

2774
01:39:15,370 --> 01:39:16,319
why might we want to?

2775
01:39:16,410 --> 01:39:16,470
Well,

2776
01:39:16,569 --> 01:39:17,799
at this point in the story,

2777
01:39:18,009 --> 01:39:19,870
it certainly could devolve into big old event,

2778
01:39:19,930 --> 01:39:21,109
and that's not great.

2779
01:39:21,200 --> 01:39:22,490
Certainly for large data sets.

2780
01:39:22,609 --> 01:39:24,089
It's nice that we're back to log in,

2781
01:39:24,290 --> 01:39:26,600
at least if you take on faith that we could kind of

2782
01:39:26,600 --> 01:39:30,319
rebalance this thing as needed and maintain a logarithmic height for it.

2783
01:39:30,490 --> 01:39:32,810
But really the holy grail of data structures is

2784
01:39:32,810 --> 01:39:35,259
to achieve something that is big O of 1,

2785
01:39:35,290 --> 01:39:38,257
like constant time whereby no matter How many numbers

2786
01:39:38,257 --> 01:39:41,107
or names or sweaters are in the data structure,

2787
01:39:41,257 --> 01:39:42,198
it will take just

2788
01:39:42,498 --> 01:39:44,158
1 step or maybe 3 steps,

2789
01:39:44,448 --> 01:39:44,498
right,

2790
01:39:44,538 --> 01:39:45,728
even 100 steps,

2791
01:39:45,737 --> 01:39:46,127
but

2792
01:39:46,337 --> 01:39:47,567
a number of steps

2793
01:39:47,897 --> 01:39:50,458
that is completely independent of how many actual

2794
01:39:50,458 --> 01:39:52,538
pieces of data are in the data structure.

2795
01:39:52,578 --> 01:39:56,388
That is to say over time it doesn't get any slower even if you've got tens,

2796
01:39:56,458 --> 01:39:56,777
hundreds,

2797
01:39:56,788 --> 01:39:57,217
thousands,

2798
01:39:57,297 --> 01:39:59,888
millions of elements in there already.

2799
01:40:00,178 --> 01:40:03,498
So how do we gain something like big O of one constant.

2800
01:40:03,616 --> 01:40:04,116
Time,

2801
01:40:04,686 --> 01:40:05,835
the appeal of which

2802
01:40:06,125 --> 01:40:08,445
is reminiscent of our early picture from week one.

2803
01:40:08,496 --> 01:40:11,206
Like this was our early algorithm for finding someone in

2804
01:40:11,206 --> 01:40:13,255
a phone book or counting students in the room,

2805
01:40:13,485 --> 01:40:14,085
something linear,

2806
01:40:14,206 --> 01:40:15,286
literally straight lines.

2807
01:40:15,405 --> 01:40:16,686
This was the logarithmic curve,

2808
01:40:16,766 --> 01:40:17,846
which especially as you zoom out,

2809
01:40:17,965 --> 01:40:18,645
starts to get very,

2810
01:40:18,766 --> 01:40:20,235
very appealing time wise.

2811
01:40:20,485 --> 01:40:22,875
Something that's constant time looks even prettier.

2812
01:40:23,045 --> 01:40:26,806
It is a straight line at like the one step mark or the two step marks,

2813
01:40:26,886 --> 01:40:28,715
whatever the constant number of step marks is.

2814
01:40:28,925 --> 01:40:29,686
And even though

2815
01:40:29,804 --> 01:40:32,423
Algorithmic will still grow in perpetuity.

2816
01:40:32,713 --> 01:40:35,204
Constant time by definition never changes,

2817
01:40:35,213 --> 01:40:36,554
and this is what we'd really like.

2818
01:40:36,594 --> 01:40:38,034
So when you're searching for someone in your phone,

2819
01:40:38,173 --> 01:40:39,474
you're searching for something on Google,

2820
01:40:39,514 --> 01:40:40,863
you're asking a question of ChatGBT,

2821
01:40:40,914 --> 01:40:42,463
you get an answer like that

2822
01:40:42,633 --> 01:40:44,063
in constant time,

2823
01:40:44,074 --> 01:40:46,704
independent of how much data is actually in there.

2824
01:40:46,914 --> 01:40:46,994
Well,

2825
01:40:47,034 --> 01:40:48,374
let's see how we can do this.

2826
01:40:48,474 --> 01:40:49,054
To do this,

2827
01:40:49,104 --> 01:40:50,673
we're going to at least need a new building block,

2828
01:40:50,753 --> 01:40:52,554
a term of art known as hashing.

2829
01:40:52,753 --> 01:40:55,874
Hashing sort of formally takes an infinite domain of value.

2830
01:40:55,992 --> 01:40:58,812
Use and maps it to a finite range of values.

2831
01:40:58,941 --> 01:40:59,981
So from high school math class,

2832
01:41:00,021 --> 01:41:00,791
domain is the input,

2833
01:41:00,941 --> 01:41:01,782
range is the output.

2834
01:41:01,861 --> 01:41:03,332
So an infinite domain

2835
01:41:03,671 --> 01:41:07,041
to a finite range is the goal here of hashing.

2836
01:41:07,122 --> 01:41:09,332
And we might see this actually in the real world when you're playing,

2837
01:41:09,541 --> 01:41:09,702
you know,

2838
01:41:09,782 --> 01:41:10,492
games or whatnot,

2839
01:41:10,501 --> 01:41:11,812
or you're cleaning up after a game.

2840
01:41:11,821 --> 01:41:12,452
Like here is,

2841
01:41:12,622 --> 01:41:15,782
here are some super jumbo playing cards that we got online and

2842
01:41:15,782 --> 01:41:18,251
suppose that you want to just get these into sorted order.

2843
01:41:18,662 --> 01:41:20,102
You could do this very painstakingly.

2844
01:41:20,182 --> 01:41:21,151
There's 52 cards here.

2845
01:41:21,182 --> 01:41:22,062
You could kind of lay them all.

2846
01:41:22,180 --> 01:41:24,689
Out and start sifting through them and put the 2 over here and

2847
01:41:24,689 --> 01:41:27,399
the 4 over here and the hearts and the clubs and so forth,

2848
01:41:27,569 --> 01:41:30,930
or you can start to look at the cards and bucketize them first to

2849
01:41:30,930 --> 01:41:36,250
take a 52 size problem and maybe shrink it down into 413 byte problems.

2850
01:41:36,330 --> 01:41:38,040
So here for instance is where

2851
01:41:38,529 --> 01:41:40,120
the first diamond might go,

2852
01:41:40,250 --> 01:41:41,600
the club here,

2853
01:41:41,850 --> 01:41:43,160
spade over here,

2854
01:41:43,250 --> 01:41:45,839
diamond over here,

2855
01:41:46,009 --> 01:41:48,140
and I can kind of just do this again and again,

2856
01:41:48,729 --> 01:41:50,250
bucketizing literally.

2857
01:41:50,850 --> 01:41:52,049
All of these values

2858
01:41:52,330 --> 01:41:53,120
so that

2859
01:41:53,370 --> 01:41:58,930
I've got a very simple heuristic that allows me to move the cards into these buckets,

2860
01:41:59,089 --> 01:42:01,279
each of which is going to have a subset of the values,

2861
01:42:01,290 --> 01:42:02,930
and then I've got smaller problems I can deal with.

2862
01:42:03,729 --> 01:42:06,169
So assume that I bucketize all 52 of these values,

2863
01:42:06,290 --> 01:42:07,850
then I've just got 4 problems remaining,

2864
01:42:07,890 --> 01:42:10,370
and I dare say it's a little easier then because they're all of the same.

2865
01:42:10,490 --> 01:42:12,959
So and so I can pretty easily sort it from ace to

2866
01:42:12,959 --> 01:42:16,750
king or whatnot because those are effectively just numbers at that point.

2867
01:42:17,000 --> 01:42:20,680
So hashing refers to again taking values from an infinite range.

2868
01:42:20,720 --> 01:42:23,629
In this case it can be finite and it is in this case,

2869
01:42:23,720 --> 01:42:25,709
but if you were doing it more generally with numbers,

2870
01:42:25,839 --> 01:42:30,240
you just have to map it to a finite range like 1234 finite.

2871
01:42:30,850 --> 01:42:33,770
Number of buckets of values at which point then you can

2872
01:42:33,770 --> 01:42:37,120
solve the problem a little differently or a little more efficiently.

2873
01:42:37,569 --> 01:42:39,509
So why is this germane?

2874
01:42:39,770 --> 01:42:39,890
Well,

2875
01:42:39,970 --> 01:42:41,430
I would propose that

2876
01:42:41,810 --> 01:42:46,120
if we want to start organizing our data in memory

2877
01:42:46,370 --> 01:42:49,240
toward an idealistic goal of achieving constant time,

2878
01:42:49,450 --> 01:42:52,680
hashing might be one ingredient for the solution there too.

2879
01:42:52,850 --> 01:42:55,560
And generally we're going to describe the process by which you decide

2880
01:42:55,850 --> 01:42:59,720
what input goes to what output is namely what's called a hash function.

2881
01:42:59,759 --> 01:43:00,410
It's a mathematical.

2882
01:43:00,547 --> 01:43:04,937
Function or a function code that takes as input a card from a deck or maybe a

2883
01:43:04,937 --> 01:43:07,948
word from a dictionary and outputs a value that

2884
01:43:07,948 --> 01:43:10,328
represents the bucket into which it should go.

2885
01:43:10,538 --> 01:43:12,257
So in the case of our contacts app,

2886
01:43:12,268 --> 01:43:12,698
for instance,

2887
01:43:12,788 --> 01:43:14,498
of course in the GUI of it you have all

2888
01:43:14,498 --> 01:43:18,368
of your friends and family top to bottom alphabetically presumably,

2889
01:43:18,737 --> 01:43:20,328
and you might want to ideally

2890
01:43:20,458 --> 01:43:21,368
find someone

2891
01:43:21,817 --> 01:43:22,768
quite quickly,

2892
01:43:22,937 --> 01:43:24,288
ideally in constant time.

2893
01:43:24,498 --> 01:43:26,337
The naive implementation that Apple or Google

2894
01:43:26,337 --> 01:43:27,737
could implement is just use linear search,

2895
01:43:27,817 --> 01:43:29,888
search through all of your contacts top to bottom,

2896
01:43:30,018 --> 01:43:30,458
and eventually.

2897
01:43:30,516 --> 01:43:32,616
You will correctly find the person,

2898
01:43:32,786 --> 01:43:35,105
but wouldn't it be nice if they instead use an array and then

2899
01:43:35,105 --> 01:43:37,786
they can use binary search and get you the person in logarithmic time?

2900
01:43:37,826 --> 01:43:38,215
That's great.

2901
01:43:38,306 --> 01:43:41,025
But if you have a lot of friends and family in there or a much larger data set,

2902
01:43:41,306 --> 01:43:44,375
wouldn't it be nice to just jump to the answer in one step

2903
01:43:44,826 --> 01:43:46,186
instead of even log of end step?

2904
01:43:46,226 --> 01:43:46,945
So that's our goal.

2905
01:43:47,065 --> 01:43:50,375
Can we get close to or actually at constant time?

2906
01:43:50,545 --> 01:43:51,465
So with the hash function,

2907
01:43:51,505 --> 01:43:54,255
we essentially have our old friend problem solving here,

2908
01:43:54,465 --> 01:43:55,496
the inside of which

2909
01:43:55,786 --> 01:43:57,666
the algorithm is known as a hash function.

2910
01:43:57,706 --> 01:43:58,386
And for instance,

2911
01:43:58,425 --> 01:44:00,355
if I'm looking at Mario's number.

2912
01:44:00,483 --> 01:44:02,523
I might now want to look for Mario,

2913
01:44:02,554 --> 01:44:06,023
not top to bottom or not divide and conquer jumping around

2914
01:44:06,023 --> 01:44:07,983
to the the middle of the middle of the middle.

2915
01:44:08,233 --> 01:44:10,403
Let me just figure out what bucket Mario is in.

2916
01:44:10,474 --> 01:44:13,874
And in the English alphabet there's 26 letters of the alphabet A through Z,

2917
01:44:13,914 --> 01:44:15,224
either uppercase or lowercase.

2918
01:44:15,574 --> 01:44:18,624
And suppose that I want to find what bucket Mario is in.

2919
01:44:18,753 --> 01:44:18,833
Well,

2920
01:44:18,903 --> 01:44:21,423
much like these cards and the suits thereof,

2921
01:44:21,633 --> 01:44:23,193
wouldn't it make sense that anyone whose names

2922
01:44:23,193 --> 01:44:25,474
starts with A goes into the first bucket and

2923
01:44:25,474 --> 01:44:29,423
maybe the Bs go into the second bucket and the Zs go into the last bucket.

2924
01:44:29,673 --> 01:44:30,354
So it stands to.

2925
01:44:30,562 --> 01:44:34,832
that if I pass in Mario to a hash function implemented in C or some other language,

2926
01:44:35,082 --> 01:44:39,171
I would like to get back to the number 12 because M is the 13th letter of the alphabet,

2927
01:44:39,242 --> 01:44:41,492
but if we start counting at 0 with our buckets,

2928
01:44:41,602 --> 01:44:42,952
which are essentially an array,

2929
01:44:43,202 --> 01:44:46,352
then it's index location 12 instead of 13.

2930
01:44:46,441 --> 01:44:46,841
Similarly,

2931
01:44:46,881 --> 01:44:47,881
if Luigi is the input,

2932
01:44:47,921 --> 01:44:49,361
I'd like to get back to the number 11.

2933
01:44:49,441 --> 01:44:52,321
So my hash function somehow takes his input in this story,

2934
01:44:52,361 --> 01:44:53,071
a string,

2935
01:44:53,312 --> 01:44:54,762
and gives me an integer.

2936
01:44:54,801 --> 01:44:58,122
I claim there's theoretically an infinite number of

2937
01:44:58,122 --> 01:45:00,231
names in the world in the English language.

2938
01:45:01,140 --> 01:45:04,060
But there's only gonna be 26 possible answers from this hash function,

2939
01:45:04,140 --> 01:45:05,180
0 through 25,

2940
01:45:05,220 --> 01:45:07,689
so that's our infinite domain to our finite range

2941
01:45:08,060 --> 01:45:08,529
instead of 4,

2942
01:45:08,580 --> 01:45:09,729
it's now 26.

2943
01:45:10,089 --> 01:45:10,259
All right,

2944
01:45:10,419 --> 01:45:11,089
so what.

2945
01:45:11,709 --> 01:45:15,770
Should we do with the computer's memory to leverage the fact that we

2946
01:45:15,770 --> 01:45:20,649
can very easily bucketize names based on the first letter of someone's name?

2947
01:45:20,729 --> 01:45:21,180
Well,

2948
01:45:21,609 --> 01:45:24,049
let me propose that the hash function part of this,

2949
01:45:24,129 --> 01:45:24,970
arcane as it looks,

2950
01:45:25,129 --> 01:45:26,250
is actually pretty straightforward.

2951
01:45:26,370 --> 01:45:28,279
So if you wanted to translate this idea into C,

2952
01:45:28,529 --> 01:45:30,879
you can include Cy.H,

2953
01:45:30,970 --> 01:45:34,370
which we've used a few times to get access to like functions like 2 upper,

2954
01:45:34,609 --> 01:45:37,200
and this is just to make sure you can be case insensitive.

2955
01:45:37,410 --> 01:45:38,209
Here's my hash function.

2956
01:45:38,325 --> 01:45:39,435
And it's going to return an in,

2957
01:45:39,475 --> 01:45:40,075
which is the goal.

2958
01:45:40,274 --> 01:45:41,865
It takes a string as input.

2959
01:45:42,115 --> 01:45:42,915
We'll call it name,

2960
01:45:43,035 --> 01:45:44,254
and what does this function do?

2961
01:45:44,314 --> 01:45:44,455
Well,

2962
01:45:44,515 --> 01:45:46,785
it's kind of some clever asy arithmetic.

2963
01:45:47,035 --> 01:45:48,745
It first converts to uppercase,

2964
01:45:48,984 --> 01:45:50,984
the first letter of that person's name.

2965
01:45:51,234 --> 01:45:52,884
So if it's all lower case,

2966
01:45:53,035 --> 01:45:56,674
forces it to uppercase Y because I want to subtract no matter what 65,

2967
01:45:57,015 --> 01:45:59,154
aka the Asky value of capital A from this,

2968
01:45:59,274 --> 01:46:00,555
and I don't want to screw up the math if

2969
01:46:00,555 --> 01:46:02,595
I'm doing like a lowercase letter minus a capital.

2970
01:46:02,674 --> 01:46:05,024
I want minus is all.

2971
01:46:05,319 --> 01:46:10,060
So this will return to me a number between 0 and 25 inclusive,

2972
01:46:10,390 --> 01:46:12,830
because if it is a letter,

2973
01:46:12,870 --> 01:46:14,180
a name that starts with a,

2974
01:46:14,470 --> 01:46:15,859
I'm only looking at the first letter.

2975
01:46:15,950 --> 01:46:16,950
I'm subtracting off A,

2976
01:46:16,990 --> 01:46:17,979
that gives me 0,

2977
01:46:18,229 --> 01:46:20,700
and I'm going to return 0 as a result,

2978
01:46:21,350 --> 01:46:21,759
if it's Z,

2979
01:46:21,790 --> 01:46:23,779
I'm going to return 25 instead.

2980
01:46:24,069 --> 01:46:25,299
Now there's no error checking in here.

2981
01:46:25,310 --> 01:46:27,979
If you type in non-English symbols,

2982
01:46:28,310 --> 01:46:29,100
it's going to break.

2983
01:46:29,390 --> 01:46:32,899
So let's just assume for simplicity this is indeed an English name that's coming in.

2984
01:46:33,069 --> 01:46:34,430
I can refine this a little bit.

2985
01:46:34,879 --> 01:46:37,879
I'm going to propose moving forward in our final week here of C

2986
01:46:37,879 --> 01:46:40,640
there are some added defenses you can put in place when writing code.

2987
01:46:40,680 --> 01:46:41,620
Like if you know

2988
01:46:41,959 --> 01:46:46,069
that you're receiving a name as input that is you're passing something in by

2989
01:46:46,479 --> 01:46:47,149
reference,

2990
01:46:47,319 --> 01:46:50,709
there's a danger now per last week because now

2991
01:46:51,080 --> 01:46:52,359
the caller of this function,

2992
01:46:52,439 --> 01:46:53,450
whoever's using this function,

2993
01:46:53,500 --> 01:46:55,720
is telling you where to find Mario and where to find.

2994
01:46:55,862 --> 01:46:56,803
Luigi's name.

2995
01:46:56,973 --> 01:46:58,933
The problem with that is that you could go to

2996
01:46:58,933 --> 01:47:01,203
that address and actually change their name in memory,

2997
01:47:01,252 --> 01:47:02,573
even if you're not supposed to.

2998
01:47:02,652 --> 01:47:04,083
You're supposed to just use the name.

2999
01:47:04,292 --> 01:47:07,812
So you can do something like const which says you should not be able to

3000
01:47:07,812 --> 01:47:11,263
change this value even though I'm not giving you a copy of it by value.

3001
01:47:11,413 --> 01:47:12,982
I'm giving you a reference there too.

3002
01:47:13,212 --> 01:47:16,893
Another refinement here is that a hash function for an array is the goal.

3003
01:47:17,625 --> 01:47:20,395
Should return a value that's 0 or 1 or 2 on up,

3004
01:47:20,465 --> 01:47:21,295
never negative,

3005
01:47:21,545 --> 01:47:24,695
so we can even more protectively say it's not just an in,

3006
01:47:24,905 --> 01:47:26,155
it's an unsigned in,

3007
01:47:26,166 --> 01:47:27,695
and we talked briefly about that last week,

3008
01:47:27,706 --> 01:47:29,025
albeit in the context of CARS.

3009
01:47:29,226 --> 01:47:31,186
These are just like minor improvements that

3010
01:47:31,186 --> 01:47:33,895
makes your code arguably better designed because you're

3011
01:47:34,226 --> 01:47:38,105
opening yourself up to fewer possible mistakes or issues.

3012
01:47:38,835 --> 01:47:38,985
All right,

3013
01:47:39,036 --> 01:47:39,826
so with that said,

3014
01:47:39,985 --> 01:47:43,465
let's now assume that we've got this kind of function in implemented

3015
01:47:43,465 --> 01:47:46,065
and we can now use it to decide what bucket to put.

3016
01:47:46,799 --> 01:47:48,939
These people's names into,

3017
01:47:49,040 --> 01:47:49,100
well,

3018
01:47:49,200 --> 01:47:51,279
let's give you what are called hash tables,

3019
01:47:51,339 --> 01:47:53,859
which are sort of the Swiss Army knives of data structures,

3020
01:47:53,919 --> 01:47:56,450
the kind of thing that some computer scientists have been quoted as saying

3021
01:47:56,450 --> 01:47:58,950
if they were stuck on a desert island with only one data structure,

3022
01:47:59,160 --> 01:48:01,049
this is probably the one they would want.

3023
01:48:01,120 --> 01:48:01,509
Why?

3024
01:48:01,720 --> 01:48:04,520
It's just really generally useful because it

3025
01:48:04,520 --> 01:48:07,399
allows you quite powerfully to associate keys

3026
01:48:07,680 --> 01:48:08,399
with values,

3027
01:48:08,479 --> 01:48:10,470
which is to say to come full circle today,

3028
01:48:10,759 --> 01:48:12,600
hash tables are often how you would implement.

3029
01:48:12,734 --> 01:48:13,944
at a lower level,

3030
01:48:14,084 --> 01:48:17,044
the thing we began class with talking about dictionaries,

3031
01:48:17,285 --> 01:48:21,475
collections of key value pairs that after all is what a phone book is if we call it,

3032
01:48:21,484 --> 01:48:21,564
you know,

3033
01:48:21,685 --> 01:48:22,555
names and numbers,

3034
01:48:22,564 --> 01:48:23,845
but it's keys and values.

3035
01:48:23,895 --> 01:48:26,834
That's what an actual English dictionary is the Oxford English Dictionary.

3036
01:48:26,845 --> 01:48:30,194
It's a bunch of words and definitions or keys and values,

3037
01:48:30,205 --> 01:48:33,995
so useful in general to be able to associate one piece of data with another

3038
01:48:34,404 --> 01:48:35,785
ergo hash tables.

3039
01:48:36,004 --> 01:48:38,515
So here's how you might implement and see a hash table.

3040
01:48:38,725 --> 01:48:40,169
You want It to be a size 26,

3041
01:48:40,250 --> 01:48:40,609
for instance,

3042
01:48:40,689 --> 01:48:42,850
so 26 buckets from A to Z,

3043
01:48:43,049 --> 01:48:44,120
hence the 26.

3044
01:48:44,330 --> 01:48:45,879
You want this to be an array,

3045
01:48:45,970 --> 01:48:46,370
and that's fine.

3046
01:48:46,410 --> 01:48:47,589
This is an array of 4 buckets.

3047
01:48:47,649 --> 01:48:51,220
I'm going to use an array of 26 buckets because a hash table 2

3048
01:48:51,450 --> 01:48:55,080
is going to be an evolution of our linked list mashed together

3049
01:48:55,290 --> 01:48:56,100
with an array.

3050
01:48:56,250 --> 01:48:57,290
So a hash table in short,

3051
01:48:57,299 --> 01:49:00,049
is going to be an array with linked lists,

3052
01:49:00,169 --> 01:49:01,040
as we'll soon see.

3053
01:49:01,169 --> 01:49:05,009
Here's the array 26 pointers to nodes.

3054
01:49:05,040 --> 01:49:08,375
So I'm going to give myself an array of pointers that is

3055
01:49:08,375 --> 01:49:12,495
going to store ultimately a whole bunch of person objects like this.

3056
01:49:12,575 --> 01:49:13,174
So for instance,

3057
01:49:13,254 --> 01:49:14,535
here's a char name,

3058
01:49:14,654 --> 01:49:16,645
Chatar number as we've discussed in the past,

3059
01:49:17,015 --> 01:49:17,924
representing a person.

3060
01:49:18,055 --> 01:49:21,484
These are the pieces of data I might want to store in this data structure.

3061
01:49:21,734 --> 01:49:22,404
However,

3062
01:49:22,854 --> 01:49:23,495
let's simplify it.

3063
01:49:23,535 --> 01:49:26,125
Let's not worry about the phone number because we're not going to call anyone today,

3064
01:49:26,274 --> 01:49:28,854
but for a linked list of persons,

3065
01:49:29,015 --> 01:49:29,935
I'm going to need to store,

3066
01:49:30,015 --> 01:49:31,415
let's say the person's name.

3067
01:49:32,020 --> 01:49:33,890
But also a pointer to the next such name,

3068
01:49:34,049 --> 01:49:35,810
to the next such name to the next such name.

3069
01:49:35,890 --> 01:49:36,129
So again,

3070
01:49:36,169 --> 01:49:38,799
I'm just deleting number as being unnecessary detail,

3071
01:49:39,250 --> 01:49:41,569
but if we're gonna have an array of linked lists,

3072
01:49:41,810 --> 01:49:47,640
this is our new definition of node for this part of class whereby it's not for a tree,

3073
01:49:47,810 --> 01:49:49,169
it's now for a hash table,

3074
01:49:49,180 --> 01:49:50,600
and we'll see this in action now.

3075
01:49:50,799 --> 01:49:52,529
Here's my array of size 2.

3076
01:49:52,629 --> 01:49:52,930
6.

3077
01:49:52,970 --> 01:49:53,689
I drew it vertically,

3078
01:49:53,740 --> 01:49:54,370
but who cares?

3079
01:49:54,450 --> 01:49:56,049
These have always been artists' renditions thereof.

3080
01:49:56,089 --> 01:49:57,680
It just fits nicely on the screen this way.

3081
01:49:57,810 --> 01:49:58,959
This is location 0.

3082
01:49:59,169 --> 01:50:00,450
This is location 25.

3083
01:50:00,490 --> 01:50:02,319
So any A name should end up over here.

3084
01:50:02,450 --> 01:50:04,680
Any Z name should end up down here,

3085
01:50:04,890 --> 01:50:05,600
and so forth.

3086
01:50:05,689 --> 01:50:08,759
Let's just generalize this away as letters of the alphabet for clarity.

3087
01:50:08,930 --> 01:50:10,089
That's where all the names are going to go.

3088
01:50:10,169 --> 01:50:11,089
So hopefully Mario here,

3089
01:50:11,209 --> 01:50:11,919
Luigi here,

3090
01:50:12,049 --> 01:50:12,970
and everyone else.

3091
01:50:13,359 --> 01:50:15,790
So what are each of these squares?

3092
01:50:15,799 --> 01:50:18,709
They're just pointers to nodes initially all null,

3093
01:50:18,870 --> 01:50:19,470
all claim,

3094
01:50:19,589 --> 01:50:23,419
but as soon as I insert Mario into this so-called hash table,

3095
01:50:23,629 --> 01:50:25,220
I'm not going to put him literally here.

3096
01:50:25,390 --> 01:50:26,939
I'm going to create a new node in memory,

3097
01:50:27,109 --> 01:50:28,100
put Mario there,

3098
01:50:28,350 --> 01:50:31,109
and then stitch it together because if I get another M name,

3099
01:50:31,149 --> 01:50:34,180
I'm going to stitch it together and together and together again.

3100
01:50:34,350 --> 01:50:35,209
So for instance,

3101
01:50:35,589 --> 01:50:37,500
here comes Mario into this data structure.

3102
01:50:37,830 --> 01:50:41,259
So this is a pointer to a person structure.

3103
01:50:41,430 --> 01:50:43,029
Here's Luigi and here's a third character.

3104
01:50:43,291 --> 01:50:43,582
As well,

3105
01:50:43,691 --> 01:50:44,242
Peach.

3106
01:50:44,611 --> 01:50:46,041
That's all working out great.

3107
01:50:46,771 --> 01:50:49,012
There's a whole bunch of characters in the Nintendo universe.

3108
01:50:49,082 --> 01:50:50,191
Here's a lot of them.

3109
01:50:50,412 --> 01:50:50,892
Unfortunately,

3110
01:50:51,041 --> 01:50:51,852
especially if you're a fan,

3111
01:50:51,932 --> 01:50:57,051
there's also other names that do start with M and L and other letters of the alphabet.

3112
01:50:57,332 --> 01:50:59,852
So we're poised to have what we're going to call collisions,

3113
01:50:59,932 --> 01:51:01,961
which is a downside of using a hash function.

3114
01:51:02,051 --> 01:51:04,892
If you're going from something infinite to something finite,

3115
01:51:05,051 --> 01:51:07,961
by definition you're going to have a heck of a lot of potential

3116
01:51:08,332 --> 01:51:09,461
collisions somehow,

3117
01:51:09,492 --> 01:51:10,452
multiple M names,

3118
01:51:10,532 --> 01:51:11,271
multiple L names,

3119
01:51:11,291 --> 01:51:11,921
and so forth.

3120
01:51:12,162 --> 01:51:12,731
So we've got a mini.

3121
01:51:12,923 --> 01:51:13,594
This somehow.

3122
01:51:13,713 --> 01:51:13,943
Well,

3123
01:51:14,153 --> 01:51:16,233
if you meet someone in the real world whose name happens

3124
01:51:16,233 --> 01:51:18,313
to start with M and you already are friends with Mario,

3125
01:51:18,354 --> 01:51:18,434
well,

3126
01:51:18,474 --> 01:51:21,113
you could delete Mario from your phone and put that new person there,

3127
01:51:21,193 --> 01:51:22,344
but that's kind of dumb.

3128
01:51:22,514 --> 01:51:23,673
You could clobber the value,

3129
01:51:23,713 --> 01:51:24,304
that is,

3130
01:51:24,673 --> 01:51:27,264
or maybe you put the M friend here,

3131
01:51:27,434 --> 01:51:28,144
and when that fills up,

3132
01:51:28,153 --> 01:51:29,383
you put the M friend here,

3133
01:51:29,394 --> 01:51:31,153
and then when you meet someone else whose name starts with M,

3134
01:51:31,193 --> 01:51:31,943
you put it here.

3135
01:51:32,113 --> 01:51:34,394
But then it just evolves into this mess at which point

3136
01:51:34,394 --> 01:51:36,543
now there's no rhyme or reason as to who is where.

3137
01:51:36,633 --> 01:51:38,074
It devolves back into something linear.

3138
01:51:38,113 --> 01:51:40,284
If you have to search the whole darn thing looking for M

3139
01:51:40,284 --> 01:51:42,594
friends just because you ran out of space where you want.

3140
01:51:42,976 --> 01:51:46,605
So here's the beauty of mashing together in array with a linked list.

3141
01:51:46,936 --> 01:51:51,485
You hash the name to the intended location like box 12 here,

3142
01:51:51,735 --> 01:51:54,076
and then you just start stringing them together in a linked

3143
01:51:54,076 --> 01:51:56,335
list and hopefully you don't have too many of those collisions,

3144
01:51:56,375 --> 01:52:00,456
but at least now you don't have to delete or make a mess of the data structure.

3145
01:52:00,576 --> 01:52:02,655
So here's another bunch of names,

3146
01:52:02,735 --> 01:52:03,965
3 starting with L.

3147
01:52:04,136 --> 01:52:06,166
Here's a bunch for the other letters of the alphabet,

3148
01:52:06,576 --> 01:52:07,706
and it's just a linked,

3149
01:52:07,936 --> 01:52:10,496
it's an array now of linked lists.

3150
01:52:10,655 --> 01:52:12,335
This then is a hash table.

3151
01:52:12,720 --> 01:52:14,459
So the question to consider now,

3152
01:52:14,470 --> 01:52:16,600
is this better than

3153
01:52:17,029 --> 01:52:17,939
an array?

3154
01:52:18,149 --> 01:52:20,339
Is this better than a linked list?

3155
01:52:20,390 --> 01:52:20,430
Well,

3156
01:52:20,479 --> 01:52:25,379
I dare say it's better than a linked list because if it were a linked list from A to Z,

3157
01:52:25,629 --> 01:52:27,479
what would be the running time of searching for anyone?

3158
01:52:27,629 --> 01:52:27,750
Well,

3159
01:52:27,910 --> 01:52:28,509
I'll spoil it,

3160
01:52:28,549 --> 01:52:30,950
big old event because even if it's alphabetically sorted,

3161
01:52:30,990 --> 01:52:34,049
you've got to start at the beginning and go all the way through the list potentially

3162
01:52:34,310 --> 01:52:36,839
to find someone like Zelda whose name starts with,

3163
01:52:37,089 --> 01:52:37,479
of course,

3164
01:52:37,589 --> 01:52:37,870
Z.

3165
01:52:38,390 --> 01:52:38,819
But here,

3166
01:52:39,325 --> 01:52:41,504
we have an array of linked lists.

3167
01:52:41,584 --> 01:52:44,205
So what's really the running time here?

3168
01:52:44,305 --> 01:52:47,325
It's not quite as bad as N steps,

3169
01:52:47,464 --> 01:52:48,984
because if you assume a uniform distribution

3170
01:52:48,984 --> 01:52:50,745
of names such that the world of Nintendo

3171
01:52:50,745 --> 01:52:54,944
maybe has as many M names as L names as A names as B names,

3172
01:52:54,984 --> 01:52:57,104
you could assume that there's a bunch of chains,

3173
01:52:57,185 --> 01:52:59,174
a bunch of linked lists here chained together,

3174
01:52:59,305 --> 01:53:00,455
but they're all roughly the same.

3175
01:53:01,109 --> 01:53:05,020
So maybe you have end names in your phone book this way,

3176
01:53:05,430 --> 01:53:08,339
but there are these lists are only of size,

3177
01:53:08,830 --> 01:53:12,410
they're only 126 of that length because you've got that many names there.

3178
01:53:12,830 --> 01:53:13,910
So what's the running time?

3179
01:53:13,959 --> 01:53:14,419
Well,

3180
01:53:14,870 --> 01:53:18,069
ideally we'd move away from link lists with big O of N

3181
01:53:18,310 --> 01:53:19,200
and achieve our cons.

3182
01:53:19,399 --> 01:53:20,020
In time,

3183
01:53:20,069 --> 01:53:20,790
but

3184
01:53:21,589 --> 01:53:24,419
we have these collisions to worry about here.

3185
01:53:24,649 --> 01:53:25,620
Just to be clear,

3186
01:53:26,200 --> 01:53:28,229
we want to get from big O of N

3187
01:53:28,549 --> 01:53:30,500
to something constant time,

3188
01:53:30,629 --> 01:53:32,770
but we're not going to get to constant time if we've got collisions.

3189
01:53:32,830 --> 01:53:35,910
If we've got 3 L names and a few B names and a few A names,

3190
01:53:36,029 --> 01:53:37,629
we can't just jump to that location.

3191
01:53:37,990 --> 01:53:39,850
And find the person we're looking for.

3192
01:53:40,060 --> 01:53:41,490
So what's the fundamental goal?

3193
01:53:41,700 --> 01:53:41,819
Well,

3194
01:53:41,939 --> 01:53:45,339
I think we want to maybe use a smarter hash function and here depicted

3195
01:53:45,339 --> 01:53:49,160
is an excerpt from a bigger hash table that is a much bigger array

3196
01:53:49,419 --> 01:53:52,520
that assumes that you're not looking at the first letter of everyone's name,

3197
01:53:52,540 --> 01:53:54,060
but apparently what instead.

3198
01:53:54,990 --> 01:53:57,839
The first three letters of the person's name,

3199
01:53:58,129 --> 01:54:02,439
which just decreases the probability of collisions because in this model,

3200
01:54:02,609 --> 01:54:07,089
I dare say there's no one else's name in the Nintendo universe that starts with LIN.

3201
01:54:07,209 --> 01:54:12,209
So now Link has its own location in memory and similarly for

3202
01:54:12,209 --> 01:54:15,770
Luigi LUI I believe is unique in the the Nintendo universe,

3203
01:54:15,810 --> 01:54:17,080
so we don't have a collision.

3204
01:54:17,450 --> 01:54:18,359
Unfortunately,

3205
01:54:18,529 --> 01:54:22,240
while this does seem to eliminate collisions based on this tiny example,

3206
01:54:22,890 --> 01:54:23,919
what's the tradeoff?

3207
01:54:24,830 --> 01:54:25,970
Or what's the catch?

3208
01:54:26,299 --> 01:54:26,689
Uh yeah.

3209
01:54:28,540 --> 01:54:29,779
This is a lot more memory.

3210
01:54:29,819 --> 01:54:30,020
I mean,

3211
01:54:30,140 --> 01:54:33,540
kind of hinted at the fact that I didn't even fit most of it on the screen anymore.

3212
01:54:33,620 --> 01:54:35,220
Here's LAA.

3213
01:54:35,339 --> 01:54:36,540
Here's LUG,

3214
01:54:36,580 --> 01:54:38,060
but what about all of the other letters of

3215
01:54:38,060 --> 01:54:42,500
the alphabet and the other combinations of all possibilities.

3216
01:54:42,589 --> 01:54:43,000
Moreover,

3217
01:54:43,100 --> 01:54:44,430
some of these just don't make much sense,

3218
01:54:44,500 --> 01:54:46,129
at least in English or in the Nintendo world.

3219
01:54:46,259 --> 01:54:50,500
I don't think there's anyone whose name is going to start with AAA or AAB or AAC.

3220
01:54:50,636 --> 01:54:52,505
AA or AA and so forth.

3221
01:54:52,625 --> 01:54:54,416
We're wasting a huge amount of space

3222
01:54:54,945 --> 01:54:57,375
to reduce the probability of collision.

3223
01:54:57,465 --> 01:54:58,295
So that's fine.

3224
01:54:58,445 --> 01:55:00,335
We might get constant time now,

3225
01:55:00,505 --> 01:55:01,346
but at what cost?

3226
01:55:01,465 --> 01:55:01,525
Well,

3227
01:55:01,666 --> 01:55:03,195
a heck of a lot more memory.

3228
01:55:03,286 --> 01:55:06,585
And so this is one of the tensions when using a hash table is you want to

3229
01:55:06,585 --> 01:55:09,025
come up with a good hash function that's maybe

3230
01:55:09,025 --> 01:55:11,576
a little more sophisticated than the first letter,

3231
01:55:11,786 --> 01:55:16,346
but not so wasteful that you need a crazy number of buckets and therefore a huge.

3232
01:55:16,631 --> 01:55:17,782
amount more memory.

3233
01:55:18,111 --> 01:55:19,222
So really,

3234
01:55:19,372 --> 01:55:20,901
even with collisions,

3235
01:55:21,191 --> 01:55:24,392
it's not quite as bad as N steps because technically if you have

3236
01:55:24,392 --> 01:55:27,662
k buckets where k is like 26 buckets or 4 in this case,

3237
01:55:27,821 --> 01:55:29,591
technically if you do assume that the names

3238
01:55:29,591 --> 01:55:31,742
are uniformly distributed over A through Z,

3239
01:55:31,751 --> 01:55:32,671
the English alphabet,

3240
01:55:32,912 --> 01:55:32,961
well,

3241
01:55:33,032 --> 01:55:36,762
each of those linked lists is going to be hopefully no bigger than N divided by K.

3242
01:55:36,821 --> 01:55:38,191
So N divided by 26.

3243
01:55:38,392 --> 01:55:39,381
But what do we know about

3244
01:55:39,912 --> 01:55:42,151
higher order terms when doing big O notation?

3245
01:55:42,470 --> 01:55:44,100
Big O of N divided by K.

3246
01:55:44,180 --> 01:55:44,379
Yes,

3247
01:55:44,459 --> 01:55:45,419
it's faster,

3248
01:55:45,819 --> 01:55:47,169
but asymptotically,

3249
01:55:47,220 --> 01:55:48,089
that is theoretically,

3250
01:55:48,160 --> 01:55:50,200
you're still talking about big O of N.

3251
01:55:50,370 --> 01:55:51,529
So here's the tension though,

3252
01:55:51,899 --> 01:55:53,270
like it's absolutely going to be faster.

3253
01:55:53,339 --> 01:55:56,370
It will be like 26 times faster than a linked list,

3254
01:55:56,660 --> 01:55:59,779
but it's still just big O of N because it's going

3255
01:55:59,779 --> 01:56:02,160
to take an amount of time that's still linear in.

3256
01:56:02,810 --> 01:56:04,279
The size of the data set,

3257
01:56:04,359 --> 01:56:07,350
so we seem to have strayed yet again away from our

3258
01:56:07,959 --> 01:56:09,109
constant time search.

3259
01:56:09,220 --> 01:56:11,229
So can we find this holy grail?

3260
01:56:11,359 --> 01:56:11,520
Well,

3261
01:56:11,600 --> 01:56:15,189
we kind of can if you let me spend just like a lot more space.

3262
01:56:15,759 --> 01:56:19,529
There are tries in the world which weirdly is short for retrieval,

3263
01:56:19,600 --> 01:56:20,879
even though we don't say retrieval,

3264
01:56:20,919 --> 01:56:21,759
but a try.

3265
01:56:22,080 --> 01:56:23,240
Is a tree

3266
01:56:23,549 --> 01:56:24,950
made out of arrays,

3267
01:56:25,069 --> 01:56:25,189
right?

3268
01:56:25,229 --> 01:56:27,350
So at some point computer scientists were just like mashing

3269
01:56:27,350 --> 01:56:30,470
things together Frankenstein style like linked lists and arrays,

3270
01:56:30,509 --> 01:56:31,220
and now we've got

3271
01:56:31,750 --> 01:56:33,500
trees and arrays.

3272
01:56:33,990 --> 01:56:36,149
You two can mash something together and come up with your own,

3273
01:56:36,270 --> 01:56:38,589
but let's look at what a try actually is because

3274
01:56:38,589 --> 01:56:41,069
it is going to get us that constant time grail.

3275
01:56:41,479 --> 01:56:44,060
So here is the root of a try.

3276
01:56:44,330 --> 01:56:49,049
You can think of each node in a try as really being an array of values

3277
01:56:49,049 --> 01:56:52,919
A through Z in the case of an English problem like we've been playing with here.

3278
01:56:53,290 --> 01:56:55,600
And what you do is you treat this array

3279
01:56:55,970 --> 01:56:59,359
as being indexed from 0 to 25 or equivalently A through Z,

3280
01:56:59,729 --> 01:57:04,810
and you treat each of those elements as a pointer to another such node in the try.

3281
01:57:05,209 --> 01:57:07,990
And what you do is implicitly store

3282
01:57:08,270 --> 01:57:11,350
the names that you're storing in this data structure

3283
01:57:11,759 --> 01:57:12,149
by

3284
01:57:12,399 --> 01:57:15,390
going to an appropriate location based on the first letter in their name

3285
01:57:15,640 --> 01:57:16,870
and then adding a pointer

3286
01:57:17,040 --> 01:57:18,879
that represents the second letter in their name,

3287
01:57:18,959 --> 01:57:21,160
adding a pointer that represents the third letter of their name,

3288
01:57:21,200 --> 01:57:21,649
and so forth.

3289
01:57:21,750 --> 01:57:22,740
So what do I mean by this?

3290
01:57:22,959 --> 01:57:24,379
Suppose we want to insert

3291
01:57:24,819 --> 01:57:25,120
toad,

3292
01:57:25,279 --> 01:57:27,040
one of the characters from the Nintendo universe,

3293
01:57:27,049 --> 01:57:27,470
first.

3294
01:57:27,640 --> 01:57:29,589
If we count up where T is in the alphabet,

3295
01:57:29,799 --> 01:57:30,240
this.

3296
01:57:31,000 --> 01:57:34,279
A pointer here will be changed from null to a pointer to

3297
01:57:34,279 --> 01:57:38,160
a new node that represents the second letter in Toad's name,

3298
01:57:38,200 --> 01:57:39,709
which is going to be of course O.

3299
01:57:40,200 --> 01:57:43,850
Then to insert TOA we're going to need another node.

3300
01:57:44,120 --> 01:57:47,359
A is going to lead me to D and for uh depiction's sake,

3301
01:57:47,399 --> 01:57:49,000
I'm going to draw it in green even though this would

3302
01:57:49,000 --> 01:57:51,080
actually be a boolean or something like that in memory.

3303
01:57:51,479 --> 01:57:54,169
That indicates that toad's name stops here.

3304
01:57:54,459 --> 01:57:55,100
So in other words,

3305
01:57:55,339 --> 01:57:55,750
this

3306
01:57:56,220 --> 01:57:58,299
try and memory has 4 nodes now.

3307
01:57:58,459 --> 01:58:01,450
Each of those nodes is essentially an array of size 26,

3308
01:58:01,859 --> 01:58:06,020
but the word toad is not actually stored in the data structure explicitly.

3309
01:58:06,100 --> 01:58:07,750
There's no chargerar toad,

3310
01:58:08,459 --> 01:58:11,540
but implicitly because the T pointer is non-null,

3311
01:58:11,660 --> 01:58:12,939
the O pointer is non-null,

3312
01:58:13,020 --> 01:58:14,359
the A pointer is non-null,

3313
01:58:14,580 --> 01:58:18,979
and the D pointer is in fact null at this point is the common technique here.

3314
01:58:19,640 --> 01:58:21,600
This allows me to to insert other

3315
01:58:21,600 --> 01:58:24,680
names from Nintendo's universe like Todet because I

3316
01:58:24,680 --> 01:58:28,310
can continue from here to go to the E node to the T node,

3317
01:58:28,560 --> 01:58:28,729
uh,

3318
01:58:28,759 --> 01:58:29,750
to the T node again,

3319
01:58:29,879 --> 01:58:32,430
and then E node which I'll again mark in green.

3320
01:58:32,640 --> 01:58:34,120
So you can even have names that are

3321
01:58:34,120 --> 01:58:37,109
substrings or equivalently super strings of each other

3322
01:58:37,399 --> 01:58:40,870
by just having all of these various bread crumbs along the way,

3323
01:58:40,879 --> 01:58:43,839
where again a non-null pointer here to a non-null to a.

3324
01:58:44,169 --> 01:58:46,680
Non-null to null pointer here indicates that

3325
01:58:46,970 --> 01:58:48,290
or it can't be null at this point.

3326
01:58:48,330 --> 01:58:51,330
This is where we have to use a boolean indicates that there is a name

3327
01:58:51,330 --> 01:58:54,640
in this data structure that ends here and there's another name that ends here.

3328
01:58:54,770 --> 01:58:55,049
Meanwhile,

3329
01:58:55,089 --> 01:58:57,109
if there's a third name from the universe like Tom,

3330
01:58:57,370 --> 01:58:57,850
same idea,

3331
01:58:57,930 --> 01:59:01,970
but eventually we can start reusing some of these arrays whereby non-null,

3332
01:59:02,049 --> 01:59:03,240
non-null null,

3333
01:59:03,250 --> 01:59:05,140
or there's a boolean flag here that says True,

3334
01:59:05,270 --> 01:59:06,279
a name ends here.

3335
01:59:06,490 --> 01:59:08,250
Now we're reusing that same array.

3336
01:59:08,629 --> 01:59:14,459
So each of the nodes represents the Ith letter of the word or the name you're trying

3337
01:59:14,459 --> 01:59:16,859
to store in the data structure and by playing

3338
01:59:16,859 --> 01:59:19,180
around with null and non-null and some booleans,

3339
01:59:19,299 --> 01:59:22,129
you can implicitly store names in this structure.

3340
01:59:22,350 --> 01:59:24,080
Now it's way too

3341
01:59:25,629 --> 01:59:28,770
pictorially difficult to depict lots and lots of names in this form.

3342
01:59:28,899 --> 01:59:30,930
So just imagine in your mind's eye that there's dozens,

3343
01:59:31,020 --> 01:59:31,470
hundreds,

3344
01:59:31,549 --> 01:59:32,419
thousands of names.

3345
01:59:32,520 --> 01:59:36,029
Now in this data structure but just more arrows and more arrays.

3346
01:59:36,229 --> 01:59:39,500
How do you actually look someone up in this data structure?

3347
01:59:39,669 --> 01:59:39,750
Well,

3348
01:59:39,790 --> 01:59:43,069
if you want to ask a question like I toad in this

3349
01:59:43,069 --> 01:59:46,660
data structure or is to in this data structure or anyone else,

3350
01:59:46,950 --> 01:59:50,459
you can simply start at the root node as we would do for any tree

3351
01:59:50,709 --> 01:59:53,390
and you hash on the first letter of toad's name,

3352
01:59:53,430 --> 01:59:55,180
which gives you this location and you check,

3353
01:59:55,350 --> 01:59:56,140
is it null.

3354
01:59:56,410 --> 01:59:57,080
If not,

3355
01:59:57,399 --> 01:59:58,830
T is implicitly there,

3356
01:59:59,000 --> 02:00:02,410
so you follow that pointer here and then you hash the second letter of

3357
02:00:02,410 --> 02:00:06,310
toad's name and O and check this pointer and you follow that arrow.

3358
02:00:06,520 --> 02:00:07,720
Then you check the third,

3359
02:00:07,799 --> 02:00:11,200
you hash on the third letter of toad's name A and you follow that arrow.

3360
02:00:11,250 --> 02:00:13,189
Then the fourth letter of toad's name D,

3361
02:00:13,359 --> 02:00:13,680
and you see,

3362
02:00:13,799 --> 02:00:14,000
ah,

3363
02:00:14,080 --> 02:00:16,600
there's a boolean here represented in green that

3364
02:00:16,600 --> 02:00:18,990
means toad is in this data structure.

3365
02:00:19,200 --> 02:00:20,120
And notice what's.

3366
02:00:20,830 --> 02:00:23,990
Subtle here it doesn't matter if there's 3 names in

3367
02:00:23,990 --> 02:00:26,580
this try or 3 million names in this try,

3368
02:00:26,640 --> 02:00:30,520
how many steps did it take me to confirm or deny that Toad is in this try?

3369
02:00:31,120 --> 02:00:32,810
1234,

3370
02:00:32,870 --> 02:00:34,379
which is arguably constant,

3371
02:00:34,430 --> 02:00:36,310
even though the names can vary at some

3372
02:00:36,310 --> 02:00:38,709
point there's no Nintendo name longer than what,

3373
02:00:38,790 --> 02:00:39,669
like 10 characters,

3374
02:00:39,680 --> 02:00:40,310
20 characters,

3375
02:00:40,350 --> 02:00:40,910
maybe 30.

3376
02:00:40,950 --> 02:00:43,660
I mean there's some reasonable bound that is finite

3377
02:00:43,660 --> 02:00:45,160
where there's never going to be a name longer

3378
02:00:45,160 --> 02:00:48,310
than that because Nintendo's never going to come up with a crazy long name for a game.

3379
02:00:48,629 --> 02:00:53,229
And so you effectively have constant time for looking up TOAD Todet,

3380
02:00:53,500 --> 02:00:53,740
Tom,

3381
02:00:53,899 --> 02:00:54,259
Mario,

3382
02:00:54,339 --> 02:00:54,830
Luigi,

3383
02:00:54,899 --> 02:00:55,180
Peach,

3384
02:00:55,310 --> 02:00:57,020
any of the other names we've looked at.

3385
02:00:57,319 --> 02:01:01,770
So this is to say a try allows you to ask questions like is Toad

3386
02:01:01,770 --> 02:01:06,669
in this data set or equivalently what is Toad's phone number in this data set,

3387
02:01:06,799 --> 02:01:08,910
because if you assume now that each of these pointers

3388
02:01:08,910 --> 02:01:10,939
ultimately is not just a bull saying yes or no,

3389
02:01:11,109 --> 02:01:14,540
but maybe it's an actual person structure with a name and a number,

3390
02:01:14,990 --> 02:01:15,620
you can

3391
02:01:15,910 --> 02:01:18,870
store even data like that your key value pairs where your

3392
02:01:18,870 --> 02:01:22,470
names are your keys and your phone numbers are your values.

3393
02:01:22,589 --> 02:01:23,359
To make this more clear,

3394
02:01:23,430 --> 02:01:24,790
then here is a data structure,

3395
02:01:24,870 --> 02:01:25,069
how.

3396
02:01:25,203 --> 02:01:26,283
Might represent in

3397
02:01:27,152 --> 02:01:27,913
each of these nodes.

3398
02:01:27,993 --> 02:01:30,103
It's not quite technically just an array.

3399
02:01:30,272 --> 02:01:31,632
It's an array of size 26.

3400
02:01:31,672 --> 02:01:34,022
We'll call it children because it represents the children

3401
02:01:34,022 --> 02:01:36,583
of that node of type struck node star.

3402
02:01:36,752 --> 02:01:37,232
And then here,

3403
02:01:37,272 --> 02:01:37,592
for instance,

3404
02:01:37,672 --> 02:01:41,152
for simplicity is that person's number if we reintroduce numbers and want

3405
02:01:41,152 --> 02:01:44,623
to store in this data structure someone's phone number as well.

3406
02:01:44,953 --> 02:01:49,152
So using that data structure and that kind of

3407
02:01:49,592 --> 02:01:49,873
code,

3408
02:01:49,913 --> 02:01:51,272
you can implement a try

3409
02:01:51,553 --> 02:01:52,993
using something as simple as this.

3410
02:01:53,085 --> 02:01:55,596
Initially your try is just a pointer to a node,

3411
02:01:55,655 --> 02:01:57,386
one such struct.

3412
02:01:57,556 --> 02:02:00,826
We can of course initialize it to null to make clear that there's no names in here,

3413
02:02:01,036 --> 02:02:02,786
but each time we allocate a node,

3414
02:02:02,956 --> 02:02:04,436
we can then add another node,

3415
02:02:04,596 --> 02:02:05,226
another node,

3416
02:02:05,715 --> 02:02:06,675
hashing on the 1st,

3417
02:02:06,795 --> 02:02:07,195
the 2nd,

3418
02:02:07,275 --> 02:02:07,596
the 3rd,

3419
02:02:07,675 --> 02:02:08,045
the 4th,

3420
02:02:08,636 --> 02:02:09,346
the last

3421
02:02:09,775 --> 02:02:11,306
character in the person's name,

3422
02:02:11,436 --> 02:02:12,636
allocating a node as needed,

3423
02:02:12,715 --> 02:02:14,195
flipping that boolean true or false,

3424
02:02:14,206 --> 02:02:16,105
or adding their phone number as a star

3425
02:02:16,525 --> 02:02:18,105
to indicate that we have then found them.

3426
02:02:18,195 --> 02:02:20,835
And so of all the data structures we've looked at today.

3427
02:02:21,759 --> 02:02:25,229
Big O of 1 is actually achieved with tries,

3428
02:02:25,560 --> 02:02:27,500
and yet curiously for problem set 5,

3429
02:02:27,759 --> 02:02:28,799
you're not gonna implement tries,

3430
02:02:28,839 --> 02:02:30,580
you're gonna implement hash tables,

3431
02:02:30,640 --> 02:02:32,200
that's sort of Swiss Army knife of data

3432
02:02:32,200 --> 02:02:34,810
structures that like every programmer everywhere knows about.

3433
02:02:35,600 --> 02:02:36,029
Why?

3434
02:02:36,120 --> 02:02:38,549
Like why not use tries

3435
02:02:39,120 --> 02:02:41,270
very often in practice perhaps.

3436
02:02:42,450 --> 02:02:43,350
Certainly can

3437
02:02:44,299 --> 02:02:44,819
But

3438
02:02:45,029 --> 02:02:46,379
what's the trade-off perhaps?

3439
02:02:46,910 --> 02:02:47,330
Yeah,

3440
02:02:49,319 --> 02:02:51,220
it's a huge amount of memory.

3441
02:02:51,430 --> 02:02:53,029
Things have escalated since the start of class.

3442
02:02:53,109 --> 02:02:53,430
We added,

3443
02:02:53,509 --> 02:02:54,439
we started with 1 inch,

3444
02:02:54,509 --> 02:02:56,669
then we added an in and a pointer and in in 2 pointers.

3445
02:02:56,709 --> 02:03:00,589
Now I'm proposing 26 pointers plus a boolean or a data structure called person.

3446
02:03:00,629 --> 02:03:00,830
I mean,

3447
02:03:00,870 --> 02:03:02,069
it's escalating significantly,

3448
02:03:02,270 --> 02:03:03,620
and the biggest catch with a try,

3449
02:03:03,790 --> 02:03:06,549
as you might have imagined with Toad and To E and Tom on the screen,

3450
02:03:06,649 --> 02:03:10,350
there's a huge amount of wasted memory just as we saw with the hash function.

3451
02:03:10,881 --> 02:03:13,332
But that can be reined in as you'll explore on the problem set with

3452
02:03:13,332 --> 02:03:18,062
a try most of the pointers in those arrays are just null and unused,

3453
02:03:18,082 --> 02:03:21,032
and it just tends to result in you're using way more memory

3454
02:03:21,202 --> 02:03:22,562
to solve the problem correctly,

3455
02:03:22,682 --> 02:03:24,361
but in a way that tends to slow the computer

3456
02:03:24,361 --> 02:03:26,432
down and just waste more memory than is useful.

3457
02:03:26,722 --> 02:03:27,312
That said,

3458
02:03:27,481 --> 02:03:28,472
just as we started today,

3459
02:03:28,642 --> 02:03:30,321
there are stacks in the real world,

3460
02:03:30,361 --> 02:03:31,952
there's cues in the real world.

3461
02:03:32,122 --> 02:03:33,291
There are even

3462
02:03:33,733 --> 02:03:35,724
Hash tables in the real world,

3463
02:03:35,844 --> 02:03:38,313
which you'll indeed implement in code for problem set 5.

3464
02:03:38,363 --> 02:03:40,744
Has anyone here ever had a salad from a restaurant

3465
02:03:40,744 --> 02:03:44,193
called Sweetgreen in Harvard Square also elsewhere in the US,

3466
02:03:44,204 --> 02:03:44,463
like

3467
02:03:44,764 --> 02:03:45,354
12,

3468
02:03:45,483 --> 02:03:45,883
like 2 of us,

3469
02:03:45,934 --> 02:03:46,324
3 of us.

3470
02:03:46,363 --> 02:03:46,793
OK,

3471
02:03:47,083 --> 02:03:47,443
so

3472
02:03:47,963 --> 02:03:50,043
not hard to imagine going to such a store,

3473
02:03:50,164 --> 02:03:53,133
getting in a queue and staring at a shelf like this because what

3474
02:03:53,133 --> 02:03:56,684
Sweetreen and similar restaurants do when you order for pickup is they.

3475
02:03:56,916 --> 02:03:57,315
Hash

3476
02:03:57,556 --> 02:04:00,315
your salad into a shelf like this.

3477
02:04:00,326 --> 02:04:03,235
And so literally in sweet green might you see some wooden shelves like this.

3478
02:04:03,405 --> 02:04:04,886
This is the A through E bucket,

3479
02:04:04,925 --> 02:04:05,886
the F through J bucket,

3480
02:04:05,925 --> 02:04:06,846
the K through N bucket,

3481
02:04:06,855 --> 02:04:09,755
and the O through Z bucket whereby if your name

3482
02:04:09,755 --> 02:04:11,605
like Maly happens to be in one of those ranges,

3483
02:04:11,686 --> 02:04:14,116
they will hash my salad and put it here.

3484
02:04:14,286 --> 02:04:14,715
But of course,

3485
02:04:14,766 --> 02:04:15,596
even in the real world,

3486
02:04:15,645 --> 02:04:18,246
there are some constraints and what can go wrong with this here

3487
02:04:18,645 --> 02:04:19,686
hash table system.

3488
02:04:21,040 --> 02:04:22,209
Someone who's been there,

3489
02:04:22,319 --> 02:04:22,910
maybe.

3490
02:04:23,479 --> 02:04:24,149
What can go wrong?

3491
02:04:24,240 --> 02:04:25,229
Imagine like the extreme,

3492
02:04:25,319 --> 02:04:26,040
lots of values here,

3493
02:04:26,120 --> 02:04:26,359
yeah.

3494
02:04:27,279 --> 02:04:28,339
So there's no more space,

3495
02:04:28,419 --> 02:04:28,549
right?

3496
02:04:28,589 --> 02:04:28,700
So,

3497
02:04:28,709 --> 02:04:29,859
and this has happened to me in the past,

3498
02:04:29,990 --> 02:04:31,810
especially since Sure before adopting this system.

3499
02:04:31,830 --> 02:04:32,790
They used to put the A's here,

3500
02:04:32,870 --> 02:04:33,270
the B's here,

3501
02:04:33,350 --> 02:04:33,830
the C's here,

3502
02:04:33,910 --> 02:04:34,310
the D's here,

3503
02:04:34,339 --> 02:04:34,939
and so forth.

3504
02:04:34,990 --> 02:04:37,939
And then someone at some point realized that they were very frequently

3505
02:04:37,939 --> 02:04:40,950
overflowing the A's to the B's and the B's to the C's,

3506
02:04:41,069 --> 02:04:43,430
that no one was using Q or Z with any frequency,

3507
02:04:43,470 --> 02:04:45,580
and so they were sort of wasting space and running out of space.

3508
02:04:45,750 --> 02:04:47,740
So at some point they decided to like literally

3509
02:04:47,740 --> 02:04:49,220
remove most of the letters of the alphabet,

3510
02:04:49,430 --> 02:04:51,020
make the buckets bigger,

3511
02:04:51,100 --> 02:04:51,430
and.

3512
02:04:51,562 --> 02:04:52,103
You are,

3513
02:04:52,312 --> 02:04:55,502
so now it's very unlikely that you're going to have so many

3514
02:04:55,833 --> 02:04:58,192
K's through ends that you overflow the shelf,

3515
02:04:58,283 --> 02:05:01,703
but this is in the real world a data structure like we've seen today.

3516
02:05:01,873 --> 02:05:03,033
And so therefore among the goals,

3517
02:05:03,073 --> 02:05:04,873
even as arcane as things seem to be getting with

3518
02:05:04,873 --> 02:05:07,103
all the pointer notation and dereferencing this and that,

3519
02:05:07,232 --> 02:05:12,112
really all we're doing in code is implementing real world solutions that other

3520
02:05:12,112 --> 02:05:14,743
people have already come up with and translating them to a new domain.

3521
02:05:14,792 --> 02:05:15,763
And the very last thing you'll do.

3522
02:05:15,996 --> 02:05:19,476
See this week is indeed implement your very own spell checker whereby we'll

3523
02:05:19,476 --> 02:05:22,855
give you a very large file of all 100,000 plus English words.

3524
02:05:22,916 --> 02:05:24,925
You'll have to come up with a clever and efficient way

3525
02:05:25,266 --> 02:05:26,315
to load it up into memory,

3526
02:05:26,326 --> 02:05:30,556
and we'll give you tools that will actually measure how fast or how slow your code is,

3527
02:05:30,675 --> 02:05:32,985
how much memory or how little memory your code is,

3528
02:05:33,116 --> 02:05:36,875
so as to actually compare it against not just your own but perhaps others as well.

3529
02:05:36,945 --> 02:05:37,436
So with that said,

3530
02:05:37,516 --> 02:05:38,585
we'll end a bit early today.

3531
02:05:38,755 --> 02:05:39,916
We'll see you next time.