0
00:00:45,540 --> 00:00:46,540
1 fish,

1
00:00:47,189 --> 00:00:48,299
2 fish,

2
00:00:48,830 --> 00:00:49,939
red fish,

3
00:00:50,590 --> 00:00:51,619
blue fish.

4
00:00:54,060 --> 00:00:55,369
Congratulations.

5
00:00:55,860 --> 00:00:57,209
Today is your day.

6
00:00:57,459 --> 00:00:59,020
You're off to great places,

7
00:00:59,180 --> 00:01:00,369
you're off and away.

8
00:01:02,150 --> 00:01:04,370
It was a bright cold day in April,

9
00:01:04,500 --> 00:01:06,410
and the clocks were striking 13.

10
00:01:06,620 --> 00:01:07,769
Winston Smith,

11
00:01:07,940 --> 00:01:11,569
his chin nuzzled into his breast in an effort to escape the vile wind,

12
00:01:11,739 --> 00:01:14,690
slipped quickly through the glass doors of victory mansions,

13
00:01:14,819 --> 00:01:16,819
though not quickly enough to prevent a swirl

14
00:01:16,819 --> 00:01:19,089
of gritty dust from entering along with him.

15
00:01:21,209 --> 00:01:21,529
Alright,

16
00:01:21,809 --> 00:01:23,440
this is CS 150,

17
00:01:23,529 --> 00:01:24,569
and this is week 2,

18
00:01:24,650 --> 00:01:26,319
and if we could after this dramatic reading,

19
00:01:26,330 --> 00:01:28,500
a round of applause for our volunteers.

20
00:01:31,819 --> 00:01:36,160
So we can now take for granted from week 1 that we now have a new way to express some

21
00:01:36,160 --> 00:01:38,040
of the ideas that we first explored in week 0

22
00:01:38,040 --> 00:01:40,870
like functions and conditionals and variables and the like,

23
00:01:40,879 --> 00:01:43,430
and now we're doing in see what we used to do in Scratch.

24
00:01:43,639 --> 00:01:46,089
Today what we're going to start to focus on is some real world

25
00:01:46,089 --> 00:01:49,150
problems so that we can take for granted that we have that expressiveness.

26
00:01:49,319 --> 00:01:51,040
We have some tools in our toolkit and

27
00:01:51,040 --> 00:01:53,120
actually start to solve some real world problems.

28
00:01:53,305 --> 00:01:55,246
Problems if representative thereof.

29
00:01:55,375 --> 00:01:55,926
In particular,

30
00:01:56,055 --> 00:01:59,085
the real world problem that we're going to start today and this week with

31
00:01:59,335 --> 00:02:00,456
is that of reading levels.

32
00:02:00,496 --> 00:02:02,646
Odds are when growing up you read at a certain

33
00:02:02,646 --> 00:02:04,536
level based on the age at which you were at.

34
00:02:04,615 --> 00:02:09,045
Maybe it was 1st grade level or 5th grade level or 10th grade level or the like,

35
00:02:09,205 --> 00:02:11,675
and that was a function of just how comfortable you were with the

36
00:02:11,675 --> 00:02:14,406
words in the book or words on the screen that you were reading.

37
00:02:14,615 --> 00:02:15,016
What you've just.

38
00:02:15,151 --> 00:02:16,701
Thanks to our volunteers

39
00:02:16,951 --> 00:02:21,031
are 3 different reading levels that each of these 3 volunteers reads at.

40
00:02:21,072 --> 00:02:21,552
And in fact,

41
00:02:21,712 --> 00:02:23,832
why don't we go ahead and hear them again and be a

42
00:02:23,832 --> 00:02:27,561
little more thoughtful this time as to assess at what reading level

43
00:02:27,792 --> 00:02:29,481
your classmate is reading.

44
00:02:29,552 --> 00:02:32,182
So let's start with Leah if you'd like to introduce yourself first.

45
00:02:32,391 --> 00:02:32,591
Hi,

46
00:02:32,701 --> 00:02:33,242
I'm Leah.

47
00:02:33,311 --> 00:02:35,222
I'm a 1st year in Holworthy,

48
00:02:35,352 --> 00:02:37,011
and here's my little thing.

49
00:02:37,511 --> 00:02:38,111
1 fish,

50
00:02:38,432 --> 00:02:39,182
2 fish,

51
00:02:39,352 --> 00:02:40,141
red fish,

52
00:02:40,432 --> 00:02:41,182
blue fish.

53
00:02:41,509 --> 00:02:47,179
So what reading level would you say Leah reads based on her recitation thereof,

54
00:02:47,279 --> 00:02:47,339
yeah,

55
00:02:47,419 --> 00:02:48,020
in the front.

56
00:02:49,539 --> 00:02:50,169
Kindergarten,

57
00:02:50,270 --> 00:02:50,419
OK,

58
00:02:50,500 --> 00:02:51,330
so a fairly young age,

59
00:02:51,339 --> 00:02:52,660
and what makes you say kindergarten?

60
00:02:53,520 --> 00:02:56,360
She is speaking in very short phrases

61
00:02:56,729 --> 00:02:58,080
without much complexity.

62
00:02:58,410 --> 00:02:58,570
OK,

63
00:02:58,690 --> 00:03:00,410
very short phrases without much complexity,

64
00:03:00,419 --> 00:03:00,990
and indeed,

65
00:03:01,169 --> 00:03:01,800
according to

66
00:03:02,089 --> 00:03:05,509
one scientific measure that we'll explore in this week's problem set,

67
00:03:05,729 --> 00:03:06,089
indeed,

68
00:03:06,130 --> 00:03:08,889
we would say that Lea reads before grade one,

69
00:03:08,970 --> 00:03:09,690
so kindergarten.

70
00:03:09,839 --> 00:03:11,020
Indeed be apt,

71
00:03:11,070 --> 00:03:11,729
but welcome

72
00:03:11,990 --> 00:03:13,240
to the stage here.

73
00:03:13,429 --> 00:03:15,660
Let's move on now to Maria if you'd like to introduce yourself.

74
00:03:15,869 --> 00:03:16,020
Yeah,

75
00:03:16,229 --> 00:03:16,429
hi,

76
00:03:16,589 --> 00:03:17,190
I'm Maria.

77
00:03:17,270 --> 00:03:19,460
I'm in Stoughton thinking of applied math.

78
00:03:19,830 --> 00:03:19,910
Um,

79
00:03:20,669 --> 00:03:21,820
congratulations.

80
00:03:22,229 --> 00:03:23,419
Today is your day.

81
00:03:23,710 --> 00:03:25,020
You're off to great places.

82
00:03:25,110 --> 00:03:26,320
You're off and away.

83
00:03:26,630 --> 00:03:30,509
Another familiar phrase perhaps at what reading level would you say Maria is?

84
00:03:31,820 --> 00:03:32,110
Yeah,

85
00:03:32,229 --> 00:03:32,630
over here.

86
00:03:35,279 --> 00:03:37,899
And what makes you say 2nd or 3rd grade?

87
00:03:41,350 --> 00:03:41,910
OK.

88
00:03:43,080 --> 00:03:46,070
So now we're starting to introduce complexities like rhyming

89
00:03:46,070 --> 00:03:47,949
and a bit more substance to the quote.

90
00:03:47,990 --> 00:03:52,350
And indeed based on that reading that same measure that I described earlier,

91
00:03:52,429 --> 00:03:54,429
which will involve a mathematical function that somehow

92
00:03:54,429 --> 00:03:56,179
analyzes what it is Maria just said,

93
00:03:56,389 --> 00:04:00,630
indeed we would conclude that she read at a 3rd grade level or grade 3.

94
00:04:00,800 --> 00:04:01,070
Finally,

95
00:04:01,130 --> 00:04:01,350
Omar,

96
00:04:01,429 --> 00:04:03,550
if you'd like to introduce yourself and read once more yours.

97
00:04:03,669 --> 00:04:04,059
OK,

98
00:04:04,639 --> 00:04:04,649
um,

99
00:04:04,789 --> 00:04:05,220
so hi everyone,

100
00:04:05,630 --> 00:04:06,320
I'm Omar.

101
00:04:06,470 --> 00:04:06,770
Um,

102
00:04:06,940 --> 00:04:09,589
I'm a freshman at Hurlbut thinking of doing Cosci,

103
00:04:09,710 --> 00:04:10,899
and this is my reading.

104
00:04:11,649 --> 00:04:11,899
Um,

105
00:04:11,970 --> 00:04:13,600
it was a bright cold day in April,

106
00:04:13,770 --> 00:04:15,720
and the clocks were striking 13.

107
00:04:15,889 --> 00:04:16,690
Winston Smith,

108
00:04:16,730 --> 00:04:20,079
his chin nuzzled into his breast in an effort to escape the vile wind,

109
00:04:20,089 --> 00:04:22,799
slipped quickly through the glass doors of victory mansions,

110
00:04:22,989 --> 00:04:24,850
though not quickly enough to prevent the swirl

111
00:04:24,850 --> 00:04:27,049
of gritty dust from entering along with him.

112
00:04:27,399 --> 00:04:27,450
All right,

113
00:04:27,529 --> 00:04:28,880
sort of escalated quickly.

114
00:04:29,130 --> 00:04:30,970
What reading level is Omar at,

115
00:04:31,049 --> 00:04:31,760
would you say?

116
00:04:32,809 --> 00:04:33,910
Someone else.

117
00:04:35,109 --> 00:04:37,209
What might you say or estimate?

118
00:04:38,489 --> 00:04:39,130
Yes,

119
00:04:39,329 --> 00:04:40,160
right here in the front.

120
00:04:41,049 --> 00:04:41,250
OK,

121
00:04:41,339 --> 00:04:41,769
8th grade,

122
00:04:41,809 --> 00:04:43,160
and what made you say that?

123
00:04:45,250 --> 00:04:45,260
Uh

124
00:04:47,739 --> 00:04:48,859
More complex sentences,

125
00:04:48,980 --> 00:04:49,959
more complex words,

126
00:04:49,980 --> 00:04:50,570
and indeed,

127
00:04:50,700 --> 00:04:51,829
according to that same measure,

128
00:04:51,859 --> 00:04:54,059
this full paragraph of text now,

129
00:04:54,140 --> 00:04:56,850
which indeed has even more grammar when you see it there on the screen,

130
00:04:57,059 --> 00:05:00,890
would be said to be at grade 10 because of that added complexity.

131
00:05:01,100 --> 00:05:01,899
So with that said,

132
00:05:01,980 --> 00:05:04,450
we're going to need to be able to somehow

133
00:05:04,700 --> 00:05:06,260
sort of crunch these numbers to determine,

134
00:05:06,380 --> 00:05:08,540
given a body of text at what reading level someone is,

135
00:05:08,619 --> 00:05:12,299
but in order to do that and apply any metrics to a body of text,

136
00:05:12,500 --> 00:05:16,339
we're going to need to represent that text in memory using something like strings.

137
00:05:16,440 --> 00:05:17,019
Last week,

138
00:05:17,059 --> 00:05:18,369
but last week with strings,

139
00:05:18,459 --> 00:05:21,970
we could really just print them out or display them wholesale on the screen.

140
00:05:22,140 --> 00:05:24,250
But I think we're going to need to break down these

141
00:05:24,250 --> 00:05:26,899
various texts and others like it at a finer grade level.

142
00:05:26,940 --> 00:05:28,579
And indeed among the goals for today is to

143
00:05:28,579 --> 00:05:31,279
explore exactly that and also to take the proverbial

144
00:05:31,279 --> 00:05:33,220
hood off of the car to take a look

145
00:05:33,220 --> 00:05:36,140
underneath and how the computer is actually working,

146
00:05:36,260 --> 00:05:38,540
how these things like strings are actually functioning.

147
00:05:38,700 --> 00:05:41,329
So if you could join me one last time in a round of applause for our volunteers,

148
00:05:41,420 --> 00:05:43,089
thank you so much for helping out.

149
00:05:43,260 --> 00:05:43,970
Thank you guys.

150
00:05:44,299 --> 00:05:44,920
Thank you.

151
00:05:45,670 --> 00:05:47,690
Thank you to Maria as well.

152
00:05:48,100 --> 00:05:51,660
So among the goals for today beyond exploring

153
00:05:51,660 --> 00:05:54,299
a representative problem like this of reading levels is

154
00:05:54,299 --> 00:05:55,570
going to be another one which is even

155
00:05:55,570 --> 00:05:58,739
more important and more omnipresent than reading levels,

156
00:05:58,820 --> 00:05:59,940
namely cryptography,

157
00:05:59,950 --> 00:06:03,660
the art of scrambling information or specifically encrypting

158
00:06:03,660 --> 00:06:05,820
it so you can send secure communications.

159
00:06:05,940 --> 00:06:08,859
Now you sort of take this for granted increasingly nowadays that when you

160
00:06:08,859 --> 00:06:12,380
send a text message or perhaps an email or check out online with

161
00:06:12,380 --> 00:06:16,238
a credit card that somehow Other your information is secure and over the

162
00:06:16,238 --> 00:06:19,787
coming weeks we're going to explore to what extent that is actually true

163
00:06:20,118 --> 00:06:21,558
and why or why not.

164
00:06:21,717 --> 00:06:22,988
Now with cryptography,

165
00:06:23,118 --> 00:06:23,717
similarly too,

166
00:06:23,798 --> 00:06:26,868
if we want to be able to send messages securely such

167
00:06:26,868 --> 00:06:28,477
that if I want to send a message to you,

168
00:06:28,638 --> 00:06:34,148
I don't want anyone else in the room to be able to figure out what it is I have said,

169
00:06:34,197 --> 00:06:36,747
even if they physically intercept that message,

170
00:06:36,917 --> 00:06:38,947
which is all too possible in the digital world,

171
00:06:38,988 --> 00:06:41,437
we're going to need to come up with metrics.

172
00:06:41,545 --> 00:06:45,295
And mechanisms for actually scrambling information in a reversible

173
00:06:45,295 --> 00:06:46,936
way so that I can write my message,

174
00:06:47,135 --> 00:06:48,006
somehow scramble it.

175
00:06:48,015 --> 00:06:51,656
You can receive that message even if after it's passed through many other hands,

176
00:06:51,735 --> 00:06:54,846
and you can descramble or decrypt that same message.

177
00:06:55,015 --> 00:06:55,575
So for instance,

178
00:06:55,656 --> 00:06:57,346
here on the screen is a message,

179
00:06:57,415 --> 00:06:58,446
a fairly simplistic one,

180
00:06:58,455 --> 00:07:00,645
that has somehow been encrypted,

181
00:07:00,656 --> 00:07:02,175
and we'll see by the end of today and by

182
00:07:02,175 --> 00:07:05,085
the end of this week that this encrypted message,

183
00:07:05,256 --> 00:07:07,286
and there's a bit of a tell on the end there,

184
00:07:07,496 --> 00:07:09,376
actually will be said to decrypt too.

185
00:07:09,493 --> 00:07:11,104
This is CS 50,

186
00:07:11,273 --> 00:07:13,593
but why is going to be the underlying question and what

187
00:07:13,593 --> 00:07:16,623
additional tools do we need on our toolkit in order to

188
00:07:16,914 --> 00:07:17,773
do that.

189
00:07:18,273 --> 00:07:19,473
Another word on tools.

190
00:07:19,553 --> 00:07:22,153
So up until now you've probably experienced some bugs,

191
00:07:22,194 --> 00:07:24,623
whether it was in scratch or ever more so in C.

192
00:07:24,683 --> 00:07:24,914
In fact,

193
00:07:24,993 --> 00:07:29,033
don't feel too bad if like the very first program you wrote in C like didn't even work.

194
00:07:29,074 --> 00:07:32,234
You couldn't even make it or compile it until you went

195
00:07:32,234 --> 00:07:34,303
back and fixed some of the code that you had written.

196
00:07:34,433 --> 00:07:34,544
Well,

197
00:07:34,553 --> 00:07:35,424
it turns out

198
00:07:35,764 --> 00:07:36,593
that bugs,

199
00:07:36,914 --> 00:07:37,104
mistakes,

200
00:07:37,114 --> 00:07:39,171
and Programs are ever so commonplace and

201
00:07:39,171 --> 00:07:41,291
even though we've already provided you with tools

202
00:07:41,291 --> 00:07:46,772
like the virtual rubber duck at CS50.AI also embedded into VS code at cs50.dev,

203
00:07:46,851 --> 00:07:49,002
of whom you can ask questions along the way.

204
00:07:49,242 --> 00:07:52,731
Among the goals today are just to give you some lifelong tools at how

205
00:07:52,731 --> 00:07:56,212
you can actually debug software yourself when you don't have a duck nearby,

206
00:07:56,291 --> 00:07:57,761
when you don't have a TA nearby,

207
00:07:57,932 --> 00:07:59,441
let alone any humans at all.

208
00:07:59,772 --> 00:08:00,562
So with debugging,

209
00:08:00,652 --> 00:08:02,332
there's going to be a number of techniques that we can

210
00:08:02,332 --> 00:08:05,252
use all toward an end of like finding and removing.

211
00:08:05,369 --> 00:08:08,709
Bugs or mistakes from our software and perhaps the person best known

212
00:08:08,709 --> 00:08:12,880
for having popularized this term of bugs is that of Dr.

213
00:08:13,549 --> 00:08:14,109
Grace Hopper,

214
00:08:14,190 --> 00:08:14,779
pictured here,

215
00:08:14,829 --> 00:08:16,869
who was a rear admiral in the navy and was one

216
00:08:16,869 --> 00:08:19,869
of the original programmers of the so-called Harvard Mark 1,

217
00:08:19,950 --> 00:08:23,350
a very early mainframe computer that if you wander across the Charles

218
00:08:23,350 --> 00:08:25,869
River over to the science and engineering complex here at Harvard,

219
00:08:25,929 --> 00:08:29,339
you can actually see part of this on display still in the lobby.

220
00:08:29,470 --> 00:08:31,579
It was succeeded by the Harvard Mark II,

221
00:08:31,750 --> 00:08:33,109
and on the Harvard Mark 2.

222
00:08:33,530 --> 00:08:34,919
Hopper and her team

223
00:08:35,250 --> 00:08:35,840
were known

224
00:08:36,049 --> 00:08:38,849
for having put this note in their logbook after

225
00:08:38,849 --> 00:08:41,130
having done some number crunching on the system there.

226
00:08:41,210 --> 00:08:42,159
And if we zoom in,

227
00:08:42,349 --> 00:08:45,210
they have found a problem with the computer this

228
00:08:45,210 --> 00:08:47,559
one day whereby there was literally a bug,

229
00:08:47,650 --> 00:08:49,890
a moth inside of the circuitry of the computer,

230
00:08:49,900 --> 00:08:51,359
and as was written here,

231
00:08:51,570 --> 00:08:54,599
first actual case of bug being found.

232
00:08:54,609 --> 00:08:57,950
And ever since then do we say ever more so the phrase bug

233
00:08:57,950 --> 00:09:02,119
and debugging when it comes to finding and eliminating problems in our code.

234
00:09:02,289 --> 00:09:02,890
So let's start.

235
00:09:02,950 --> 00:09:03,609
With just that,

236
00:09:03,619 --> 00:09:03,820
in fact,

237
00:09:03,900 --> 00:09:07,340
let me go over to VS code and let's deliberately make some mistakes together that

238
00:09:07,340 --> 00:09:08,700
might very well be reminiscent of some of

239
00:09:08,700 --> 00:09:10,809
the mistakes you've accidentally made thus far,

240
00:09:11,020 --> 00:09:14,099
but along the way give you all the more tools for solving

241
00:09:14,099 --> 00:09:18,150
those problems as opposed to sort of having to ask someone else,

242
00:09:18,340 --> 00:09:19,380
be it virtual or physical,

243
00:09:19,419 --> 00:09:19,729
for help,

244
00:09:19,770 --> 00:09:22,489
and actually find these mistakes in your own code.

245
00:09:22,659 --> 00:09:24,900
Let me go ahead and consciously in VS code

246
00:09:24,900 --> 00:09:28,219
create a program known to be buggy called buggy.c.

247
00:09:28,659 --> 00:09:29,820
And in this program,

248
00:09:29,940 --> 00:09:33,900
let's go ahead and do some fairly Familiar code initially.

249
00:09:33,940 --> 00:09:37,859
I'm going to go ahead and start just like we did last week with In Main Void.

250
00:09:38,030 --> 00:09:39,780
More on that today before long

251
00:09:40,349 --> 00:09:41,190
inside of my curly braces,

252
00:09:41,239 --> 00:09:42,190
I'm going to say print F,

253
00:09:42,270 --> 00:09:42,780
hello,

254
00:09:43,030 --> 00:09:43,619
comma,

255
00:09:43,830 --> 00:09:44,419
world.

256
00:09:45,429 --> 00:09:45,940
That's it.

257
00:09:46,039 --> 00:09:48,099
Now I'm going to go back to my terminal window here.

258
00:09:48,229 --> 00:09:52,739
I'm going to go ahead and do make buggy to make a program from that source code,

259
00:09:52,869 --> 00:09:53,619
but before I do,

260
00:09:53,710 --> 00:09:55,659
odds are even after just a week of this stuff,

261
00:09:55,830 --> 00:09:58,419
you can probably spot a few mistakes

262
00:09:58,590 --> 00:09:59,059
I've made,

263
00:09:59,109 --> 00:09:59,719
a few bugs.

264
00:09:59,750 --> 00:10:00,700
What do you see wrong

265
00:10:01,190 --> 00:10:01,349
already,

266
00:10:01,419 --> 00:10:01,669
yeah.

267
00:10:03,700 --> 00:10:05,359
I didn't include standard IO.

268
00:10:06,070 --> 00:10:06,080
H,

269
00:10:06,090 --> 00:10:07,609
that so-called header file,

270
00:10:07,650 --> 00:10:10,729
which is important because it tells the compiler that

271
00:10:10,729 --> 00:10:13,609
I plan to use functions therein like printF,

272
00:10:13,650 --> 00:10:14,760
which clearly I'm doing.

273
00:10:14,890 --> 00:10:18,340
So let me go in and include standardio.h.

274
00:10:18,690 --> 00:10:20,169
What else seems to be wrong here?

275
00:10:20,239 --> 00:10:20,450
Yeah.

276
00:10:22,859 --> 00:10:25,210
I'm missing a semicolon at the end of line 5 here,

277
00:10:25,289 --> 00:10:27,039
so I'm gonna go ahead and add that in,

278
00:10:27,090 --> 00:10:29,359
and this is subtle and arguably not a bug,

279
00:10:29,409 --> 00:10:30,729
but maybe an aesthetic detail.

280
00:10:30,849 --> 00:10:31,479
What else

281
00:10:31,880 --> 00:10:33,179
have I done arguably wrong,

282
00:10:33,270 --> 00:10:33,369
yeah,

283
00:10:33,409 --> 00:10:33,919
and back.

284
00:10:36,460 --> 00:10:36,650
Yeah,

285
00:10:36,729 --> 00:10:40,140
I forgot my backslash and the new line character just to move the

286
00:10:40,140 --> 00:10:42,289
cursor to the next line so that when I get a new prompt,

287
00:10:42,330 --> 00:10:43,880
it's on a fresh line of its own.

288
00:10:44,070 --> 00:10:44,210
Again,

289
00:10:44,289 --> 00:10:45,070
more of an aesthetic,

290
00:10:45,090 --> 00:10:47,320
but certainly a pretty reasonable thing to do.

291
00:10:47,530 --> 00:10:49,250
So let me go ahead now and actually in

292
00:10:49,250 --> 00:10:51,960
my terminal window run Ma buggy and indeed compiled.

293
00:10:52,130 --> 00:10:53,280
But up until then

294
00:10:53,530 --> 00:10:55,080
had I not fixed those mistakes,

295
00:10:55,179 --> 00:10:57,210
I would have triggered a whole bunch of bugs,

296
00:10:57,250 --> 00:10:59,400
a whole bunch of error messages as a result.

297
00:10:59,450 --> 00:10:59,799
In fact,

298
00:11:00,010 --> 00:11:02,130
let's rewind in time and undo the fixes.

299
00:11:02,263 --> 00:11:05,882
Just made and go back to the original form here and try running again,

300
00:11:06,132 --> 00:11:10,013
make buggy enter and we'll see some scary looking messages up here.

301
00:11:10,132 --> 00:11:12,442
Let me scroll up to the top of the output here

302
00:11:12,612 --> 00:11:15,893
where we see buggy.c colon 3,

303
00:11:16,013 --> 00:11:17,143
which means line 3.

304
00:11:17,302 --> 00:11:18,882
That's where the problem is right now.

305
00:11:19,172 --> 00:11:19,682
error.

306
00:11:19,692 --> 00:11:21,403
Call to undeclared library function,

307
00:11:21,413 --> 00:11:22,533
print F with type,

308
00:11:22,543 --> 00:11:24,482
and then it starts to get a little more complicated,

309
00:11:24,572 --> 00:11:27,882
but I do see clearly that it's calling my attention to print.

310
00:11:28,065 --> 00:11:29,445
So hopefully at some point,

311
00:11:29,575 --> 00:11:30,375
if not last week,

312
00:11:30,495 --> 00:11:31,495
hopefully this week onward,

313
00:11:31,695 --> 00:11:32,495
your instinct will be,

314
00:11:32,596 --> 00:11:32,935
oh,

315
00:11:33,096 --> 00:11:33,255
all right,

316
00:11:33,296 --> 00:11:33,806
I'm an idiot.

317
00:11:33,815 --> 00:11:37,335
I forgot the header file in which print F is actually declared.

318
00:11:37,375 --> 00:11:38,135
It's not a huge deal.

319
00:11:38,185 --> 00:11:39,366
It's going to come with practice,

320
00:11:39,575 --> 00:11:41,205
so that's how I might know

321
00:11:41,736 --> 00:11:44,426
in more intuitively what in fact

322
00:11:45,015 --> 00:11:46,375
the solution here might be.

323
00:11:46,536 --> 00:11:49,005
Now here's another common mistake that I've just gone in and fixed,

324
00:11:49,135 --> 00:11:51,255
but I did do something wrong and hopefully none of

325
00:11:51,255 --> 00:11:53,806
you actually did this because it's an annual FAQ.

326
00:11:54,135 --> 00:11:56,046
What did I just do accidentally wrong?

327
00:11:57,510 --> 00:11:59,020
So it's not studio.H,

328
00:11:59,030 --> 00:12:03,239
it's standard IO.h. So do kind of ingrain that one for standard input output.

329
00:12:03,469 --> 00:12:06,789
The next though bug that I haven't yet fixed is that semicolon.

330
00:12:06,830 --> 00:12:09,469
So let me clear my screen and rerun Make Buggy.

331
00:12:09,549 --> 00:12:12,020
I should no longer see that first error message anymore,

332
00:12:12,229 --> 00:12:14,429
but I now do see another error message online.

333
00:12:14,534 --> 00:12:17,424
5 expected semicolon after expression.

334
00:12:17,515 --> 00:12:17,604
All right,

335
00:12:17,674 --> 00:12:18,674
that one's pretty explicit,

336
00:12:18,755 --> 00:12:20,184
so I'm going to go ahead and fix this,

337
00:12:20,354 --> 00:12:22,914
but notice that up until now my code wouldn't have

338
00:12:22,914 --> 00:12:25,385
been able to compile because of those two error messages.

339
00:12:25,395 --> 00:12:28,445
It stopped showing me by showing me these errors,

340
00:12:28,554 --> 00:12:29,265
but at this point,

341
00:12:29,344 --> 00:12:31,674
if I run make buggy enter.

342
00:12:32,010 --> 00:12:35,869
It did in fact compile and yet it's arguably still buggy because

343
00:12:35,869 --> 00:12:39,539
when I run buggy I get my prompt on the wrong line.

344
00:12:39,630 --> 00:12:43,010
So this is a distinction now between a syntax error,

345
00:12:43,150 --> 00:12:46,030
something that or a programming error that

346
00:12:46,030 --> 00:12:48,190
outright stops my program from compiling.

347
00:12:48,210 --> 00:12:51,869
It's sort of a deal breaker versus something that's maybe more of a logical error.

348
00:12:51,909 --> 00:12:55,270
I actually meant to move the cursor to the next line and so there's different.

349
00:12:55,400 --> 00:12:57,979
Types of errors in the world as we're seeing here

350
00:12:57,979 --> 00:13:01,109
of course if I rerun Make Buggy Againslash buggy,

351
00:13:01,150 --> 00:13:05,460
now we're back in business hopefully with the intention of having this,

352
00:13:05,619 --> 00:13:06,390
uh,

353
00:13:06,400 --> 00:13:07,780
display exactly that.

354
00:13:08,150 --> 00:13:08,309
All right,

355
00:13:08,429 --> 00:13:08,539
well,

356
00:13:08,549 --> 00:13:11,700
let's modify to look a little more like something else from last week.

357
00:13:11,869 --> 00:13:15,059
Recall that last week I started to get someone's name

358
00:13:15,309 --> 00:13:16,150
more dynamically,

359
00:13:16,190 --> 00:13:18,710
so I said something like name equals get string.

360
00:13:18,940 --> 00:13:20,369
And that was a function we introduced,

361
00:13:20,390 --> 00:13:22,750
and I might have said something like this what's your name?

362
00:13:22,830 --> 00:13:25,580
question mark with a space just to move the cursor over.

363
00:13:25,710 --> 00:13:28,419
I know now I definitely need to end my thought with a semicolon.

364
00:13:28,590 --> 00:13:30,539
I could try and compile this.

365
00:13:30,750 --> 00:13:31,900
Make buggy

366
00:13:32,070 --> 00:13:32,580
now

367
00:13:32,989 --> 00:13:35,830
and I'm seeing a different error message altogether

368
00:13:35,830 --> 00:13:36,909
that you might not have seen yet.

369
00:13:37,030 --> 00:13:41,099
So on buggy.C line 5 error use of undeclared identifier

370
00:13:41,510 --> 00:13:42,130
name.

371
00:13:42,989 --> 00:13:45,140
What now is the mistake that I've made?

372
00:13:45,429 --> 00:13:46,390
Why does it not know?

373
00:13:48,099 --> 00:13:48,330
Yeah,

374
00:13:48,409 --> 00:13:51,000
I forgot to declare the type of this variable,

375
00:13:51,130 --> 00:13:53,289
which for those of you with the prior programming experience is

376
00:13:53,289 --> 00:13:55,809
not something you have to do in some languages like Python,

377
00:13:55,820 --> 00:13:56,479
for instance,

378
00:13:56,650 --> 00:13:57,890
but in languages like C,

379
00:13:57,969 --> 00:13:58,650
C++,

380
00:13:58,859 --> 00:13:59,270
Java,

381
00:13:59,330 --> 00:14:02,000
and others you do in fact need to explicitly tell

382
00:14:02,000 --> 00:14:04,900
the compiler that you want to instantiate a vari.

383
00:14:05,390 --> 00:14:09,460
create a variable in the computer's memory by telling it it's type,

384
00:14:09,590 --> 00:14:12,549
and it's not going to be an in because I don't want an integer,

385
00:14:12,559 --> 00:14:12,820
of course,

386
00:14:12,830 --> 00:14:17,260
in this case I want text which we now know to be called string instead.

387
00:14:17,549 --> 00:14:17,830
All right,

388
00:14:17,989 --> 00:14:19,270
I think this fixes that bug,

389
00:14:19,349 --> 00:14:21,830
so let me do make buggy again and hopefully.

390
00:14:22,539 --> 00:14:22,919
Huh,

391
00:14:22,989 --> 00:14:25,580
a fatal error this time again indicating that my

392
00:14:25,580 --> 00:14:29,169
code did not recompile on line 5 still,

393
00:14:29,500 --> 00:14:30,539
I have an error,

394
00:14:30,619 --> 00:14:34,489
but this time it says use of undeclared identifier string.

395
00:14:34,619 --> 00:14:36,229
Did I mean standard in.

396
00:14:36,460 --> 00:14:37,669
So this is a bit of a red herring.

397
00:14:37,679 --> 00:14:41,260
The compiler's trying to be helpful in saying did I mean standard in,

398
00:14:41,739 --> 00:14:43,099
but I don't think I actually do.

399
00:14:43,179 --> 00:14:46,890
That just is the most similar looking word in the compiler's own memory.

400
00:14:47,109 --> 00:14:49,289
What's the actual mistake that I've made here?

401
00:14:49,580 --> 00:14:49,890
Yeah.

402
00:14:53,650 --> 00:14:53,840
Yeah,

403
00:14:53,919 --> 00:14:57,400
I didn't include the CS50 header file because string

404
00:14:57,400 --> 00:15:00,559
recall is a feature of the CS 50 library,

405
00:15:00,630 --> 00:15:03,750
as is get string and get into and others.

406
00:15:03,880 --> 00:15:06,710
So the solution here is indeed to go up here

407
00:15:06,960 --> 00:15:08,080
and just to be nitpicky,

408
00:15:08,119 --> 00:15:09,840
I tend to alphabetize my header files.

409
00:15:09,849 --> 00:15:11,400
It's not strictly required technically,

410
00:15:11,440 --> 00:15:12,469
but stylistically.

411
00:15:12,760 --> 00:15:14,159
I find it nice to be able to skim the

412
00:15:14,159 --> 00:15:16,400
header files alphabetically to see if something is there.

413
00:15:16,525 --> 00:15:18,525
Not I can include CS50.

414
00:15:18,794 --> 00:15:23,554
H in addition to standardio.h and it's in that file CS50.h that not

415
00:15:23,554 --> 00:15:28,315
only is get string declared so that the compiler knows that it exists,

416
00:15:28,434 --> 00:15:30,715
it turns out so is the word string.

417
00:15:30,804 --> 00:15:32,075
So this is a bit of a white lie,

418
00:15:32,085 --> 00:15:34,145
and this is something we do in the early weeks of the class.

419
00:15:34,395 --> 00:15:36,515
We dug up these old training wheels from a bicycle,

420
00:15:36,554 --> 00:15:39,315
the whole idea being to sort of keep you up and avoid you having to do.

421
00:15:39,400 --> 00:15:41,059
Too much complexity early on.

422
00:15:41,270 --> 00:15:44,630
The point of these training wheels in the form of the CS 50 library is to

423
00:15:44,630 --> 00:15:49,500
let us kind of ignore what a string really is for just another week or two,

424
00:15:49,830 --> 00:15:52,940
after which we will then peel back that layer,

425
00:15:53,150 --> 00:15:54,469
take off those training wheels,

426
00:15:54,489 --> 00:15:56,539
and reveal to you what is actually going on.

427
00:15:56,669 --> 00:15:57,340
So for now,

428
00:15:57,510 --> 00:15:59,140
strings exist,

429
00:15:59,349 --> 00:16:01,469
but they exist because of the CS 50 library.

430
00:16:01,489 --> 00:16:02,219
In a couple of weeks.

431
00:16:02,275 --> 00:16:03,494
They're still going to exist,

432
00:16:03,664 --> 00:16:05,215
but we're going to call them by a different name,

433
00:16:05,304 --> 00:16:06,815
as we'll eventually see.

434
00:16:06,984 --> 00:16:08,414
But everyone in the real world,

435
00:16:09,065 --> 00:16:11,895
every software developer uses the phrase string.

436
00:16:12,065 --> 00:16:13,424
So this is a concept that exists.

437
00:16:13,505 --> 00:16:15,294
It is not CS 50 specific at all.

438
00:16:15,465 --> 00:16:16,775
It's just that in C,

439
00:16:16,984 --> 00:16:22,174
the word string doesn't typically exist unless you make it so as we have.

440
00:16:22,455 --> 00:16:22,625
All right,

441
00:16:22,705 --> 00:16:24,984
so I think now if I clear my terminal window.

442
00:16:25,479 --> 00:16:27,340
And rerun make buggy.

443
00:16:27,510 --> 00:16:31,219
Now it should in fact compile and if I runs buggy enter,

444
00:16:31,510 --> 00:16:33,669
I should be able to type in my name and now

445
00:16:33,840 --> 00:16:34,640
voila,

446
00:16:34,820 --> 00:16:35,500
hello.

447
00:16:36,169 --> 00:16:38,909
So this is now not a syntax error because I

448
00:16:38,909 --> 00:16:42,270
didn't screw up my code per se like it compiled.

449
00:16:42,349 --> 00:16:43,989
Everything is grammatically correct,

450
00:16:44,070 --> 00:16:44,739
so to speak,

451
00:16:44,950 --> 00:16:45,989
but logically,

452
00:16:46,190 --> 00:16:46,789
intellectually,

453
00:16:46,830 --> 00:16:47,909
this is not what I wanted,

454
00:16:47,950 --> 00:16:48,080
right?

455
00:16:48,169 --> 00:16:49,640
I wanted it presumably to say hello,

456
00:16:50,020 --> 00:16:50,580
David,

457
00:16:50,869 --> 00:16:52,859
so let's fix one final bug here.

458
00:16:53,229 --> 00:16:54,109
How do I fix this?

459
00:16:54,119 --> 00:16:54,979
On what line?

460
00:16:56,390 --> 00:16:58,159
How do I get it to say yeah hello David.

461
00:17:01,729 --> 00:17:01,989
Yeah,

462
00:17:02,150 --> 00:17:04,589
on line 7 I need to do the string placeholder,

463
00:17:04,709 --> 00:17:05,540
the format code,

464
00:17:05,670 --> 00:17:06,069
so to speak,

465
00:17:06,189 --> 00:17:06,780
percents,

466
00:17:06,790 --> 00:17:07,589
and then one more thing,

467
00:17:07,699 --> 00:17:08,339
someone else.

468
00:17:08,589 --> 00:17:09,709
What do I do after this?

469
00:17:10,630 --> 00:17:10,810
Yeah,

470
00:17:10,949 --> 00:17:11,579
and back

471
00:17:13,900 --> 00:17:14,290
Yeah,

472
00:17:14,540 --> 00:17:16,579
comma and then add the variable name that contains

473
00:17:16,579 --> 00:17:18,459
the value I want to substitute in there,

474
00:17:18,500 --> 00:17:19,459
which is indeed name,

475
00:17:19,500 --> 00:17:21,170
though I could have called it anything I want.

476
00:17:21,579 --> 00:17:21,660
All right,

477
00:17:21,739 --> 00:17:26,118
so now make buggy enter seems to have compiled again buggy.

478
00:17:26,380 --> 00:17:27,969
Now I type in my name once more,

479
00:17:28,219 --> 00:17:29,890
and now we're back in business.

480
00:17:29,979 --> 00:17:32,010
So over the course of these few exercises,

481
00:17:32,290 --> 00:17:35,219
clearly I meant to make most of all of these bugs,

482
00:17:35,300 --> 00:17:35,930
these mistakes,

483
00:17:36,099 --> 00:17:36,449
but

484
00:17:36,619 --> 00:17:38,739
they demonstrate not only syntax error.

485
00:17:39,026 --> 00:17:41,225
which are just going to stop the compiler in its tracks.

486
00:17:41,306 --> 00:17:43,735
Like you won't even be able to compile your code

487
00:17:44,186 --> 00:17:45,375
until you fix those things.

488
00:17:45,505 --> 00:17:48,215
But even after that there could be these latent bugs that

489
00:17:48,745 --> 00:17:53,625
seem to not be there until you actually provide input and see what's

490
00:17:53,625 --> 00:17:57,215
actually happening at so-called run time when you're running the actual code.

491
00:17:57,385 --> 00:18:00,255
And so here's where it's no longer as easy

492
00:18:00,255 --> 00:18:02,745
as just reading the error message and figuring out what

493
00:18:02,745 --> 00:18:05,182
it means because there There is no error message

494
00:18:05,182 --> 00:18:06,682
that appeared on the screen when it said hello,

495
00:18:06,741 --> 00:18:07,312
comma world.

496
00:18:07,352 --> 00:18:09,261
We had to use our own human intellect and realize,

497
00:18:09,432 --> 00:18:09,592
OK,

498
00:18:09,631 --> 00:18:11,212
that's clearly not what I wanted.

499
00:18:11,391 --> 00:18:14,501
Had you run CS 50's own Check 50 program on something like that,

500
00:18:14,771 --> 00:18:18,092
we could have told you that that's not correct by automatically

501
00:18:18,432 --> 00:18:19,751
assessing the correctness of it,

502
00:18:19,871 --> 00:18:23,891
but the compiler has no idea what you are trying to achieve logically.

503
00:18:23,952 --> 00:18:28,751
It only knows about the language C itself and the requisite syntax for actually.

504
00:18:29,209 --> 00:18:29,430
Uh,

505
00:18:29,609 --> 00:18:31,520
writing and compiling code.

506
00:18:31,770 --> 00:18:36,410
So how could we go about solving logical problems in code?

507
00:18:36,530 --> 00:18:40,479
So I would propose that we start to consider this here list

508
00:18:40,729 --> 00:18:41,439
whereby

509
00:18:41,670 --> 00:18:44,729
when you want to find a logical problem in your code

510
00:18:44,729 --> 00:18:48,199
and better understand what's going on or really what's going wrong,

511
00:18:48,410 --> 00:18:50,239
printF is going to be your friend.

512
00:18:50,329 --> 00:18:52,719
Up until now we've used printF to literally print on the screen.

513
00:18:52,810 --> 00:18:53,520
Hello David.

514
00:18:53,630 --> 00:18:55,890
Hello Kelly or anything else on the screen,

515
00:18:56,140 --> 00:19:00,819
but you can certainly use PrintF temporarily to just print stuff out

516
00:19:00,819 --> 00:19:03,859
inside of your program that you might want to better understand.

517
00:19:03,869 --> 00:19:06,410
And then once you understand it and once you've solved some problem,

518
00:19:06,560 --> 00:19:06,739
fine,

519
00:19:06,819 --> 00:19:09,099
then you can delete those temporary lines of code,

520
00:19:09,140 --> 00:19:10,050
recompile,

521
00:19:10,380 --> 00:19:11,170
and move on.

522
00:19:11,339 --> 00:19:14,420
So let's use printF as a debugging tool in that sense.

523
00:19:14,500 --> 00:19:18,020
Let me go back over to VS code here and let me in this same program.

524
00:19:18,579 --> 00:19:22,969
Buggy.c sort of delete everything and start over with a different sort of bug.

525
00:19:23,099 --> 00:19:24,910
I'm going to include standard IO.

526
00:19:25,459 --> 00:19:26,329
H at the top.

527
00:19:26,540 --> 00:19:28,770
I'm going to do in Main void after that.

528
00:19:28,900 --> 00:19:30,900
And then inside Maine I'm going to do a simple

529
00:19:30,900 --> 00:19:33,890
for loop that just prints out like a stack of

530
00:19:34,260 --> 00:19:38,689
3 bricks like we saw in the world of Mario when Mario needed to,

531
00:19:38,739 --> 00:19:41,250
we claimed sort of jump over a stack of bricks.

532
00:19:41,260 --> 00:19:44,050
We want to print out just 3 of those at the moment.

533
00:19:44,180 --> 00:19:46,099
So I'm going to go ahead and say 4 in.

534
00:19:46,540 --> 00:19:47,890
I equals 0.

535
00:19:48,260 --> 00:19:52,170
I is less than or equal to 3 because I want 3 of these

536
00:19:52,439 --> 00:19:53,689
I plus plus.

537
00:19:53,859 --> 00:19:57,130
Then inside of this 4 loop I'm going to go ahead and quite simply do print F hash

538
00:19:57,130 --> 00:19:59,780
symbol to represent the brick followed by a new

539
00:19:59,780 --> 00:20:01,689
line to move the cursor to the next line,

540
00:20:01,939 --> 00:20:03,880
semicolon to complete the thought.

541
00:20:04,140 --> 00:20:07,420
Now I've deliberately made a stupid mistake here,

542
00:20:07,459 --> 00:20:10,140
but in the context of a simple enough program that we can focus on

543
00:20:10,140 --> 00:20:13,939
the debugging technique on not on the obscurity of the bug in question.

544
00:20:14,189 --> 00:20:16,770
Hopefully you'll spot the bug in just a moment if not already.

545
00:20:16,900 --> 00:20:19,420
When I do make buggy now and do buggy,

546
00:20:19,459 --> 00:20:20,890
I don't get 3 bricks.

547
00:20:21,099 --> 00:20:22,050
I of course get

548
00:20:22,310 --> 00:20:24,709
1234 total.

549
00:20:24,780 --> 00:20:26,969
So there's a logical bug in this program,

550
00:20:27,180 --> 00:20:29,180
and odds are you can already spot what it is.

551
00:20:29,300 --> 00:20:32,579
But let me propose that this program is representative of

552
00:20:32,579 --> 00:20:34,500
a type of problem that you can solve a little

553
00:20:34,500 --> 00:20:38,290
more diagnostically by poking around and really asking the computer

554
00:20:38,290 --> 00:20:41,449
via print up to show you what's really going on,

555
00:20:41,579 --> 00:20:41,979
and I would.

556
00:20:42,229 --> 00:20:44,780
that one of the most helpful techniques in a situation like this,

557
00:20:44,859 --> 00:20:48,650
if you're trying to wrap your mind around why are there 4 bricks instead of 3,

558
00:20:48,939 --> 00:20:49,150
well,

559
00:20:49,339 --> 00:20:51,520
clearly this is related to the loop somehow.

560
00:20:51,819 --> 00:20:57,170
So let's look a little more thoughtfully at what the value of I is before we print out

561
00:20:57,420 --> 00:20:58,780
each of those bricks,

562
00:20:58,819 --> 00:21:03,209
and I might literally do something like this temporarily print F quote unquote

563
00:21:03,209 --> 00:21:09,939
I is peri backslashn close quote and then I could just print.

564
00:21:10,180 --> 00:21:11,189
Right here and now,

565
00:21:11,420 --> 00:21:14,130
the value of I just so that I can actually see it.

566
00:21:14,380 --> 00:21:16,290
Let me now go down into my terminal window,

567
00:21:16,579 --> 00:21:19,140
make buggy again buggy,

568
00:21:19,170 --> 00:21:19,699
and now,

569
00:21:19,739 --> 00:21:21,160
and I'll full screen my terminal,

570
00:21:21,239 --> 00:21:23,900
I'll get some diagnostic information at the same time.

571
00:21:24,069 --> 00:21:25,030
So when I is 1,

572
00:21:25,140 --> 00:21:25,969
I get a brick.

573
00:21:26,140 --> 00:21:26,579
When I,

574
00:21:26,930 --> 00:21:27,650
when I is 0,

575
00:21:27,660 --> 00:21:28,280
I get a brick.

576
00:21:28,400 --> 00:21:29,130
When I is 1,

577
00:21:29,140 --> 00:21:29,939
I get another brick.

578
00:21:29,979 --> 00:21:30,619
When I is 2,

579
00:21:30,630 --> 00:21:31,449
I get another brick.

580
00:21:31,619 --> 00:21:32,609
When I is 3,

581
00:21:32,979 --> 00:21:34,400
I get a 4th brick.

582
00:21:34,540 --> 00:21:35,890
So now I can kind of see that,

583
00:21:35,900 --> 00:21:36,359
OK,

584
00:21:36,540 --> 00:21:37,369
my loop is working,

585
00:21:37,619 --> 00:21:37,819
but I'm.

586
00:21:37,949 --> 00:21:39,310
Going too far.

587
00:21:39,500 --> 00:21:40,619
I'm going too long now.

588
00:21:40,939 --> 00:21:43,099
I can do this even more succinctly for what it's worth.

589
00:21:43,219 --> 00:21:45,010
I don't need a whole new print def statement.

590
00:21:45,140 --> 00:21:47,290
I could just go into my existing print def,

591
00:21:47,540 --> 00:21:49,010
put my percent I there,

592
00:21:49,219 --> 00:21:51,609
and then maybe just space just to scooch things over,

593
00:21:51,780 --> 00:21:53,969
and then print out i in that same line.

594
00:21:54,140 --> 00:21:56,739
If I now do make buggy buggy,

595
00:21:56,819 --> 00:21:57,250
OK,

596
00:21:57,469 --> 00:21:59,329
now I'm seeing that I'm printing a hash,

597
00:21:59,540 --> 00:22:04,260
a brick for each value of I from I equals 012,

598
00:22:04,380 --> 00:22:05,739
and also 3.

599
00:22:06,010 --> 00:22:08,479
So the solution of course is that I shouldn't be starting

600
00:22:08,479 --> 00:22:12,109
at 0 and iterating less than or equal to 3.

601
00:22:12,280 --> 00:22:13,079
The solution is like,

602
00:22:13,140 --> 00:22:13,319
oh,

603
00:22:13,439 --> 00:22:14,040
I'm an idiot.

604
00:22:14,119 --> 00:22:16,270
I should have said less than 3,

605
00:22:16,319 --> 00:22:19,550
or if I prefer to count starting at 1 like a normal person,

606
00:22:19,680 --> 00:22:24,229
I could have said I equal to 1 and then go up 2 and through 3.

607
00:22:24,319 --> 00:22:25,359
But as I claimed last week,

608
00:22:25,400 --> 00:22:26,469
the canonical way,

609
00:22:26,599 --> 00:22:30,469
the most common way to do this is start counting at 0 and go up 2,

610
00:22:30,640 --> 00:22:34,000
but not through the total value that you have in mind.

611
00:22:34,910 --> 00:22:37,680
But there's going to be another technique that's worth knowing here.

612
00:22:37,810 --> 00:22:39,760
Let me go ahead and sort of abstract this away by

613
00:22:39,760 --> 00:22:43,000
whipping up a slightly better variant of this as follows.

614
00:22:43,209 --> 00:22:45,060
Let me go ahead and delete this for loop.

615
00:22:45,250 --> 00:22:47,250
Let me assume for the moment that inside of Maine,

616
00:22:47,329 --> 00:22:50,180
I'm going to ask the user now for the height of a pyramid,

617
00:22:50,209 --> 00:22:51,400
and I'm going to do something like this.

618
00:22:51,410 --> 00:22:53,489
In H equals get in,

619
00:22:53,500 --> 00:22:54,930
and let's prompt the user.

620
00:22:55,270 --> 00:22:57,920
for the height value of this pyramid

621
00:22:58,130 --> 00:22:58,839
or this wall,

622
00:22:58,959 --> 00:23:00,890
and then let's go ahead and assume there exists

623
00:23:00,890 --> 00:23:04,079
a function called print column who takes as input

624
00:23:04,290 --> 00:23:05,199
a number H,

625
00:23:05,329 --> 00:23:07,000
which is how many bricks you want to print.

626
00:23:07,250 --> 00:23:11,479
Now this function does not exist yet print column get in does exist,

627
00:23:11,489 --> 00:23:12,630
but I don't have access to it,

628
00:23:12,650 --> 00:23:13,969
so let me not make the same mistake twice.

629
00:23:14,050 --> 00:23:15,010
What do I need to add?

630
00:23:16,010 --> 00:23:17,260
At the top of this file,

631
00:23:17,530 --> 00:23:17,979
yeah.

632
00:23:19,280 --> 00:23:22,949
I need the CS 50 header file because I'm using the get in function now,

633
00:23:22,989 --> 00:23:24,550
which again comes from our library,

634
00:23:24,630 --> 00:23:25,180
not C.

635
00:23:25,319 --> 00:23:26,790
So let me go ahead and include CS50.

636
00:23:26,989 --> 00:23:27,400
H.

637
00:23:27,630 --> 00:23:29,099
But now print column,

638
00:23:29,310 --> 00:23:31,150
I can invent this function myself.

639
00:23:31,229 --> 00:23:37,550
So let me go ahead and say void print column in height in parentheses.

640
00:23:37,650 --> 00:23:38,900
More on that in just a moment.

641
00:23:39,030 --> 00:23:43,660
And then I'm going to recreate the loop from before 4 in I equals 0.

642
00:23:43,869 --> 00:23:44,750
I is less than.

643
00:23:44,824 --> 00:23:45,775
are equal to the height,

644
00:23:45,814 --> 00:23:48,444
so I'm going to deliberately for now make that same mistake as before

645
00:23:48,694 --> 00:23:49,545
I + plus,

646
00:23:49,555 --> 00:23:52,094
and then inside of this 4 loop I'm going to go ahead and print

647
00:23:52,094 --> 00:23:56,364
out a single hash and a new line to represent that there brick.

648
00:23:56,734 --> 00:23:57,564
So now

649
00:23:58,015 --> 00:24:00,724
Main can use a function called print column.

650
00:24:00,935 --> 00:24:04,214
It's going to pass in the value of H and then this 4 loop in

651
00:24:04,214 --> 00:24:07,285
the print column function is going to take care of printing this thing for me.

652
00:24:07,425 --> 00:24:08,405
So let me do this again.

653
00:24:08,574 --> 00:24:10,214
Make buggy enter.

654
00:24:10,579 --> 00:24:11,599
So far so good.

655
00:24:11,930 --> 00:24:12,660
buggy.

656
00:24:12,729 --> 00:24:13,810
Let's put it in height.

657
00:24:13,890 --> 00:24:15,810
I'm going to say manually height of 3,

658
00:24:15,849 --> 00:24:17,469
and I should see 3 bricks,

659
00:24:17,609 --> 00:24:19,439
but of course I'm still seeing 4.

660
00:24:19,609 --> 00:24:20,640
Now before we move on,

661
00:24:20,729 --> 00:24:22,599
let me hide my terminal and propose that

662
00:24:22,770 --> 00:24:24,640
this is just kind of stylistically

663
00:24:24,859 --> 00:24:28,109
bad to put anything other than your main function at the top,

664
00:24:28,239 --> 00:24:32,439
but recall that if I move my helper function print column,

665
00:24:32,449 --> 00:24:36,199
and it's a helper function insofar as I made it to help me solve another problem,

666
00:24:36,530 --> 00:24:38,599
I can't recompile and run my code now.

667
00:24:39,089 --> 00:24:39,530
Why?

668
00:24:40,380 --> 00:24:41,489
The compiler won't let me,

669
00:24:41,569 --> 00:24:41,849
yeah.

670
00:24:47,189 --> 00:24:49,819
Exactly when the compiler gets to line 7 of my code,

671
00:24:49,910 --> 00:24:53,859
it's going to abort compilation because it doesn't know what print column is.

672
00:24:53,949 --> 00:24:54,349
Why?

673
00:24:54,670 --> 00:24:57,579
Because I don't tell it what it is until line 10,

674
00:24:57,630 --> 00:25:00,979
and this was the only time I proposed that copy paste is reasonable

675
00:25:00,979 --> 00:25:04,859
is to highlight and copy the very first line of that function,

676
00:25:05,109 --> 00:25:07,489
paste it above main with a semicolon,

677
00:25:07,630 --> 00:25:09,939
and that's a so-called function prototype.

678
00:25:10,109 --> 00:25:11,979
It specifies what the name of it is,

679
00:25:12,109 --> 00:25:13,020
what its inputs are,

680
00:25:13,069 --> 00:25:13,660
if any,

681
00:25:13,790 --> 00:25:14,949
and what its output is,

682
00:25:14,989 --> 00:25:15,270
if any.

683
00:25:15,422 --> 00:25:17,883
And more on these inputs and outputs later on.

684
00:25:18,012 --> 00:25:20,282
But now this is just a more complicated

685
00:25:20,282 --> 00:25:23,203
but more modularized version of the same program.

686
00:25:23,373 --> 00:25:24,522
Let me do make buggy,

687
00:25:24,772 --> 00:25:26,392
still compiles buggy,

688
00:25:26,493 --> 00:25:27,363
type in 3,

689
00:25:27,572 --> 00:25:29,363
and I still have that same bug.

690
00:25:29,532 --> 00:25:31,902
But the catch now is that my code has gotten

691
00:25:32,142 --> 00:25:33,223
more complicated,

692
00:25:33,233 --> 00:25:38,292
and the point of my having abstracted away this idea of printing a column

693
00:25:38,292 --> 00:25:41,812
into a new function is that there's just more code now to debug.

694
00:25:41,892 --> 00:25:43,652
I could certainly go in there and start adding print.

695
00:25:43,965 --> 00:25:47,105
But at some point printF is going to be a very primitive tool,

696
00:25:47,115 --> 00:25:48,786
and you're going to waste more time

697
00:25:49,115 --> 00:25:50,026
adding printFs,

698
00:25:50,036 --> 00:25:51,345
recompiling your code,

699
00:25:51,635 --> 00:25:52,505
running your code,

700
00:25:52,725 --> 00:25:53,556
changing the print F,

701
00:25:53,566 --> 00:25:54,755
recompiling your code,

702
00:25:54,875 --> 00:25:55,436
running your code.

703
00:25:55,475 --> 00:25:57,276
It's going to get very tedious quickly when you have

704
00:25:57,515 --> 00:25:59,345
lots of lines of code on the screen.

705
00:25:59,595 --> 00:26:03,605
So can I actually step through my code line by line,

706
00:26:03,635 --> 00:26:06,465
maybe like your TA would in a section or a small class,

707
00:26:06,635 --> 00:26:08,426
line by line walking through the code?

708
00:26:08,715 --> 00:26:12,036
You can because another tool that you have access to.

709
00:26:12,560 --> 00:26:14,959
Is that called debug 50.

710
00:26:15,229 --> 00:26:17,260
So this is a CS 50 command

711
00:26:17,390 --> 00:26:19,829
that will start an industry standard debugger,

712
00:26:19,869 --> 00:26:24,150
and a debugger is a piece of software that is used in the real world that

713
00:26:24,150 --> 00:26:26,270
literally lets you do that debug your code

714
00:26:26,270 --> 00:26:29,660
by letting you slow down or even pause execution

715
00:26:29,869 --> 00:26:32,140
and walk through execution of your code

716
00:26:32,430 --> 00:26:33,420
line by line.

717
00:26:33,550 --> 00:26:36,869
The only reason we call it debug 50 is because in VS code it's a little annoying.

718
00:26:36,974 --> 00:26:41,125
To start the debugger and so we automated the process of starting the debugger,

719
00:26:41,165 --> 00:26:43,405
but everything thereafter has nothing to do with CS 50

720
00:26:43,405 --> 00:26:47,484
and everything to do with real world software engineering techniques.

721
00:26:47,805 --> 00:26:48,875
So how do we use this?

722
00:26:49,005 --> 00:26:51,324
Let me go back to VS code here and let me

723
00:26:51,324 --> 00:26:54,084
propose that I want to step through this code line by line

724
00:26:54,084 --> 00:26:56,714
just like we might at a whiteboard in a smaller class

725
00:26:56,714 --> 00:26:59,864
to figure out why I'm getting 4 instead of 3 hashes.

726
00:27:00,005 --> 00:27:00,125
Well,

727
00:27:00,135 --> 00:27:01,275
in my terminal window.

728
00:27:01,829 --> 00:27:03,619
What I'm going to go ahead and do is this

729
00:27:03,949 --> 00:27:07,250
debug 50 space buggy.

730
00:27:07,630 --> 00:27:09,380
So debug 50 is the command.

731
00:27:09,589 --> 00:27:12,020
It needs to know what program I want to debug.

732
00:27:12,189 --> 00:27:13,930
So I'm specifying buggy,

733
00:27:13,989 --> 00:27:16,339
which is the name of the program I just compiled.

734
00:27:16,630 --> 00:27:18,959
I'm going to get an error though with the first time I run this,

735
00:27:19,510 --> 00:27:21,400
as will you if you make the same mistake.

736
00:27:21,589 --> 00:27:23,380
I'm about to see this message here.

737
00:27:23,589 --> 00:27:25,270
Looks like you haven't set any break points.

738
00:27:25,603 --> 00:27:27,723
Set at least one break point by clicking to the

739
00:27:27,723 --> 00:27:30,733
left of a line number and then rerun debug 50.

740
00:27:30,922 --> 00:27:32,353
So what is this really telling me?

741
00:27:32,522 --> 00:27:32,682
Well,

742
00:27:32,883 --> 00:27:36,483
the debugger has no idea when and where I want to pause

743
00:27:36,483 --> 00:27:39,953
execution so as to start walking through my code line by line.

744
00:27:40,123 --> 00:27:42,042
It wants me to tell it where to break,

745
00:27:42,203 --> 00:27:45,072
that is where to pause by clicking on a line number.

746
00:27:45,203 --> 00:27:46,912
So let me hide my terminal for just a moment,

747
00:27:46,922 --> 00:27:48,922
and you've probably never done this intentionally.

748
00:27:49,066 --> 00:27:50,645
But if you hover over

749
00:27:50,816 --> 00:27:53,176
the space to the left of your program's line numbers,

750
00:27:53,215 --> 00:27:54,485
you'll see a little red dot,

751
00:27:54,536 --> 00:27:56,015
a little stop sign of sorts.

752
00:27:56,176 --> 00:27:57,975
If you actually click on a line number,

753
00:27:58,015 --> 00:27:59,255
that red dot will stay there,

754
00:27:59,265 --> 00:28:02,026
and you can see the hover here saying click to add breakpoint.

755
00:28:02,296 --> 00:28:05,855
What I'm going to go ahead and do is say click to add a breakpoint at main.

756
00:28:05,975 --> 00:28:07,456
Main is the entry point to my program.

757
00:28:07,495 --> 00:28:08,865
It's the default function that gets called.

758
00:28:08,936 --> 00:28:12,765
Let's break right away so I can step through this code line by line.

759
00:28:13,296 --> 00:28:13,495
All right,

760
00:28:13,576 --> 00:28:15,095
let me reopen my terminal window.

761
00:28:15,619 --> 00:28:21,119
And clear it and then run debug 50 again with slash buggy enter and

762
00:28:21,119 --> 00:28:24,069
now a whole bunch of stuff is going to happen quickly on the screen

763
00:28:24,280 --> 00:28:25,869
and then it's going to clean itself up

764
00:28:26,280 --> 00:28:29,829
because once the debugger is running and ready to go,

765
00:28:30,040 --> 00:28:34,359
it's going to allow me to start stepping through my code line by line.

766
00:28:34,599 --> 00:28:35,819
So what is going on?

767
00:28:35,979 --> 00:28:36,069
Well,

768
00:28:36,189 --> 00:28:38,479
notice nothing has happened in the terminal yet.

769
00:28:38,550 --> 00:28:38,979
Why?

770
00:28:39,329 --> 00:28:41,890
Because my code has been paused inside of main.

771
00:28:42,189 --> 00:28:42,739
In particular,

772
00:28:42,989 --> 00:28:45,189
it's been paused in the first real line of code.

773
00:28:45,270 --> 00:28:47,099
So the curly brace is uninteresting.

774
00:28:47,189 --> 00:28:49,300
The first line is just the function's name essentially.

775
00:28:49,510 --> 00:28:50,910
So line 8 is the first juicy.

776
00:28:51,055 --> 00:28:53,234
Of code that could possibly do anything useful.

777
00:28:53,444 --> 00:28:55,234
It's been highlighted here in yellow,

778
00:28:55,464 --> 00:28:57,405
and that the fact that this cursor is here

779
00:28:57,405 --> 00:29:00,114
means that we have broken execution on this line,

780
00:29:00,244 --> 00:29:02,354
but we have not yet executed this line,

781
00:29:02,484 --> 00:29:04,854
which is why in the terminal I don't see anything yet.

782
00:29:04,964 --> 00:29:07,364
I definitely don't see heights followed by colon.

783
00:29:07,869 --> 00:29:09,300
Notice what else has happened here.

784
00:29:09,469 --> 00:29:11,750
All of a sudden in the left hand side of the screen where

785
00:29:11,750 --> 00:29:15,459
your File Explorer typically is or where the CS 50 duct typically is,

786
00:29:15,650 --> 00:29:17,939
we see mention of variables.

787
00:29:18,069 --> 00:29:20,829
You can actually see inside of the debugger what the value

788
00:29:20,829 --> 00:29:23,660
of any variable in the computer's memory happens to be.

789
00:29:23,869 --> 00:29:26,099
Now I don't quite understand this right now.

790
00:29:26,229 --> 00:29:27,739
We'll come back to this over time,

791
00:29:27,869 --> 00:29:28,780
but weirdly,

792
00:29:29,150 --> 00:29:31,510
before line 8 even executes,

793
00:29:31,630 --> 00:29:35,430
it seems that H has a default value of 32,700.

794
00:29:35,545 --> 00:29:36,275
64,

795
00:29:36,364 --> 00:29:38,035
which seems to have come from nowhere.

796
00:29:38,185 --> 00:29:38,954
As an aside,

797
00:29:39,125 --> 00:29:41,244
this is going to be what's called a garbage value,

798
00:29:41,285 --> 00:29:44,314
and this is actually why we have Oscar so omnipresently here.

799
00:29:44,454 --> 00:29:48,755
A garbage value tends to be a default value inside of a variable

800
00:29:49,005 --> 00:29:52,834
that's the result of that memory having been used previously for something else.

801
00:29:53,005 --> 00:29:53,875
Inside of your computer,

802
00:29:53,964 --> 00:29:55,104
you've got all of this memory,

803
00:29:55,165 --> 00:29:56,885
random access memory or RAM.

804
00:29:56,895 --> 00:29:57,834
More on that today,

805
00:29:58,045 --> 00:30:00,515
and it stands to reason that my computer or whatever

806
00:30:00,515 --> 00:30:03,244
cloud server we're using has been running for some time.

807
00:30:03,510 --> 00:30:08,849
So the bits that H is going to use might already have some random switches on and off,

808
00:30:08,939 --> 00:30:13,130
some random pattern of bits that happens to give me 32,764.

809
00:30:13,300 --> 00:30:15,329
But the moment this line of code executes,

810
00:30:15,579 --> 00:30:18,300
that value is going to get changed to what I actually want it to be,

811
00:30:18,380 --> 00:30:20,650
which is what the human is going to type in.

812
00:30:20,900 --> 00:30:21,219
Meanwhile,

813
00:30:21,260 --> 00:30:23,550
at the bottom here you'll see a so-called call stack.

814
00:30:23,619 --> 00:30:25,170
More on this too in the weeks to come,

815
00:30:25,380 --> 00:30:27,219
but you'll see that we've paused on the

816
00:30:27,219 --> 00:30:30,739
function called main in the file called buggy.c.

817
00:30:31,609 --> 00:30:33,589
So how do I do something useful?

818
00:30:33,689 --> 00:30:33,770
Well,

819
00:30:33,810 --> 00:30:35,369
at the very top of the debugger,

820
00:30:35,380 --> 00:30:37,729
you'll see a whole bunch of color coded icons.

821
00:30:37,890 --> 00:30:39,170
One looks like a play button,

822
00:30:39,180 --> 00:30:40,079
and if I click that,

823
00:30:40,150 --> 00:30:42,849
it's just going to continue execution of my code as

824
00:30:42,849 --> 00:30:44,760
though I don't want to step through it anymore.

825
00:30:44,829 --> 00:30:46,359
So I'm not going to click that just yet.

826
00:30:46,609 --> 00:30:47,489
The second arrow,

827
00:30:47,569 --> 00:30:49,839
which is a little curved arrow over a dot,

828
00:30:50,170 --> 00:30:52,239
is the so-called step over line,

829
00:30:52,329 --> 00:30:55,180
which will mean step over this line and execute it,

830
00:30:55,410 --> 00:30:56,930
but only one line at a time.

831
00:30:57,540 --> 00:30:59,020
Let's go ahead and do exactly that.

832
00:30:59,099 --> 00:31:01,430
So I'm going to click the step over icon,

833
00:31:01,459 --> 00:31:02,130
the second one,

834
00:31:02,160 --> 00:31:04,229
which is the curved arrow with the dot under it.

835
00:31:04,579 --> 00:31:05,170
Click.

836
00:31:05,579 --> 00:31:08,800
Now I see in my terminal window height being prompted.

837
00:31:08,979 --> 00:31:09,140
All right,

838
00:31:09,180 --> 00:31:12,089
let's go ahead and type in 3 just like I did before and hit enter.

839
00:31:12,540 --> 00:31:13,890
Now notice what happens.

840
00:31:13,930 --> 00:31:17,540
Execution has paused on line 9 instead of 8.

841
00:31:17,739 --> 00:31:19,530
And you'll see that my variable,

842
00:31:19,609 --> 00:31:21,400
a so-called local variable,

843
00:31:21,689 --> 00:31:24,040
has the value of 3 as intended.

844
00:31:24,250 --> 00:31:24,449
All right,

845
00:31:24,530 --> 00:31:26,719
so far this isn't all that enlightening other

846
00:31:26,719 --> 00:31:28,959
than demonstrative of the fact that I can pause

847
00:31:29,290 --> 00:31:31,520
execution of my program anytime I want.

848
00:31:31,780 --> 00:31:34,760
So let's now click that step over button again

849
00:31:34,969 --> 00:31:37,160
so that we actually print this column.

850
00:31:37,489 --> 00:31:37,969
Click.

851
00:31:38,459 --> 00:31:39,479
And there we have it,

852
00:31:39,650 --> 00:31:42,400
4 hashes at the bottom of the screen.

853
00:31:42,609 --> 00:31:44,770
Now execution is paused at the end of the function.

854
00:31:44,849 --> 00:31:48,410
This is just my opportunity to either stop or restart or continue.

855
00:31:48,489 --> 00:31:50,199
I'm just going to go ahead and click the play button

856
00:31:50,410 --> 00:31:51,890
and let it finish executing.

857
00:31:52,089 --> 00:31:54,849
Unfortunately that wasn't really at all in in.

858
00:31:54,949 --> 00:31:57,500
Lightning except to confirm for me that I typed in

859
00:31:57,500 --> 00:31:59,949
3 and 3 is what is in the computer's memory.

860
00:32:00,300 --> 00:32:01,930
Not that interesting though yet.

861
00:32:02,099 --> 00:32:02,719
So let's do this.

862
00:32:02,859 --> 00:32:05,329
Let's leave the break point on line 6 as before.

863
00:32:05,459 --> 00:32:08,160
Let's rerun the debugger by running debug 50buggy.

864
00:32:09,900 --> 00:32:11,449
Let's let it do its startup thing,

865
00:32:11,859 --> 00:32:13,050
which looks a little messy at first,

866
00:32:13,099 --> 00:32:15,170
but now we've highlighted line 8 again.

867
00:32:15,420 --> 00:32:19,339
I'm going to go ahead and step over this line because I do want to get an N.

868
00:32:19,800 --> 00:32:22,010
I'm going to type in 3 again enter,

869
00:32:22,260 --> 00:32:24,680
but this time instead of stepping over

870
00:32:25,020 --> 00:32:27,709
line 9 and just letting print column happen,

871
00:32:27,900 --> 00:32:29,530
this is where the debugger gets powerful.

872
00:32:29,739 --> 00:32:33,300
Let me step into line 9 and walk through

873
00:32:33,300 --> 00:32:36,569
the print column function itself line by line.

874
00:32:36,780 --> 00:32:39,339
So let me go ahead and click not this button,

875
00:32:39,540 --> 00:32:41,380
which is the curved arrow over the dot,

876
00:32:41,500 --> 00:32:42,449
but the next one,

877
00:32:42,459 --> 00:32:44,569
which is the step into button.

878
00:32:44,969 --> 00:32:45,449
Click.

879
00:32:45,900 --> 00:32:48,689
And now you'll see that execution has jumped inside

880
00:32:48,689 --> 00:32:51,760
the print column and paused on line 14,

881
00:32:51,969 --> 00:32:56,000
at which point I can see at top left what the default value of I is,

882
00:32:56,010 --> 00:33:00,250
and this is some crazy garbage value because whatever bits are being used to

883
00:33:00,250 --> 00:33:04,680
store I's value have some random garbage from some previous use of that memory.

884
00:33:04,890 --> 00:33:06,969
But as soon as line 14 executes once,

885
00:33:07,089 --> 00:33:09,030
I bet I is going to take on a value of

886
00:33:09,449 --> 00:33:10,160
0.

887
00:33:10,250 --> 00:33:11,229
So let's do that.

888
00:33:11,449 --> 00:33:13,969
I'm going to go ahead and click step over.

889
00:33:14,479 --> 00:33:17,239
Because I don't need to step into this because there's no other functions there.

890
00:33:17,390 --> 00:33:21,150
Step over it and immediately at top left I is now 0.

891
00:33:21,439 --> 00:33:23,119
Now line 16 is highlighted.

892
00:33:23,229 --> 00:33:24,550
Let's step over this,

893
00:33:25,079 --> 00:33:25,319
OK?

894
00:33:25,439 --> 00:33:27,229
Not in the terminal window what do you see?

895
00:33:27,439 --> 00:33:29,079
The first of our hashes.

896
00:33:29,239 --> 00:33:30,150
Let's step over,

897
00:33:30,319 --> 00:33:31,150
step over,

898
00:33:31,520 --> 00:33:32,280
second hash,

899
00:33:32,319 --> 00:33:33,750
and I is now 1.

900
00:33:34,000 --> 00:33:34,599
Step over,

901
00:33:34,800 --> 00:33:35,469
step over.

902
00:33:35,680 --> 00:33:38,189
Now we see a third hash and I is now 2.

903
00:33:38,479 --> 00:33:39,119
Step over,

904
00:33:39,319 --> 00:33:39,930
step over.

905
00:33:39,939 --> 00:33:40,349
OK,

906
00:33:40,599 --> 00:33:42,439
there's the symptom of the bug.

907
00:33:43,209 --> 00:33:44,400
4 hashes

908
00:33:44,729 --> 00:33:46,280
and yet I is 3,

909
00:33:46,430 --> 00:33:47,130
but wait a minute,

910
00:33:47,209 --> 00:33:51,040
this is going to draw my attention now to line 14 before I continue on or wait a minute.

911
00:33:51,160 --> 00:33:53,959
3 is of course less than or equal to 3,

912
00:33:54,290 --> 00:33:56,959
which is why I got that 4th hash on the screen.

913
00:33:57,130 --> 00:33:57,859
So at the end of the day,

914
00:33:57,920 --> 00:34:01,089
like you still need to exercise some of your own human intellect to figure out.

915
00:34:01,180 --> 00:34:02,739
And understand what's going on,

916
00:34:02,910 --> 00:34:07,180
but the value of this here debugger is that you can pause and work

917
00:34:07,180 --> 00:34:11,159
through things at your own pace and poke around inside of your own code

918
00:34:11,370 --> 00:34:15,250
and better understand what's happening as opposed to compiling the program,

919
00:34:15,370 --> 00:34:15,840
running it,

920
00:34:16,129 --> 00:34:19,379
and just now having to infer from the symptoms alone

921
00:34:19,810 --> 00:34:21,810
what the source of the problem might be.

922
00:34:23,350 --> 00:34:24,649
So that was a lot.

923
00:34:24,770 --> 00:34:27,010
Let me go ahead here and just let it continue to

924
00:34:27,010 --> 00:34:28,918
the end because I know what the problem is now.

925
00:34:28,978 --> 00:34:30,918
I need to change the less than or equal to sign

926
00:34:31,129 --> 00:34:32,679
to a simple less than instead.

927
00:34:33,648 --> 00:34:35,928
Questions though on debug 50 or any of these steps,

928
00:34:35,967 --> 00:34:36,208
yeah.

929
00:34:36,850 --> 00:34:36,860
Sure,

930
00:34:39,219 --> 00:34:39,228
um,

931
00:34:39,239 --> 00:34:40,350
could you go over what the break point.

932
00:34:41,000 --> 00:34:42,469
And then my second.

933
00:34:43,938 --> 00:34:43,947
Mhm.

934
00:34:50,899 --> 00:34:51,260
Correct.

935
00:34:51,379 --> 00:34:54,250
So in order of your questions,

936
00:34:54,418 --> 00:34:56,100
what again are these break points,

937
00:34:56,179 --> 00:34:58,260
the break point or the little red stop sign

938
00:34:58,260 --> 00:35:02,100
here just tells the debugger where to pause execution.

939
00:35:02,139 --> 00:35:03,020
So frankly,

940
00:35:03,120 --> 00:35:05,580
I didn't have to break pause execution at Maine.

941
00:35:05,820 --> 00:35:07,870
If I really care about debugging print column,

942
00:35:07,939 --> 00:35:10,330
I could have clicked down here instead,

943
00:35:10,540 --> 00:35:12,270
and then it would have just run main automatically

944
00:35:12,270 --> 00:35:15,020
and only paused once print column gets called.

945
00:35:15,100 --> 00:35:17,250
So a break point is where your code will break,

946
00:35:17,300 --> 00:35:18,419
the point at which it will break.

947
00:35:18,909 --> 00:35:20,790
As for the garbage values,

948
00:35:20,899 --> 00:35:23,979
I'm it's I'm oversimplifying exactly what's going

949
00:35:23,979 --> 00:35:25,479
on inside of the computer's memory,

950
00:35:25,590 --> 00:35:29,260
and it's not necessarily using exactly the same memory as before,

951
00:35:29,550 --> 00:35:33,409
but the operating system will govern exactly how the memory is laid out.

952
00:35:33,909 --> 00:35:36,419
This is actually a significant problem,

953
00:35:36,429 --> 00:35:39,830
long story short in a lot of today's systems because it's

954
00:35:39,830 --> 00:35:42,909
not that interesting to me to know that there was 32,000,

955
00:35:42,989 --> 00:35:43,840
whatever that number is,

956
00:35:43,870 --> 00:35:43,989
or.

957
00:35:44,195 --> 00:35:45,004
Negative number,

958
00:35:45,274 --> 00:35:49,185
but suppose that that revealed the password of someone,

959
00:35:49,445 --> 00:35:52,264
another program or function that had some information there.

960
00:35:52,435 --> 00:35:54,584
It seems all too easy with the debugger,

961
00:35:54,794 --> 00:35:55,564
let alone see,

962
00:35:55,594 --> 00:35:57,195
to actually poke around the computer's memory,

963
00:35:57,235 --> 00:35:59,104
and we're going to come back to that in a couple of weeks.

964
00:35:59,274 --> 00:36:02,625
But for now it's a garbage value insofar as you didn't put the value there,

965
00:36:02,745 --> 00:36:05,104
it somehow got there on its own for now.

966
00:36:05,235 --> 00:36:06,185
Other questions.

967
00:36:10,600 --> 00:36:13,629
Some like when it's 0 goes to 1 at the end of the 4,

968
00:36:13,679 --> 00:36:15,800
but when it goes the 4 the next time because.

969
00:36:19,669 --> 00:36:20,370
After you

970
00:36:23,929 --> 00:36:24,209
Correct.

971
00:36:24,250 --> 00:36:26,729
So the question is about the order of operations for a 4 loop.

972
00:36:26,810 --> 00:36:28,399
So the first time you go through a 4 loop,

973
00:36:28,520 --> 00:36:29,879
the initialization happens,

974
00:36:29,889 --> 00:36:31,800
the stuff before the first semicolon,

975
00:36:32,090 --> 00:36:32,520
and

976
00:36:32,679 --> 00:36:34,449
the condition is actually checked,

977
00:36:34,489 --> 00:36:35,600
the Boolean expression.

978
00:36:35,889 --> 00:36:38,479
Then everything inside of the curly braces is executed,

979
00:36:38,830 --> 00:36:41,770
then the incrementation or update happens.

980
00:36:41,860 --> 00:36:45,560
Which in this case is I + plus and then the condition is again checked,

981
00:36:45,639 --> 00:36:46,639
the Boolean expression,

982
00:36:46,810 --> 00:36:47,939
the code is executed,

983
00:36:48,090 --> 00:36:49,169
the update happens,

984
00:36:49,290 --> 00:36:50,179
the condition again,

985
00:36:50,290 --> 00:36:51,239
the code is updated,

986
00:36:51,250 --> 00:36:52,840
and so it starts to loop like this.

987
00:36:52,969 --> 00:36:55,610
The debugger's graphics are fairly simplistic and it just highlights

988
00:36:55,610 --> 00:36:58,330
the whole line without making super clear what's happening,

989
00:36:58,409 --> 00:36:59,929
but that's just the definition of a for loop.

990
00:37:00,719 --> 00:37:01,540
Good question.

991
00:37:01,989 --> 00:37:04,739
Others about debug 50 or print death?

992
00:37:06,949 --> 00:37:06,959
All

993
00:37:07,469 --> 00:37:07,699
right,

994
00:37:07,780 --> 00:37:08,129
yeah.

995
00:37:09,149 --> 00:37:10,080
the

996
00:37:11,179 --> 00:37:11,639
And uh

997
00:37:12,750 --> 00:37:15,689
Can you change the position of I plus and height?

998
00:37:16,030 --> 00:37:16,870
Short answer no.

999
00:37:16,949 --> 00:37:18,500
The first thing is the initialization,

1000
00:37:18,550 --> 00:37:20,449
the variable you want to create and initialize.

1001
00:37:20,629 --> 00:37:22,469
The second thing is the actual condition,

1002
00:37:22,510 --> 00:37:23,860
the so-called boolean expression.

1003
00:37:24,030 --> 00:37:25,629
The third thing is always the update.

1004
00:37:25,669 --> 00:37:26,860
So it must come in this order.

1005
00:37:27,070 --> 00:37:30,340
What you're not seeing is that you can actually have multiple boolean expressions,

1006
00:37:30,429 --> 00:37:32,030
you can have multiple initializations,

1007
00:37:32,080 --> 00:37:33,120
you can have multiple updates,

1008
00:37:33,149 --> 00:37:34,020
but we're keeping it

1009
00:37:34,389 --> 00:37:35,100
simple for now.

1010
00:37:35,570 --> 00:37:36,689
And this is canonical.

1011
00:37:36,959 --> 00:37:37,159
All right,

1012
00:37:37,239 --> 00:37:38,189
so to make clear,

1013
00:37:38,399 --> 00:37:42,840
assuming that either print F or Debug 50 helped me

1014
00:37:42,840 --> 00:37:45,500
figure out where the illogic was in my thoughts,

1015
00:37:45,639 --> 00:37:47,879
I now know that the fix here is to just go and

1016
00:37:47,879 --> 00:37:50,510
change the less than or equal to to a simple less than,

1017
00:37:50,560 --> 00:37:51,719
and if I run the program again,

1018
00:37:51,800 --> 00:37:55,560
of course it's going to give me the 3 bricks that I always wanted instead.

1019
00:37:55,840 --> 00:37:57,989
But there's other techniques we can use too.

1020
00:37:58,110 --> 00:37:59,959
So besides printF and debug,

1021
00:38:00,010 --> 00:38:03,260
you might wonder why we have a 7 ft duck behind me here,

1022
00:38:03,389 --> 00:38:04,979
all of these little rubber ducks on the floor.

1023
00:38:05,030 --> 00:38:07,820
So rubber duck debugging per week zero is actually a thing.

1024
00:38:08,159 --> 00:38:09,979
This was popularized in a book some years ago,

1025
00:38:10,010 --> 00:38:12,040
and the idea is that when you are facing some bugs,

1026
00:38:12,110 --> 00:38:13,340
some mistake in your program,

1027
00:38:13,469 --> 00:38:15,260
or you're just confused on some concept,

1028
00:38:15,590 --> 00:38:20,830
there is anecdotal evidence to suggest that just talking out the problem with an.

1029
00:38:20,975 --> 00:38:23,245
An inanimate object like a rubber duck on your

1030
00:38:23,245 --> 00:38:26,205
desk is enough often for that proverbial light bulb

1031
00:38:26,205 --> 00:38:28,354
to go off over your head because you hear

1032
00:38:28,354 --> 00:38:30,955
in your own words what confusion you're having,

1033
00:38:31,084 --> 00:38:32,754
what illogical thoughts you're having,

1034
00:38:32,804 --> 00:38:36,754
and you don't even need another human or TA or AI in the room

1035
00:38:36,965 --> 00:38:38,245
to answer the problem for you.

1036
00:38:38,314 --> 00:38:38,754
So in fact,

1037
00:38:38,764 --> 00:38:40,284
on the way out today at the end of class,

1038
00:38:40,364 --> 00:38:43,125
we've got hundreds of ducks and enough for everyone to take home

1039
00:38:43,125 --> 00:38:45,604
with you if you'd like to use that as another debugging technique,

1040
00:38:45,645 --> 00:38:46,064
whether in

1041
00:38:46,219 --> 00:38:47,209
50 or something else,

1042
00:38:47,379 --> 00:38:48,899
but of course now in the age of AI,

1043
00:38:48,909 --> 00:38:55,610
you also have the AI powered virtual duck at CS50.AI and also in VS code at CS50.dev,

1044
00:38:55,820 --> 00:38:58,580
which really is a mechanism for asking questions that

1045
00:38:58,580 --> 00:39:01,060
you don't think you can solve on your own.

1046
00:39:01,139 --> 00:39:04,179
So it might be reasonable to ask the duck what does this

1047
00:39:04,179 --> 00:39:07,290
error message mean if you're having trouble wrapping your mind around it,

1048
00:39:07,500 --> 00:39:11,139
but it's less reasonable to say copy paste your code into the duck and say.

1049
00:39:11,245 --> 00:39:12,385
What's wrong with my code?

1050
00:39:12,594 --> 00:39:14,395
You should really be meeting the AI halfway.

1051
00:39:14,475 --> 00:39:14,834
After all,

1052
00:39:14,915 --> 00:39:16,614
what's the point of actually doing this or any

1053
00:39:16,614 --> 00:39:18,915
other class is to develop that muscle memory,

1054
00:39:19,155 --> 00:39:20,195
develop those mental models,

1055
00:39:20,274 --> 00:39:21,594
get some practical skills.

1056
00:39:21,754 --> 00:39:24,745
So try hard to walk that line between asking the duck

1057
00:39:24,745 --> 00:39:27,824
too much versus deploying some of these same tools yourself,

1058
00:39:27,885 --> 00:39:29,034
print FDbug 50,

1059
00:39:29,074 --> 00:39:31,304
even a physical rubber duck on your desk

1060
00:39:31,665 --> 00:39:34,064
before you resort to sort of escalating it to

1061
00:39:34,274 --> 00:39:36,225
human-like or duck help.

1062
00:39:36,610 --> 00:39:36,629
All right,

1063
00:39:37,760 --> 00:39:41,429
so with those tools added to one's tool kit,

1064
00:39:41,719 --> 00:39:44,280
let's actually consider and reveal what's been going

1065
00:39:44,280 --> 00:39:46,550
on underneath the hood since last week.

1066
00:39:46,760 --> 00:39:49,239
So this was the mental model we proposed for last week,

1067
00:39:49,280 --> 00:39:51,500
whereby when you write source code in a language like C,

1068
00:39:52,040 --> 00:39:55,000
it's not something that the computer itself understands natively

1069
00:39:55,000 --> 00:39:57,479
because computers we saw only understand zeros and ones,

1070
00:39:57,639 --> 00:39:59,070
AKA machine code.

1071
00:39:59,280 --> 00:40:03,830
So the compiler is the program that we use to convert your source code.

1072
00:40:04,080 --> 00:40:08,270
To the machine's code from C to zeros in 1 in this case.

1073
00:40:08,350 --> 00:40:08,709
More generally,

1074
00:40:08,719 --> 00:40:11,860
a compiler is just a program that translates one language to another,

1075
00:40:11,909 --> 00:40:14,939
and in this case we're going from source code to machine code.

1076
00:40:15,149 --> 00:40:16,879
So let's consider what's really happening.

1077
00:40:16,909 --> 00:40:19,699
And indeed this is among the goals of this week is to take

1078
00:40:19,699 --> 00:40:23,469
a look at a lower level so that when you encounter more interesting,

1079
00:40:23,550 --> 00:40:24,550
more challenging problems,

1080
00:40:24,590 --> 00:40:27,590
you'll understand from so-called first principles what the

1081
00:40:27,590 --> 00:40:29,510
computer is actually doing and supposed to do.

1082
00:40:29,699 --> 00:40:34,169
So you can deductively figure things out for yourself and generally not

1083
00:40:34,169 --> 00:40:37,290
view computers as like magic or I don't know how this works.

1084
00:40:37,409 --> 00:40:40,360
You'll have a fairly bottom up sense of how

1085
00:40:40,360 --> 00:40:43,840
everything works by term's end inside of any computer,

1086
00:40:43,929 --> 00:40:44,300
laptop,

1087
00:40:44,370 --> 00:40:44,840
desktop,

1088
00:40:44,889 --> 00:40:45,139
phone,

1089
00:40:45,250 --> 00:40:46,479
or the like these days.

1090
00:40:46,689 --> 00:40:49,000
So here's the simplest of programs that we wrote last week,

1091
00:40:49,010 --> 00:40:52,080
even though there's a lot of syntactic complexity as we've seen.

1092
00:40:52,250 --> 00:40:54,330
The goal is to get it to machine code.

1093
00:40:54,449 --> 00:40:55,169
These here zero.

1094
00:40:55,320 --> 00:40:56,030
And ones.

1095
00:40:56,189 --> 00:41:00,979
So how has that been happening when you just run Make since last week?

1096
00:41:01,189 --> 00:41:01,389
Well,

1097
00:41:01,709 --> 00:41:03,389
these are the two commands that we've typically

1098
00:41:03,389 --> 00:41:05,790
run after creating a file like hello.c.

1099
00:41:06,070 --> 00:41:09,820
We then compile with Make hello and then we run it with hello.

1100
00:41:10,030 --> 00:41:13,580
So let's give ourselves this starting point real quick just so that we have

1101
00:41:13,870 --> 00:41:17,219
an example in mind of exactly what it is we're compiling.

1102
00:41:17,320 --> 00:41:19,100
So let me go back to VS code here.

1103
00:41:19,389 --> 00:41:20,590
Close out buggy.c.

1104
00:41:21,229 --> 00:41:25,219
And let's create a new file just like last week called hello.c

1105
00:41:25,219 --> 00:41:29,179
inside of which is our old friend Standardio.h in Main void,

1106
00:41:29,189 --> 00:41:31,129
and then inside of this we'll keep it simple,

1107
00:41:31,379 --> 00:41:33,260
just printing out hello world,

1108
00:41:33,419 --> 00:41:35,489
which again is my source code in C.

1109
00:41:35,820 --> 00:41:38,459
How do I now actually compile that?

1110
00:41:38,580 --> 00:41:38,699
Well,

1111
00:41:38,780 --> 00:41:41,570
of course I can go down to my terminal window,

1112
00:41:41,739 --> 00:41:43,750
make hello hello,

1113
00:41:43,899 --> 00:41:44,739
and we're off and running.

1114
00:41:45,409 --> 00:41:47,320
So it was a bit of a white lie for me to let

1115
00:41:47,320 --> 00:41:51,110
you think though that last week the compiler itself is called Make.

1116
00:41:51,360 --> 00:41:52,429
Make is a command

1117
00:41:52,639 --> 00:41:54,270
that literally makes your program.

1118
00:41:54,399 --> 00:41:55,929
It makes it by compiling it,

1119
00:41:55,979 --> 00:41:57,729
but make is not technically the compiler.

1120
00:41:57,739 --> 00:41:59,469
If we really want to get nitpicky,

1121
00:41:59,560 --> 00:42:04,000
the compiler you've been using is actually called Clang for C language,

1122
00:42:04,080 --> 00:42:06,000
and this is a very popular compiler freely.

1123
00:42:06,153 --> 00:42:06,992
All open source,

1124
00:42:07,022 --> 00:42:07,423
so to speak,

1125
00:42:07,502 --> 00:42:11,173
you can even look at the code other humans wrote to create the compiler

1126
00:42:11,623 --> 00:42:12,052
online,

1127
00:42:12,262 --> 00:42:16,772
and what Make is really doing for us is essentially automating this command.

1128
00:42:16,982 --> 00:42:21,423
So all this time I could have just run clang space hello.c,

1129
00:42:22,022 --> 00:42:22,532
but

1130
00:42:22,742 --> 00:42:25,173
the default file name from Klang,

1131
00:42:25,302 --> 00:42:26,252
the compiler,

1132
00:42:26,542 --> 00:42:26,843
we

1133
00:42:27,105 --> 00:42:29,436
and for historical reasons it's not going to be hello,

1134
00:42:29,605 --> 00:42:32,766
as you would hope it's going to be a do out for

1135
00:42:32,766 --> 00:42:36,605
assembler output and we don't do this in the first in week one

1136
00:42:36,605 --> 00:42:40,525
of the class because like this just makes things unnecessarily complex that we're

1137
00:42:40,525 --> 00:42:42,875
adding some random name that you just have to know to type.

1138
00:42:43,085 --> 00:42:43,476
However,

1139
00:42:43,565 --> 00:42:45,456
we can do this now as follows.

1140
00:42:45,525 --> 00:42:47,486
Let me go back to VS code here.

1141
00:42:48,100 --> 00:42:50,620
Let me clear my terminal and type LS and

1142
00:42:50,620 --> 00:42:53,620
we'll see everything we've created thus far buggy.c,

1143
00:42:53,860 --> 00:42:54,820
which when I compiled it,

1144
00:42:54,860 --> 00:42:55,689
I got buggy,

1145
00:42:55,899 --> 00:42:56,719
and hello.c,

1146
00:42:56,780 --> 00:42:57,379
which I just wrote,

1147
00:42:57,419 --> 00:42:58,250
and when I compiled it,

1148
00:42:58,260 --> 00:42:59,370
I got hello.

1149
00:42:59,659 --> 00:43:01,340
Let's do this command now manually though.

1150
00:43:01,500 --> 00:43:04,500
Let's use clang on hello.c and hit enter.

1151
00:43:05,010 --> 00:43:06,320
That too seems to work,

1152
00:43:06,449 --> 00:43:09,719
but if I now type LS you'll see a third program

1153
00:43:10,129 --> 00:43:11,540
specifically called A.out,

1154
00:43:11,649 --> 00:43:13,280
which happens to be the same as hello,

1155
00:43:13,330 --> 00:43:16,520
it just is using the default name instead of my custom name hello,

1156
00:43:16,689 --> 00:43:18,030
but if I do slash A.

1157
00:43:18,219 --> 00:43:18,679
out,

1158
00:43:18,889 --> 00:43:21,080
indeed that too will work.

1159
00:43:21,389 --> 00:43:26,000
But the reason we don't do that certainly in the first week of the course is that

1160
00:43:26,250 --> 00:43:29,929
things get a little annoying or sort of escalate quickly thereafter.

1161
00:43:30,010 --> 00:43:33,719
So let me go ahead and change this program as we've done a few times already.

1162
00:43:33,909 --> 00:43:35,459
Let me include CS50.

1163
00:43:35,689 --> 00:43:37,870
H so that we get access to like get string.

1164
00:43:38,060 --> 00:43:40,719
Let me do string name equals get string,

1165
00:43:40,810 --> 00:43:41,370
quote unquote.

1166
00:43:41,500 --> 00:43:42,560
What's your name?

1167
00:43:42,570 --> 00:43:43,090
question mark,

1168
00:43:43,209 --> 00:43:43,879
close quote.

1169
00:43:44,050 --> 00:43:46,120
And then down here just like before,

1170
00:43:46,330 --> 00:43:48,639
let me add my percent S and add in my name.

1171
00:43:48,729 --> 00:43:49,840
So I did that super quickly,

1172
00:43:49,969 --> 00:43:51,610
but it's the same program we wrote a few minutes

1173
00:43:51,610 --> 00:43:53,760
ago and it's the same one we wrote last week.

1174
00:43:54,169 --> 00:43:58,120
What happens now though is as follows if I now try to do clang,

1175
00:43:58,409 --> 00:44:00,320
hello.c enter,

1176
00:44:00,570 --> 00:44:01,449
I actually get.

1177
00:44:01,620 --> 00:44:02,770
An error message,

1178
00:44:02,800 --> 00:44:04,879
this one perhaps more cryptic than most.

1179
00:44:05,330 --> 00:44:09,800
Somehow or other I have this error Linker command failed with exit code one

1180
00:44:10,090 --> 00:44:13,120
because of an undefined reference to get string.

1181
00:44:13,419 --> 00:44:15,530
Now in the past when we've seen undefined

1182
00:44:15,530 --> 00:44:18,000
or really undeclared mentions of get string,

1183
00:44:18,090 --> 00:44:20,080
the problem was just with missing this line.

1184
00:44:20,250 --> 00:44:21,600
This line is clearly here.

1185
00:44:21,979 --> 00:44:24,639
But the catch is I'm getting this error message

1186
00:44:24,639 --> 00:44:27,360
now because when I run clang of hello.c,

1187
00:44:27,919 --> 00:44:33,719
I'm just assuming that lang knows where to find the CS50 version of Get string,

1188
00:44:33,760 --> 00:44:35,550
and that is not the case.

1189
00:44:35,959 --> 00:44:36,750
Technically,

1190
00:44:36,919 --> 00:44:40,629
if I want the compiler to compile this code for me,

1191
00:44:40,800 --> 00:44:42,459
what I'm actually going to have to do

1192
00:44:42,959 --> 00:44:43,790
is this.

1193
00:44:44,080 --> 00:44:49,040
Let me go back to uh my terminal window here and I'm gonna say clang.

1194
00:44:49,860 --> 00:44:51,300
Hello.c,

1195
00:44:51,659 --> 00:44:53,139
but I'm then going to specify

1196
00:44:53,659 --> 00:44:54,739
LCS 50,

1197
00:44:54,820 --> 00:44:56,330
which is cryptic at first glance,

1198
00:44:56,580 --> 00:44:58,330
but this is telling the compiler

1199
00:44:58,659 --> 00:45:03,010
to link in the CS 50 library so that it knows what

1200
00:45:03,010 --> 00:45:06,449
the zeros and ones are that belong to the get string function.

1201
00:45:06,739 --> 00:45:07,350
Long story short,

1202
00:45:07,419 --> 00:45:08,449
if I hit enter now,

1203
00:45:08,659 --> 00:45:10,209
the error message has gone away.

1204
00:45:10,379 --> 00:45:11,179
If I type LS,

1205
00:45:11,219 --> 00:45:11,969
I've still got a.

1206
00:45:11,979 --> 00:45:12,330
out,

1207
00:45:12,340 --> 00:45:12,540
but it's.

1208
00:45:12,685 --> 00:45:13,675
New version thereof,

1209
00:45:13,754 --> 00:45:16,955
and if I do a out now I see the new behavior

1210
00:45:16,955 --> 00:45:20,125
where I can type in my name and see hello David.

1211
00:45:20,475 --> 00:45:22,495
Now this is getting a little stupid that I keep using A.

1212
00:45:22,715 --> 00:45:22,905
out.

1213
00:45:22,995 --> 00:45:24,504
We can change that as well.

1214
00:45:24,715 --> 00:45:25,264
In fact,

1215
00:45:25,475 --> 00:45:26,195
these commands,

1216
00:45:26,235 --> 00:45:27,155
as we're starting to see,

1217
00:45:27,354 --> 00:45:29,314
support what are called command line arguments,

1218
00:45:29,324 --> 00:45:31,594
and a lot of the programs we've run already take

1219
00:45:31,594 --> 00:45:35,715
command line arguments when we run code space hello.c,

1220
00:45:35,995 --> 00:45:38,195
the so-called command line argument.

1221
00:45:38,500 --> 00:45:40,689
To code is hello.c.

1222
00:45:40,889 --> 00:45:42,199
When I run make hello,

1223
00:45:42,409 --> 00:45:45,199
the command line argument to make is hello.

1224
00:45:45,270 --> 00:45:45,770
In other words,

1225
00:45:45,810 --> 00:45:48,850
the command line arguments to a program are all of the words

1226
00:45:48,850 --> 00:45:53,399
you're typing in your terminal after the name of the program itself,

1227
00:45:53,610 --> 00:45:56,489
whether it's make or whether it's code or any.

1228
00:45:56,570 --> 00:45:56,620
Else,

1229
00:45:57,600 --> 00:46:02,290
so this is to say what I just ran clang of hello.clCS50.

1230
00:46:02,540 --> 00:46:05,199
I was passing in two command line arguments hello.c,

1231
00:46:05,280 --> 00:46:06,469
which is the code I want to compile,

1232
00:46:06,639 --> 00:46:07,790
and dash LCS 50,

1233
00:46:07,800 --> 00:46:09,760
which means use the CS 50 library,

1234
00:46:09,840 --> 00:46:10,350
please.

1235
00:46:10,520 --> 00:46:11,989
But I can add another to the mix.

1236
00:46:12,120 --> 00:46:14,669
I can actually do something like this

1237
00:46:15,120 --> 00:46:16,429
whereby I do clang

1238
00:46:17,199 --> 00:46:18,709
oh hello,

1239
00:46:19,040 --> 00:46:20,929
then I can do hello.c.

1240
00:46:21,639 --> 00:46:24,520
And then dash LCS50 enter.

1241
00:46:24,909 --> 00:46:26,100
Now that too seems to work,

1242
00:46:26,229 --> 00:46:27,399
and if I type LS,

1243
00:46:27,629 --> 00:46:27,669
well,

1244
00:46:27,679 --> 00:46:29,110
I've got all the same programs as before.

1245
00:46:29,159 --> 00:46:31,389
So let's go ahead and get rid of those to make clear what's going on.

1246
00:46:31,429 --> 00:46:33,179
I'm going to remove a out.

1247
00:46:33,429 --> 00:46:34,899
I'm going to remove hello,

1248
00:46:35,310 --> 00:46:36,260
and just for good measure,

1249
00:46:36,270 --> 00:46:37,620
I'll remove buggy as well,

1250
00:46:37,629 --> 00:46:40,179
so that all I have left in this folder is source code.

1251
00:46:40,389 --> 00:46:41,229
So if I type LS,

1252
00:46:41,330 --> 00:46:42,500
there's my two files.

1253
00:46:42,709 --> 00:46:43,590
Let's do this again,

1254
00:46:43,669 --> 00:46:44,379
clang

1255
00:46:45,149 --> 00:46:46,219
oh hello.

1256
00:46:46,770 --> 00:46:49,639
Hello.c-LCs 50.

1257
00:46:49,969 --> 00:46:50,540
Enter.

1258
00:46:50,929 --> 00:46:52,149
Now if I type LS,

1259
00:46:52,250 --> 00:46:53,050
I don't see how a.

1260
00:46:53,060 --> 00:46:56,969
out anymore because apparently according to the documentation for Klang,

1261
00:46:57,050 --> 00:46:58,239
the actual compiler,

1262
00:46:58,409 --> 00:47:03,959
if you pass 0 as a command line argument followed by another word of your choice,

1263
00:47:04,129 --> 00:47:07,570
you can name the program anything you want without having to resort to

1264
00:47:07,570 --> 00:47:11,169
MV or clicking on it and typing a new name in manually.

1265
00:47:11,439 --> 00:47:12,919
So if I now do hello,

1266
00:47:12,989 --> 00:47:14,500
I see the exact same version

1267
00:47:14,830 --> 00:47:16,580
where it's just asking me for my name

1268
00:47:16,830 --> 00:47:17,820
and then printing it out.

1269
00:47:17,949 --> 00:47:18,669
But long story short,

1270
00:47:18,750 --> 00:47:21,070
the whole point of this exercise is that like

1271
00:47:21,070 --> 00:47:23,629
running commands like this quickly gets very tedious.

1272
00:47:23,669 --> 00:47:25,500
You have to remember like the order in which to do it,

1273
00:47:25,510 --> 00:47:26,550
what the command line argument.

1274
00:47:26,590 --> 00:47:28,620
I mean this is just stupid waste of time,

1275
00:47:28,949 --> 00:47:29,310
typically,

1276
00:47:29,389 --> 00:47:31,030
certainly in week one of the course they have to

1277
00:47:31,030 --> 00:47:33,820
memorize these kinds of magical commands to get things working.

1278
00:47:33,989 --> 00:47:34,649
But for now,

1279
00:47:34,790 --> 00:47:35,139
no,

1280
00:47:35,310 --> 00:47:36,310
that when you run make.

1281
00:47:36,419 --> 00:47:39,409
It's essentially automating all of that for you and making

1282
00:47:39,409 --> 00:47:43,090
it as simple semantically as make hello or make buggy,

1283
00:47:43,129 --> 00:47:45,520
but what's really happening is the make command,

1284
00:47:45,889 --> 00:47:49,399
because of the way we've configured CS50.dev for you,

1285
00:47:49,649 --> 00:47:51,800
is doing all of this behind the scenes.

1286
00:47:51,889 --> 00:47:52,860
It's not that magical.

1287
00:47:53,010 --> 00:47:56,199
This just means change the file name to hello when you compile it.

1288
00:47:56,449 --> 00:47:58,080
This just means compile this code,

1289
00:47:58,209 --> 00:48:01,290
and this just means use the CS 50 library.

1290
00:48:02,080 --> 00:48:02,949
Like that's all

1291
00:48:03,820 --> 00:48:06,959
But that message about linking something in,

1292
00:48:06,969 --> 00:48:11,209
there's there's something juicy going on there such that make is in fact

1293
00:48:11,209 --> 00:48:14,679
helping us sort of solve a whole bunch of problems when we compile.

1294
00:48:14,889 --> 00:48:15,250
And in fact,

1295
00:48:15,290 --> 00:48:17,929
let me propose that if we take a step back and

1296
00:48:17,929 --> 00:48:20,280
look at some of the actual code that we're compiling,

1297
00:48:20,649 --> 00:48:23,530
let's consider like what we actually mean by compiling.

1298
00:48:23,729 --> 00:48:23,850
Yes,

1299
00:48:23,889 --> 00:48:26,419
it's the case that the compiler code means to go from source code.

1300
00:48:26,739 --> 00:48:27,760
To machine code,

1301
00:48:28,010 --> 00:48:30,239
but technically there's a few more steps involved.

1302
00:48:30,610 --> 00:48:31,120
Technically,

1303
00:48:31,169 --> 00:48:32,919
when you compile your code,

1304
00:48:33,090 --> 00:48:35,050
that's sort of become the industry term of art

1305
00:48:35,050 --> 00:48:37,530
that really is referring to 4 separate processes,

1306
00:48:37,610 --> 00:48:39,919
all of which are happening in succession automatically,

1307
00:48:40,129 --> 00:48:41,850
but each of which is doing a different thing.

1308
00:48:41,929 --> 00:48:43,149
So just once,

1309
00:48:43,330 --> 00:48:45,899
let's walk through these these several steps.

1310
00:48:46,090 --> 00:48:47,840
So what is this pre-processing step?

1311
00:48:48,090 --> 00:48:51,800
So consider this program here which we wrote in brief last week.

1312
00:48:51,850 --> 00:48:53,620
We've got include standardio.H,

1313
00:48:53,770 --> 00:48:56,139
which is there because we want to be able to use print.

1314
00:48:56,392 --> 00:48:59,501
Ultimately we've then got a prototype for this meow function,

1315
00:48:59,541 --> 00:49:00,931
and the meow function does this.

1316
00:49:01,102 --> 00:49:04,142
All it does is print out quote unquote meow followed by a new line,

1317
00:49:04,382 --> 00:49:05,132
takes no input,

1318
00:49:05,501 --> 00:49:06,822
returns no return values.

1319
00:49:06,902 --> 00:49:09,072
The main function now has a 4 loop,

1320
00:49:09,172 --> 00:49:12,372
iterates 3 times each time calling the meow function,

1321
00:49:12,422 --> 00:49:14,172
and we saw this already earlier today.

1322
00:49:14,461 --> 00:49:15,552
This line of code here,

1323
00:49:15,622 --> 00:49:16,852
the so-called prototype,

1324
00:49:17,062 --> 00:49:21,291
is necessary because we need to tell the compiler that meow exists

1325
00:49:21,781 --> 00:49:23,531
before we actually use it here,

1326
00:49:23,882 --> 00:49:25,862
especially if I don't get around to implementing it.

1327
00:49:26,043 --> 00:49:26,724
Until later,

1328
00:49:26,914 --> 00:49:29,263
so this copy paste of that first line of code,

1329
00:49:29,434 --> 00:49:30,563
a so-called prototype,

1330
00:49:30,753 --> 00:49:31,983
solved that problem.

1331
00:49:32,414 --> 00:49:36,063
This is what the header files are essentially doing for us.

1332
00:49:36,513 --> 00:49:38,303
Before I use printF down here,

1333
00:49:38,434 --> 00:49:40,753
the compiler needs to know what it is,

1334
00:49:40,924 --> 00:49:41,833
what its inputs are,

1335
00:49:41,954 --> 00:49:43,104
what its outputs are.

1336
00:49:43,464 --> 00:49:49,154
Turns out the prototype for printF is going to be in standardio.H,

1337
00:49:49,303 --> 00:49:52,303
and that's what that line of code has been doing for us all this time.

1338
00:49:52,434 --> 00:49:52,674
In fact,

1339
00:49:52,714 --> 00:49:55,553
let's take a simpler example that we keep using here whereby I'm in.

1340
00:49:55,696 --> 00:49:56,446
Including CS50.

1341
00:49:56,815 --> 00:50:01,845
H and standard IO.h and I'm using the CS50 get string function to get someone's

1342
00:50:01,845 --> 00:50:04,956
name and put it in a variable called name and then I'm printing out hello,

1343
00:50:06,006 --> 00:50:06,795
such and such.

1344
00:50:07,206 --> 00:50:11,035
What's going on now when I preprocess this file by running make,

1345
00:50:11,065 --> 00:50:12,516
which in turn runs clang?

1346
00:50:12,766 --> 00:50:13,156
Well,

1347
00:50:13,365 --> 00:50:17,426
the compiler finds on the server's hard drive the file called CS50.

1348
00:50:18,395 --> 00:50:23,996
H goes inside and essentially copies and pastes its contents into my own code.

1349
00:50:24,406 --> 00:50:25,166
Meanwhile,

1350
00:50:25,909 --> 00:50:28,389
Such that we get the prototype there for get string,

1351
00:50:28,399 --> 00:50:29,310
and we haven't seen this yet,

1352
00:50:29,510 --> 00:50:31,860
but it stands to reason that all this time using printF

1353
00:50:31,860 --> 00:50:34,219
we've been passing in a prompt like what's your name?

1354
00:50:34,389 --> 00:50:36,060
and we've been getting back a string.

1355
00:50:36,270 --> 00:50:38,219
What's inside the parentheses we call is the input,

1356
00:50:38,469 --> 00:50:40,469
what's before the function name is the output,

1357
00:50:40,510 --> 00:50:41,760
the so-called return value.

1358
00:50:41,909 --> 00:50:43,290
What about standardio.h?

1359
00:50:43,350 --> 00:50:45,979
It's in that file that printF's prototype is.

1360
00:50:46,159 --> 00:50:49,820
So essentially what the compiler does when preprocessing this file

1361
00:50:49,820 --> 00:50:52,590
is it finds standard IO.h somewhere on the server's heart.

1362
00:50:52,721 --> 00:50:56,152
Drive goes inside and copy and pastes those relevant

1363
00:50:56,152 --> 00:50:58,622
lines of code into my code as well.

1364
00:50:58,832 --> 00:51:01,412
It's to avoid me having to do all of that myself,

1365
00:51:01,552 --> 00:51:02,231
find the file,

1366
00:51:02,312 --> 00:51:02,632
copy,

1367
00:51:02,672 --> 00:51:03,031
paste it,

1368
00:51:03,041 --> 00:51:04,662
or manually type out the prototype.

1369
00:51:04,872 --> 00:51:07,632
These preprocessor directives just automate all of that

1370
00:51:07,751 --> 00:51:08,291
TDM.

1371
00:51:08,592 --> 00:51:11,112
So what this effectively has at the top of my code

1372
00:51:11,112 --> 00:51:14,711
after the file has been preprocessed is all of those hash symbols

1373
00:51:15,231 --> 00:51:19,552
followed by Inclu are changed to contain the actual contents of those.

1374
00:51:19,644 --> 00:51:20,464
Header files.

1375
00:51:20,753 --> 00:51:25,303
Now the compiler knows what GitString is all about and what printF is all about.

1376
00:51:25,543 --> 00:51:27,753
That then is the preprocessing step.

1377
00:51:28,154 --> 00:51:30,224
What does compiling technically mean?

1378
00:51:30,434 --> 00:51:33,483
Compiling means taking that pre-processed code,

1379
00:51:33,583 --> 00:51:35,543
which again looks a little something like this,

1380
00:51:35,793 --> 00:51:39,063
and convert it into something called assembly code,

1381
00:51:39,184 --> 00:51:41,513
and we won't spend much time in this class on assembly code,

1382
00:51:41,593 --> 00:51:45,253
but this is how programmers used to write code before there was C,

1383
00:51:45,664 --> 00:51:46,474
before there was Python.

1384
00:51:46,565 --> 00:51:48,706
And Java and all of these other modern languages,

1385
00:51:49,035 --> 00:51:51,025
programmers were writing code like this.

1386
00:51:51,395 --> 00:51:52,385
Before this existed,

1387
00:51:52,555 --> 00:51:54,585
they were programming zeros and ones into

1388
00:51:54,585 --> 00:51:56,966
the earliest of mainframe computers using punch

1389
00:51:56,966 --> 00:52:00,385
cards and other technologies like literally sheets of paper with holes in them.

1390
00:52:00,635 --> 00:52:01,315
Not very fun,

1391
00:52:01,436 --> 00:52:02,156
very tedious,

1392
00:52:02,315 --> 00:52:03,585
so the world invented this.

1393
00:52:03,996 --> 00:52:04,966
Also not very fun,

1394
00:52:05,115 --> 00:52:05,726
very tedious,

1395
00:52:05,756 --> 00:52:07,105
so the world invented C.

1396
00:52:07,516 --> 00:52:08,206
Not that much fun,

1397
00:52:08,275 --> 00:52:10,516
so the world invented Python and so forth that we

1398
00:52:10,516 --> 00:52:12,785
continue to sort of evolve as a species with code,

1399
00:52:12,986 --> 00:52:13,446
but

1400
00:52:13,820 --> 00:52:17,169
The compiler technically takes your preprocessed source code and

1401
00:52:17,169 --> 00:52:19,560
converts it into something that looks like this cryptic,

1402
00:52:19,610 --> 00:52:20,590
and that's to be expected,

1403
00:52:20,729 --> 00:52:22,290
but there are some familiar phrases.

1404
00:52:22,370 --> 00:52:23,409
There's mention of main,

1405
00:52:23,689 --> 00:52:24,879
there's mention of get string,

1406
00:52:25,050 --> 00:52:26,560
there's mention of print F.

1407
00:52:26,570 --> 00:52:29,209
and there's a bunch of other things move and push

1408
00:52:29,209 --> 00:52:31,840
and XO and call and these other commands here.

1409
00:52:31,889 --> 00:52:33,649
These are the assembly instructions.

1410
00:52:33,810 --> 00:52:35,929
Those are the lowest level instructions that

1411
00:52:35,929 --> 00:52:38,360
the CPU inside of a computer understands.

1412
00:52:38,518 --> 00:52:40,568
CPU is the central processing unit,

1413
00:52:40,708 --> 00:52:44,417
the thing by Intel or AMD or Apple or other companies.

1414
00:52:44,748 --> 00:52:46,508
Those are the lowest level commands that the

1415
00:52:46,508 --> 00:52:49,018
actual hardware inside of the computer understand.

1416
00:52:49,228 --> 00:52:55,068
It's just nice to be able to write words like main and for and print F than it

1417
00:52:55,068 --> 00:52:59,258
would be to run these much more arcane commands that you'd have to look up in a manual.

1418
00:52:59,387 --> 00:53:03,107
So compiling just takes C code and makes it a lower.

1419
00:53:03,385 --> 00:53:06,035
Level type of code called assembly.

1420
00:53:06,246 --> 00:53:07,045
When I said a.

1421
00:53:07,226 --> 00:53:09,055
out means assembler output.

1422
00:53:09,365 --> 00:53:13,145
That's why inside of that file is essentially the output of an assembler.

1423
00:53:13,525 --> 00:53:13,726
All right,

1424
00:53:13,766 --> 00:53:14,595
we're almost there.

1425
00:53:14,766 --> 00:53:16,605
What does it mean to assemble a program,

1426
00:53:16,645 --> 00:53:19,355
which is step 3 of the compilation process?

1427
00:53:19,605 --> 00:53:22,845
That means converting assembly code to the actual

1428
00:53:22,845 --> 00:53:24,706
zeros and ones we keep talking about.

1429
00:53:24,805 --> 00:53:26,486
So if the file is called hello.c,

1430
00:53:26,825 --> 00:53:27,766
when that file is a.

1431
00:53:27,914 --> 00:53:32,533
Assembled the assembly code becomes the zeros and ones for your code in hello.

1432
00:53:32,864 --> 00:53:33,144
C,

1433
00:53:33,384 --> 00:53:36,894
but your code is not everything that composes your final program.

1434
00:53:37,184 --> 00:53:43,374
Your code from hello.c has to be combined with code from CS50's library,

1435
00:53:43,503 --> 00:53:46,343
from the standard IO library that other humans wrote.

1436
00:53:46,464 --> 00:53:48,194
I and the team wrote the CS 50 code.

1437
00:53:48,263 --> 00:53:51,214
Other humans in the world wrote the print F code and standard IO.

1438
00:53:51,424 --> 00:53:52,374
So essentially.

1439
00:53:52,612 --> 00:53:56,632
Fourth and final step is to link all of those zeros and ones together.

1440
00:53:57,062 --> 00:53:58,352
Somewhere on the server

1441
00:53:58,642 --> 00:54:00,892
there is not just the header file CS50.

1442
00:54:01,082 --> 00:54:01,731
H and Standardio.

1443
00:54:02,402 --> 00:54:02,481
H,

1444
00:54:02,842 --> 00:54:03,681
but your code,

1445
00:54:03,802 --> 00:54:04,681
hello.c,

1446
00:54:05,011 --> 00:54:07,011
our codecs50.c,

1447
00:54:07,241 --> 00:54:07,842
and

1448
00:54:08,201 --> 00:54:11,832
the code that contains ride's own implementation.

1449
00:54:12,041 --> 00:54:12,632
bit of a white lie.

1450
00:54:12,642 --> 00:54:14,892
It's technically not called standardio.C,

1451
00:54:14,951 --> 00:54:17,162
but the point remains ultimately the same.

1452
00:54:17,429 --> 00:54:20,649
So these files have already been compiled for you in advance.

1453
00:54:20,899 --> 00:54:22,010
This is your code.

1454
00:54:22,300 --> 00:54:25,550
What the assembly process does is it combines

1455
00:54:25,659 --> 00:54:27,850
all of that into zeros and 1s,

1456
00:54:27,860 --> 00:54:32,530
and then all three chunks of zeros and 1s are linked together.

1457
00:54:32,729 --> 00:54:36,620
So if you think back to when I tried compiling the code without LCS 50,

1458
00:54:36,659 --> 00:54:37,739
there was some mention of link.

1459
00:54:38,840 --> 00:54:43,389
linking just means the computer did not know how to link your code

1460
00:54:43,679 --> 00:54:47,629
with CS 50's code because we were missing LCS 50,

1461
00:54:47,760 --> 00:54:51,110
which tells the compiler to go find it somewhere on the hard drive.

1462
00:54:51,239 --> 00:54:54,159
And the final step then of linking is to combine all of

1463
00:54:54,159 --> 00:54:57,729
those zeros and ones into one bigger blob of zeros and ones,

1464
00:54:57,739 --> 00:55:02,850
and that's What's inside your Hello program that you can execute.

1465
00:55:03,179 --> 00:55:04,570
So long story short,

1466
00:55:04,939 --> 00:55:08,889
these 4 steps are what's been happening ever since the start of last week

1467
00:55:09,219 --> 00:55:09,939
pre-processing,

1468
00:55:09,979 --> 00:55:10,540
compiling,

1469
00:55:10,620 --> 00:55:11,060
assembling,

1470
00:55:11,070 --> 00:55:11,770
and linking.

1471
00:55:11,979 --> 00:55:14,290
But thankfully the world of programmers

1472
00:55:14,580 --> 00:55:18,620
generally just treats all four of these steps as what we know now as.

1473
00:55:19,439 --> 00:55:20,060
Compiling,

1474
00:55:20,199 --> 00:55:23,479
it's just a lot easier to say compile and not worry about those lower level details,

1475
00:55:23,560 --> 00:55:25,229
but that might reveal better to you

1476
00:55:25,600 --> 00:55:28,510
what all these error messages mean when you see hints of

1477
00:55:28,959 --> 00:55:30,719
this kind of terminology.

1478
00:55:32,649 --> 00:55:33,489
Questions

1479
00:55:34,199 --> 00:55:35,439
On any and all of that,

1480
00:55:35,850 --> 00:55:36,350
from here on out,

1481
00:55:36,370 --> 00:55:37,719
we're gonna go higher level than lower,

1482
00:55:37,810 --> 00:55:38,090
yeah.

1483
00:55:39,580 --> 00:55:39,649
I,

1484
00:55:39,689 --> 00:55:39,909
I,

1485
00:55:40,050 --> 00:55:43,600
I don't get the part with the like when we're talking about

1486
00:55:44,330 --> 00:55:47,090
um well I think it's the assembly process

1487
00:55:47,090 --> 00:55:48,669
when you basically convert into zeros and ones um

1488
00:55:50,169 --> 00:55:52,750
doesn't like across the multiple like the three different ones so

1489
00:55:52,750 --> 00:55:55,560
the zeros and ones signify different things like one can signify text

1490
00:55:55,560 --> 00:55:58,899
and the other can signify something else how does the computer know

1491
00:55:58,899 --> 00:56:02,090
like what part what 8 bit corresponds to like which part?

1492
00:56:02,250 --> 00:56:02,750
Really good question.

1493
00:56:02,770 --> 00:56:04,689
How does the computer know which of those zeros and

1494
00:56:04,810 --> 00:56:09,129
ones corresponds to data like numbers or strings of text or.

1495
00:56:09,445 --> 00:56:10,054
commands.

1496
00:56:10,125 --> 00:56:12,334
We're going to come back to that in week 4 of the class,

1497
00:56:12,415 --> 00:56:13,485
but long story short,

1498
00:56:13,614 --> 00:56:15,824
what we just saw on the screen is a big blob of zeros and

1499
00:56:15,895 --> 00:56:18,094
ones actually follows some pattern where the

1500
00:56:18,094 --> 00:56:21,054
bits up top represent a certain functionality.

1501
00:56:21,094 --> 00:56:22,925
The bits on the bottom represent something else,

1502
00:56:23,094 --> 00:56:24,774
and they're organized into patterns.

1503
00:56:24,854 --> 00:56:25,804
So long story short,

1504
00:56:25,814 --> 00:56:26,675
we'll come back to that,

1505
00:56:26,814 --> 00:56:27,814
but they follow conventions.

1506
00:56:27,854 --> 00:56:30,344
It's not just a hot mess of like zeros and ones.

1507
00:56:30,695 --> 00:56:31,564
Other questions.

1508
00:56:38,300 --> 00:56:38,729
Correct,

1509
00:56:38,739 --> 00:56:41,260
the pre-processing step goes into the header file

1510
00:56:41,260 --> 00:56:43,550
and essentially copies and paste the contents of

1511
00:56:43,550 --> 00:56:48,250
it into your own code so you don't have to waste time doing that manually yourself.

1512
00:56:48,459 --> 00:56:49,090
Other questions?

1513
00:56:49,260 --> 00:56:54,139
Just curiosity when you're talking about the um how it convert

1514
00:56:54,139 --> 00:56:57,699
it to assembly code and you're saying that the CPUs.

1515
00:56:58,510 --> 00:56:59,969
Commands is the CPU that

1516
00:57:00,530 --> 00:57:01,899
That into the binary

1517
00:57:02,750 --> 00:57:03,250
Uh,

1518
00:57:03,530 --> 00:57:03,699
no,

1519
00:57:03,939 --> 00:57:04,020
the,

1520
00:57:04,330 --> 00:57:06,129
so when you compile your code,

1521
00:57:06,250 --> 00:57:10,330
you're going from the uh assembly code to the zeros and ones.

1522
00:57:10,689 --> 00:57:10,850
That,

1523
00:57:11,010 --> 00:57:11,209
sorry,

1524
00:57:11,399 --> 00:57:11,520
uh,

1525
00:57:11,649 --> 00:57:12,540
when you compile,

1526
00:57:12,850 --> 00:57:13,600
let me pull up the,

1527
00:57:13,689 --> 00:57:14,409
the chart again.

1528
00:57:15,120 --> 00:57:16,909
When you compile your code,

1529
00:57:17,000 --> 00:57:20,639
you're going from the C code to the assembly code,

1530
00:57:20,959 --> 00:57:25,840
and the patterns you get when you see the assembly code are specific to a certain CPU.

1531
00:57:25,959 --> 00:57:27,010
So long story short,

1532
00:57:27,239 --> 00:57:31,639
if you're designing software for iPhones or for Android devices or Macs or PCs,

1533
00:57:31,649 --> 00:57:35,830
you're going to necessarily use a different compiler because given the same C code,

1534
00:57:36,000 --> 00:57:38,030
you will get different assembly.

1535
00:57:38,216 --> 00:57:40,645
Instructions in the output and this is why you can't

1536
00:57:40,645 --> 00:57:43,966
just take back in the day like a CD containing a

1537
00:57:43,966 --> 00:57:45,605
program from a Mac and run it on a PC

1538
00:57:45,605 --> 00:57:48,676
or vice versa because it's the wrong patterns of instructions.

1539
00:57:48,766 --> 00:57:53,275
But the reason why we have all of these annoying layers of complexity

1540
00:57:53,486 --> 00:57:56,726
is because 14 different people can now implement the notion of compiling.

1541
00:57:56,845 --> 00:57:58,385
Someone can implement the preprocessor.

1542
00:57:58,406 --> 00:57:59,595
Someone can implement the compiler,

1543
00:57:59,605 --> 00:58:00,085
the assembler,

1544
00:58:00,095 --> 00:58:00,535
the linker,

1545
00:58:00,666 --> 00:58:01,406
and you can actually collaborate.

1546
00:58:01,541 --> 00:58:04,201
By breaking things down into these quantized steps,

1547
00:58:04,572 --> 00:58:06,211
but also you can do this step,

1548
00:58:06,291 --> 00:58:06,652
this step,

1549
00:58:06,731 --> 00:58:10,892
and then two different people can write compilers to actually write to output

1550
00:58:10,892 --> 00:58:14,521
assembly code for like iPhones over here and Android devices over here,

1551
00:58:14,582 --> 00:58:17,922
but all of us can still enjoy using the same language up here.

1552
00:58:18,172 --> 00:58:20,011
So there's a lot of reasons for this complexity.

1553
00:58:20,092 --> 00:58:21,521
Just understanding it is useful,

1554
00:58:21,681 --> 00:58:24,691
but you're not going to need to use this sort of knowledge day to day.

1555
00:58:25,080 --> 00:58:26,939
But it's what enables so much of today's

1556
00:58:27,429 --> 00:58:28,540
complexity nonetheless.

1557
00:58:29,060 --> 00:58:29,149
All right,

1558
00:58:29,229 --> 00:58:31,540
so a bit of a flourish now as to

1559
00:58:31,830 --> 00:58:33,459
what we've been doing with compiling.

1560
00:58:33,629 --> 00:58:33,830
Well,

1561
00:58:33,989 --> 00:58:37,139
compiling is going ultimately from source code to machine code.

1562
00:58:37,429 --> 00:58:39,429
Couldn't you just kind of reverse the process,

1563
00:58:39,469 --> 00:58:39,550
right?

1564
00:58:39,629 --> 00:58:42,429
If someone wrote really interesting software like Microsoft

1565
00:58:42,429 --> 00:58:44,270
Word or Excel or something like that,

1566
00:58:44,469 --> 00:58:44,550
well,

1567
00:58:44,629 --> 00:58:46,120
when I buy it or download it,

1568
00:58:46,199 --> 00:58:49,189
like I literally have a copy of all of those zeros and ones,

1569
00:58:49,350 --> 00:58:50,629
couldn't I just kind of reverse this

1570
00:58:50,629 --> 00:58:53,899
process and reverse engineer someone else's code by

1571
00:58:54,250 --> 00:58:57,040
Decompiling it and this is genuinely a threat,

1572
00:58:57,070 --> 00:59:01,290
and this comes up in matters of law and intellectual property because the zeros

1573
00:59:01,290 --> 00:59:04,889
and ones have to be accessible to you and to your computer so it's not

1574
00:59:04,889 --> 00:59:08,290
a great feeling if someone with enough time and enough savvy could sort of

1575
00:59:08,290 --> 00:59:12,479
reinvent Microsoft Word by just figuring out what all those zeros and ones mean.

1576
00:59:12,689 --> 00:59:13,000
However,

1577
00:59:13,090 --> 00:59:14,889
it's sort of easier said than done to

1578
00:59:14,889 --> 00:59:18,399
reverse engineer code from these zeros and ones.

1579
00:59:18,610 --> 00:59:19,050
For instance,

1580
00:59:19,129 --> 00:59:22,760
this pattern of bits on the screen here did what did we say last week?

1581
00:59:24,790 --> 00:59:25,260
Silly quote,

1582
00:59:25,340 --> 00:59:26,770
no normal person should be able to answer this,

1583
00:59:26,780 --> 00:59:28,139
but I did say it before.

1584
00:59:29,040 --> 00:59:30,229
These zeros and ones print what?

1585
00:59:30,889 --> 00:59:32,479
It just prints out hello world,

1586
00:59:32,520 --> 00:59:35,959
and I cannot glance at that and figure it out like off the top of my head,

1587
00:59:36,040 --> 00:59:36,550
but

1588
00:59:36,840 --> 00:59:37,750
if I know

1589
00:59:38,040 --> 00:59:39,280
what architecture,

1590
00:59:39,399 --> 00:59:42,879
what CPU this code has been compiled into and I pay attention in week

1591
00:59:42,879 --> 00:59:45,590
4 and know what the various layout of the zeros and ones are,

1592
00:59:45,760 --> 00:59:47,310
I could painstakingly

1593
00:59:47,679 --> 00:59:51,000
figure out what each of those patterns of zeros and 1 means

1594
00:59:51,000 --> 00:59:53,560
by breaking them into chunks of 8 or 16 or 30.

1595
00:59:53,800 --> 00:59:54,370
64,

1596
00:59:54,379 --> 00:59:57,270
which are common units of measure that I alluded to last week.

1597
00:59:57,479 --> 00:59:59,510
Now that's going to take a crazy amount of time

1598
00:59:59,800 --> 01:00:03,270
and the sort of presumption is that if you are smart enough

1599
01:00:03,270 --> 01:00:05,830
and capable enough and have enough free time to do that,

1600
01:00:06,000 --> 01:00:08,389
it would probably take you less time to just implement

1601
01:00:08,389 --> 01:00:10,929
Microsoft Word the normal way and just rebuild the software.

1602
01:00:10,959 --> 01:00:12,209
It's going to take you more time to go in

1603
01:00:12,209 --> 01:00:14,629
reverse than it would in the so-called forward direction,

1604
01:00:14,750 --> 01:00:16,239
but there's other subtleties as well.

1605
01:00:16,729 --> 01:00:17,870
Inside of this code

1606
01:00:18,129 --> 01:00:20,870
is not only commands like printF functions like printF,

1607
01:00:20,969 --> 01:00:22,360
but suppose that it contained a loop,

1608
01:00:22,370 --> 01:00:22,729
for instance,

1609
01:00:22,770 --> 01:00:23,530
to print meow,

1610
01:00:23,610 --> 01:00:23,810
meow,

1611
01:00:23,889 --> 01:00:24,229
meow.

1612
01:00:24,570 --> 01:00:24,649
Well,

1613
01:00:24,729 --> 01:00:26,850
we know already that you can use a for loop sometimes,

1614
01:00:26,929 --> 01:00:27,889
or you can use a while loop,

1615
01:00:27,899 --> 01:00:29,010
but they're functionally equivalent.

1616
01:00:29,030 --> 01:00:31,439
It's sort of a stylistic decision which one you use,

1617
01:00:31,570 --> 01:00:32,909
whichever one you're more comfortable with,

1618
01:00:32,969 --> 01:00:34,729
or maybe feels a little better design.

1619
01:00:35,320 --> 01:00:35,790
But

1620
01:00:36,040 --> 01:00:39,870
you can't figure out from the zeros and ones whether or not it was a Y loop

1621
01:00:39,870 --> 01:00:44,550
or a 4 loop because it just results in the same pattern of zeros and ones.

1622
01:00:44,560 --> 01:00:45,830
It's just a programmer's choice,

1623
01:00:46,000 --> 01:00:49,149
which is to say you can't even perfectly reverse engineer everything

1624
01:00:49,719 --> 01:00:51,719
because it's not going to be obvious from the zeros

1625
01:00:51,719 --> 01:00:53,959
and ones what the source code originally looked like.

1626
01:00:54,000 --> 01:00:54,469
But again,

1627
01:00:54,679 --> 01:00:58,280
the bigger deal breaker is if you have that much time and energy and savvy,

1628
01:00:58,290 --> 01:00:58,719
just like.

1629
01:00:58,845 --> 01:01:00,426
Implement Microsoft Word itself.

1630
01:01:00,595 --> 01:01:01,976
Don't try to reverse the whole process,

1631
01:01:02,035 --> 01:01:03,825
which is going to be much more painstaking

1632
01:01:04,115 --> 01:01:05,516
and time consuming instead.

1633
01:01:05,775 --> 01:01:07,226
Now this is not true for all languages,

1634
01:01:07,236 --> 01:01:08,145
and just as a teaser,

1635
01:01:08,156 --> 01:01:09,476
in a few weeks' time when we talk

1636
01:01:09,476 --> 01:01:12,186
about web programming in another language called JavaScript,

1637
01:01:12,355 --> 01:01:15,115
it turns out that JavaScript source code is

1638
01:01:15,115 --> 01:01:17,785
actually sent from web servers to web browsers,

1639
01:01:17,795 --> 01:01:21,115
and you can look at the source code of any website on the internet,

1640
01:01:21,196 --> 01:01:22,145
Harvard.edu.

1641
01:01:22,642 --> 01:01:23,541
Book.com,

1642
01:01:23,552 --> 01:01:24,602
gmail.com,

1643
01:01:24,632 --> 01:01:25,941
it's going to be there,

1644
01:01:26,231 --> 01:01:27,221
so not all languages,

1645
01:01:27,231 --> 01:01:27,711
it turns out,

1646
01:01:27,721 --> 01:01:29,541
are even compiled typically.

1647
01:01:29,951 --> 01:01:33,382
Sometimes the source code is just executed by the underlying computer.

1648
01:01:33,592 --> 01:01:35,721
So we're just scratching the surface of some of the implications

1649
01:01:35,721 --> 01:01:37,302
of all of this in a little bit of time,

1650
01:01:37,312 --> 01:01:39,592
let's take a look further under the hood at the actual memory,

1651
01:01:39,672 --> 01:01:40,691
solve some other problems,

1652
01:01:40,771 --> 01:01:42,231
but I think it's now time for Cheez It.

1653
01:01:42,312 --> 01:01:43,862
So let's go ahead and take a 10 minute break.

1654
01:01:44,271 --> 01:01:45,521
Snacks are now served.

1655
01:01:45,672 --> 01:01:46,231
See you in 10.

1656
01:01:47,320 --> 01:01:47,330
All

1657
01:01:47,949 --> 01:01:48,179
right,

1658
01:01:48,389 --> 01:01:51,189
we are back and up until now when we've been writing code,

1659
01:01:51,300 --> 01:01:55,070
recall that we have to specify like what type of value you want to put in a variable.

1660
01:01:55,129 --> 01:01:59,060
Like that's why I had to go in and add string before the word name in my first bug today.

1661
01:01:59,229 --> 01:01:59,919
But it turns out C,

1662
01:01:59,989 --> 01:02:00,949
as we've kind of seen already,

1663
01:02:00,989 --> 01:02:02,689
has a whole bunch of these data types.

1664
01:02:03,030 --> 01:02:04,189
I rattled these off last week,

1665
01:02:04,199 --> 01:02:06,899
Bull into long float double char string,

1666
01:02:07,030 --> 01:02:10,550
but we'll consider for a moment just how much space each of these things takes

1667
01:02:10,550 --> 01:02:14,830
up and see if we can help you see what the debugger was seeing earlier.

1668
01:02:14,870 --> 01:02:15,830
That is what is.

1669
01:02:16,156 --> 01:02:16,736
In memory.

1670
01:02:16,795 --> 01:02:17,595
So a bull,

1671
01:02:17,676 --> 01:02:18,206
it turns out,

1672
01:02:18,275 --> 01:02:19,466
actually takes up one bite,

1673
01:02:19,476 --> 01:02:21,236
which is kind of stupid because technically a bull,

1674
01:02:21,516 --> 01:02:22,156
true or false,

1675
01:02:22,315 --> 01:02:23,906
really only needs one bit.

1676
01:02:24,156 --> 01:02:27,835
It just turns out that it's more efficient and easier to just use a whole bite,

1677
01:02:27,845 --> 01:02:28,516
8 bits,

1678
01:02:28,635 --> 01:02:30,436
even though 7 of them are effectively unused.

1679
01:02:30,516 --> 01:02:33,385
So a bull will take up 1 bite even though it's just true and false.

1680
01:02:33,516 --> 01:02:35,196
An int recall uses 4 bytes.

1681
01:02:35,236 --> 01:02:37,525
So if you want to count really high with an int,

1682
01:02:37,555 --> 01:02:40,555
the highest you can go is roughly 4 billion we've claimed,

1683
01:02:40,676 --> 01:02:42,236
unless you want to represent negative numbers,

1684
01:02:42,275 --> 01:02:44,186
in which case the highest is like 2 billion,

1685
01:02:44,275 --> 01:02:46,922
because if Want to be able to count all the way down to -2 billion.

1686
01:02:47,001 --> 01:02:48,312
You've got to kind of split the difference.

1687
01:02:48,642 --> 01:02:50,031
A long meanwhile is twice that.

1688
01:02:50,041 --> 01:02:51,122
It uses 8 bytes,

1689
01:02:51,162 --> 01:02:54,521
which is roughly 9 quadrillion possibilities,

1690
01:02:54,622 --> 01:02:57,271
which is quite a few more than 4 billion.

1691
01:02:57,761 --> 01:03:00,112
That is if you want to include negative numbers as well.

1692
01:03:00,241 --> 01:03:03,241
Then we had floats which were real numbers with decimal points which

1693
01:03:03,241 --> 01:03:06,251
speak to just how precise you can be with significant digits.

1694
01:03:06,281 --> 01:03:08,162
A float is 4 bytes by default,

1695
01:03:08,281 --> 01:03:10,991
but a double gives you twice as many bits to play with,

1696
01:03:11,001 --> 01:03:13,122
which gets you get lets you be more precise.

1697
01:03:13,808 --> 01:03:16,728
Even though at the end of the day whether you're using floats or doubles,

1698
01:03:16,808 --> 01:03:22,087
floating point imprecision as we've seen is a fundamental problem for scientific,

1699
01:03:22,407 --> 01:03:22,728
financial,

1700
01:03:22,768 --> 01:03:26,278
and other types of computing where precision is ever so important.

1701
01:03:26,447 --> 01:03:27,288
A char meanwhile,

1702
01:03:27,367 --> 01:03:28,238
at least as we've seen it,

1703
01:03:28,248 --> 01:03:31,278
is a single byte using Asy characters specifically.

1704
01:03:31,407 --> 01:03:33,127
And then string I'll put as a question mark

1705
01:03:33,127 --> 01:03:35,197
because a string totally depends on its length.

1706
01:03:35,327 --> 01:03:36,758
If you're storing high,

1707
01:03:36,968 --> 01:03:38,417
that's like 12 bytes.

1708
01:03:38,447 --> 01:03:39,248
If you storing hello,

1709
01:03:39,367 --> 01:03:41,318
that's like 5 bytes and so forth.

1710
01:03:41,417 --> 01:03:41,808
So string.

1711
01:03:41,904 --> 01:03:46,364
Things depend on how many characters you actually want to store inside of them.

1712
01:03:46,533 --> 01:03:47,323
So where does this go?

1713
01:03:47,414 --> 01:03:47,493
Well,

1714
01:03:47,573 --> 01:03:49,884
here's a picture of a stick of memory,

1715
01:03:51,053 --> 01:03:51,573
a dim,

1716
01:03:51,583 --> 01:03:52,134
so to speak,

1717
01:03:52,214 --> 01:03:54,323
whereby on this stick of memory,

1718
01:03:54,333 --> 01:03:55,684
which is slid into your computer,

1719
01:03:55,733 --> 01:03:56,253
your laptop,

1720
01:03:56,333 --> 01:03:56,823
your desktop,

1721
01:03:56,864 --> 01:03:57,614
or some other device,

1722
01:03:57,803 --> 01:03:59,694
there's all these little black chips that essentially

1723
01:03:59,694 --> 01:04:02,293
contain lots of room for zeros and ones.

1724
01:04:02,323 --> 01:04:03,464
It's somehow electronic,

1725
01:04:03,614 --> 01:04:06,523
but inside of there are all of the zeros and ones that we can

1726
01:04:07,134 --> 01:04:07,964
store data in.

1727
01:04:08,134 --> 01:04:09,404
So if we kind of zoom in on this,

1728
01:04:09,454 --> 01:04:10,414
it stands to reason.

1729
01:04:10,929 --> 01:04:12,260
That for the sake of discussion,

1730
01:04:12,409 --> 01:04:14,889
if this one chip represents like 1 gigabyte,

1731
01:04:15,169 --> 01:04:16,600
1 billion bytes,

1732
01:04:16,770 --> 01:04:21,209
it stands to reason that we could slap some addresses on these bytes whereby

1733
01:04:21,209 --> 01:04:24,040
we could say this is the first byte and this is the last bite,

1734
01:04:24,090 --> 01:04:29,290
or more precisely this is by 0123 by 1 billion,

1735
01:04:29,370 --> 01:04:30,560
and it doesn't matter if it's top down,

1736
01:04:30,570 --> 01:04:30,729
left,

1737
01:04:30,770 --> 01:04:31,239
right,

1738
01:04:31,469 --> 01:04:35,159
or any other order we're just talking about this conceptually at the moment.

1739
01:04:35,290 --> 01:04:35,610
So in fact,

1740
01:04:35,689 --> 01:04:38,010
let's go ahead and draw this really as a grid of memory,

1741
01:04:38,050 --> 01:04:39,050
a sort of canvas that we.

1742
01:04:39,169 --> 01:04:42,360
Just use to store types of data like bows

1743
01:04:42,360 --> 01:04:44,750
and ins and jars and floats and everything else.

1744
01:04:44,959 --> 01:04:47,360
If we are going to use 1 bye to store like a char,

1745
01:04:47,679 --> 01:04:47,989
well,

1746
01:04:48,080 --> 01:04:50,600
you might use just these 8 bits up here,

1747
01:04:50,679 --> 01:04:51,800
1 bye up here.

1748
01:04:51,879 --> 01:04:52,949
If you want to store an in,

1749
01:04:53,040 --> 01:04:53,149
well,

1750
01:04:53,159 --> 01:04:53,760
that's 4,

1751
01:04:53,800 --> 01:04:57,320
you might use all 4 of these bytes necessarily contiguous.

1752
01:04:57,399 --> 01:04:59,719
You can't just choose random bits all over the place

1753
01:04:59,719 --> 01:05:01,760
when you have a 4 byte value like an in,

1754
01:05:01,939 --> 01:05:05,389
they're all going to be contiguous back to back to back in memory like this.

1755
01:05:05,479 --> 01:05:07,070
But if you've got a long or a double,

1756
01:05:07,110 --> 01:05:07,439
you might.

1757
01:05:07,560 --> 01:05:09,149
Use 8 bytes instead.

1758
01:05:09,389 --> 01:05:11,520
So truly when you store a value in memory,

1759
01:05:11,750 --> 01:05:13,620
whether it's a little number or a big number,

1760
01:05:13,790 --> 01:05:15,629
all you're doing is using some of the

1761
01:05:15,629 --> 01:05:19,100
zeros and ones physically in the computer's hardware somewhere

1762
01:05:19,389 --> 01:05:20,820
and letting it permute them,

1763
01:05:20,870 --> 01:05:24,919
turn them on and off to represent that value you're trying to store.

1764
01:05:25,290 --> 01:05:25,590
All right,

1765
01:05:25,669 --> 01:05:27,870
so let's go ahead and abstract away from the hardware though,

1766
01:05:27,949 --> 01:05:31,949
and let's just start to think of this grid of memory sort of in zoomed

1767
01:05:31,949 --> 01:05:35,860
in form and consider at a lower level what is actually being stored inside.

1768
01:05:35,949 --> 01:05:36,389
of here.

1769
01:05:36,459 --> 01:05:37,139
For instance,

1770
01:05:37,500 --> 01:05:41,540
suppose that we've got some code like this containing 3 scores on like problem sets.

1771
01:05:41,580 --> 01:05:42,899
You've got a 72 on one of them,

1772
01:05:43,100 --> 01:05:44,139
a 73 on another,

1773
01:05:44,199 --> 01:05:45,810
and a 33 on the third.

1774
01:05:45,899 --> 01:05:48,300
I've deliberately chosen our old friends 72,

1775
01:05:48,340 --> 01:05:48,820
73,

1776
01:05:48,899 --> 01:05:49,669
33,

1777
01:05:49,780 --> 01:05:51,250
which we call spell high

1778
01:05:51,540 --> 01:05:54,770
or together in the context of colors is like a shade of yellow

1779
01:05:54,770 --> 01:05:57,780
just so that we're not adding some new random numbers to the mix.

1780
01:05:57,820 --> 01:05:59,850
These are our old friends three integers.

1781
01:05:59,979 --> 01:06:00,070
Well,

1782
01:06:00,100 --> 01:06:01,139
let's use these in a program.

1783
01:06:01,179 --> 01:06:04,209
Let me go over to BS code here and let me create with code.

1784
01:06:04,709 --> 01:06:07,360
A program called scores.c that's just going to let me

1785
01:06:07,360 --> 01:06:11,040
quickly calculate my average score on my problem sets.

1786
01:06:11,159 --> 01:06:12,550
I'm going to go ahead and include,

1787
01:06:12,800 --> 01:06:13,530
as we often do,

1788
01:06:13,679 --> 01:06:14,239
standard IO.

1789
01:06:14,439 --> 01:06:15,090
H at the top.

1790
01:06:15,199 --> 01:06:16,540
I'm going to do in Main,

1791
01:06:16,709 --> 01:06:18,189
void after that,

1792
01:06:18,280 --> 01:06:19,840
and then inside of my curly braces,

1793
01:06:19,919 --> 01:06:22,129
I'm going to do exactly those sample lines of code.

1794
01:06:22,159 --> 01:06:22,760
My first.

1795
01:06:23,850 --> 01:06:26,560
was let's say a 72.

1796
01:06:26,850 --> 01:06:29,360
My second score was 73,

1797
01:06:29,449 --> 01:06:32,010
and my third score was 33.

1798
01:06:32,050 --> 01:06:33,530
So I've declared three variables,

1799
01:06:33,649 --> 01:06:35,439
one for each of my problem set scores.

1800
01:06:35,649 --> 01:06:36,919
Now let's calculate the average.

1801
01:06:37,050 --> 01:06:38,860
So print F quote unquote,

1802
01:06:39,050 --> 01:06:39,850
average colon,

1803
01:06:39,889 --> 01:06:41,010
just so I know what I'm printing.

1804
01:06:41,290 --> 01:06:45,159
And now I'm going to go ahead and use maybe percent I

1805
01:06:45,550 --> 01:06:47,189
backslash N and then

1806
01:06:47,439 --> 01:06:49,080
what I'm going to pass in is a bit of math.

1807
01:06:49,239 --> 01:06:55,750
So to compute an average it's just score 1 plus score 2 plus score 3 divided by 3,

1808
01:06:55,840 --> 01:06:57,000
and I put the scores,

1809
01:06:57,010 --> 01:06:57,560
the numerator.

1810
01:06:57,739 --> 01:07:00,889
Parentheses just like in grade school like I need to do that

1811
01:07:00,889 --> 01:07:04,239
operation first before doing the division so just like math class,

1812
01:07:04,370 --> 01:07:06,159
semicolon at the end to finish my thought.

1813
01:07:06,330 --> 01:07:07,280
Let's see how this goes.

1814
01:07:07,449 --> 01:07:11,679
Make scores enterslash scores and it would seem

1815
01:07:11,679 --> 01:07:14,280
that my average across these three problem sets

1816
01:07:14,649 --> 01:07:17,100
is 72,

1817
01:07:17,449 --> 01:07:18,040
which I,

1818
01:07:18,169 --> 01:07:18,959
which is great,

1819
01:07:19,090 --> 01:07:21,520
but I don't think that's actually

1820
01:07:22,010 --> 01:07:22,959
what I

1821
01:07:23,290 --> 01:07:23,879
want

1822
01:07:24,090 --> 01:07:24,679
here.

1823
01:07:24,810 --> 01:07:25,879
What have I done wrong?

1824
01:07:26,429 --> 01:07:27,610
It's unintentional,

1825
01:07:27,699 --> 01:07:27,979
yeah.

1826
01:07:30,469 --> 01:07:30,770
Yeah,

1827
01:07:30,909 --> 01:07:32,909
I'm kind of being a little generous with myself here.

1828
01:07:32,989 --> 01:07:34,729
I didn't really factor in my worst score,

1829
01:07:34,790 --> 01:07:35,870
so that was accidental.

1830
01:07:35,969 --> 01:07:37,260
So now let me do this correctly.

1831
01:07:37,590 --> 01:07:39,879
Make scores slash scores,

1832
01:07:39,989 --> 01:07:40,659
and now,

1833
01:07:40,949 --> 01:07:41,179
OK,

1834
01:07:41,250 --> 01:07:42,580
my average is 59,

1835
01:07:42,669 --> 01:07:42,979
but I,

1836
01:07:43,070 --> 01:07:43,860
I beg to differ.

1837
01:07:43,870 --> 01:07:44,550
I'd like to quibble.

1838
01:07:44,590 --> 01:07:45,389
My score technically,

1839
01:07:45,429 --> 01:07:48,020
I think mathematically should really be 5913.

1840
01:07:48,110 --> 01:07:50,379
I'm kind of being cheated that third of a point.

1841
01:07:50,429 --> 01:07:51,709
So what's going on here?

1842
01:07:51,790 --> 01:07:54,719
Why am I only seeing 59 and not my full grade?

1843
01:07:57,040 --> 01:07:57,649
So when

1844
01:08:00,729 --> 01:08:01,159
Perfect,

1845
01:08:01,209 --> 01:08:02,030
because I'm using integers.

1846
01:08:02,090 --> 01:08:02,850
When I divide by 3,

1847
01:08:02,929 --> 01:08:04,929
it's going to truncate everything after the decimal point,

1848
01:08:04,939 --> 01:08:07,000
which we touched on at the very end of week one,

1849
01:08:07,209 --> 01:08:09,340
which is an issue with just truncation in general.

1850
01:08:09,469 --> 01:08:10,570
So one approach to fix this,

1851
01:08:10,649 --> 01:08:13,070
I could change my percent I to F,

1852
01:08:13,169 --> 01:08:15,479
which is the format code it turns out for a float,

1853
01:08:15,489 --> 01:08:16,879
and that is what I want to print.

1854
01:08:17,009 --> 01:08:18,720
So let's see if that fix alone is enough.

1855
01:08:18,850 --> 01:08:19,779
Make scores,

1856
01:08:20,120 --> 01:08:20,729
oops,

1857
01:08:20,810 --> 01:08:21,569
it's not.

1858
01:08:21,939 --> 01:08:24,290
I got ahead of myself there and let me scroll up to the error.

1859
01:08:24,410 --> 01:08:26,000
Format specifies double,

1860
01:08:26,129 --> 01:08:28,089
but the argument has type in.

1861
01:08:28,299 --> 01:08:30,439
Turns out you can use percent F for doubles as well,

1862
01:08:30,540 --> 01:08:31,729
so that's why I'm seeing double,

1863
01:08:31,740 --> 01:08:33,990
even though I intended to float in this case.

1864
01:08:34,290 --> 01:08:35,439
So there's a problem here.

1865
01:08:35,529 --> 01:08:36,029
I,

1866
01:08:36,209 --> 01:08:40,044
the argument has Type in even though I'm passing in percent,

1867
01:08:40,575 --> 01:08:42,375
you're seeing mention of percent D here,

1868
01:08:42,455 --> 01:08:44,384
which is an alternative to percent I.

1869
01:08:44,395 --> 01:08:47,325
We typically encourage you to use percent I because I for integer,

1870
01:08:47,455 --> 01:08:49,774
but there is a that is not the solution to this

1871
01:08:49,774 --> 01:08:52,125
problem because I want my third of a point back.

1872
01:08:52,415 --> 01:08:53,935
So how could I go about fixing this?

1873
01:08:54,055 --> 01:08:54,104
Well,

1874
01:08:54,134 --> 01:08:56,924
the fundamental problem here is that I'm trying to format

1875
01:08:56,924 --> 01:08:59,955
an integer as a float or even as a double.

1876
01:09:00,214 --> 01:09:00,444
Well,

1877
01:09:00,535 --> 01:09:03,774
I need to convert these scores to floats instead,

1878
01:09:03,854 --> 01:09:04,895
so I could go in.

1879
01:09:05,209 --> 01:09:06,450
And change this to float,

1880
01:09:06,729 --> 01:09:07,620
this to float,

1881
01:09:07,850 --> 01:09:08,520
this to float,

1882
01:09:08,529 --> 01:09:08,890
and heck,

1883
01:09:08,970 --> 01:09:09,890
just to be super precise,

1884
01:09:09,930 --> 01:09:12,240
I could add a 0.0 on the end of each of them,

1885
01:09:12,430 --> 01:09:14,529
just to make super clear these are floats,

1886
01:09:14,689 --> 01:09:15,600
but there's another way,

1887
01:09:15,770 --> 01:09:16,279
I could,

1888
01:09:16,330 --> 01:09:17,259
for instance,

1889
01:09:17,850 --> 01:09:18,149
Uh,

1890
01:09:18,200 --> 01:09:23,370
simply convert my denominator to 3.0 because it turns out so

1891
01:09:23,370 --> 01:09:26,640
long as you involve like one float in your math,

1892
01:09:26,879 --> 01:09:28,609
the whole thing is going to get promoted,

1893
01:09:28,649 --> 01:09:29,120
so to speak,

1894
01:09:29,160 --> 01:09:31,299
to floating point values instead of integers.

1895
01:09:31,370 --> 01:09:32,720
I don't have to convert all of them.

1896
01:09:32,890 --> 01:09:34,720
So I think now if I do make scores,

1897
01:09:34,810 --> 01:09:36,359
scores now,

1898
01:09:36,490 --> 01:09:36,879
ah,

1899
01:09:37,000 --> 01:09:38,819
there's my third of a percent,

1900
01:09:39,529 --> 01:09:41,240
the third of a point back.

1901
01:09:41,609 --> 01:09:43,410
There's another way to do this just as an aside,

1902
01:09:43,450 --> 01:09:43,770
and we'll see.

1903
01:09:43,859 --> 01:09:48,189
This again down the line if you really want to stick with 3 because it's a little weird

1904
01:09:48,411 --> 01:09:51,689
just semantically to divide by 3.0,

1905
01:09:51,810 --> 01:09:53,189
like that's an implementation detail,

1906
01:09:53,210 --> 01:09:55,561
but you're truly computing an average of 3 things.

1907
01:09:55,730 --> 01:09:59,130
You can technically cast the 3 to a float

1908
01:09:59,411 --> 01:10:02,130
in parentheses you can specify the data type that

1909
01:10:02,130 --> 01:10:04,681
you want to convert another data type to,

1910
01:10:05,050 --> 01:10:07,681
and this too should make the compiler happy.

1911
01:10:07,931 --> 01:10:08,411
A ha,

1912
01:10:08,581 --> 01:10:09,530
scores.

1913
01:10:09,570 --> 01:10:09,891
I get.

1914
01:10:10,021 --> 01:10:11,021
Roughly the same answer.

1915
01:10:11,091 --> 01:10:13,722
We're seeing some floating point in precision though nonetheless,

1916
01:10:13,972 --> 01:10:15,521
but that too would achieve

1917
01:10:15,812 --> 01:10:16,682
the goal here.

1918
01:10:16,812 --> 01:10:17,722
But a short,

1919
01:10:17,852 --> 01:10:21,762
that's all just a function of floating point arithmetic there.

1920
01:10:21,932 --> 01:10:24,392
So what's going on now actually in

1921
01:10:24,611 --> 01:10:25,571
the computer's memory?

1922
01:10:25,651 --> 01:10:28,441
Let me revert back to the simpler one with just 00 there

1923
01:10:28,441 --> 01:10:31,401
and let me propose that we consider where these three things are

1924
01:10:31,611 --> 01:10:32,142
in memory.

1925
01:10:32,211 --> 01:10:32,332
Well,

1926
01:10:32,372 --> 01:10:35,202
if we treat this as my grid or canvas of memory,

1927
01:10:35,452 --> 01:10:36,643
who knows where they're End up,

1928
01:10:36,652 --> 01:10:37,573
but for the sake of discussion,

1929
01:10:37,652 --> 01:10:41,053
let's assume that 72 ended up in the top left of my computer's memory.

1930
01:10:41,252 --> 01:10:42,522
I've drawn it to scale,

1931
01:10:42,612 --> 01:10:43,143
so to speak,

1932
01:10:43,373 --> 01:10:48,183
and that this score 1 variable is clearly taking up 4 bytes of memory,

1933
01:10:48,252 --> 01:10:48,942
and it's an inch,

1934
01:10:48,962 --> 01:10:51,893
and that's typically how many bytes are used on systems.

1935
01:10:52,062 --> 01:10:54,083
Technically it depends on the exact system you're using,

1936
01:10:54,163 --> 01:10:56,933
but nowadays it's pretty reasonable to assume that an

1937
01:10:56,933 --> 01:11:00,172
integer will be 32 bits on most modern systems.

1938
01:11:00,333 --> 01:11:02,013
Score 2 is probably over there so.

1939
01:11:02,374 --> 01:11:03,883
Score 3 is probably over there,

1940
01:11:04,014 --> 01:11:06,043
so I'm using 12 bytes total,

1941
01:11:06,173 --> 01:11:08,613
4 bytes for each of these values.

1942
01:11:08,804 --> 01:11:08,894
All right,

1943
01:11:08,974 --> 01:11:11,043
so that's really all that's going on underneath the hood.

1944
01:11:11,213 --> 01:11:12,374
I don't have to worry about this.

1945
01:11:12,414 --> 01:11:15,213
The compiler essentially figured out for me where

1946
01:11:15,213 --> 01:11:16,883
to put all of these things in memory,

1947
01:11:17,054 --> 01:11:18,253
but what really is in memory,

1948
01:11:18,333 --> 01:11:18,454
well,

1949
01:11:18,574 --> 01:11:20,403
technically each of these variables,

1950
01:11:20,653 --> 01:11:21,293
if it's,

1951
01:11:21,374 --> 01:11:23,204
if it's composed of 32 bits,

1952
01:11:23,213 --> 01:11:26,104
is really just a pattern of literally 320s and 1s,

1953
01:11:26,113 --> 01:11:27,293
and I figured out the pattern here.

1954
01:11:27,333 --> 01:11:28,414
I crammed them all into the.

1955
01:11:28,504 --> 01:11:29,165
Space there,

1956
01:11:29,254 --> 01:11:32,455
but you see here 3 patterns of 32

1957
01:11:32,455 --> 01:11:35,645
bits which collectively compose those numbers there.

1958
01:11:35,854 --> 01:11:37,365
But let's consider design now.

1959
01:11:37,535 --> 01:11:38,765
In terms of my code,

1960
01:11:38,774 --> 01:11:40,004
this gets the job done.

1961
01:11:40,214 --> 01:11:44,524
It's not that bad or big of a deal for just calculating the average of 3 scores,

1962
01:11:44,734 --> 01:11:47,294
but this should also start to rub you the wrong

1963
01:11:47,294 --> 01:11:49,964
way this week onward when it comes to design.

1964
01:11:50,134 --> 01:11:51,055
Like this is correct,

1965
01:11:51,294 --> 01:11:54,575
especially now that I clamored back my third of a point.

1966
01:11:55,629 --> 01:11:57,220
But this is bad design

1967
01:11:57,509 --> 01:11:58,919
using the variables in this way.

1968
01:11:58,950 --> 01:12:00,580
Why might you think?

1969
01:12:01,959 --> 01:12:02,459
Yeah.

1970
01:12:06,549 --> 01:12:06,689
Yeah,

1971
01:12:07,830 --> 01:12:10,390
I'm going to have to type in each score manually with each

1972
01:12:10,390 --> 01:12:12,979
passing week when I get the 4th problem set in the 5th.

1973
01:12:13,109 --> 01:12:13,310
I mean,

1974
01:12:13,470 --> 01:12:16,220
surely people who came before us came up with a better

1975
01:12:16,220 --> 01:12:19,310
way to solve this problem than like manually create 10 variables,

1976
01:12:19,350 --> 01:12:20,109
20 variables,

1977
01:12:20,189 --> 01:12:22,140
whatever it is by the end of the semester.

1978
01:12:22,310 --> 01:12:25,390
It just feels a little sloppy and indeed that's often the

1979
01:12:25,390 --> 01:12:27,479
way to think about the quality of something is designed.

1980
01:12:27,680 --> 01:12:28,660
Think about the extreme.

1981
01:12:28,750 --> 01:12:29,430
If you don't have 3.

1982
01:12:29,496 --> 01:12:29,866
Scores,

1983
01:12:29,945 --> 01:12:31,675
but 30 or 300,

1984
01:12:31,875 --> 01:12:33,786
is this really going to be the best way to do it?

1985
01:12:33,795 --> 01:12:34,556
And if you feel like,

1986
01:12:34,636 --> 01:12:34,675
no,

1987
01:12:34,726 --> 01:12:34,795
no,

1988
01:12:34,875 --> 01:12:36,186
there's got to be a better way,

1989
01:12:36,425 --> 01:12:40,085
odds are there are certainly if the language itself is well designed.

1990
01:12:40,275 --> 01:12:43,145
So let's consider how else we might go about solving this.

1991
01:12:43,315 --> 01:12:43,395
Well,

1992
01:12:43,405 --> 01:12:46,155
it turns out we can treat our canvas of memory,

1993
01:12:46,195 --> 01:12:48,125
that grid of bytes,

1994
01:12:48,195 --> 01:12:51,395
into chunks of memory known as arrays.

1995
01:12:51,662 --> 01:12:56,012
An array is a chunk of contiguous memory back to back to back,

1996
01:12:56,262 --> 01:12:58,051
whereby if you want to store 3 things,

1997
01:12:58,142 --> 01:13:01,452
you ask the computer for a chunk of memory for 3 things.

1998
01:13:01,541 --> 01:13:02,291
If you want 30,

1999
01:13:02,301 --> 01:13:03,941
you ask for one chunk of size 30.

2000
01:13:04,102 --> 01:13:04,771
If you want even more,

2001
01:13:04,782 --> 01:13:06,861
you ask for a chunk of size 300.

2002
01:13:06,952 --> 01:13:07,872
Chunk is not a term of art.

2003
01:13:07,941 --> 01:13:11,532
I'm just using it to colloquially explain what an array actually is.

2004
01:13:11,622 --> 01:13:13,301
It's a chunk or a block of memory.

2005
01:13:13,609 --> 01:13:15,529
That is back to back to back to back.

2006
01:13:15,879 --> 01:13:17,870
So what does this mean in practice?

2007
01:13:17,959 --> 01:13:18,120
Well,

2008
01:13:18,200 --> 01:13:21,149
it means that we can introduce a little bit of new syntax and see.

2009
01:13:21,319 --> 01:13:24,589
If I want to create one variable instead of 3,

2010
01:13:24,640 --> 01:13:27,069
and certainly 1 variable instead of 30,

2011
01:13:27,399 --> 01:13:29,310
I can use syntax like this.

2012
01:13:29,560 --> 01:13:30,450
Hey compiler,

2013
01:13:30,649 --> 01:13:33,950
give me a variable called scores plural.

2014
01:13:34,270 --> 01:13:37,149
Give me room for 3 integers therein.

2015
01:13:37,279 --> 01:13:39,430
So it's a little bit of a weird syntax,

2016
01:13:39,439 --> 01:13:41,200
but you specify the type of all.

2017
01:13:41,290 --> 01:13:45,370
Of the values in the array you specify the name of the array scores in this case,

2018
01:13:45,399 --> 01:13:47,709
and I pluralized it just semantically because it makes more sense

2019
01:13:47,709 --> 01:13:50,319
than calling it score now and then in square brackets,

2020
01:13:50,399 --> 01:13:50,879
so to speak,

2021
01:13:51,080 --> 01:13:56,109
you specify how many integers you want to put into that chunk of memory.

2022
01:13:56,359 --> 01:14:01,709
So this one line of code now will essentially give me 12 bytes automatically,

2023
01:14:01,879 --> 01:14:06,040
but they'll all be referable by the name scores plural.

2024
01:14:06,399 --> 01:14:08,790
So let's go ahead and weave this into some code.

2025
01:14:09,379 --> 01:14:09,939
As follows.

2026
01:14:09,979 --> 01:14:11,370
Let me go back to VS code here,

2027
01:14:11,620 --> 01:14:12,419
clear my terminal,

2028
01:14:12,459 --> 01:14:14,299
and now let's just whip up the same kind of

2029
01:14:14,299 --> 01:14:16,709
program but get rid of these three independent variables.

2030
01:14:16,720 --> 01:14:18,839
And instead let's go ahead and just say

2031
01:14:19,060 --> 01:14:22,290
in scores plural bracket 3.

2032
01:14:22,540 --> 01:14:24,819
Now I need a way to initialize the three values,

2033
01:14:24,859 --> 01:14:25,930
but this I can do too.

2034
01:14:26,029 --> 01:14:28,240
It turns out that if I want to put 3 values in this,

2035
01:14:28,259 --> 01:14:29,700
I just need slightly new syntax.

2036
01:14:29,979 --> 01:14:33,979
I can say scores 0 equals 72 scores.

2037
01:14:34,242 --> 01:14:38,071
1 equals 73 scores 2 equals 33.

2038
01:14:38,142 --> 01:14:40,301
So it's not all that different from having three variables,

2039
01:14:40,381 --> 01:14:42,941
but now I technically have one variable and I

2040
01:14:42,941 --> 01:14:47,551
am indexing into it at different locations locations 01,

2041
01:14:47,662 --> 01:14:48,211
and 2,

2042
01:14:48,222 --> 01:14:51,751
and it's a 0 because we always in computing start counting from 0.

2043
01:14:51,941 --> 01:14:55,651
So I do scores bracket 0 is going to be my 72 problem set.

2044
01:14:55,821 --> 01:14:58,171
Scores 1 is my 73 problem set,

2045
01:14:58,182 --> 01:14:59,211
and scores 2.

2046
01:14:59,273 --> 01:15:03,034
Is my weakest my 33P sets.

2047
01:15:03,164 --> 01:15:05,224
Now my syntax down here has to change because

2048
01:15:05,224 --> 01:15:07,744
there are no more score 12 score 3 variables,

2049
01:15:07,824 --> 01:15:13,903
but there are scores 0 plus scores 1 plus and notice what VS Code is trying to do for me.

2050
01:15:13,914 --> 01:15:18,653
It's saving me some keystrokes as I type in scores and type 1 single bracket.

2051
01:15:18,863 --> 01:15:21,423
Notice it finishes my thought for me and magically puts the

2052
01:15:21,423 --> 01:15:24,224
cursor where I want it so I can put the two.

2053
01:15:24,315 --> 01:15:26,465
Right there and generally save on keystrokes,

2054
01:15:26,545 --> 01:15:27,666
but that has nothing to do with C.

2055
01:15:27,706 --> 01:15:30,695
It just has to do with VS code trying to be now helpful.

2056
01:15:30,945 --> 01:15:35,456
So I think now if I go down here and do make scores slash scores,

2057
01:15:35,625 --> 01:15:36,945
we get the same answer,

2058
01:15:37,025 --> 01:15:42,105
but it's arguably better designed because I now have one variable instead of 3,

2059
01:15:42,266 --> 01:15:43,675
let alone many more.

2060
01:15:43,746 --> 01:15:44,145
And in fact,

2061
01:15:44,186 --> 01:15:46,096
if I wanted to change the total number of scores,

2062
01:15:46,266 --> 01:15:49,226
I can just change what's in that initial square bracket.

2063
01:15:49,629 --> 01:15:51,450
So if we consider what's going on now,

2064
01:15:51,620 --> 01:15:53,490
if we look at the computer's memory,

2065
01:15:53,620 --> 01:15:54,950
it's the same exact layout,

2066
01:15:55,140 --> 01:15:56,979
but there's no more 3 variable names.

2067
01:15:57,060 --> 01:15:59,069
There's one scores 0,

2068
01:15:59,180 --> 01:16:00,229
scores 1,

2069
01:16:00,459 --> 01:16:01,580
and scores 2.

2070
01:16:01,620 --> 01:16:06,649
And notice here ever more important in arrays values are indeed contiguous

2071
01:16:07,029 --> 01:16:07,459
back to.

2072
01:16:07,575 --> 01:16:08,375
Back to back.

2073
01:16:08,444 --> 01:16:09,884
Now the screen is only so wide,

2074
01:16:09,964 --> 01:16:12,685
so they kind of wrap around to the next row of bytes,

2075
01:16:12,714 --> 01:16:14,194
but the computer has no notion of up,

2076
01:16:14,205 --> 01:16:14,404
down,

2077
01:16:14,444 --> 01:16:14,604
left,

2078
01:16:14,685 --> 01:16:14,884
right.

2079
01:16:14,924 --> 01:16:17,205
I mean it's just a piece of hardware that's got lots

2080
01:16:17,205 --> 01:16:20,524
of bytes available that can be addressed from the first bite

2081
01:16:20,845 --> 01:16:22,524
all the way down to the last bite.

2082
01:16:22,535 --> 01:16:25,415
The wrapping is just a visual artifact on this here screen.

2083
01:16:26,270 --> 01:16:26,589
All right,

2084
01:16:26,790 --> 01:16:28,060
so if I've done this now,

2085
01:16:28,149 --> 01:16:29,549
maybe we can make this program a little more

2086
01:16:29,549 --> 01:16:31,549
dynamic than just hard coding in my scores.

2087
01:16:31,609 --> 01:16:32,379
Let me go in

2088
01:16:32,589 --> 01:16:36,270
and add the CS 50 header library so that we could also use,

2089
01:16:36,310 --> 01:16:36,629
for instance,

2090
01:16:36,669 --> 01:16:39,470
like get in and start getting these scores dynamically.

2091
01:16:39,560 --> 01:16:40,660
So I could do get in

2092
01:16:41,229 --> 01:16:43,540
and I could prompt the user for a score.

2093
01:16:43,750 --> 01:16:48,029
I could use get in again and I can prompt the user for another PET score.

2094
01:16:48,069 --> 01:16:49,950
I can use get into a third time.

2095
01:16:50,180 --> 01:16:52,149
And prompt the user for a third

2096
01:16:52,520 --> 01:16:53,750
such score

2097
01:16:54,080 --> 01:16:56,629
and then pretty much the rest of my code can stay the same.

2098
01:16:56,759 --> 01:16:58,419
Let's do make scores again,

2099
01:16:59,080 --> 01:17:00,660
scores 72,

2100
01:17:00,680 --> 01:17:01,430
73,

2101
01:17:01,479 --> 01:17:02,160
33,

2102
01:17:02,200 --> 01:17:03,759
and now my program's a little more interactive.

2103
01:17:03,799 --> 01:17:05,600
Like this doesn't work for just my 3 scores.

2104
01:17:05,640 --> 01:17:07,589
It can work for anyone's scores in the class.

2105
01:17:07,839 --> 01:17:09,870
Now this too hints of bad design.

2106
01:17:10,160 --> 01:17:14,430
I like my introduction of the array because I now have one variable instead of 3,

2107
01:17:14,879 --> 01:17:18,950
but what now might rub you the wrong way among lines 78,

2108
01:17:19,000 --> 01:17:19,640
and 9.

2109
01:17:20,410 --> 01:17:20,799
Yeah.

2110
01:17:22,080 --> 01:17:22,770
It's repetitive.

2111
01:17:22,830 --> 01:17:22,990
I mean,

2112
01:17:23,029 --> 01:17:23,830
I typed it manually,

2113
01:17:23,910 --> 01:17:27,299
but I might as well have just copied and pasted like literally the same thing.

2114
01:17:27,589 --> 01:17:30,109
So what's a candidate for fixing this?

2115
01:17:30,229 --> 01:17:32,229
Like what programming construct might clean this up,

2116
01:17:32,310 --> 01:17:32,549
yeah.

2117
01:17:34,470 --> 01:17:34,660
Yeah,

2118
01:17:34,740 --> 01:17:36,620
we could use a 4 loop or a Y loop or whatever,

2119
01:17:36,700 --> 01:17:38,100
but a 4 loop would get the job done,

2120
01:17:38,140 --> 01:17:39,430
and that's often my go to.

2121
01:17:39,459 --> 01:17:40,609
So let's do that instead.

2122
01:17:40,779 --> 01:17:45,609
Let's go under my declaration of the array and do 4 in I equals 0,

2123
01:17:45,859 --> 01:17:46,890
I less than 3,

2124
01:17:46,899 --> 01:17:47,649
I + plus,

2125
01:17:47,740 --> 01:17:49,450
which we keep seeing again and again.

2126
01:17:49,859 --> 01:17:49,890
Uh,

2127
01:17:50,029 --> 01:17:51,089
now how do I

2128
01:17:51,700 --> 01:17:53,939
index into the array at the right location?

2129
01:17:54,009 --> 01:17:54,100
Well,

2130
01:17:54,140 --> 01:17:56,129
here's where the square brackets are kind of powerful.

2131
01:17:56,299 --> 01:18:02,020
I can just say my scores array at the location I should get an in.

2132
01:18:03,419 --> 01:18:05,339
From the user as follows.

2133
01:18:05,459 --> 01:18:08,250
So now I'm using get it once inside of a loop,

2134
01:18:08,500 --> 01:18:10,500
but because I keeps getting incremented,

2135
01:18:10,580 --> 01:18:13,450
as we've done many a time now for meowing and other goals,

2136
01:18:13,620 --> 01:18:15,770
I'm putting the first one at location 0.

2137
01:18:15,899 --> 01:18:16,330
Why?

2138
01:18:16,649 --> 01:18:18,250
Because I is initialized to 0.

2139
01:18:18,379 --> 01:18:20,290
I'm putting the second one at location 1.

2140
01:18:20,500 --> 01:18:20,930
Why?

2141
01:18:21,209 --> 01:18:24,729
Because I'm going to + + or increment I on the next iteration,

2142
01:18:24,979 --> 01:18:25,979
then the next iteration.

2143
01:18:26,020 --> 01:18:30,569
So this has the ultimate effect of putting these three scores at location 01,

2144
01:18:30,979 --> 01:18:31,660
and 2.

2145
01:18:31,979 --> 01:18:34,850
Instead of me having to type all of that out manually,

2146
01:18:35,209 --> 01:18:38,000
now I don't love how I've done this still.

2147
01:18:38,049 --> 01:18:39,359
If we really want to nitpick,

2148
01:18:39,410 --> 01:18:41,120
this solves the problem correctly,

2149
01:18:41,490 --> 01:18:43,839
but it's kind of

2150
01:18:44,490 --> 01:18:46,540
got a poor design decision still.

2151
01:18:46,609 --> 01:18:48,040
It's got a magic number,

2152
01:18:48,069 --> 01:18:49,180
as people say.

2153
01:18:49,609 --> 01:18:52,479
What is the magic number here and why is it bad?

2154
01:18:53,439 --> 01:18:53,689
Yeah,

2155
01:18:53,830 --> 01:18:54,209
over here.

2156
01:18:59,609 --> 01:18:59,839
Yeah,

2157
01:19:00,240 --> 01:19:00,799
it was a little soft,

2158
01:19:00,810 --> 01:19:03,759
but I think the number 3 is hard coded in two places.

2159
01:19:03,839 --> 01:19:05,080
We've got it on line 6,

2160
01:19:05,120 --> 01:19:06,419
which is the size of the array,

2161
01:19:06,600 --> 01:19:07,930
and then again on line 7,

2162
01:19:08,000 --> 01:19:09,529
which is how many times I want to integrate.

2163
01:19:09,560 --> 01:19:11,270
But those are the exact same

2164
01:19:11,720 --> 01:19:12,509
concepts,

2165
01:19:12,759 --> 01:19:15,950
but it's on the honor system that I typed the number 3 correctly both times.

2166
01:19:16,040 --> 01:19:18,149
So I think we can fix this a little better.

2167
01:19:18,240 --> 01:19:22,149
I could do something like in N equals 3,

2168
01:19:22,439 --> 01:19:24,750
and then I could use N here

2169
01:19:25,040 --> 01:19:28,359
and then I could use N here so that now I only change it in.

2170
01:19:28,470 --> 01:19:31,180
One place if your eyes are wandering to the bottom of the program,

2171
01:19:31,259 --> 01:19:33,049
there's still a problem here

2172
01:19:33,220 --> 01:19:35,060
because I've still hard coded 01 and 2,

2173
01:19:35,100 --> 01:19:36,089
but we'll come back to that.

2174
01:19:36,259 --> 01:19:37,660
But this is arguably a little better.

2175
01:19:37,700 --> 01:19:39,129
But let's talk a little bit about style.

2176
01:19:39,410 --> 01:19:40,740
Typically when you have a con,

2177
01:19:41,339 --> 01:19:44,330
typically when you've got a variable that should not change its value,

2178
01:19:44,500 --> 01:19:47,569
we saw last week that we should declare it as constant,

2179
01:19:47,740 --> 01:19:50,379
and the trick there is to literally just write constant

2180
01:19:50,379 --> 01:19:52,589
for short in front of the type of the variable,

2181
01:19:52,779 --> 01:19:54,970
and now it should not be changeable by you,

2182
01:19:55,029 --> 01:19:55,700
by a colleague,

2183
01:19:55,779 --> 01:19:56,500
a collaborator,

2184
01:19:56,509 --> 01:19:57,180
or the like.

2185
01:19:57,560 --> 01:20:01,660
But typically too by convention stylistically to make visually

2186
01:20:01,660 --> 01:20:04,009
clear to another programmer that this is a constant,

2187
01:20:04,259 --> 01:20:07,060
it's convention also to capitalize constant,

2188
01:20:07,140 --> 01:20:10,330
so to actually use like a capital N here in all places

2189
01:20:10,700 --> 01:20:13,750
just to make clear visually that there's something

2190
01:20:13,750 --> 01:20:16,330
interesting about this variable and indeed it is a

2191
01:20:16,700 --> 01:20:18,500
constant that cannot be changed.

2192
01:20:19,049 --> 01:20:19,069
All right,

2193
01:20:19,919 --> 01:20:20,919
with that refinement,

2194
01:20:21,080 --> 01:20:23,790
I don't think we've really improved the program fundamentally.

2195
01:20:23,919 --> 01:20:26,700
I think we're going to need to do a bit more work to do this really well.

2196
01:20:26,770 --> 01:20:28,270
So I'm going to do this a little quickly,

2197
01:20:28,439 --> 01:20:31,399
but mostly to make the point that we can make this indeed more dynamic.

2198
01:20:31,439 --> 01:20:33,149
So let me hide my terminal window there.

2199
01:20:33,450 --> 01:20:36,399
Let me go ahead now and get the scores,

2200
01:20:36,410 --> 01:20:38,910
as I already am as follows here,

2201
01:20:39,359 --> 01:20:41,589
and let me go ahead and

2202
01:20:42,359 --> 01:20:43,649
uh assume

2203
01:20:43,879 --> 01:20:44,790
for the sake of

2204
01:20:45,970 --> 01:20:46,580
time.

2205
01:20:46,819 --> 01:20:50,000
That we have a function that exists already called average

2206
01:20:50,209 --> 01:20:52,319
and I simply want to pass in

2207
01:20:52,609 --> 01:20:56,359
to that average function the scores whose average I want to calculate.

2208
01:20:56,490 --> 01:20:58,609
So average does not exist off the shelf.

2209
01:20:58,729 --> 01:21:01,120
Like I can't just use an existing library for it.

2210
01:21:01,129 --> 01:21:03,120
I'm going to have to implement this thing myself,

2211
01:21:03,450 --> 01:21:04,160
but how?

2212
01:21:04,330 --> 01:21:04,609
All right,

2213
01:21:04,689 --> 01:21:04,810
well,

2214
01:21:04,850 --> 01:21:07,359
let's go ahead and do this at the top of my file.

2215
01:21:07,569 --> 01:21:08,049
I'm going to go.

2216
01:21:08,185 --> 01:21:09,015
Head and

2217
01:21:09,334 --> 01:21:12,325
compute or define a function called

2218
01:21:12,734 --> 01:21:13,765
average

2219
01:21:14,325 --> 01:21:17,444
uh that takes in what an array of

2220
01:21:17,654 --> 01:21:18,334
numbers.

2221
01:21:18,375 --> 01:21:20,044
So this syntax is going to be a bit new,

2222
01:21:20,115 --> 01:21:21,854
but the way I do this is in

2223
01:21:22,455 --> 01:21:26,334
say array bracket 0 or array sounds a little too generic.

2224
01:21:26,375 --> 01:21:27,205
Let's just call it

2225
01:21:27,535 --> 01:21:29,404
numbers for instance here.

2226
01:21:29,790 --> 01:21:35,430
So that says my average function is going to take as an argument in array of numbers.

2227
01:21:35,589 --> 01:21:38,299
This average function though should return a value too,

2228
01:21:38,750 --> 01:21:41,899
and it should return what type of value from what we've seen thus far.

2229
01:21:43,930 --> 01:21:45,439
A number of floats specifically.

2230
01:21:45,479 --> 01:21:46,279
It could be in,

2231
01:21:46,359 --> 01:21:48,950
but then I'm going to get short changed by 3 of a point potentially.

2232
01:21:49,080 --> 01:21:51,640
So I think I wanted to return a float or if you really want precision,

2233
01:21:51,680 --> 01:21:53,910
then you could return a double just to be really nitpicky,

2234
01:21:53,959 --> 01:21:55,669
but that seems excessive here.

2235
01:21:55,990 --> 01:21:56,160
All right,

2236
01:21:56,279 --> 01:21:58,229
well now inside of my average function,

2237
01:21:58,279 --> 01:21:59,680
how can I calculate the average?

2238
01:21:59,759 --> 01:21:59,839
Well,

2239
01:21:59,879 --> 01:22:01,200
this is just kind of like a math thing,

2240
01:22:01,240 --> 01:22:05,330
so I could declare a variable called sum and set it equal to 0.

2241
01:22:05,729 --> 01:22:09,890
I could then have a 4 loop inside of this function for in I gets 0,

2242
01:22:09,979 --> 01:22:11,029
I less than.

2243
01:22:11,779 --> 01:22:12,140
Huh,

2244
01:22:12,220 --> 01:22:12,299
uh,

2245
01:22:12,379 --> 01:22:13,259
I'm gonna come back to this.

2246
01:22:13,339 --> 01:22:14,410
The number of

2247
01:22:14,620 --> 01:22:16,250
numbers in the array,

2248
01:22:16,419 --> 01:22:17,870
and then I'm gonna do I plus plus,

2249
01:22:17,879 --> 01:22:21,770
and then on each iteration I'm gonna do sum equals whatever the current sum is

2250
01:22:22,060 --> 01:22:22,850
plus

2251
01:22:23,100 --> 01:22:24,839
whatever is in the numbers array

2252
01:22:25,220 --> 01:22:26,759
at that location.

2253
01:22:27,259 --> 01:22:28,270
So I'm going a little quickly,

2254
01:22:28,339 --> 01:22:31,830
but again I'm just applying the same lesson learned numbers is my array.

2255
01:22:32,399 --> 01:22:35,750
Numbers 1 means go to the I location in there,

2256
01:22:35,910 --> 01:22:37,270
but if my loop starts at 0,

2257
01:22:37,279 --> 01:22:39,669
that means go to location 0 and then 1 and then 2,

2258
01:22:39,680 --> 01:22:40,000
and heck,

2259
01:22:40,020 --> 01:22:41,520
if there's more scores in this array,

2260
01:22:41,600 --> 01:22:42,750
it's just going to keep going

2261
01:22:43,040 --> 01:22:45,310
on up from there because of the plus plus.

2262
01:22:45,560 --> 01:22:47,520
But I hesitated here for a couple of reasons,

2263
01:22:47,600 --> 01:22:48,629
so I put it to do here,

2264
01:22:48,640 --> 01:22:50,810
which is not a thing that's a note to self.

2265
01:22:51,279 --> 01:22:52,560
How far do I iterate?

2266
01:22:52,640 --> 01:22:52,720
Well,

2267
01:22:52,759 --> 01:22:54,870
if you've come into CS 150 with programming before,

2268
01:22:54,979 --> 01:22:56,540
you can usually just ask an array,

2269
01:22:56,640 --> 01:22:57,509
AKA a vector,

2270
01:22:57,520 --> 01:23:00,549
what its length is in Java and in Python and the like.

2271
01:23:00,720 --> 01:23:01,750
You can't do that in C.

2272
01:23:02,189 --> 01:23:05,410
So if I want to know what the length is of this array,

2273
01:23:05,899 --> 01:23:08,419
I've got to have the function tell me.

2274
01:23:08,459 --> 01:23:11,450
So I'm gonna to additionally propose that this average function

2275
01:23:11,700 --> 01:23:13,129
can't just take the array,

2276
01:23:13,299 --> 01:23:15,740
it's also going to have to take another argument,

2277
01:23:15,819 --> 01:23:16,970
a second input

2278
01:23:17,220 --> 01:23:20,779
for instance called length that tells me how long it is.

2279
01:23:21,000 --> 01:23:22,450
And then down here,

2280
01:23:22,540 --> 01:23:26,399
which is where we started the story when I used this so-called average function.

2281
01:23:26,819 --> 01:23:30,350
I'm gonna have to tell the average function by passing in N

2282
01:23:30,660 --> 01:23:34,620
how many numbers are in that array just because this is annoying that you

2283
01:23:34,620 --> 01:23:38,250
have to pass in not only the array but also its size separately.

2284
01:23:38,419 --> 01:23:39,890
That's the way it's done in C.

2285
01:23:40,100 --> 01:23:42,459
More recent languages have improved upon this so you can

2286
01:23:42,459 --> 01:23:44,180
just figure out what the length of the array.

2287
01:23:44,319 --> 01:23:47,100
is as we'll see in a few weeks in Python.

2288
01:23:47,390 --> 01:23:47,640
All right,

2289
01:23:47,750 --> 01:23:49,229
back to the average function at hand.

2290
01:23:49,310 --> 01:23:50,500
I think we're almost there.

2291
01:23:50,750 --> 01:23:52,859
This is a little unnecessarily verbose.

2292
01:23:53,109 --> 01:23:54,859
Recall that we can tighten this up

2293
01:23:55,310 --> 01:23:58,500
by just doing plus equals whatever is in numbers 1.

2294
01:23:58,669 --> 01:23:59,589
That's just tightening it up.

2295
01:23:59,629 --> 01:24:01,020
It's syntactic sugar,

2296
01:24:01,149 --> 01:24:01,790
so to speak.

2297
01:24:02,180 --> 01:24:03,600
And then the last thing I'm going to do in

2298
01:24:03,600 --> 01:24:06,939
my average function is what actually calculate the average.

2299
01:24:07,000 --> 01:24:07,759
So what is the average?

2300
01:24:07,830 --> 01:24:08,799
It's just the numerator,

2301
01:24:08,839 --> 01:24:13,350
like the sum of all of the scores divided by the total number of all of the scores.

2302
01:24:13,479 --> 01:24:13,560
Well,

2303
01:24:13,600 --> 01:24:14,669
I've got the sum,

2304
01:24:14,919 --> 01:24:16,839
so I think I just want to do some

2305
01:24:17,229 --> 01:24:18,509
divided by what

2306
01:24:18,720 --> 01:24:20,319
to get the actual average now.

2307
01:24:22,209 --> 01:24:22,520
Yeah.

2308
01:24:24,759 --> 01:24:28,890
Exactly sum divided by length will give me the average because the sum is the

2309
01:24:28,890 --> 01:24:30,850
numerator effectively all of the scores added

2310
01:24:30,850 --> 01:24:32,890
together and the denominator is the length.

2311
01:24:32,970 --> 01:24:35,200
How many numbers were there actually?

2312
01:24:35,410 --> 01:24:37,680
Now I can't just write this math expression here.

2313
01:24:37,890 --> 01:24:40,580
If this is going to be my function's return value,

2314
01:24:40,609 --> 01:24:42,279
and we've done this once or twice before,

2315
01:24:42,490 --> 01:24:43,250
I literally say.

2316
01:24:43,310 --> 01:24:47,299
And my average function return this value so it hands back the work.

2317
01:24:47,390 --> 01:24:49,250
I could use printF and just print it on the screen,

2318
01:24:49,379 --> 01:24:50,899
but I don't want that visual side effect.

2319
01:24:50,979 --> 01:24:53,529
I want to hand it back so that

2320
01:24:53,899 --> 01:24:55,490
on line 23

2321
01:24:55,819 --> 01:25:02,100
I can simply calculate the average of those end scores and let print F use it

2322
01:25:02,419 --> 01:25:05,580
as the value of that format code F.

2323
01:25:07,040 --> 01:25:07,410
All right,

2324
01:25:08,359 --> 01:25:08,930
uh,

2325
01:25:08,939 --> 01:25:11,609
I think we are in reasonably good shape.

2326
01:25:11,859 --> 01:25:13,709
Let me cross my fingers now

2327
01:25:13,939 --> 01:25:15,020
and hope I didn't screw this up.

2328
01:25:15,140 --> 01:25:15,870
Make scores.

2329
01:25:16,399 --> 01:25:16,970
OK,

2330
01:25:17,279 --> 01:25:18,410
slash scores,

2331
01:25:18,819 --> 01:25:20,470
how many do we want to do?

2332
01:25:20,500 --> 01:25:21,500
So we'll do 72,

2333
01:25:21,620 --> 01:25:22,180
73,

2334
01:25:22,259 --> 01:25:22,939
33,

2335
01:25:22,979 --> 01:25:23,600
enter,

2336
01:25:23,979 --> 01:25:24,850
and there is,

2337
01:25:24,859 --> 01:25:25,129
oh,

2338
01:25:25,419 --> 01:25:26,330
so close,

2339
01:25:26,939 --> 01:25:27,669
average.

2340
01:25:29,299 --> 01:25:30,330
I've had a regression.

2341
01:25:30,500 --> 01:25:33,629
I've made the same mistake again just in a different way.

2342
01:25:34,509 --> 01:25:35,859
I think I saw your hand go up.

2343
01:25:35,939 --> 01:25:36,890
Why am I getting

2344
01:25:37,259 --> 01:25:39,890
59 and I'm not getting my third of a point?

2345
01:25:46,910 --> 01:25:47,419
Yeah,

2346
01:25:47,629 --> 01:25:50,029
I in this return line on line 11 right now,

2347
01:25:50,040 --> 01:25:54,430
I'm again stupidly doing integer divided by integer that will make us

2348
01:25:54,430 --> 01:25:57,830
suffer from inte integer truncation because if you're returning an integer,

2349
01:25:57,910 --> 01:26:00,339
there's no room for the decimal point or any numbers thereafter.

2350
01:26:00,549 --> 01:26:01,589
So how do we fix this?

2351
01:26:01,669 --> 01:26:02,020
Well,

2352
01:26:02,229 --> 01:26:04,990
I could change the sum to float like that would.

2353
01:26:05,089 --> 01:26:05,600
Reasonable.

2354
01:26:05,640 --> 01:26:07,669
So then I do a float divided by the length.

2355
01:26:07,879 --> 01:26:10,680
I could do my casting trick like convert the flow,

2356
01:26:10,720 --> 01:26:14,890
the length to a float just for the sake of floating point arithmetic.

2357
01:26:15,040 --> 01:26:16,350
There's a bunch of ways to solve this,

2358
01:26:16,359 --> 01:26:17,910
but I think I'll go with this one now.

2359
01:26:18,120 --> 01:26:19,209
Let me now do make

2360
01:26:19,359 --> 01:26:21,959
scores again 72,

2361
01:26:22,000 --> 01:26:22,560
73,

2362
01:26:22,569 --> 01:26:23,330
33.

2363
01:26:23,549 --> 01:26:24,450
And now I've got,

2364
01:26:24,509 --> 01:26:26,129
albeit with some imprecision,

2365
01:26:26,339 --> 01:26:28,540
I think enough precision certainly for like a college

2366
01:26:28,540 --> 01:26:32,450
grade in this case 59.333 and so forth.

2367
01:26:32,859 --> 01:26:33,100
OK,

2368
01:26:33,259 --> 01:26:35,430
so what are the things to actually care about here?

2369
01:26:35,500 --> 01:26:37,450
So there's a decent amount of code here.

2370
01:26:37,600 --> 01:26:39,979
Most of it is sort of stuff we've seen before,

2371
01:26:40,020 --> 01:26:42,770
but the interesting parts I would propose are this.

2372
01:26:43,060 --> 01:26:46,930
When you create your own function that takes an array as input,

2373
01:26:47,140 --> 01:26:49,859
you have to take as input the length of the array.

2374
01:26:49,939 --> 01:26:52,009
You're not going to be able to figure it out correctly,

2375
01:26:52,259 --> 01:26:54,040
as in modern newer languages.

2376
01:26:54,180 --> 01:26:54,779
You also need,

2377
01:26:54,819 --> 01:26:55,020
of course,

2378
01:26:55,100 --> 01:26:56,740
to pass in the array itself.

2379
01:26:56,819 --> 01:26:58,279
How do you pass in an array?

2380
01:26:58,459 --> 01:26:58,540
Well,

2381
01:26:58,620 --> 01:26:59,970
when you're defining the function,

2382
01:27:00,100 --> 01:27:02,220
you specify the type of values in the array.

2383
01:27:02,649 --> 01:27:05,160
Whatever you want to name the array inside of this function,

2384
01:27:05,290 --> 01:27:07,370
and then you use empty square brackets like this.

2385
01:27:07,410 --> 01:27:10,080
You don't have to put in or some other number there.

2386
01:27:10,330 --> 01:27:12,250
All you need to tell the compiler is that my

2387
01:27:12,250 --> 01:27:16,200
average function is going to take some array of values,

2388
01:27:16,930 --> 01:27:17,990
specifically this many.

2389
01:27:18,089 --> 01:27:20,399
You don't put it inside the square brackets there.

2390
01:27:20,609 --> 01:27:22,049
Then when I use it now it's just.

2391
01:27:22,180 --> 01:27:25,200
The now familiar syntax when you want to index into your array,

2392
01:27:25,290 --> 01:27:27,600
that is go to location 0 or 1 or 2,

2393
01:27:27,810 --> 01:27:29,680
you just use square bracket notation here.

2394
01:27:29,810 --> 01:27:30,850
But the array itself,

2395
01:27:30,859 --> 01:27:31,379
recall,

2396
01:27:31,649 --> 01:27:34,890
was actually created in Maine when I did this line of

2397
01:27:34,890 --> 01:27:37,720
code here where I said give me an array called scores,

2398
01:27:37,930 --> 01:27:41,729
each of whose values it's going to be an in and I want this many of them.

2399
01:27:42,129 --> 01:27:44,589
And so maybe the final flourish that I'll add here

2400
01:27:45,040 --> 01:27:48,990
just to be sort of nitpicky is I keep saying that main should really go at the top,

2401
01:27:49,040 --> 01:27:49,279
fine,

2402
01:27:49,319 --> 01:27:49,990
no big deal.

2403
01:27:50,160 --> 01:27:51,839
Let me highlight my average function,

2404
01:27:52,000 --> 01:27:54,350
move it to the bottom of my file just because,

2405
01:27:54,600 --> 01:27:55,279
and then

2406
01:27:55,560 --> 01:27:58,310
And only then I'll copy and paste that first line,

2407
01:27:58,350 --> 01:27:59,509
the so-called prototype,

2408
01:27:59,759 --> 01:28:04,660
so that lang doesn't freak out by not knowing what the average function is.

2409
01:28:04,830 --> 01:28:05,580
So in short,

2410
01:28:05,830 --> 01:28:07,750
there's seemingly a bunch of complexity here,

2411
01:28:07,870 --> 01:28:11,299
but all were the only thing that's really new in this one example

2412
01:28:11,540 --> 01:28:16,180
is this is how you pass to a function in a array that already exists elsewhere,

2413
01:28:16,430 --> 01:28:17,109
not by its name,

2414
01:28:17,149 --> 01:28:18,990
but by the square brackets there.

2415
01:28:20,479 --> 01:28:20,870
OK.

2416
01:28:22,049 --> 01:28:22,959
Questions

2417
01:28:23,290 --> 01:28:25,450
on arrays or any of this new syntax,

2418
01:28:25,529 --> 01:28:25,879
yeah.

2419
01:28:30,379 --> 01:28:30,399
When did

2420
01:28:31,009 --> 01:28:31,759
the whole like

2421
01:28:32,430 --> 01:28:32,770
OK.

2422
01:28:33,490 --> 01:28:35,520
Said that we could store as a float

2423
01:28:35,930 --> 01:28:38,089
and instead of saying 3.0 is a float,

2424
01:28:38,370 --> 01:28:40,609
you just said because 3.0 is a float.

2425
01:28:40,689 --> 01:28:42,290
How does it know it's not a double?

2426
01:28:43,240 --> 01:28:43,560
Oh,

2427
01:28:43,930 --> 01:28:45,419
how does it know it's not a double?

2428
01:28:45,490 --> 01:28:46,419
So by default,

2429
01:28:46,529 --> 01:28:49,600
if you just type a number like 3.0 into your code,

2430
01:28:49,930 --> 01:28:52,319
it will be assumed to be a double

2431
01:28:52,569 --> 01:28:53,479
just because,

2432
01:28:53,810 --> 01:28:54,009
um,

2433
01:28:54,020 --> 01:28:54,930
raw values,

2434
01:28:55,009 --> 01:28:57,689
literal numbers with a decimal point will be treated by

2435
01:28:57,689 --> 01:29:01,209
the compiler as doubles and be allocated 64 bits.

2436
01:29:02,890 --> 01:29:03,149
percentage

2437
01:29:04,129 --> 01:29:04,459
Uh,

2438
01:29:04,740 --> 01:29:05,250
uh,

2439
01:29:05,259 --> 01:29:05,899
just because,

2440
01:29:05,979 --> 01:29:10,339
like the world did not need to create a new format code like percent D is not double.

2441
01:29:10,419 --> 01:29:12,109
percent D is decimal integer,

2442
01:29:12,379 --> 01:29:13,290
but don't worry about that.

2443
01:29:13,299 --> 01:29:15,169
We tend not to talk about it too much in class.

2444
01:29:15,339 --> 01:29:16,339
percent I is integer,

2445
01:29:16,459 --> 01:29:17,870
percent F is float,

2446
01:29:18,339 --> 01:29:20,209
but percent F is also double.

2447
01:29:21,100 --> 01:29:28,000
And this is not consistent because what's a long percent LLI what did I say last week?

2448
01:29:28,160 --> 01:29:30,870
percent LLI gives you a long integer.

2449
01:29:31,200 --> 01:29:32,299
It's just a mess

2450
01:29:33,160 --> 01:29:33,359
that's,

2451
01:29:33,439 --> 01:29:35,629
there's no good reason for this other than historical baggage.

2452
01:29:37,069 --> 01:29:37,310
Sure,

2453
01:29:37,470 --> 01:29:38,620
I'm not sure if that's reassuring,

2454
01:29:38,629 --> 01:29:39,060
but

2455
01:29:39,580 --> 01:29:40,060
all right,

2456
01:29:40,509 --> 01:29:41,529
so,

2457
01:29:41,870 --> 01:29:43,319
um,

2458
01:29:44,180 --> 01:29:44,189
OK,

2459
01:29:44,810 --> 01:29:47,209
let's use this knowledge for like something useful now

2460
01:29:47,209 --> 01:29:51,290
and actually tease apart what is how we can use

2461
01:29:51,290 --> 01:29:53,770
these these skills for good and to better understand

2462
01:29:53,770 --> 01:29:56,129
what's going on inside of the computer as follows.

2463
01:29:56,209 --> 01:29:58,040
Let me go over to our grid of memory

2464
01:29:58,209 --> 01:29:59,729
and this time let's not store some numbers,

2465
01:29:59,770 --> 01:30:01,490
but let's store like these three lines of code.

2466
01:30:01,589 --> 01:30:02,459
These three variables,

2467
01:30:02,540 --> 01:30:03,600
so 3 chars,

2468
01:30:03,740 --> 01:30:05,250
even though you know where this is going,

2469
01:30:05,299 --> 01:30:08,419
like this is not good design because I've got 3 stupidly named variables C1,

2470
01:30:08,479 --> 01:30:08,740
C2,

2471
01:30:08,819 --> 01:30:09,370
C3.

2472
01:30:09,419 --> 01:30:10,609
But let's make a point first.

2473
01:30:10,819 --> 01:30:12,830
The first variable's value is quote unquote h.

2474
01:30:12,939 --> 01:30:14,049
Second is I.

2475
01:30:14,229 --> 01:30:15,819
Third is exclamation point.

2476
01:30:15,859 --> 01:30:18,819
Why though am I using single quotes suddenly instead of double quotes?

2477
01:30:20,229 --> 01:30:22,580
It's a character.chars are single quotes,

2478
01:30:22,779 --> 01:30:24,359
strings are double quotes,

2479
01:30:24,379 --> 01:30:26,290
and we'll see the distinction why in a moment.

2480
01:30:26,419 --> 01:30:26,899
So for instance,

2481
01:30:26,979 --> 01:30:29,740
if this is my grid of memory and this program contains just 3 variables,

2482
01:30:29,819 --> 01:30:30,700
each of them a char,

2483
01:30:31,299 --> 01:30:33,580
odds are they'll end up like this in memory C1,

2484
01:30:33,620 --> 01:30:34,020
C2,

2485
01:30:34,029 --> 01:30:34,529
C3,

2486
01:30:34,660 --> 01:30:34,919
H.

2487
01:30:35,370 --> 01:30:38,149
assuming there's nothing else going on in my program,

2488
01:30:38,299 --> 01:30:41,439
they're just going to end up being back to back to back in this way,

2489
01:30:41,500 --> 01:30:42,529
even though it might not,

2490
01:30:42,799 --> 01:30:43,169
uh,

2491
01:30:43,259 --> 01:30:44,290
in this way.

2492
01:30:44,779 --> 01:30:45,169
So

2493
01:30:45,419 --> 01:30:46,509
what does this really mean?

2494
01:30:46,595 --> 01:30:47,625
is going on.

2495
01:30:47,665 --> 01:30:47,745
Well,

2496
01:30:47,825 --> 01:30:48,904
let's go ahead and poke around.

2497
01:30:48,984 --> 01:30:50,575
Let me go back to BS code here.

2498
01:30:50,745 --> 01:30:52,424
Let's close scores.c,

2499
01:30:52,665 --> 01:30:53,665
reopen my terminal,

2500
01:30:53,674 --> 01:30:57,654
and let's create a new program called Hi.c and just do something playful.

2501
01:30:57,904 --> 01:30:59,265
So let me include standard IO.

2502
01:30:59,464 --> 01:31:00,294
H at the top.

2503
01:31:00,464 --> 01:31:02,734
Let me do in main void after that,

2504
01:31:02,825 --> 01:31:04,064
and inside of my curly braces,

2505
01:31:04,145 --> 01:31:07,254
let's just repeat this C1 equals H in caps,

2506
01:31:07,464 --> 01:31:10,384
char C2 equals I in caps,

2507
01:31:10,404 --> 01:31:12,345
and then char C3 equals.

2508
01:31:13,319 --> 01:31:15,520
In uh in exclamation point,

2509
01:31:15,700 --> 01:31:16,350
that's all.

2510
01:31:16,799 --> 01:31:21,290
Now let's actually poke around and see what's inside the computer's memory.

2511
01:31:21,359 --> 01:31:22,390
So I could do something like this.

2512
01:31:22,399 --> 01:31:23,350
I could print F,

2513
01:31:24,040 --> 01:31:24,669
for instance,

2514
01:31:24,950 --> 01:31:25,609
C,

2515
01:31:26,520 --> 01:31:27,040
C,

2516
01:31:27,919 --> 01:31:28,379
C

2517
01:31:28,640 --> 01:31:32,149
backslash N and C turns out means character.

2518
01:31:32,319 --> 01:31:33,680
So what do I want to plug in C1,

2519
01:31:33,720 --> 01:31:34,120
C2,

2520
01:31:34,200 --> 01:31:36,200
and C3 semicolon.

2521
01:31:36,479 --> 01:31:38,020
So let's go ahead and do this.

2522
01:31:38,100 --> 01:31:42,209
Make hi enter high and voila,

2523
01:31:42,220 --> 01:31:43,899
there's my HI exclamation point.

2524
01:31:43,979 --> 01:31:44,620
There's no magic here.

2525
01:31:44,700 --> 01:31:47,009
Like I'm literally just printing out three HR variables.

2526
01:31:47,259 --> 01:31:47,890
I can,

2527
01:31:47,970 --> 01:31:49,020
I don't need the spaces.

2528
01:31:49,100 --> 01:31:51,649
If I want to get rid of those spaces between the word,

2529
01:31:51,859 --> 01:31:52,620
I can remake this,

2530
01:31:52,740 --> 01:31:53,419
make hi

2531
01:31:53,899 --> 01:31:54,339
hi,

2532
01:31:54,500 --> 01:31:55,689
and now we're back in business.

2533
01:31:57,660 --> 01:32:01,060
But here's where an understanding of types can give you a bit of power and sort.

2534
01:32:01,209 --> 01:32:02,569
Satiate some curiosity.

2535
01:32:02,740 --> 01:32:04,680
What if I change my percent C

2536
01:32:05,060 --> 01:32:05,439
to peri peri

2537
01:32:08,970 --> 01:32:09,200
peri.

2538
01:32:09,299 --> 01:32:10,029
So into into

2539
01:32:10,600 --> 01:32:10,609
into.

2540
01:32:10,620 --> 01:32:11,089
Well,

2541
01:32:12,100 --> 01:32:17,910
turns out that a char is really just a number because it's an ACI value from 0 to 255.

2542
01:32:17,939 --> 01:32:20,209
So there's nothing stopping me from telling the compiler,

2543
01:32:20,419 --> 01:32:21,629
don't print these as chars,

2544
01:32:21,720 --> 01:32:22,839
print them as integers.

2545
01:32:22,930 --> 01:32:24,029
So let's do make high

2546
01:32:24,859 --> 01:32:25,140
high,

2547
01:32:25,240 --> 01:32:25,379
E.

2548
01:32:26,290 --> 01:32:27,470
And that's a little cryptic.

2549
01:32:27,479 --> 01:32:30,879
It looks like it's saying 727,333,

2550
01:32:31,000 --> 01:32:31,470
but no,

2551
01:32:31,600 --> 01:32:33,229
let me add those spaces back

2552
01:32:33,520 --> 01:32:35,430
in between each of those placeholders.

2553
01:32:35,479 --> 01:32:37,029
Ma high again.

2554
01:32:39,240 --> 01:32:41,109
There are our old friends 72,

2555
01:32:41,149 --> 01:32:41,790
73,

2556
01:32:41,799 --> 01:32:42,799
33.

2557
01:32:42,810 --> 01:32:45,740
It is not necessary in this case to say in.

2558
01:32:46,450 --> 01:32:46,459
In

2559
01:32:48,640 --> 01:32:51,520
in because the compiler is smart enough and printF is smart enough that

2560
01:32:51,520 --> 01:32:54,000
if you hand it a value that happens to be a char,

2561
01:32:54,399 --> 01:32:56,680
it knows already it's going to be an integer essentially,

2562
01:32:56,729 --> 01:32:59,830
so you don't even need to bother explicitly casting it this way.

2563
01:33:00,040 --> 01:33:02,919
We're essentially implicitly casting it to an integer

2564
01:33:02,919 --> 01:33:05,669
by using those format codes as such.

2565
01:33:06,120 --> 01:33:06,240
All right.

2566
01:33:06,365 --> 01:33:09,075
So that just proves that what I've claimed is the case that

2567
01:33:09,075 --> 01:33:12,785
there is this equivalence between characters and numbers is actually the case

2568
01:33:13,145 --> 01:33:14,234
inside of the computer's memory.

2569
01:33:14,314 --> 01:33:16,194
So even though you're storing HI exclamation point,

2570
01:33:16,435 --> 01:33:19,455
technically you're storing three patterns of 8 bits

2571
01:33:19,455 --> 01:33:22,185
each that give you these decimal numbers 72,

2572
01:33:22,314 --> 01:33:23,075
73,

2573
01:33:23,115 --> 01:33:26,145
and 33 or specifically these patterns here.

2574
01:33:26,669 --> 01:33:27,200
All right then,

2575
01:33:27,229 --> 01:33:28,180
what is a string?

2576
01:33:28,350 --> 01:33:29,939
And this is where things get a little more interesting.

2577
01:33:30,029 --> 01:33:30,470
A string,

2578
01:33:30,479 --> 01:33:31,189
as we've used it,

2579
01:33:31,350 --> 01:33:34,270
is like a whole word or a phrase or when we started class today,

2580
01:33:34,310 --> 01:33:36,020
like a whole paragraph of text.

2581
01:33:36,229 --> 01:33:37,779
So that's multiple values.

2582
01:33:37,870 --> 01:33:39,180
Now why is that

2583
01:33:39,470 --> 01:33:40,669
interesting for us potentially?

2584
01:33:40,830 --> 01:33:40,950
Well,

2585
01:33:40,990 --> 01:33:43,459
let's go ahead and write one line of code as a string.

2586
01:33:43,589 --> 01:33:46,419
So here for instance is one line of code with a string.

2587
01:33:46,509 --> 01:33:48,580
Let's go ahead and put that into my program.

2588
01:33:48,750 --> 01:33:51,299
So I'm going to go back to VS code here and clear my terminal,

2589
01:33:51,549 --> 01:33:53,819
and I'm going to go ahead and delete all of this code

2590
01:33:54,549 --> 01:33:55,500
here for a moment.

2591
01:33:56,049 --> 01:34:01,959
And I'm going to do something like this strings equals quote unquote high with

2592
01:34:02,180 --> 01:34:03,669
with double quotes now.

2593
01:34:03,879 --> 01:34:05,560
And now just like in week one,

2594
01:34:05,600 --> 01:34:06,549
I'm going to print out

2595
01:34:06,959 --> 01:34:10,229
pers backslash N and print out the value of S.

2596
01:34:10,540 --> 01:34:11,359
Per earlier,

2597
01:34:11,680 --> 01:34:15,160
because string is technically one of our training wheels for just a few weeks,

2598
01:34:15,319 --> 01:34:17,370
I'm going to additionally include CS 50.

2599
01:34:17,600 --> 01:34:20,470
H at the top so that the compiler knows about

2600
01:34:20,640 --> 01:34:21,959
what this word is string.

2601
01:34:22,640 --> 01:34:22,879
All right,

2602
01:34:23,040 --> 01:34:24,200
let's go into the terminal.

2603
01:34:24,240 --> 01:34:25,049
Make high

2604
01:34:25,959 --> 01:34:27,149
high enter,

2605
01:34:27,439 --> 01:34:28,629
and we're back in business,

2606
01:34:28,759 --> 01:34:31,750
printing that out now as an entire string.

2607
01:34:31,919 --> 01:34:31,979
Well,

2608
01:34:32,040 --> 01:34:34,540
what's going on inside of the computer's memory this time?

2609
01:34:34,640 --> 01:34:34,759
Well,

2610
01:34:34,850 --> 01:34:37,560
I still have HI exclamation point,

2611
01:34:37,799 --> 01:34:38,830
but it's a string now.

2612
01:34:39,000 --> 01:34:39,049
Well,

2613
01:34:39,120 --> 01:34:40,799
it turns out the way that's going to be laid

2614
01:34:40,799 --> 01:34:43,520
out in the computer's memory is exactly like before.

2615
01:34:43,734 --> 01:34:44,685
There's no mention of C1,

2616
01:34:44,694 --> 01:34:45,004
C2,

2617
01:34:45,015 --> 01:34:46,444
C3 because those variables don't exist.

2618
01:34:46,535 --> 01:34:48,004
There's just one variables,

2619
01:34:48,174 --> 01:34:50,694
but it's referring to 3 bytes of memory,

2620
01:34:50,774 --> 01:34:51,524
it would seem

2621
01:34:51,774 --> 01:34:52,145
HI point,

2622
01:34:54,095 --> 01:34:55,725
and you can kind of see where this is going,

2623
01:34:55,895 --> 01:34:59,674
like a string as a spoiler turns out it's actually just what?

2624
01:35:01,970 --> 01:35:04,430
It's just going to be an array of characters,

2625
01:35:04,439 --> 01:35:06,759
hence the dots we're trying to connect today.

2626
01:35:06,919 --> 01:35:07,919
So at the moment though,

2627
01:35:08,000 --> 01:35:09,879
this is a single variables a string,

2628
01:35:10,160 --> 01:35:11,609
the value of which is HI.

2629
01:35:12,839 --> 01:35:13,359
But you know what,

2630
01:35:13,390 --> 01:35:14,910
if it is in fact an array,

2631
01:35:15,120 --> 01:35:16,919
I bet we can start playing around with our new

2632
01:35:16,919 --> 01:35:20,240
square bracket notation and see as much in our.

2633
01:35:20,354 --> 01:35:21,095
Actual code.

2634
01:35:21,185 --> 01:35:21,544
So in fact,

2635
01:35:21,625 --> 01:35:22,734
let me go ahead and do this.

2636
01:35:22,944 --> 01:35:24,174
In VS code now.

2637
01:35:24,384 --> 01:35:25,694
Let's not use percent S.

2638
01:35:25,944 --> 01:35:27,305
Let's use C,

2639
01:35:27,944 --> 01:35:28,435
C,

2640
01:35:28,665 --> 01:35:30,654
and C 3 times.

2641
01:35:30,904 --> 01:35:32,214
Then instead of just S,

2642
01:35:32,504 --> 01:35:35,915
let's print it out like it is an arrays 0,

2643
01:35:36,024 --> 01:35:37,095
S1,

2644
01:35:38,145 --> 01:35:38,584
S2.

2645
01:35:39,140 --> 01:35:40,229
Let's go back to VS code,

2646
01:35:40,339 --> 01:35:40,410
uh,

2647
01:35:40,540 --> 01:35:41,729
my terminal and BS code,

2648
01:35:41,939 --> 01:35:42,649
make high

2649
01:35:43,419 --> 01:35:45,379
high and nothing has changed,

2650
01:35:45,500 --> 01:35:46,970
but I'm printing it out now

2651
01:35:47,379 --> 01:35:50,180
one character at a time because I understand what's

2652
01:35:50,180 --> 01:35:52,930
going on underneath the hood in this case.

2653
01:35:53,149 --> 01:35:54,859
I can actually see these values now.

2654
01:35:54,939 --> 01:35:57,509
Let's go ahead and change the percent C to I

2655
01:35:57,740 --> 01:36:02,439
and at a space just so it's easier to read percent I space I space.

2656
01:36:02,759 --> 01:36:06,819
Don't need my casts in parentheses because printF is smart enough to do this for me.

2657
01:36:07,069 --> 01:36:08,870
Make high again.lahi.

2658
01:36:09,310 --> 01:36:12,189
There again is my 72 73 33.

2659
01:36:12,310 --> 01:36:12,660
However,

2660
01:36:13,109 --> 01:36:16,600
that came from the mere fact that I put in double quotes.

2661
01:36:19,430 --> 01:36:23,000
So what's really happening here is it seems that

2662
01:36:23,109 --> 01:36:26,470
a string is indeed just an array of characters.

2663
01:36:27,049 --> 01:36:30,290
But how does the computer know when doing percents

2664
01:36:30,669 --> 01:36:32,629
know what to actually print?

2665
01:36:32,750 --> 01:36:33,390
In other words,

2666
01:36:33,509 --> 01:36:35,970
it stands to reason that eventually if I've got more variables,

2667
01:36:36,069 --> 01:36:36,500
more code,

2668
01:36:36,700 --> 01:36:38,859
there's going to be other stuff in the computer's memory.

2669
01:36:39,189 --> 01:36:43,810
Why does print F know when using percent S to Stop here

2670
01:36:44,020 --> 01:36:46,250
and not just keep printing characters that are over here,

2671
01:36:46,419 --> 01:36:49,080
especially if I did have more variables and more stuff in memory.

2672
01:36:49,379 --> 01:36:49,459
Well,

2673
01:36:49,540 --> 01:36:50,490
let's take a look

2674
01:36:50,740 --> 01:36:53,100
at what's just past the end of this array.

2675
01:36:53,220 --> 01:36:58,299
Let's go back to VS code and now let's get a little crazy and add in a 4th I.

2676
01:36:58,649 --> 01:37:00,919
And even though this shouldn't exist,

2677
01:37:01,209 --> 01:37:02,839
let's do S3,

2678
01:37:02,930 --> 01:37:04,049
which even though it's the number 3,

2679
01:37:04,089 --> 01:37:05,479
it's the 4th location,

2680
01:37:07,149 --> 01:37:08,299
but H is only 3 values.

2681
01:37:08,370 --> 01:37:12,540
So let's look 1 location past the end of this array.

2682
01:37:15,600 --> 01:37:15,620
Make.

2683
01:37:16,330 --> 01:37:17,319
Interesting.

2684
01:37:17,930 --> 01:37:18,379
It seems,

2685
01:37:18,450 --> 01:37:19,600
and maybe it's just luck,

2686
01:37:19,850 --> 01:37:20,720
good or bad,

2687
01:37:20,970 --> 01:37:25,160
that the 4th bye in the computer's memory seems to be

2688
01:37:25,569 --> 01:37:26,580
a 0.

2689
01:37:26,930 --> 01:37:27,049
Well,

2690
01:37:27,129 --> 01:37:29,009
that's actually very much by design.

2691
01:37:29,049 --> 01:37:32,120
It turns out if we look a little further by convention,

2692
01:37:32,490 --> 01:37:35,359
what the compiler will do for us automatically

2693
01:37:35,649 --> 01:37:36,729
is terminate,

2694
01:37:36,810 --> 01:37:39,919
that is end any string we put in double quotes

2695
01:37:40,370 --> 01:37:42,209
with a pattern of 8.

2696
01:37:42,734 --> 01:37:45,895
er bits more succinctly it's just the number 0 because

2697
01:37:45,895 --> 01:37:47,535
if you do the math where you've got 80s,

2698
01:37:47,575 --> 01:37:50,134
it gives you zero and decimal or more

2699
01:37:50,134 --> 01:37:52,334
technically the way it's typically written is this

2700
01:37:52,334 --> 01:37:55,115
because it's not like the number 0 that we want to see on the screen.

2701
01:37:55,415 --> 01:37:59,435
Backslash 0 similar to backslash N is sort of a special escape character.

2702
01:37:59,734 --> 01:38:02,634
This just means literally 80 bits,

2703
01:38:02,774 --> 01:38:06,734
not the number 0 that you might see in a phone number or something like that.

2704
01:38:07,180 --> 01:38:08,779
So even though we said

2705
01:38:09,060 --> 01:38:12,899
strings equals high with an exclamation point,

2706
01:38:13,189 --> 01:38:14,680
seemingly 3 characters,

2707
01:38:14,870 --> 01:38:17,129
how many bytes does a string

2708
01:38:17,509 --> 01:38:20,390
of length 3 actually seem to take up in memory?

2709
01:38:21,890 --> 01:38:23,479
It's actually gonna be 4,

2710
01:38:23,729 --> 01:38:25,049
and this happens automatically.

2711
01:38:25,129 --> 01:38:27,049
That's what the double quotes are doing for you.

2712
01:38:27,089 --> 01:38:29,649
They're telling the compiler this is not just a single character,

2713
01:38:29,729 --> 01:38:31,529
this is a sequence of characters.

2714
01:38:31,770 --> 01:38:35,009
Please be sure to terminate it for me automatically

2715
01:38:35,410 --> 01:38:38,649
with a special pattern of 80 bits,

2716
01:38:38,689 --> 01:38:41,359
and that special pattern of 80 bits actually has a name.

2717
01:38:41,609 --> 01:38:42,410
It's the so called.

2718
01:38:42,790 --> 01:38:46,339
Null character or NUL for short.

2719
01:38:46,509 --> 01:38:50,089
The null character is just a bite of zero bits,

2720
01:38:50,100 --> 01:38:52,250
and it represents the end of a string.

2721
01:38:52,430 --> 01:38:53,419
You've actually seen it before,

2722
01:38:53,470 --> 01:38:54,459
if super briefly,

2723
01:38:54,669 --> 01:38:55,339
two weeks ago.

2724
01:38:55,509 --> 01:38:56,470
He was our AI chart,

2725
01:38:56,479 --> 01:38:59,660
and we focus mostly on like this column here and this column here,

2726
01:38:59,669 --> 01:39:01,700
and then we looked at the exclamation point over here,

2727
01:39:01,750 --> 01:39:03,180
but all this time over here,

2728
01:39:03,669 --> 01:39:06,140
Asky character 0 is null,

2729
01:39:06,370 --> 01:39:07,069
NUL,

2730
01:39:07,109 --> 01:39:10,669
which just means that's how you pronounce all 80 bits.

2731
01:39:10,750 --> 01:39:12,100
It's been there this whole time.

2732
01:39:13,120 --> 01:39:14,870
So why is it done this way?

2733
01:39:15,160 --> 01:39:15,319
Well,

2734
01:39:15,399 --> 01:39:19,549
how is the computer actually printing something out in memory?

2735
01:39:19,720 --> 01:39:19,839
Well,

2736
01:39:19,919 --> 01:39:21,439
it needs to know where to stop.

2737
01:39:21,549 --> 01:39:22,520
PrintF is pretty stupid.

2738
01:39:22,589 --> 01:39:23,839
Odds are inside a print up there's just

2739
01:39:23,839 --> 01:39:25,430
a loop that starts printing the first character,

2740
01:39:25,479 --> 01:39:26,029
the next character,

2741
01:39:26,089 --> 01:39:26,810
the next character,

2742
01:39:27,160 --> 01:39:29,270
and it's looking for the end of the string.

2743
01:39:29,520 --> 01:39:29,839
Why?

2744
01:39:29,919 --> 01:39:29,959
Well,

2745
01:39:30,319 --> 01:39:31,029
consider what might happen.

2746
01:39:31,240 --> 01:39:33,709
Suppose you've got a program that has not just one string,

2747
01:39:33,839 --> 01:39:34,399
but 2,

2748
01:39:34,520 --> 01:39:34,879
for instance,

2749
01:39:35,040 --> 01:39:36,200
two strings like this.

2750
01:39:36,399 --> 01:39:36,720
So in fact,

2751
01:39:36,799 --> 01:39:37,399
let me go back to.

2752
01:39:37,745 --> 01:39:38,254
code here,

2753
01:39:38,384 --> 01:39:39,294
clear my terminal,

2754
01:39:39,384 --> 01:39:42,174
and let's just make this program a little more interesting for a moment.

2755
01:39:42,464 --> 01:39:48,865
String T equals by for instance and then down here let's do two print Fs percents,

2756
01:39:49,004 --> 01:39:51,214
backslash N and print outs.

2757
01:39:51,345 --> 01:39:54,214
Print F pers backslash N print out T.

2758
01:39:54,544 --> 01:39:55,104
Now to be clear,

2759
01:39:55,274 --> 01:39:57,535
percents means string placeholder.

2760
01:39:57,785 --> 01:40:00,294
T and S are just also the names of the variables.

2761
01:40:00,305 --> 01:40:02,214
There's no percent T that we want to use here.

2762
01:40:02,709 --> 01:40:02,870
All right,

2763
01:40:02,990 --> 01:40:04,430
let me go down to my terminal,

2764
01:40:04,549 --> 01:40:05,270
make high

2765
01:40:05,709 --> 01:40:05,950
high,

2766
01:40:05,990 --> 01:40:06,629
and voila,

2767
01:40:06,709 --> 01:40:09,500
I get high and by just like you would have expected last week.

2768
01:40:09,669 --> 01:40:11,779
But what's going on inside of the computer's memory?

2769
01:40:11,910 --> 01:40:11,990
Well,

2770
01:40:12,069 --> 01:40:16,740
insofar as I've asked it to create two variables S and T like this.

2771
01:40:16,759 --> 01:40:21,020
Odds are what's happening in the computer's memory is high is ending up here,

2772
01:40:21,029 --> 01:40:21,189
a.

2773
01:40:21,314 --> 01:40:22,145
A S T,

2774
01:40:23,044 --> 01:40:24,234
because there's nothing else in this program,

2775
01:40:24,305 --> 01:40:25,694
it's probably going to end up here,

2776
01:40:25,705 --> 01:40:26,395
BE,

2777
01:40:27,145 --> 01:40:29,294
but it wraps on this particular screen.

2778
01:40:29,584 --> 01:40:33,654
T is taking up 12345 bytes total,

2779
01:40:33,785 --> 01:40:34,895
just as high

2780
01:40:35,225 --> 01:40:40,095
it's taking up 4 bytes total because the compiler is automatically adding for me

2781
01:40:40,504 --> 01:40:41,645
the backslash zero,

2782
01:40:41,665 --> 01:40:42,814
the null character

2783
01:40:42,984 --> 01:40:46,714
to make clear to other functions where this string

2784
01:40:46,984 --> 01:40:47,575
ends.

2785
01:40:48,100 --> 01:40:48,109
So

2786
01:40:49,689 --> 01:40:52,819
what does this mean in real terms and why is it 0?

2787
01:40:53,129 --> 01:40:53,810
Why is it 0?

2788
01:40:53,930 --> 01:40:54,049
Like,

2789
01:40:54,129 --> 01:40:54,319
uh,

2790
01:40:54,529 --> 01:40:56,810
just because like at the end of the day all we have is bits.

2791
01:40:56,890 --> 01:40:58,720
We've got 8 bits to work with for chars.

2792
01:40:58,850 --> 01:40:59,890
You've got to pick some pattern.

2793
01:40:59,970 --> 01:41:01,100
We could have chosen all ones.

2794
01:41:01,149 --> 01:41:02,370
We could have chosen all zeros.

2795
01:41:02,430 --> 01:41:03,839
We could have chosen something arbitrary.

2796
01:41:03,970 --> 01:41:06,049
A bunch of humans in a room years ago decided.

2797
01:41:06,850 --> 01:41:08,729
8 zeros will mean the null character.

2798
01:41:08,779 --> 01:41:13,250
That's the special character we will use to terminate strings in this way.

2799
01:41:13,500 --> 01:41:13,700
Well,

2800
01:41:13,859 --> 01:41:14,799
what does that mean

2801
01:41:15,020 --> 01:41:16,259
with our new syntax?

2802
01:41:16,330 --> 01:41:16,419
Well,

2803
01:41:16,500 --> 01:41:18,770
it means we can poke around with strings as well.

2804
01:41:18,939 --> 01:41:21,729
So even though that first variable is S and that second one is T,

2805
01:41:21,899 --> 01:41:26,209
you could technically poke around and access S 0 and 1 and 2 and 3,

2806
01:41:26,299 --> 01:41:28,850
T 0123 and 4,

2807
01:41:28,859 --> 01:41:29,609
and so forth.

2808
01:41:29,729 --> 01:41:30,100
So in fact,

2809
01:41:30,129 --> 01:41:31,819
if I wanted to dive in deeply there.

2810
01:41:32,339 --> 01:41:33,500
And actually see that.

2811
01:41:33,689 --> 01:41:33,770
Well,

2812
01:41:33,850 --> 01:41:37,080
let me go ahead and do this back in VS code here.

2813
01:41:37,290 --> 01:41:38,680
Let me make a refinement here.

2814
01:41:38,729 --> 01:41:42,279
I've now got my two strings here.

2815
01:41:42,939 --> 01:41:46,350
I could go and for instance down here just like before,

2816
01:41:46,649 --> 01:41:46,970
C,

2817
01:41:47,450 --> 01:41:47,770
C,

2818
01:41:48,209 --> 01:41:48,740
C,

2819
01:41:49,649 --> 01:41:50,140
C,

2820
01:41:51,259 --> 01:41:51,500
C,

2821
01:41:51,850 --> 01:41:52,049
C,

2822
01:41:52,450 --> 01:41:52,959
C,

2823
01:41:53,330 --> 01:41:55,799
and if I then do S 0.

2824
01:41:56,250 --> 01:41:56,500
Uh,

2825
01:41:56,529 --> 01:41:57,930
S1,

2826
01:41:59,060 --> 01:41:59,560
S2,

2827
01:41:59,569 --> 01:42:00,100
oops,

2828
01:42:00,240 --> 01:42:00,649
2,

2829
01:42:00,729 --> 01:42:01,810
and then down here T

2830
01:42:02,609 --> 01:42:03,140
0

2831
01:42:03,919 --> 01:42:04,359
T1,

2832
01:42:04,459 --> 01:42:05,609
T2,

2833
01:42:06,209 --> 01:42:06,799
T3,

2834
01:42:06,810 --> 01:42:10,120
and I'm doing that only because the word by is longer than the word hi.

2835
01:42:10,370 --> 01:42:12,120
If I do make hi.i.

2836
01:42:12,410 --> 01:42:15,040
Same principles work even in this context here.

2837
01:42:15,209 --> 01:42:17,259
But let's add an interesting twist just because

2838
01:42:17,569 --> 01:42:20,600
if I have these values in memory here.

2839
01:42:21,100 --> 01:42:22,549
As follows.

2840
01:42:22,669 --> 01:42:22,859
Well,

2841
01:42:22,979 --> 01:42:25,399
it's kind of if I've got two words in memory,

2842
01:42:25,620 --> 01:42:31,310
I could use them in an array too instead of having like S and T or word 1 and 2.

2843
01:42:31,419 --> 01:42:33,490
I can actually put strings in an array too.

2844
01:42:33,580 --> 01:42:34,689
So let's go ahead and do this.

2845
01:42:34,859 --> 01:42:37,810
Let me go back to VS code and just for fun now,

2846
01:42:37,819 --> 01:42:39,089
let's go ahead and do this.

2847
01:42:39,339 --> 01:42:40,609
Give me an array

2848
01:42:40,939 --> 01:42:43,819
called Words that's going to fit two strings,

2849
01:42:44,020 --> 01:42:44,259
then.

2850
01:42:44,345 --> 01:42:45,654
In the first words,

2851
01:42:45,814 --> 01:42:47,725
words 0 put high,

2852
01:42:48,015 --> 01:42:48,694
then in words

2853
01:42:49,125 --> 01:42:50,384
1 put by.

2854
01:42:50,535 --> 01:42:52,455
The only thing new here is that I'm making an

2855
01:42:52,455 --> 01:42:54,814
array of strings now instead of an array of ins,

2856
01:42:54,825 --> 01:42:57,165
but all of the syntax is exactly the same.

2857
01:42:57,415 --> 01:42:58,875
How can I go about printing these things?

2858
01:42:58,975 --> 01:42:59,174
Well,

2859
01:42:59,294 --> 01:42:59,975
just as before,

2860
01:43:00,015 --> 01:43:02,964
I can do print Fs backslash N

2861
01:43:03,254 --> 01:43:05,044
and print out words 0.

2862
01:43:05,174 --> 01:43:07,575
Then I can do print Fos.

2863
01:43:08,319 --> 01:43:10,250
Backslash N words 1.

2864
01:43:10,350 --> 01:43:10,419
Again,

2865
01:43:10,490 --> 01:43:14,049
I'm just sort of applying the same simple syntax that we

2866
01:43:14,049 --> 01:43:18,370
saw before I again of the 6th version of this program,

2867
01:43:18,439 --> 01:43:18,529
right?

2868
01:43:18,569 --> 01:43:21,549
I'm just sort of jumping through hoops and tactically to demonstrate that

2869
01:43:21,549 --> 01:43:25,729
these are just different lenses through which to look at the exact.

2870
01:43:25,870 --> 01:43:26,810
Same idea.

2871
01:43:27,060 --> 01:43:29,649
And while a normal person would not do this,

2872
01:43:29,979 --> 01:43:30,830
we could

2873
01:43:31,220 --> 01:43:35,740
think about what's really going on in memory with arrays of words when those

2874
01:43:35,740 --> 01:43:40,339
words themselves are arrays of characters because a word is just a string.

2875
01:43:40,419 --> 01:43:41,560
So this code here

2876
01:43:41,819 --> 01:43:43,529
gives us something like this in memory

2877
01:43:43,799 --> 01:43:46,370
in that program a moment ago this is words 0,

2878
01:43:46,580 --> 01:43:47,580
this is words 1.

2879
01:43:47,620 --> 01:43:49,959
The only thing that's different is I'm not calling them SNT.

2880
01:43:50,100 --> 01:43:51,299
I've given them one name.

2881
01:43:51,819 --> 01:43:52,970
With two locations,

2882
01:43:53,049 --> 01:43:54,089
0 and 1.

2883
01:43:54,350 --> 01:43:54,729
Well,

2884
01:43:54,899 --> 01:43:59,290
if each of these values is itself a string,

2885
01:43:59,540 --> 01:43:59,620
well,

2886
01:43:59,700 --> 01:44:02,160
you said earlier that a string is just an array,

2887
01:44:02,419 --> 01:44:04,620
so we can actually think of these two strings,

2888
01:44:04,700 --> 01:44:06,290
even though the syntax is getting a little crazy.

2889
01:44:06,979 --> 01:44:11,509
Using two sets of square bracket notation where I can index into

2890
01:44:11,819 --> 01:44:13,410
my array of words

2891
01:44:13,569 --> 01:44:17,250
and then index into the individual letters of that word

2892
01:44:17,540 --> 01:44:19,339
by just using more square brackets.

2893
01:44:19,379 --> 01:44:21,069
And again this is just to demonstrate a point

2894
01:44:21,069 --> 01:44:22,979
not because a normal person would do this,

2895
01:44:23,020 --> 01:44:25,089
but if I go back to VS code

2896
01:44:25,580 --> 01:44:27,419
instead of printing out these two strings,

2897
01:44:27,540 --> 01:44:29,040
why don't I do something like this?

2898
01:44:29,049 --> 01:44:29,729
Print F

2899
01:44:31,259 --> 01:44:31,600
C

2900
01:44:32,129 --> 01:44:32,540
C

2901
01:44:32,830 --> 01:44:33,899
C backslash N.

2902
01:44:34,359 --> 01:44:34,779
Then

2903
01:44:34,959 --> 01:44:36,910
let's print out the first word,

2904
01:44:37,160 --> 01:44:38,870
but the first character they're in.

2905
01:44:39,080 --> 01:44:40,310
Let's print out the first word,

2906
01:44:40,399 --> 01:44:42,069
but the second character they're in,

2907
01:44:42,270 --> 01:44:43,350
the first word,

2908
01:44:43,640 --> 01:44:45,720
but the third character they're in,

2909
01:44:45,830 --> 01:44:48,649
and even though I'm saying 3rd and 2nd and 1st,

2910
01:44:48,720 --> 01:44:52,350
it's 21 and 0 respectively because we start counting at 0.

2911
01:44:52,640 --> 01:44:55,970
And then lastly here we can print out the second word C,

2912
01:44:56,279 --> 01:44:56,600
C,

2913
01:44:56,799 --> 01:44:57,009
C,

2914
01:44:57,319 --> 01:44:57,479
C,

2915
01:44:57,490 --> 01:44:58,310
backslash N

2916
01:44:58,600 --> 01:44:59,709
then words bracket,

2917
01:45:00,520 --> 01:45:02,790
how do I get to the second word in this array?

2918
01:45:04,129 --> 01:45:05,450
Words bracket 1,

2919
01:45:05,770 --> 01:45:07,330
the first character they're in.

2920
01:45:07,410 --> 01:45:08,399
Words bracket 1,

2921
01:45:08,450 --> 01:45:10,120
the second character they're in.

2922
01:45:10,129 --> 01:45:11,129
Words bracket 1,

2923
01:45:11,330 --> 01:45:13,970
the third character they're in words bracket 1.

2924
01:45:14,359 --> 01:45:16,890
The last character therein and again

2925
01:45:17,020 --> 01:45:19,330
I'm this is just to demonstrate a point,

2926
01:45:19,359 --> 01:45:20,740
but if I do make high now high,

2927
01:45:22,009 --> 01:45:25,089
we have full control over everything that's going on.

2928
01:45:25,299 --> 01:45:27,609
If you now do agree and understand

2929
01:45:27,899 --> 01:45:29,189
that an array

2930
01:45:29,540 --> 01:45:31,609
can be indexed into with square bracket notation,

2931
01:45:31,720 --> 01:45:34,209
as can a string because a string is itself

2932
01:45:34,660 --> 01:45:35,319
just

2933
01:45:35,540 --> 01:45:36,330
an array.

2934
01:45:36,899 --> 01:45:39,939
Strings are arrays for today's purposes then.

2935
01:45:41,160 --> 01:45:43,549
Questions on any and all of these

2936
01:45:43,919 --> 01:45:44,600
tricks.

2937
01:45:48,180 --> 01:45:48,589
No?

2938
01:45:48,819 --> 01:45:49,100
All right,

2939
01:45:49,339 --> 01:45:49,500
yeah,

2940
01:45:49,620 --> 01:45:50,290
in front.

2941
01:45:53,379 --> 01:45:53,549
about

2942
01:45:55,270 --> 01:45:55,810
OK.

2943
01:45:55,979 --> 01:45:56,200
Like,

2944
01:45:56,299 --> 01:45:58,000
with like the full average in in in

2945
01:45:58,790 --> 01:45:58,819
in

2946
01:45:59,000 --> 01:45:59,490
in number,

2947
01:45:59,660 --> 01:46:00,220
is that,

2948
01:46:00,419 --> 01:46:02,419
is that establishing in the right?

2949
01:46:02,470 --> 01:46:03,209
like how are you?

2950
01:46:03,220 --> 01:46:04,540
How do you like establish?

2951
01:46:05,859 --> 01:46:07,399
How do you establish or create an array?

2952
01:46:07,459 --> 01:46:07,540
Well,

2953
01:46:07,620 --> 01:46:08,779
in the context of this program,

2954
01:46:08,830 --> 01:46:10,000
if I go back to VS code,

2955
01:46:10,140 --> 01:46:11,220
line 6 here

2956
01:46:11,580 --> 01:46:13,450
gives me an array of size 2.

2957
01:46:14,259 --> 01:46:16,120
An array of two strings if you will.

2958
01:46:16,350 --> 01:46:18,390
The previous example we were playing with,

2959
01:46:18,410 --> 01:46:20,160
which was my scores,

2960
01:46:20,649 --> 01:46:21,129
oops,

2961
01:46:21,290 --> 01:46:22,060
wrong program,

2962
01:46:22,709 --> 01:46:23,359
wrong file.

2963
01:46:23,490 --> 01:46:26,080
If I open up scores.c as before,

2964
01:46:26,430 --> 01:46:27,490
this line here,

2965
01:46:27,649 --> 01:46:28,479
line 9,

2966
01:46:28,649 --> 01:46:31,399
gives me an array of N integers.

2967
01:46:32,609 --> 01:46:35,839
So that is what establishes or creates the array in memory.

2968
01:46:35,979 --> 01:46:37,009
You specify a name,

2969
01:46:37,220 --> 01:46:37,839
the size,

2970
01:46:37,939 --> 01:46:38,589
and the type.

2971
01:46:39,779 --> 01:46:40,370
That's all.

2972
01:46:40,899 --> 01:46:44,379
And the only thing that's new today again is the square bracket notation,

2973
01:46:44,419 --> 01:46:47,370
which in this context creates an array of that size,

2974
01:46:47,580 --> 01:46:48,930
but once it exists,

2975
01:46:49,020 --> 01:46:53,450
you can then access that chunk of memory by using square brackets as well.

2976
01:46:56,979 --> 01:46:57,850
Other questions

2977
01:46:58,080 --> 01:46:58,339
on a raise,

2978
01:46:58,419 --> 01:46:58,580
yeah,

2979
01:46:58,779 --> 01:46:59,180
in front.

2980
01:47:05,620 --> 01:47:05,629
Or

2981
01:47:06,669 --> 01:47:07,549
do you need to go in

2982
01:47:08,310 --> 01:47:08,629
index index.

2983
01:47:10,049 --> 01:47:10,560
Good question.

2984
01:47:10,569 --> 01:47:11,979
Do you need to

2985
01:47:12,169 --> 01:47:14,879
go index by index to put things inside of an array?

2986
01:47:15,089 --> 01:47:16,000
Short answer no.

2987
01:47:16,089 --> 01:47:19,399
So let me open up again scores.c from before,

2988
01:47:19,770 --> 01:47:24,160
and what I could have done in an earlier version of my program

2989
01:47:24,649 --> 01:47:26,729
would be something like this.

2990
01:47:26,770 --> 01:47:28,500
I could have done 72,

2991
01:47:28,540 --> 01:47:29,189
73,

2992
01:47:29,200 --> 01:47:29,919
33,

2993
01:47:29,930 --> 01:47:33,120
and I deliberately didn't show this because I didn't wanna add too much complexity,

2994
01:47:33,250 --> 01:47:33,410
but.

2995
01:47:33,544 --> 01:47:38,805
You can use curly braces in this new way and initialize the array in one line,

2996
01:47:38,814 --> 01:47:40,535
and in that case you don't even need to specify

2997
01:47:40,535 --> 01:47:42,334
the size because the compiler is not an idiot.

2998
01:47:42,535 --> 01:47:44,685
It can figure out that if you've got 3 numbers on the right,

2999
01:47:44,875 --> 01:47:48,145
it knows that it only needs 3 elements on the left to put them into.

3000
01:47:48,495 --> 01:47:50,285
But let me undo that and leave it just as I did,

3001
01:47:50,294 --> 01:47:51,104
but short answer yes,

3002
01:47:51,134 --> 01:47:54,134
you can statically initialize an array if you know all of the

3003
01:47:54,134 --> 01:47:57,214
values up front and not when using get in in that case.

3004
01:47:57,950 --> 01:47:58,529
All right,

3005
01:47:58,709 --> 01:47:59,160
so

3006
01:47:59,390 --> 01:48:01,160
if you're on board with the idea

3007
01:48:01,430 --> 01:48:03,049
that all a string is,

3008
01:48:03,069 --> 01:48:07,229
is an array and that array is always null terminated,

3009
01:48:07,390 --> 01:48:08,379
we can now.

3010
01:48:09,580 --> 01:48:12,859
Use that knowledge to solve some simple problems and

3011
01:48:12,859 --> 01:48:14,979
problems that others have already solved before us.

3012
01:48:15,100 --> 01:48:17,490
So let me go ahead and close that file in VS code.

3013
01:48:17,700 --> 01:48:20,779
Let me go ahead and open up another program here called length.C

3014
01:48:20,779 --> 01:48:23,700
and let's just play around with the length of strings as follows.

3015
01:48:23,819 --> 01:48:26,089
Let me include the CS 50 library at the top.

3016
01:48:26,339 --> 01:48:28,490
Let me include standard IO after that.

3017
01:48:28,660 --> 01:48:30,850
Let me do into Main void after that,

3018
01:48:30,899 --> 01:48:32,240
and then inside of Main,

3019
01:48:32,419 --> 01:48:34,419
let's prompt the user for their name.

3020
01:48:34,899 --> 01:48:40,040
By using get string and just say name Colin today and then after that,

3021
01:48:40,250 --> 01:48:43,770
let's go ahead and figure out the length of the person's name like D A V I D.

3022
01:48:43,810 --> 01:48:46,529
I should get the answer of 5 and K E L L Y,

3023
01:48:46,569 --> 01:48:49,640
we should get the answer of 5 and hopefully for a longer or shorter name,

3024
01:48:49,810 --> 01:48:51,419
we'll get the correct answer as well.

3025
01:48:51,729 --> 01:48:53,890
So how can I go about counting.

3026
01:48:54,379 --> 01:48:57,000
The number of characters in a string.

3027
01:48:57,080 --> 01:48:57,200
Well,

3028
01:48:57,290 --> 01:48:59,270
the string is just an array,

3029
01:48:59,439 --> 01:49:02,419
and that array ends with the null character.

3030
01:49:02,680 --> 01:49:04,160
There's a bunch of ways we can do this,

3031
01:49:04,240 --> 01:49:05,669
but let me go ahead and do this.

3032
01:49:05,879 --> 01:49:07,959
Let me create a variable called N which

3033
01:49:07,959 --> 01:49:10,629
eventually will contain the length of the name,

3034
01:49:10,799 --> 01:49:14,870
and I'm going to set it equal to 0 because I don't know anything yet about the length.

3035
01:49:15,319 --> 01:49:17,080
Then I can do this with a 4 loop,

3036
01:49:17,120 --> 01:49:19,470
but I prefer this time to use a while loop.

3037
01:49:19,640 --> 01:49:20,950
I'm gonna say the following

3038
01:49:21,359 --> 01:49:23,040
while the person's name.

3039
01:49:23,729 --> 01:49:25,120
At that location

3040
01:49:25,649 --> 01:49:28,200
does not equal backslash zero,

3041
01:49:28,850 --> 01:49:29,680
go ahead

3042
01:49:29,890 --> 01:49:31,129
and add 1

3043
01:49:31,450 --> 01:49:32,450
to the value of N.

3044
01:49:33,279 --> 01:49:34,810
And then after all of this,

3045
01:49:35,020 --> 01:49:36,359
go ahead and print out

3046
01:49:36,740 --> 01:49:38,729
with percent I backslash N

3047
01:49:39,299 --> 01:49:40,540
the value of N.

3048
01:49:40,979 --> 01:49:42,410
So what's going on here,

3049
01:49:42,660 --> 01:49:45,569
this is easier said when you know already where you want to go with it,

3050
01:49:45,580 --> 01:49:46,149
but with practice,

3051
01:49:46,220 --> 01:49:47,930
you too can bang this out pretty quickly.

3052
01:49:48,189 --> 01:49:49,859
N is going to contain the length of my string.

3053
01:49:50,359 --> 01:49:54,870
I have in my loop here a boolean expression that's just asking the question,

3054
01:49:54,959 --> 01:49:58,000
Does name at the current value of N

3055
01:49:58,359 --> 01:49:59,919
not equal the null character?

3056
01:49:59,959 --> 01:50:00,319
In other words,

3057
01:50:00,359 --> 01:50:01,040
you're asking yourself,

3058
01:50:01,200 --> 01:50:02,080
Is this character null?

3059
01:50:02,160 --> 01:50:03,000
Is this character null?

3060
01:50:03,080 --> 01:50:03,890
Is this character null,

3061
01:50:03,959 --> 01:50:04,850
is this character null?

3062
01:50:04,879 --> 01:50:05,589
And if not,

3063
01:50:05,720 --> 01:50:06,339
you keep going,

3064
01:50:06,560 --> 01:50:07,350
you keep going.

3065
01:50:07,479 --> 01:50:10,149
And this is kind of a clever trick because I'm using N.

3066
01:50:10,660 --> 01:50:12,410
And incrementing it inside the loop.

3067
01:50:12,490 --> 01:50:13,799
So when I look at D,

3068
01:50:14,049 --> 01:50:15,879
that's not equal to backslash zero,

3069
01:50:15,930 --> 01:50:17,049
so I increment N.

3070
01:50:17,370 --> 01:50:18,319
Now N is 1,

3071
01:50:18,490 --> 01:50:20,089
so I look at name bracket 1.

3072
01:50:20,169 --> 01:50:21,129
What's it name bracket 1?

3073
01:50:21,140 --> 01:50:21,919
If it's my name,

3074
01:50:22,089 --> 01:50:24,770
A A does not equals 0,

3075
01:50:24,930 --> 01:50:25,850
so it increments N.

3076
01:50:25,930 --> 01:50:26,600
What's at location?

3077
01:50:27,129 --> 01:50:28,879
D A V I D V

3078
01:50:29,009 --> 01:50:30,689
V does not equal backslash n.

3079
01:50:30,879 --> 01:50:32,000
So we repeat with I,

3080
01:50:32,149 --> 01:50:33,399
we repeat with D,

3081
01:50:33,609 --> 01:50:34,240
and then

3082
01:50:34,370 --> 01:50:36,359
we get to the end of my name,

3083
01:50:36,569 --> 01:50:40,009
which is the null character because the get string

3084
01:50:40,009 --> 01:50:42,790
function and C put it there automatically for me.

3085
01:50:43,129 --> 01:50:44,200
The null character

3086
01:50:44,890 --> 01:50:49,000
does equals zero and does not get incremented any more time.

3087
01:50:49,089 --> 01:50:51,009
So at this point in the story on line 13,

3088
01:50:51,020 --> 01:50:55,529
N is still 5 because I have not counted the new the null character.

3089
01:50:55,830 --> 01:50:58,180
So I hope I will see 5 on the screen.

3090
01:50:58,339 --> 01:51:01,589
This is just kind of a very mechanical way of checking,

3091
01:51:01,620 --> 01:51:01,819
checking,

3092
01:51:01,899 --> 01:51:02,100
checking,

3093
01:51:02,180 --> 01:51:02,390
checking,

3094
01:51:02,459 --> 01:51:03,430
trying to figure out

3095
01:51:03,970 --> 01:51:06,939
through inference how long the string is because it's as

3096
01:51:06,939 --> 01:51:09,970
long as it takes to get to that backslash zero,

3097
01:51:10,020 --> 01:51:11,089
the null character.

3098
01:51:11,259 --> 01:51:14,660
So let's do make length enters length.

3099
01:51:14,814 --> 01:51:17,564
Type in my name David and I indeed get 5.

3100
01:51:17,645 --> 01:51:19,354
Let's go ahead and do length.

3101
01:51:19,564 --> 01:51:19,955
Kelly,

3102
01:51:20,055 --> 01:51:22,404
I indeed get 5 and hopefully for shorter and longer

3103
01:51:22,404 --> 01:51:24,754
names I'm going to get the exact same thing too.

3104
01:51:24,884 --> 01:51:25,154
In fact,

3105
01:51:25,185 --> 01:51:28,225
we can try a corner case length enter.

3106
01:51:28,564 --> 01:51:29,794
Let's not give it a name at all.

3107
01:51:30,004 --> 01:51:31,395
If I just hit enter here,

3108
01:51:31,725 --> 01:51:33,685
what should the length of the person's name be?

3109
01:51:35,200 --> 01:51:35,790
0,

3110
01:51:36,040 --> 01:51:37,080
which is not incorrect.

3111
01:51:37,120 --> 01:51:38,350
It's literally true,

3112
01:51:38,720 --> 01:51:41,910
but that's because we're going to get back essentially quote unquote,

3113
01:51:42,120 --> 01:51:44,669
but even though it's quote unquote in the computer's memory,

3114
01:51:44,839 --> 01:51:46,830
it's still going to take up one bite

3115
01:51:47,200 --> 01:51:49,919
because the get string function will still put null at

3116
01:51:49,919 --> 01:51:53,009
the end of the string even if it's got no characters

3117
01:51:53,319 --> 01:51:54,100
therein.

3118
01:51:54,529 --> 01:51:55,439
So it turns out.

3119
01:51:56,040 --> 01:51:59,950
This is not something you need to do frequently like initializing a variable,

3120
01:51:59,959 --> 01:52:00,919
using a loop like this.

3121
01:52:01,000 --> 01:52:03,439
It turns out there are better solutions to this problem.

3122
01:52:03,520 --> 01:52:06,399
You do not need to reinvent this wheel yourself because it

3123
01:52:06,399 --> 01:52:09,169
turns out in addition to standard IO.H and CS 50.

3124
01:52:09,359 --> 01:52:11,430
H and as you probably saw on Problemset one,

3125
01:52:11,680 --> 01:52:12,049
math.

3126
01:52:12,439 --> 01:52:14,520
H and perhaps others,

3127
01:52:14,680 --> 01:52:16,200
there are other libraries out there,

3128
01:52:16,359 --> 01:52:18,029
namely the string library itself.

3129
01:52:18,040 --> 01:52:18,279
In fact,

3130
01:52:18,319 --> 01:52:19,890
if you go into the CS50 manual,

3131
01:52:19,950 --> 01:52:24,879
you can look up the documentation for a header file called string.H which contains.

3132
01:52:25,475 --> 01:52:28,455
for that is prototypes for a whole bunch of helpful functions.

3133
01:52:28,495 --> 01:52:28,725
In fact,

3134
01:52:28,734 --> 01:52:31,884
the manual pages for it are at this URL here.

3135
01:52:32,095 --> 01:52:33,254
The most important function,

3136
01:52:33,294 --> 01:52:35,055
and the one we're going to use so often for the

3137
01:52:35,055 --> 01:52:39,325
next few weeks is wonderfully called Stirlang for string length.

3138
01:52:39,615 --> 01:52:44,375
Someone else literally decades ago wrote the code that essentially looks

3139
01:52:44,375 --> 01:52:47,524
quite like this but packaged it up in a function that you

3140
01:52:47,524 --> 01:52:49,975
and I can use so we don't have to jump through

3141
01:52:49,975 --> 01:52:52,294
these stupid hoops just to count the length of a string.

3142
01:52:52,375 --> 01:52:54,285
We can just ask the string length function.

3143
01:52:54,810 --> 01:52:56,169
What the length of a string is,

3144
01:52:56,209 --> 01:52:57,169
but odds are,

3145
01:52:57,180 --> 01:53:00,680
if we looked at the C code that someone wrote decades ago,

3146
01:53:00,689 --> 01:53:03,069
it would look indeed quite like this.

3147
01:53:03,209 --> 01:53:05,160
So how can I simplify this program?

3148
01:53:05,490 --> 01:53:05,649
Well,

3149
01:53:05,770 --> 01:53:07,759
I can get rid of all of this code here.

3150
01:53:08,049 --> 01:53:10,020
I can include string.

3151
01:53:10,450 --> 01:53:11,919
H at the top of my file,

3152
01:53:12,129 --> 01:53:13,930
and then I quite simply.

3153
01:53:14,115 --> 01:53:19,415
Do something like this in length equals stir lang of name.

3154
01:53:19,665 --> 01:53:21,305
That's going to put in the variable length,

3155
01:53:21,384 --> 01:53:21,634
actually,

3156
01:53:21,745 --> 01:53:25,145
let's be consistent in N equals stir length of name,

3157
01:53:25,165 --> 01:53:26,154
and then on line 9,

3158
01:53:26,265 --> 01:53:27,134
let's print it out.

3159
01:53:27,384 --> 01:53:28,134
Let's try this.

3160
01:53:28,225 --> 01:53:29,214
Make length

3161
01:53:30,225 --> 01:53:31,805
length David.

3162
01:53:32,064 --> 01:53:32,584
OK,

3163
01:53:32,984 --> 01:53:33,615
Kelly,

3164
01:53:34,225 --> 01:53:34,705
OK,

3165
01:53:34,825 --> 01:53:35,464
and no one.

3166
01:53:35,790 --> 01:53:36,569
And 0,

3167
01:53:36,660 --> 01:53:37,939
it seems to now be working.

3168
01:53:38,020 --> 01:53:43,129
So this is a wheel we do not need to reinvent and frankly now in a matter of design

3169
01:53:43,339 --> 01:53:45,149
I don't really need the variable N anymore.

3170
01:53:45,220 --> 01:53:48,490
Recall that we can nest our functions just like we did with average before.

3171
01:53:48,609 --> 01:53:49,970
So let me get rid of that line

3172
01:53:50,180 --> 01:53:54,609
and just say sterling of name is actually perfectly reasonable here.

3173
01:53:55,419 --> 01:53:55,439
All right,

3174
01:53:56,290 --> 01:53:56,410
well,

3175
01:53:56,529 --> 01:53:57,729
what more can we do with this?

3176
01:53:57,850 --> 01:53:57,890
Well,

3177
01:53:57,970 --> 01:53:59,529
let's consider some other matters of design.

3178
01:53:59,629 --> 01:54:01,410
Let me close out length.C and let's

3179
01:54:01,410 --> 01:54:04,990
create another program of our own called String.c

3180
01:54:05,319 --> 01:54:07,729
in which we'll play around now with this library and others.

3181
01:54:07,850 --> 01:54:09,339
Let me go ahead and include CS50.

3182
01:54:09,529 --> 01:54:09,979
H.

3183
01:54:10,649 --> 01:54:13,560
Let me go ahead and include standardio.h.

3184
01:54:13,970 --> 01:54:15,799
Let me go ahead and include also

3185
01:54:16,250 --> 01:54:17,640
string.h.

3186
01:54:18,080 --> 01:54:18,339
All right,

3187
01:54:18,609 --> 01:54:19,589
what do I want to now do?

3188
01:54:19,609 --> 01:54:21,770
Well in Main void and inside of Main?

3189
01:54:22,290 --> 01:54:23,560
Let's go ahead and

3190
01:54:23,770 --> 01:54:25,740
write a program that prints a string character

3191
01:54:25,740 --> 01:54:28,089
by character just to demonstrate these mechanics.

3192
01:54:28,209 --> 01:54:30,500
So strings equals get string,

3193
01:54:30,600 --> 01:54:32,529
and I'm going to ask the user for some input because

3194
01:54:32,529 --> 01:54:34,479
I just want to play around with any old string.

3195
01:54:34,609 --> 01:54:36,600
I'm going to go ahead and proactively say

3196
01:54:36,930 --> 01:54:37,959
output here,

3197
01:54:38,169 --> 01:54:39,879
and I'm going to go ahead and

3198
01:54:40,620 --> 01:54:43,200
not use a new line character there deliberately.

3199
01:54:43,410 --> 01:54:45,140
Below this now I'm going to have a 4 loop,

3200
01:54:45,209 --> 01:54:47,890
though I could use a Y loop that says in I equals 0,

3201
01:54:47,930 --> 01:54:50,129
I is less than slang.

3202
01:54:50,779 --> 01:54:54,910
Of the string I just got from the human and increment I on each iteration,

3203
01:54:54,959 --> 01:54:59,470
and on each iteration print out just one character in that string.

3204
01:55:00,040 --> 01:55:03,720
Specifically at S location I and then at the very bottom of this program,

3205
01:55:03,799 --> 01:55:06,830
let's just print a single backslash end to move the character onto a new line.

3206
01:55:07,040 --> 01:55:07,839
Long story short,

3207
01:55:08,000 --> 01:55:08,709
what have I done?

3208
01:55:08,910 --> 01:55:11,830
I wrote a stupid little program that prompts the user for a string,

3209
01:55:12,040 --> 01:55:13,790
prints the word output thereafter,

3210
01:55:13,910 --> 01:55:17,080
and then just prints the word that they typed in character by character by

3211
01:55:17,080 --> 01:55:21,029
character by character until it reaches the end of the string based on the length

3212
01:55:21,439 --> 01:55:22,600
returned by Stirling.

3213
01:55:23,319 --> 01:55:25,410
So let's go ahead and run this in my terminal window.

3214
01:55:25,450 --> 01:55:28,089
I'm going to do make strings string,

3215
01:55:28,129 --> 01:55:29,680
and I'll type in my own name it before.

3216
01:55:29,850 --> 01:55:30,649
This was a subtlety.

3217
01:55:30,689 --> 01:55:33,120
I deliberately wrote two spaces here

3218
01:55:33,450 --> 01:55:34,040
because I just,

3219
01:55:34,120 --> 01:55:34,850
um,

3220
01:55:34,890 --> 01:55:35,529
to be nitpicky,

3221
01:55:35,609 --> 01:55:38,879
I wanted input and output to line up perfectly so you can see what's happening.

3222
01:55:39,049 --> 01:55:39,319
Indeed,

3223
01:55:39,330 --> 01:55:40,399
if I do enter here,

3224
01:55:40,689 --> 01:55:41,919
now I see input is David,

3225
01:55:42,029 --> 01:55:43,250
the output is David as well.

3226
01:55:43,290 --> 01:55:45,759
So that was just a formatting trick that I foresaw.

3227
01:55:46,839 --> 01:55:50,330
Why is this program correct but not arguably well designed?

3228
01:55:52,419 --> 01:55:54,500
It's pretty good in that it's using the Stirling function.

3229
01:55:54,529 --> 01:55:56,520
I didn't reinvent the wheel unnecessarily,

3230
01:55:56,850 --> 01:55:59,479
but there's an inefficiency that's kind of subtle.

3231
01:56:02,509 --> 01:56:03,839
And it relates to

3232
01:56:04,129 --> 01:56:05,689
how a for loop works.

3233
01:56:08,509 --> 01:56:09,350
Any thoughts?

3234
01:56:09,430 --> 01:56:13,299
This program I claim is doing unnecessary work somewhere.

3235
01:56:15,080 --> 01:56:15,779
Yeah.

3236
01:56:17,870 --> 01:56:18,169
OK,

3237
01:56:18,250 --> 01:56:19,149
that's definitely stupid.

3238
01:56:19,290 --> 01:56:19,540
Um,

3239
01:56:19,549 --> 01:56:21,520
you don't have to output a character by character,

3240
01:56:21,529 --> 01:56:23,919
that's just my pedagogical decision here.

3241
01:56:24,169 --> 01:56:26,560
So correct but not the question we're fishing for.

3242
01:56:27,689 --> 01:56:28,959
There's a second stupid thing,

3243
01:56:29,040 --> 01:56:29,319
yeah.

3244
01:56:33,930 --> 01:56:33,990
Che

3245
01:56:36,140 --> 01:56:36,850
Yes,

3246
01:56:37,140 --> 01:56:39,049
every time through this loop,

3247
01:56:39,220 --> 01:56:42,500
and this isn't so much my uh conscious choice but my mistake.

3248
01:56:42,950 --> 01:56:45,140
I'm checking the length of S again and again.

3249
01:56:45,220 --> 01:56:45,419
Why?

3250
01:56:45,620 --> 01:56:47,060
Because recall how a for loop works.

3251
01:56:47,140 --> 01:56:49,750
The initialization happens once at the very beginning.

3252
01:56:50,020 --> 01:56:51,810
Then you check the Boolean expression.

3253
01:56:52,100 --> 01:56:53,529
Then if it's true,

3254
01:56:53,660 --> 01:56:54,490
you do the code.

3255
01:56:54,620 --> 01:56:55,500
Then you do the update,

3256
01:56:55,620 --> 01:56:56,970
then you check the boolean expression,

3257
01:56:57,100 --> 01:56:58,049
then you do the code.

3258
01:56:58,299 --> 01:56:59,609
Update Boolean expression,

3259
01:56:59,700 --> 01:57:00,569
you do the code.

3260
01:57:00,700 --> 01:57:03,250
But every time you evaluate this Boolean expression,

3261
01:57:03,379 --> 01:57:03,979
you're asking,

3262
01:57:04,060 --> 01:57:06,379
does is I less than the ster length of S?

3263
01:57:06,540 --> 01:57:10,890
But this is A function call like you are literally using Stirling again and again and

3264
01:57:10,890 --> 01:57:13,930
again and like a crazy person you're asking the computer what's the length of S,

3265
01:57:13,970 --> 01:57:14,689
what's the length of S?

3266
01:57:14,729 --> 01:57:15,450
What's the length of S?

3267
01:57:15,620 --> 01:57:16,720
It's not going to change.

3268
01:57:16,850 --> 01:57:18,759
It's going to be the same no matter what.

3269
01:57:19,009 --> 01:57:20,399
So how can we fix this?

3270
01:57:20,450 --> 01:57:21,000
Well,

3271
01:57:21,330 --> 01:57:22,000
I could

3272
01:57:22,209 --> 01:57:24,799
solve this in a couple of ways like I could,

3273
01:57:24,890 --> 01:57:25,399
for instance,

3274
01:57:25,410 --> 01:57:30,609
down here dot and equals stirling of S and store it in a variable n.

3275
01:57:30,939 --> 01:57:31,910
And just do that.

3276
01:57:32,129 --> 01:57:34,680
I think that eliminates the inefficiency because now

3277
01:57:34,680 --> 01:57:37,120
I calculate the length of s once.

3278
01:57:37,290 --> 01:57:38,390
It's not going to change,

3279
01:57:38,450 --> 01:57:39,500
nor is my variable,

3280
01:57:39,649 --> 01:57:41,930
so I can now use and reuse that variable.

3281
01:57:41,939 --> 01:57:43,410
It's just saving me a little bit of time,

3282
01:57:43,490 --> 01:57:43,609
you know,

3283
01:57:43,649 --> 01:57:44,799
microseconds maybe,

3284
01:57:44,930 --> 01:57:47,370
but when you're writing bigger programs and you're doing things in loops,

3285
01:57:47,450 --> 01:57:49,589
if that loop is running not 3 times or 5 times,

3286
01:57:49,770 --> 01:57:50,799
but a million times,

3287
01:57:51,250 --> 01:57:52,270
millions of times,

3288
01:57:52,490 --> 01:57:53,740
all of those microseconds,

3289
01:57:53,770 --> 01:57:55,609
milliseconds might very well add up.

3290
01:57:55,770 --> 01:57:58,729
But it turns out there's some syntactic tricks we can do too.

3291
01:57:59,029 --> 01:58:00,959
I alluded to this earlier.

3292
01:58:01,129 --> 01:58:03,149
If you want to initialize not one variable,

3293
01:58:03,479 --> 01:58:04,359
but 2,

3294
01:58:04,569 --> 01:58:08,879
you can actually do it all before the first semicolon like that.

3295
01:58:09,129 --> 01:58:13,000
So now on line 9 I'm declaring a variable called I and setting equal to 0,

3296
01:58:13,080 --> 01:58:15,359
and I'm declaring a second variable called N,

3297
01:58:15,569 --> 01:58:16,979
also the same type in,

3298
01:58:17,410 --> 01:58:20,049
and setting it equal to the length of S.

3299
01:58:20,520 --> 01:58:23,009
And now I can use that again and again.

3300
01:58:23,229 --> 01:58:23,299
Now,

3301
01:58:23,310 --> 01:58:23,850
as an aside,

3302
01:58:23,859 --> 01:58:27,890
this is a little bit of a white lie because smart compilers nowadays are so advanced

3303
01:58:27,890 --> 01:58:31,160
that they will notice that you're calling Sterling again and again inside of a loop,

3304
01:58:31,200 --> 01:58:33,810
and they will just fix this for you unbeknownst to you,

3305
01:58:34,180 --> 01:58:36,990
but it's representative of a class of problems that you should be

3306
01:58:36,990 --> 01:58:40,020
able to spot with your own human eyes and avoid altogether so

3307
01:58:40,020 --> 01:58:43,540
that you don't waste more time and more compute and more money

3308
01:58:43,540 --> 01:58:47,129
in some sense than you might otherwise need to in this case.

3309
01:58:47,939 --> 01:58:49,169
Any questions

3310
01:58:49,419 --> 01:58:50,529
on that there,

3311
01:58:51,060 --> 01:58:51,689
optimization,

3312
01:58:51,750 --> 01:58:52,100
yeah.

3313
01:58:55,270 --> 01:58:56,669
You do not say it again.

3314
01:58:56,709 --> 01:58:58,470
The constraint is that you have to use the

3315
01:58:58,470 --> 01:59:00,419
same data type for all of your initialization,

3316
01:59:00,549 --> 01:59:03,669
so you better hope that you only want ins in this case.

3317
01:59:03,709 --> 01:59:04,020
Otherwise,

3318
01:59:04,029 --> 01:59:06,020
you got to pull it out and do what I did earlier.

3319
01:59:06,430 --> 01:59:07,029
Good question.

3320
01:59:08,370 --> 01:59:09,160
Others

3321
01:59:09,370 --> 01:59:10,160
on this.

3322
01:59:12,839 --> 01:59:13,350
Yeah.

3323
01:59:16,240 --> 01:59:18,200
When does it account for spaces?

3324
01:59:18,240 --> 01:59:18,359
Uh,

3325
01:59:18,459 --> 01:59:22,589
a space is just uh ask a character number 32,

3326
01:59:22,919 --> 01:59:24,470
so there's nothing special about it.

3327
01:59:24,549 --> 01:59:25,709
It's sort of invisible,

3328
01:59:25,759 --> 01:59:26,750
but it is there.

3329
01:59:27,040 --> 01:59:29,200
It is treated like any other character.

3330
01:59:29,310 --> 01:59:30,830
There's no special accounting whatsoever.

3331
01:59:31,120 --> 01:59:32,129
The null character,

3332
01:59:32,160 --> 01:59:33,390
which is also invisible,

3333
01:59:33,600 --> 01:59:38,520
is special because Pri F and Stirling know to look for the end of that variable,

3334
01:59:38,750 --> 01:59:40,520
the end of that value as such.

3335
01:59:41,339 --> 01:59:41,540
All right,

3336
01:59:41,620 --> 01:59:44,819
let's try one other demonstration of some of these ideas here.

3337
01:59:44,899 --> 01:59:46,109
Let me go into

3338
01:59:46,379 --> 01:59:46,390
Uh,

3339
01:59:47,529 --> 01:59:50,970
another file that we'll create called how about uppercase.c.

3340
01:59:51,129 --> 01:59:53,970
Let's write a super simple program that like uppercases a string that the

3341
01:59:53,970 --> 01:59:55,839
human types in and see how we can do this sort of good,

3342
01:59:55,850 --> 01:59:56,040
better,

3343
01:59:56,049 --> 01:59:56,680
and best.

3344
01:59:56,850 --> 01:59:58,740
So I'm going to call this file uppercase.c.

3345
01:59:59,129 --> 01:59:59,959
Inside of this file,

3346
01:59:59,970 --> 02:00:01,290
let's use our now friends,

3347
02:00:01,689 --> 02:00:05,830
include CS50.h. Let's do include standardio.h.

3348
02:00:06,250 --> 02:00:08,040
Let's then include lastly,

3349
02:00:08,330 --> 02:00:10,319
how about string.

3350
02:00:10,879 --> 02:00:11,220
H?

3351
02:00:11,410 --> 02:00:15,000
And the goal here inside of Main is going to be

3352
02:00:15,569 --> 02:00:16,109
to

3353
02:00:16,680 --> 02:00:17,870
Get a string from the user,

3354
02:00:18,000 --> 02:00:20,029
so string S equals get string,

3355
02:00:20,060 --> 02:00:22,520
and we're gonna ask the user for a before string,

3356
02:00:22,759 --> 02:00:25,839
representing what it is they typed before we uppercase everything.

3357
02:00:26,339 --> 02:00:30,470
Then I'm going to go ahead after that and print out just as a placeholder after

3358
02:00:30,689 --> 02:00:34,930
and two spaces just to be nitpicky so that the text lines up vertically on the screen.

3359
02:00:35,180 --> 02:00:38,430
Now I'm going to do the following 4 I equals 0,

3360
02:00:38,740 --> 02:00:41,770
N equals slang of S,

3361
02:00:42,060 --> 02:00:45,649
semicolon I less than N just like before I + +.

3362
02:00:45,819 --> 02:00:47,620
So I'm just kicking off a loop that's going

3363
02:00:47,620 --> 02:00:50,129
to iterate over the string the human typed in.

3364
02:00:50,500 --> 02:00:54,103
Now if my goal in life is to Change

3365
02:00:54,353 --> 02:00:56,493
the user's input from lower case,

3366
02:00:56,712 --> 02:00:58,422
if indeed in lower case to upper case,

3367
02:00:58,672 --> 02:01:00,422
let's just express that literally

3368
02:01:00,833 --> 02:01:01,422
if

3369
02:01:01,712 --> 02:01:03,913
the current character in the string,

3370
02:01:04,073 --> 02:01:04,632
so SI

3371
02:01:05,862 --> 02:01:08,263
is greater than or equal to

3372
02:01:09,473 --> 02:01:10,062
A

3373
02:01:10,553 --> 02:01:17,192
and S bra I is less than or equal to z using single quotes,

3374
02:01:17,353 --> 02:01:20,592
this is arguably a very clever way of expressing the question is it lower.

3375
02:01:20,695 --> 02:01:24,355
Case we know from our AI chart from week 0

3376
02:01:24,616 --> 02:01:25,045
that

3377
02:01:25,485 --> 02:01:28,965
the AI chart has not only numbers representing all the uppercase

3378
02:01:28,965 --> 02:01:31,326
letters but also numbers representing all the lower case letters.

3379
02:01:31,405 --> 02:01:32,286
Lowercase a for instance,

3380
02:01:32,295 --> 02:01:33,116
is 97,

3381
02:01:33,286 --> 02:01:35,175
and they are all contiguous thereafter.

3382
02:01:35,605 --> 02:01:37,355
So we can actually treat

3383
02:01:37,605 --> 02:01:41,605
just like we did before chars as ins and ins as chars and sort of ask

3384
02:01:41,605 --> 02:01:47,846
mathematical questions about these chars and say is S I between A and Z inclusive.

3385
02:01:48,279 --> 02:01:50,080
So if it is lowercase,

3386
02:01:50,120 --> 02:01:51,870
and I'll add a comment here for clarity,

3387
02:01:52,160 --> 02:01:54,660
if SI is lowercase,

3388
02:01:54,720 --> 02:01:55,759
what do we want to do?

3389
02:01:55,879 --> 02:01:57,319
We want to force it to uppercase.

3390
02:01:57,359 --> 02:01:59,629
So this is a little trick I can do as follows.

3391
02:01:59,640 --> 02:02:00,310
Print F.

3392
02:02:00,629 --> 02:02:01,720
The current character,

3393
02:02:01,859 --> 02:02:03,169
but let's do some math on it.

3394
02:02:03,439 --> 02:02:07,049
Let's changes I by subtracting

3395
02:02:07,299 --> 02:02:08,250
some value.

3396
02:02:08,419 --> 02:02:08,540
Well,

3397
02:02:08,620 --> 02:02:10,140
what might that value be?

3398
02:02:10,209 --> 02:02:14,290
We'll recall from week ze our AI chart here and let's focus,

3399
02:02:14,299 --> 02:02:14,810
for instance,

3400
02:02:14,899 --> 02:02:17,660
on the lower case letters here and the uppercase letters here.

3401
02:02:17,740 --> 02:02:20,580
What's the distance between all upper and lower case letters?

3402
02:02:21,180 --> 02:02:22,049
It's 32,

3403
02:02:22,129 --> 02:02:22,290
right,

3404
02:02:22,330 --> 02:02:23,879
and the lowercase letters are bigger,

3405
02:02:24,089 --> 02:02:24,810
so it stands to reason.

3406
02:02:24,850 --> 02:02:27,399
If I just subtract 32 from the lower case letter,

3407
02:02:27,609 --> 02:02:30,970
it's going to immediately get me to the uppercase version thereof.

3408
02:02:31,209 --> 02:02:32,089
So this is kind of cool.

3409
02:02:32,169 --> 02:02:35,040
So I can actually go back to VS code and I can literally

3410
02:02:35,040 --> 02:02:39,009
subtract the number 32 in this case because AI is a standard,

3411
02:02:39,089 --> 02:02:40,359
it's not going to change.

3412
02:02:40,640 --> 02:02:43,479
Else if the letter is not lowercase,

3413
02:02:43,729 --> 02:02:46,750
I'm just going to go ahead and print it out unchanged

3414
02:02:47,140 --> 02:02:47,930
without doing.

3415
02:02:48,839 --> 02:02:50,830
Any mathematics at all to it,

3416
02:02:50,919 --> 02:02:52,529
and I'll make clear with the comment,

3417
02:02:53,080 --> 02:02:53,470
uh,

3418
02:02:53,609 --> 02:02:57,149
else if not lower case makes clear what's going on there.

3419
02:02:57,479 --> 02:02:57,680
All right,

3420
02:02:57,720 --> 02:03:00,520
let me go ahead and make upper case in my terminal window.

3421
02:03:01,000 --> 02:03:01,560
uppercase.

3422
02:03:01,799 --> 02:03:02,729
Let's type in my

3423
02:03:03,200 --> 02:03:04,629
name all lower case

3424
02:03:04,959 --> 02:03:05,479
and I get back,

3425
02:03:05,600 --> 02:03:05,919
David,

3426
02:03:06,000 --> 02:03:06,149
uh,

3427
02:03:06,439 --> 02:03:07,310
minor bug,

3428
02:03:07,879 --> 02:03:08,990
couple bugs actually.

3429
02:03:09,200 --> 02:03:10,799
Let me fix my spacing.

3430
02:03:10,879 --> 02:03:13,189
I think I want another space after the word after,

3431
02:03:13,240 --> 02:03:14,959
and at the very bottom of my program,

3432
02:03:15,000 --> 02:03:15,720
I think I want

3433
02:03:15,959 --> 02:03:17,040
a backslash n.

3434
02:03:17,680 --> 02:03:18,189
Now

3435
02:03:18,399 --> 02:03:19,299
let's rerun

3436
02:03:19,560 --> 02:03:23,589
uh make on uppercase uppercase enter DAVID and now

3437
02:03:24,120 --> 02:03:26,109
it's forcing it all to uppercase.

3438
02:03:26,240 --> 02:03:26,520
Meanwhile,

3439
02:03:26,560 --> 02:03:29,149
if I do it once more and type in name capitalized,

3440
02:03:29,439 --> 02:03:33,410
it's still gonna force everything else to uppercase Questions.

3441
02:03:35,930 --> 02:03:36,109
Oh,

3442
02:03:36,120 --> 02:03:36,609
I'm an idiot.

3443
02:03:36,640 --> 02:03:36,919
OK,

3444
02:03:36,939 --> 02:03:37,560
thank you.

3445
02:03:38,620 --> 02:03:38,970
Yes,

3446
02:03:39,100 --> 02:03:39,500
uh,

3447
02:03:39,779 --> 02:03:40,939
I misspelled after,

3448
02:03:41,020 --> 02:03:42,259
otherwise my aligning,

3449
02:03:42,540 --> 02:03:43,500
my alignment would have worked.

3450
02:03:43,580 --> 02:03:44,339
So let's do this again,

3451
02:03:44,500 --> 02:03:45,209
make uppercase,

3452
02:03:45,220 --> 02:03:47,029
if only so that we can prove

3453
02:03:47,399 --> 02:03:48,330
it's the same,

3454
02:03:48,620 --> 02:03:49,819
DAVID and all lower case,

3455
02:03:49,830 --> 02:03:50,580
and there we go.

3456
02:03:50,700 --> 02:03:51,450
That was thank you,

3457
02:03:51,459 --> 02:03:52,100
the intent.

3458
02:03:52,790 --> 02:03:52,959
Alright,

3459
02:03:53,149 --> 02:03:54,279
so it's kind of a little trick,

3460
02:03:54,290 --> 02:03:55,709
but this is kind of tedious,

3461
02:03:55,750 --> 02:03:55,870
right?

3462
02:03:55,970 --> 02:03:56,830
Like Microsoft Word,

3463
02:03:56,910 --> 02:03:59,790
Google Docs all have the ability to toggle case from

3464
02:03:59,790 --> 02:04:01,709
uppercase to lower case or lower case to uppercase.

3465
02:04:01,750 --> 02:04:04,399
It's kind of annoying that you have to write this much code to achieve something so

3466
02:04:04,790 --> 02:04:05,259
simple,

3467
02:04:05,390 --> 02:04:06,859
seemingly and so commonplace.

3468
02:04:06,990 --> 02:04:07,109
Well,

3469
02:04:07,149 --> 02:04:09,109
it turns out there's a better approach here.

3470
02:04:09,765 --> 02:04:12,115
In addition to there being the string library,

3471
02:04:12,285 --> 02:04:14,075
there's also the C-type library.

3472
02:04:14,125 --> 02:04:15,475
In Cype.H,

3473
02:04:15,765 --> 02:04:16,555
another header file,

3474
02:04:16,674 --> 02:04:20,555
there's a whole bunch of other functions that are useful that relate to characters,

3475
02:04:20,794 --> 02:04:21,375
uh,

3476
02:04:21,404 --> 02:04:22,084
characters,

3477
02:04:22,165 --> 02:04:22,395
uh,

3478
02:04:22,404 --> 02:04:23,165
in AI.

3479
02:04:23,765 --> 02:04:24,404
So for instance,

3480
02:04:24,444 --> 02:04:25,714
if we go ahead and use this.

3481
02:04:26,209 --> 02:04:26,810
As follows,

3482
02:04:26,890 --> 02:04:29,060
I'm going to go ahead at the top of my file here

3483
02:04:29,290 --> 02:04:30,359
and include now C.

3484
02:04:31,129 --> 02:04:31,330
H.

3485
02:04:31,609 --> 02:04:34,689
It turns out there's going to be functions via

3486
02:04:34,689 --> 02:04:37,720
which I can actually ask these questions myself.

3487
02:04:37,930 --> 02:04:38,540
For instance,

3488
02:04:38,609 --> 02:04:40,080
in this next version of the program,

3489
02:04:40,250 --> 02:04:43,839
I don't need to do any of this clever but pretty verbose

3490
02:04:44,140 --> 02:04:44,700
math.

3491
02:04:44,890 --> 02:04:45,879
I can just say

3492
02:04:46,209 --> 02:04:48,490
if the is lower function,

3493
02:04:48,529 --> 02:04:51,879
which comes from the CType library passing in SI,

3494
02:04:52,240 --> 02:04:53,200
returns true,

3495
02:04:53,450 --> 02:04:54,850
will then convert.

3496
02:04:55,203 --> 02:04:58,743
The letter to lower uppercase by subtracting 32,

3497
02:04:58,783 --> 02:05:01,933
but you know I don't even need to do this mental math or math in code.

3498
02:05:02,103 --> 02:05:07,223
I can also from the CT type library use a function called 2 upper which takes

3499
02:05:07,223 --> 02:05:13,013
as input a character like SI and let someone else's function do the work for me.

3500
02:05:13,223 --> 02:05:15,533
So let me go back down to my terminal window here.

3501
02:05:15,823 --> 02:05:20,573
Let me make uppercase now uppercase enter before DAVID.

3502
02:05:20,823 --> 02:05:22,002
This now works too.

3503
02:05:22,103 --> 02:05:23,743
But if I really dig into the documentation.

3504
02:05:23,846 --> 02:05:25,036
And for the CType library,

3505
02:05:25,076 --> 02:05:25,976
you'll see that

3506
02:05:26,195 --> 02:05:29,596
you can just use the is lower function on any character and

3507
02:05:29,596 --> 02:05:33,675
it will very intelligently only uppercase it if it is actually lowercase.

3508
02:05:33,875 --> 02:05:37,235
So someone else years ago wrote the conditional code that

3509
02:05:37,235 --> 02:05:40,096
checks if it's between little a and little Z.

3510
02:05:40,315 --> 02:05:41,425
So knowing this,

3511
02:05:41,675 --> 02:05:43,465
and you would see that indeed in the documentation,

3512
02:05:43,605 --> 02:05:44,866
I don't even need this else.

3513
02:05:45,315 --> 02:05:48,866
I can instead just get rid of this whole conditional,

3514
02:05:48,996 --> 02:05:51,266
tighten my code up significantly here,

3515
02:05:51,476 --> 02:05:52,686
and simply say.

3516
02:05:53,200 --> 02:05:55,109
Print F using percent C,

3517
02:05:55,319 --> 02:05:57,959
the two upper version of that same letter and

3518
02:05:57,959 --> 02:06:00,839
let the function itself realize if it's uppercase,

3519
02:06:00,959 --> 02:06:01,959
pass it through unchanged,

3520
02:06:02,040 --> 02:06:02,850
if it's lowercase,

3521
02:06:03,000 --> 02:06:03,910
change it first

3522
02:06:04,240 --> 02:06:05,149
and then return it.

3523
02:06:05,319 --> 02:06:07,850
So now if I open my terminal window again and clear it,

3524
02:06:08,160 --> 02:06:11,790
make uppercase uppercase enter DAVID,

3525
02:06:11,959 --> 02:06:13,149
and we're back in business.

3526
02:06:13,279 --> 02:06:13,560
So again,

3527
02:06:13,640 --> 02:06:17,359
demonstrative of how if you find that coding is becoming tedious or

3528
02:06:17,359 --> 02:06:19,910
you're solving a problem that like surely someone else has solved,

3529
02:06:20,120 --> 02:06:21,919
odds are there is in fact.

3530
02:06:21,995 --> 02:06:25,734
A library function for whether it's from CS 50 or from the standard library

3531
02:06:25,984 --> 02:06:27,654
that you yourselves can use.

3532
02:06:28,104 --> 02:06:29,825
And unlike the CS 50 library,

3533
02:06:29,935 --> 02:06:32,035
which is indeed CS50 specific,

3534
02:06:32,185 --> 02:06:35,535
which is why Klang needed to know about L CS 50,

3535
02:06:35,865 --> 02:06:38,424
many of these libraries just automatically work.

3536
02:06:38,464 --> 02:06:40,975
You don't need to link in the C-type library.

3537
02:06:40,984 --> 02:06:43,095
You don't need to link in other libraries,

3538
02:06:43,555 --> 02:06:47,345
but non-standard libraries like CS 50's training wheels for the first few weeks,

3539
02:06:47,584 --> 02:06:48,785
we do need to do that.

3540
02:06:48,904 --> 02:06:50,944
But Ma is configured to do all of that.

3541
02:06:51,479 --> 02:06:52,390
Automatically

3542
02:06:52,600 --> 02:06:53,149
for you.

3543
02:06:54,709 --> 02:06:54,729
All right,

3544
02:06:55,899 --> 02:06:58,209
in our final minutes together,

3545
02:06:58,299 --> 02:07:01,459
let's go ahead now and reveal some of the details we've been

3546
02:07:03,299 --> 02:07:04,819
sweeping under the rug about Maine.

3547
02:07:04,899 --> 02:07:08,979
I asked on week one that you just sort of take on faith that you got to do the void,

3548
02:07:09,140 --> 02:07:09,859
you got to do the end,

3549
02:07:09,899 --> 02:07:10,680
you got to do the void,

3550
02:07:10,689 --> 02:07:11,450
and all of that.

3551
02:07:11,620 --> 02:07:11,669
Well,

3552
02:07:11,740 --> 02:07:13,169
let's see why that actually is.

3553
02:07:13,259 --> 02:07:15,450
So Maine is special insofar as in C,

3554
02:07:15,660 --> 02:07:18,299
it is the function that will be called automatically

3555
02:07:18,299 --> 02:07:20,979
after you've compiled and then run your code just.

3556
02:07:21,109 --> 02:07:23,540
Because not all languages standardize the name of the function,

3557
02:07:23,709 --> 02:07:27,410
but C and C++ and Java and certain other ones do in this case.

3558
02:07:27,750 --> 02:07:29,410
Here is the most canonical,

3559
02:07:29,430 --> 02:07:30,990
simple form of Maine.

3560
02:07:31,350 --> 02:07:34,750
We know that including standardio.h just gives us access

3561
02:07:34,750 --> 02:07:36,879
to the prototypes for functions like print F.

3562
02:07:37,189 --> 02:07:40,979
But what's going on with IT and what's going on with void?

3563
02:07:41,029 --> 02:07:41,089
Well,

3564
02:07:41,189 --> 02:07:43,950
void in parenthesis here just means that Maine,

3565
02:07:44,029 --> 02:07:47,350
and in turn all of the programs we've written up until this moment.

3566
02:07:47,740 --> 02:07:49,910
Do not take command line arguments.

3567
02:07:50,060 --> 02:07:51,779
Literally every program we've written out,

3568
02:07:54,069 --> 02:07:54,540
hello,

3569
02:07:54,799 --> 02:07:55,700
scores,

3570
02:07:56,700 --> 02:07:57,120
everything else,

3571
02:07:57,419 --> 02:08:00,580
I have never once typed another word after the

3572
02:08:00,580 --> 02:08:02,810
name of our programs that we've written in class.

3573
02:08:03,060 --> 02:08:05,930
That is because every program has void

3574
02:08:05,930 --> 02:08:08,250
inside of these parentheses telling the computer

3575
02:08:08,540 --> 02:08:11,520
this program does not take command line arguments,

3576
02:08:11,580 --> 02:08:13,020
words after the programs.

3577
02:08:13,120 --> 02:08:18,419
Name that is different from make and code and CD and other commands

3578
02:08:18,419 --> 02:08:22,410
that you've typed with words after them their names at the prompt,

3579
02:08:22,620 --> 02:08:28,250
but it turns out the other supported syntax for the main function in C

3580
02:08:28,500 --> 02:08:29,540
can look like this too,

3581
02:08:29,620 --> 02:08:31,649
which at a glance looks like kind of a mouthful,

3582
02:08:31,819 --> 02:08:36,149
but it just means that Ma can take zero arguments or it can take 2.

3583
02:08:36,419 --> 02:08:37,529
If it takes 2,

3584
02:08:37,740 --> 02:08:38,580
the first.

3585
02:08:39,129 --> 02:08:40,339
is an integer

3586
02:08:40,609 --> 02:08:43,770
and the second is an array of strings.

3587
02:08:43,930 --> 02:08:48,080
By convention those inputs are called RC and RV.

3588
02:08:48,250 --> 02:08:52,310
RC is the count of arguments that are typed after the after the program's name.

3589
02:08:52,569 --> 02:08:54,049
RV is the argument vector,

3590
02:08:54,169 --> 02:08:56,959
AKA array of actual words.

3591
02:08:56,970 --> 02:08:57,450
In other words,

3592
02:08:57,490 --> 02:09:00,490
now that we have the ability to use arrays,

3593
02:09:00,640 --> 02:09:05,160
we can get 0 or 1 or 2 or 3 or more words from users.

3594
02:09:05,672 --> 02:09:08,462
The prompt when they run our own programs.

3595
02:09:08,583 --> 02:09:09,953
So what do I mean by this?

3596
02:09:10,183 --> 02:09:14,502
We can now write programs that actually have command line arguments as follows.

3597
02:09:14,542 --> 02:09:16,772
Let me go into BS code here and close our

3598
02:09:17,062 --> 02:09:18,333
old program uppercase.

3599
02:09:18,583 --> 02:09:20,803
Let's write a new simpler program here

3600
02:09:21,062 --> 02:09:26,053
in my terminal called greet.c and just greet the user in a couple of different ways.

3601
02:09:26,143 --> 02:09:28,022
So I'm going to include initially CS50.

3602
02:09:28,433 --> 02:09:28,493
H,

3603
02:09:28,502 --> 02:09:31,573
and then I'm going to include standardio.h here.

3604
02:09:31,862 --> 02:09:35,706
Then I'm going to Say in main void without introducing anything new just yet.

3605
02:09:35,956 --> 02:09:40,866
I'm going to ask the user like we did last week for a return value from Get string,

3606
02:09:41,116 --> 02:09:43,166
asking them what's your name,

3607
02:09:43,215 --> 02:09:44,666
as we've done so many times.

3608
02:09:44,835 --> 02:09:51,105
Then I'm going to say print hello com persn spitting out their answer as follows.

3609
02:09:51,155 --> 02:09:52,826
Same program as last week again.

3610
02:09:52,996 --> 02:09:54,036
I'm going to make greet.

3611
02:09:54,275 --> 02:09:55,746
I'm going to say greet,

3612
02:09:55,786 --> 02:09:57,866
and I'm prompted now for my name.

3613
02:09:58,116 --> 02:09:58,795
I hit enter.

3614
02:09:59,740 --> 02:10:02,700
Notice that I did not take any command line arguments.

3615
02:10:02,779 --> 02:10:05,759
The only command Iran was greet,

3616
02:10:06,060 --> 02:10:07,259
no other words.

3617
02:10:07,419 --> 02:10:11,459
Let's now use this new trick and actually let the user type their name when

3618
02:10:11,459 --> 02:10:13,459
they're running my program rather than waste their

3619
02:10:13,459 --> 02:10:15,450
time by using Getstring and prompting them.

3620
02:10:15,700 --> 02:10:16,970
Let me go into

3621
02:10:17,259 --> 02:10:18,209
my editor here.

3622
02:10:18,379 --> 02:10:20,209
Let's get rid of the CS 50 library.

3623
02:10:20,419 --> 02:10:22,299
Let's get rid of my use of Getstring.

3624
02:10:22,959 --> 02:10:27,339
And let's simply change void to in RGC,

3625
02:10:27,649 --> 02:10:29,890
then string RGV open

3626
02:10:30,569 --> 02:10:31,799
open bracket close bracket.

3627
02:10:31,990 --> 02:10:32,680
That's all.

3628
02:10:33,049 --> 02:10:33,879
Down here,

3629
02:10:34,129 --> 02:10:35,540
let's simply print out

3630
02:10:35,970 --> 02:10:39,600
RGV 1 for reasons we'll soon see.

3631
02:10:39,979 --> 02:10:44,149
The only change that I'm making really is changing the prototype for Maine

3632
02:10:44,439 --> 02:10:45,339
from the first version,

3633
02:10:45,350 --> 02:10:47,500
which we've been using for like a week and a bit now,

3634
02:10:47,790 --> 02:10:48,819
to the second version,

3635
02:10:48,870 --> 02:10:50,779
which is the only other version supported.

3636
02:10:50,950 --> 02:10:53,100
I'm gonna go back to my terminal window now,

3637
02:10:53,419 --> 02:10:54,830
make greet,

3638
02:10:55,189 --> 02:10:55,580
and

3639
02:10:56,430 --> 02:10:57,129
darn it,

3640
02:10:57,549 --> 02:10:58,979
I shouldn't so close.

3641
02:11:00,160 --> 02:11:00,890
Why did I make,

3642
02:11:01,000 --> 02:11:01,490
uh,

3643
02:11:01,640 --> 02:11:03,509
how do I fix the mistake I accidentally made?

3644
02:11:04,120 --> 02:11:04,200
Yeah,

3645
02:11:04,319 --> 02:11:04,799
and back.

3646
02:11:05,490 --> 02:11:05,709
Oh,

3647
02:11:05,759 --> 02:11:05,830
no,

3648
02:11:05,910 --> 02:11:06,339
in front.

3649
02:11:08,910 --> 02:11:09,180
Yes,

3650
02:11:09,299 --> 02:11:11,220
I should have kept the CS 50 library because it's

3651
02:11:11,220 --> 02:11:14,180
in the CS 50 library that string is defined,

3652
02:11:14,220 --> 02:11:15,379
so includes CS50.

3653
02:11:16,290 --> 02:11:19,209
H in week 4 we will delete that line for real

3654
02:11:19,419 --> 02:11:21,379
and actually show you what string actually is.

3655
02:11:21,459 --> 02:11:24,459
I promised at the start of class that string is a term of art,

3656
02:11:24,540 --> 02:11:25,990
but it's not a keyword in C,

3657
02:11:26,339 --> 02:11:28,450
but it will see what it means in a couple of weeks' time.

3658
02:11:28,560 --> 02:11:28,740
OK,

3659
02:11:28,859 --> 02:11:29,490
let me fix this.

3660
02:11:29,589 --> 02:11:31,939
Make greet.greet,

3661
02:11:32,060 --> 02:11:33,990
but now I'm going to type before.

3662
02:11:34,044 --> 02:11:35,944
I even hit enter my actual name,

3663
02:11:36,154 --> 02:11:37,424
and when I hit enter now,

3664
02:11:37,674 --> 02:11:38,384
I see

3665
02:11:38,634 --> 02:11:39,955
hello David.

3666
02:11:40,075 --> 02:11:42,225
If I instead do greet Kelly,

3667
02:11:42,395 --> 02:11:42,895
enter,

3668
02:11:43,115 --> 02:11:45,225
now I see hello Kelly.

3669
02:11:45,274 --> 02:11:47,654
If I do nothing like greet enter,

3670
02:11:47,915 --> 02:11:49,154
I just see hello null,

3671
02:11:49,234 --> 02:11:51,404
which is not the same null as before NUL.

3672
02:11:51,475 --> 02:11:54,354
This is NULL for reasons we'll come back to before long,

3673
02:11:54,515 --> 02:11:56,794
but clearly Pri F knows something's going on.

3674
02:11:56,875 --> 02:11:59,035
There's no actual word there.

3675
02:11:59,740 --> 02:12:00,359
Why though,

3676
02:12:00,540 --> 02:12:02,259
did I do RV1?

3677
02:12:02,370 --> 02:12:02,500
Well,

3678
02:12:02,540 --> 02:12:05,359
it turns out that just as a feature of C,

3679
02:12:05,620 --> 02:12:08,770
if I recompile this program and do slash greet

3680
02:12:09,319 --> 02:12:09,959
and

3681
02:12:10,299 --> 02:12:11,509
type in

3682
02:12:11,859 --> 02:12:12,850
nothing else,

3683
02:12:13,419 --> 02:12:15,020
I'm gonna see something kind of curious.

3684
02:12:15,560 --> 02:12:16,040
Hello.

3685
02:12:16,870 --> 02:12:20,339
greet because automatically the zero location

3686
02:12:20,669 --> 02:12:25,060
in the RVR variable will automatically contain the program's own name.

3687
02:12:25,149 --> 02:12:25,950
Why is this useful?

3688
02:12:26,029 --> 02:12:27,029
If you ever want to do something

3689
02:12:27,029 --> 02:12:29,669
self-referential like thanks for running my program or

3690
02:12:29,669 --> 02:12:32,859
you want to show documentation for your program and the name of your program,

3691
02:12:32,950 --> 02:12:36,180
that it depends on whatever the file itself is called,

3692
02:12:36,350 --> 02:12:38,069
you can use RV 0,

3693
02:12:38,080 --> 02:12:41,799
which will always contain the program's name no matter what the file.

3694
02:12:41,970 --> 02:12:44,089
Has been named or renamed to,

3695
02:12:44,339 --> 02:12:46,620
but we can fix that null issue now in a couple of ways.

3696
02:12:46,660 --> 02:12:49,330
So RC is the other input that I said now can exist,

3697
02:12:49,459 --> 02:12:51,529
which is the count of arguments at the prompt.

3698
02:12:51,700 --> 02:12:53,700
So if I want to check if the user actually typed their name,

3699
02:12:53,779 --> 02:12:57,250
I could say something like if R C equals equals 2,

3700
02:12:57,500 --> 02:13:01,180
well then and only then go ahead and print out their

3701
02:13:01,180 --> 02:13:04,589
name else let's just do some clever default like print F,

3702
02:13:04,979 --> 02:13:06,899
quote unquote hello world or heck,

3703
02:13:06,939 --> 02:13:07,770
nothing at all.

3704
02:13:07,979 --> 02:13:08,140
This.

3705
02:13:08,259 --> 02:13:10,490
Version of the program now is a little smarter because when

3706
02:13:10,490 --> 02:13:12,970
I run Make greet and do greed of my name,

3707
02:13:13,200 --> 02:13:14,609
it works exactly as intended.

3708
02:13:14,770 --> 02:13:17,000
But if I forget and only do greed,

3709
02:13:17,209 --> 02:13:18,410
it's going to say hello world.

3710
02:13:18,569 --> 02:13:18,850
Moreover,

3711
02:13:18,930 --> 02:13:21,089
if I don't quite cooperate and I say David Malan,

3712
02:13:21,410 --> 02:13:21,899
enter,

3713
02:13:22,089 --> 02:13:26,049
it similarly just ignores me because our count is not 2 anymore.

3714
02:13:26,290 --> 02:13:27,569
It's now 3.

3715
02:13:27,810 --> 02:13:31,379
So RC contains the total numbers of words at the prompt,

3716
02:13:31,600 --> 02:13:34,490
but the first one is always the program's name.

3717
02:13:35,419 --> 02:13:35,830
Question.

3718
02:13:38,529 --> 02:13:38,970
Why do you

3719
02:13:45,939 --> 02:13:46,080
Sorry,

3720
02:13:46,140 --> 02:13:47,529
can you say that once a little louder?

3721
02:13:56,959 --> 02:13:58,479
Why is it information that we just have,

3722
02:13:58,560 --> 02:13:59,479
or?

3723
02:14:06,660 --> 02:14:07,000
Oh,

3724
02:14:07,250 --> 02:14:09,290
so the short answer is just because,

3725
02:14:09,330 --> 02:14:11,100
like the definition of C,

3726
02:14:11,129 --> 02:14:12,810
if you look at the documentation for C,

3727
02:14:13,009 --> 02:14:17,479
you can either define Maine as taking no arguments with the word void,

3728
02:14:17,890 --> 02:14:20,720
or you can specify that Ma can take two arguments,

3729
02:14:20,729 --> 02:14:25,399
and the compiler and the operating system will just ensure that if you provide two,

3730
02:14:25,689 --> 02:14:26,879
those two variables,

3731
02:14:26,930 --> 02:14:31,370
RC and RV will be filled with those two values automatically.

3732
02:14:33,009 --> 02:14:35,589
Someone else decided that though that's just the way it works.

3733
02:14:35,649 --> 02:14:36,330
You can't come up,

3734
02:14:36,370 --> 02:14:37,330
you can't put 3 there,

3735
02:14:37,370 --> 02:14:38,290
you can't put 4 there,

3736
02:14:38,410 --> 02:14:40,080
you can change the names of those variables,

3737
02:14:40,089 --> 02:14:41,129
but not the types.

3738
02:14:42,129 --> 02:14:43,250
Because of this convention.

3739
02:14:43,450 --> 02:14:45,520
So there's one last feature of Maine then.

3740
02:14:45,609 --> 02:14:47,490
It's the actual value with returns.

3741
02:14:47,609 --> 02:14:48,149
Up until now,

3742
02:14:48,169 --> 02:14:51,479
every program I've written starts with in Ma something.

3743
02:14:51,529 --> 02:14:52,410
I mean something.

3744
02:14:52,419 --> 02:14:53,089
What is that in?

3745
02:14:53,129 --> 02:14:54,160
We have yet to use it.

3746
02:14:54,450 --> 02:14:55,160
Technically,

3747
02:14:55,290 --> 02:14:58,529
the value that Maine returns is going to be called a so-called exit status,

3748
02:14:58,540 --> 02:15:01,359
which is a numeric status that indicates success or failure.

3749
02:15:01,609 --> 02:15:03,370
Numbers are everywhere in the world of computing.

3750
02:15:03,410 --> 02:15:03,810
So for instance,

3751
02:15:03,850 --> 02:15:05,430
here's a screenshot from Zoom whereby

3752
02:15:05,549 --> 02:15:06,540
Something goes wrong with Zoom,

3753
02:15:06,580 --> 02:15:08,810
like you have bad internet connectivity or something like that,

3754
02:15:08,939 --> 02:15:11,370
you might see an error code like 1132.

3755
02:15:11,509 --> 02:15:14,479
That means nothing to normal people unless you Google it,

3756
02:15:14,500 --> 02:15:15,490
look up the documentation,

3757
02:15:15,580 --> 02:15:17,029
but it means something very much

3758
02:15:17,259 --> 02:15:19,830
to the software engineers who wrote this code because they know,

3759
02:15:19,899 --> 02:15:20,419
oh shoot,

3760
02:15:20,470 --> 02:15:22,540
1132 means this error,

3761
02:15:22,549 --> 02:15:24,660
and they probably have a spreadsheet or a cheat sheet somewhere

3762
02:15:24,660 --> 02:15:28,229
that converts those codes to actually useful error messages and frankly,

3763
02:15:28,299 --> 02:15:29,020
in a better world.

3764
02:15:29,229 --> 02:15:31,310
They would just tell you what the problem is rather

3765
02:15:31,310 --> 02:15:33,620
than just say report the problem and mention this number.

3766
02:15:33,790 --> 02:15:34,819
That said on the web,

3767
02:15:35,149 --> 02:15:37,109
odds are you're familiar with this number 404,

3768
02:15:37,149 --> 02:15:39,810
which is also a weird thing for so many normal people to know,

3769
02:15:39,870 --> 02:15:41,509
but this generally means file not found.

3770
02:15:41,629 --> 02:15:44,200
It's a numeric code that signifies that something has gone wrong.

3771
02:15:44,479 --> 02:15:46,140
Exit status isn't quite this,

3772
02:15:46,189 --> 02:15:47,459
but it's similar in spirit.

3773
02:15:47,629 --> 02:15:48,279
In Maine,

3774
02:15:48,509 --> 02:15:52,470
you can return a value like 0 or 1 or 2 or something else.

3775
02:15:52,660 --> 02:15:55,240
to indicate whether something was successful or not.

3776
02:15:55,319 --> 02:15:56,109
By convention,

3777
02:15:56,319 --> 02:15:56,799
a program,

3778
02:15:56,839 --> 02:15:58,750
a function like main returns 0

3779
02:15:59,080 --> 02:16:01,109
on success if all is well,

3780
02:16:01,319 --> 02:16:03,750
and that leaves you then with like several 100

3781
02:16:04,080 --> 02:16:07,839
possible things that can go wrong because you could return 1 to signify one thing,

3782
02:16:08,120 --> 02:16:09,120
2 to return another,

3783
02:16:09,160 --> 02:16:10,240
3 to signify another,

3784
02:16:10,250 --> 02:16:12,629
and so long as you have a spreadsheet or a cheat sheet or something,

3785
02:16:12,759 --> 02:16:16,040
you can just keep track as the programmer as to what error means what.

3786
02:16:16,450 --> 02:16:18,129
So what does this mean in real terms?

3787
02:16:18,209 --> 02:16:18,250
Well,

3788
02:16:18,290 --> 02:16:19,839
if I go over to VS code here,

3789
02:16:20,049 --> 02:16:22,359
let me implement a relatively simple program,

3790
02:16:22,450 --> 02:16:24,689
our last called Status.c.

3791
02:16:25,129 --> 02:16:26,799
So in status.c,

3792
02:16:27,250 --> 02:16:29,020
I'm going to go ahead and use

3793
02:16:29,250 --> 02:16:31,200
the CS 50 library at the top,

3794
02:16:31,330 --> 02:16:33,599
the standard IO library at the top,

3795
02:16:33,849 --> 02:16:36,250
and then inside of Int Main

3796
02:16:36,610 --> 02:16:38,769
and with our new format.

3797
02:16:39,115 --> 02:16:45,945
RC string arg square brackets inside of main I'm going to now do the following.

3798
02:16:46,235 --> 02:16:46,554
If

3799
02:16:46,674 --> 02:16:49,544
RGC does not equal 2,

3800
02:16:49,915 --> 02:16:52,355
then I'm going to go ahead and print out this time a warning.

3801
02:16:52,365 --> 02:16:54,544
I'm not going to have some silly default like he world.

3802
02:16:54,674 --> 02:16:57,105
Let's tell the user that they didn't use my program correct,

3803
02:16:57,155 --> 02:17:01,424
and I'm going to say print F missing command line argument.

3804
02:17:01,977 --> 02:17:03,619
And we'll assume they know what that means.

3805
02:17:04,008 --> 02:17:04,329
Then

3806
02:17:04,529 --> 02:17:05,648
to signify an error,

3807
02:17:05,727 --> 02:17:07,199
I'm going to say return 1.

3808
02:17:07,329 --> 02:17:08,018
It could be 2,

3809
02:17:08,048 --> 02:17:08,758
it could be 3,

3810
02:17:08,808 --> 02:17:10,128
but this is the first possible error,

3811
02:17:10,168 --> 02:17:11,758
so I'm going to start simple with 1.

3812
02:17:12,088 --> 02:17:12,958
Otherwise,

3813
02:17:13,249 --> 02:17:14,758
if RXC does equal 2,

3814
02:17:14,768 --> 02:17:16,718
and I get to this part of my code,

3815
02:17:16,928 --> 02:17:23,239
I'm going to say hello SN and pass in RV 1 just like before.

3816
02:17:23,289 --> 02:17:25,579
And just to be super specific,

3817
02:17:25,648 --> 02:17:27,892
I'm going Return 0 to tell the computer,

3818
02:17:27,983 --> 02:17:29,132
the operating system,

3819
02:17:29,222 --> 02:17:30,252
that this is success.

3820
02:17:30,462 --> 02:17:31,852
0 signifies success.

3821
02:17:32,142 --> 02:17:34,182
Any other value signifies error.

3822
02:17:34,323 --> 02:17:35,653
Let's make status now.

3823
02:17:35,903 --> 02:17:37,333
Let's do status,

3824
02:17:37,382 --> 02:17:38,862
and this is a little magical,

3825
02:17:38,942 --> 02:17:40,493
but let me go ahead and

3826
02:17:40,743 --> 02:17:42,212
cooperate initially.

3827
02:17:42,302 --> 02:17:44,132
I'm going to type in my name David

3828
02:17:44,262 --> 02:17:46,452
and I'm going to see hello David.

3829
02:17:47,022 --> 02:17:48,063
Most people wouldn't know this,

3830
02:17:48,163 --> 02:17:51,896
but among the commands you can type at your Terminal are this one here

3831
02:17:51,896 --> 02:17:54,946
and the TFs and the TAs and I would do something like this.

3832
02:17:55,196 --> 02:17:55,434
We,

3833
02:17:55,456 --> 02:17:56,625
after running your code,

3834
02:17:56,754 --> 02:17:57,575
can do echo,

3835
02:17:57,736 --> 02:17:57,956
space,

3836
02:17:58,036 --> 02:17:59,264
dollar sign question mark,

3837
02:17:59,555 --> 02:18:05,786
and we can see secretly the return value that your program returned 0 in this case.

3838
02:18:06,116 --> 02:18:06,555
Meanwhile,

3839
02:18:06,635 --> 02:18:07,725
if we do this again,

3840
02:18:08,135 --> 02:18:09,264
status

3841
02:18:10,875 --> 02:18:11,504
status,

3842
02:18:11,635 --> 02:18:14,135
and let me not type my name this time.

3843
02:18:14,594 --> 02:18:15,504
When I do this,

3844
02:18:15,715 --> 02:18:17,486
I see missing command line argument.

3845
02:18:17,514 --> 02:18:19,514
What value should the code have returned then?

3846
02:18:20,429 --> 02:18:20,750
One,

3847
02:18:20,950 --> 02:18:21,660
so let's see,

3848
02:18:21,750 --> 02:18:23,500
echo dollar sign question mark,

3849
02:18:23,799 --> 02:18:24,860
there's the one.

3850
02:18:25,030 --> 02:18:26,790
So even after just one week of CS 50,

3851
02:18:26,799 --> 02:18:30,580
if you've ever wondered how Check 50 knows if your code was correct or not,

3852
02:18:30,950 --> 02:18:35,230
among the ways we check for that is by checking the semi-secret status code,

3853
02:18:35,308 --> 02:18:36,150
this exit status,

3854
02:18:36,160 --> 02:18:36,388
which is.

3855
02:18:36,504 --> 02:18:37,315
really a secret.

3856
02:18:37,415 --> 02:18:39,865
It's just not displayed to normal people because it's not all that

3857
02:18:39,865 --> 02:18:43,735
enlightening unless you're the software developer who wrote the code in question.

3858
02:18:43,905 --> 02:18:45,945
But this means we could return one in some cases or

3859
02:18:45,945 --> 02:18:49,683
2 in other cases or 3 or 4 and yet others.

3860
02:18:49,775 --> 02:18:52,665
And these command line arguments are sort of everywhere and in fact.

3861
02:18:53,208 --> 02:18:55,477
A program I skipped over a moment ago was going to be this.

3862
02:18:55,689 --> 02:18:58,449
There's no academic value to what you're about to see,

3863
02:18:58,529 --> 02:18:58,958
but

3864
02:18:59,609 --> 02:19:03,039
another program that takes command line arguments is known as CAOSay,

3865
02:19:03,048 --> 02:19:04,689
and this is sort of very famous in computing

3866
02:19:04,689 --> 02:19:06,758
circles because it's been on systems for many years.

3867
02:19:07,098 --> 02:19:12,159
CASay is a program that allows you to type in a word after the prompt like moo,

3868
02:19:12,499 --> 02:19:14,659
and it will print out what's called Askki Art,

3869
02:19:14,727 --> 02:19:17,138
an adorable little cow with a speech bubble that says moo,

3870
02:19:17,189 --> 02:19:19,048
so kind of evocative of like scratch.

3871
02:19:19,535 --> 02:19:21,195
But it takes other command line arguments,

3872
02:19:21,285 --> 02:19:23,504
not just the words that you want to come out of its mouth,

3873
02:19:23,794 --> 02:19:26,235
but even the appearance that you want it to have.

3874
02:19:26,315 --> 02:19:27,065
So for instance,

3875
02:19:27,195 --> 02:19:30,525
I can say dash F duck and

3876
02:19:30,714 --> 02:19:32,144
run it again enter,

3877
02:19:32,275 --> 02:19:34,405
and now I have a little cute duck saying mu,

3878
02:19:34,433 --> 02:19:35,384
which is a bit of a bug.

3879
02:19:35,433 --> 02:19:38,504
So let me change that to quack for instance instead.

3880
02:19:38,724 --> 02:19:38,915
And again,

3881
02:19:38,995 --> 02:19:40,065
no academic value here.

3882
02:19:40,075 --> 02:19:42,224
It's just fun to now play with the various options.

3883
02:19:42,275 --> 02:19:43,985
But if we really want to have fun with this,

3884
02:19:43,995 --> 02:19:44,834
we can do another one,

3885
02:19:44,955 --> 02:19:45,115
so.

3886
02:19:45,330 --> 02:19:50,120
I say dragon and we can say something like R and

3887
02:19:50,120 --> 02:19:53,009
now we have this crazy dragon appearing on the screen,

3888
02:19:53,219 --> 02:19:54,250
which is to say

3889
02:19:54,580 --> 02:19:54,700
again,

3890
02:19:54,820 --> 02:19:55,650
no value here.

3891
02:19:55,860 --> 02:19:58,139
It's just fun to play with command line arguments

3892
02:19:58,139 --> 02:20:00,059
sometimes and how is CO say doing this?

3893
02:20:00,099 --> 02:20:00,259
Well,

3894
02:20:00,419 --> 02:20:04,820
someone wrote code maybe in C or some other language using RGC and RV

3895
02:20:04,820 --> 02:20:08,580
and poking around at their values and maybe a conditional that says if the

3896
02:20:08,900 --> 02:20:10,129
F value is dragon,

3897
02:20:10,339 --> 02:20:11,299
then print this graphic.

3898
02:20:11,415 --> 02:20:12,724
Else if the value is duck,

3899
02:20:12,804 --> 02:20:13,875
then print this other one,

3900
02:20:13,985 --> 02:20:16,804
it all boils down to the same fundamentals of week zero of

3901
02:20:16,804 --> 02:20:19,554
functions and conditionals and loops and boolean expressions and the like.

3902
02:20:19,724 --> 02:20:22,634
It's just being composed into more and more interesting things.

3903
02:20:22,844 --> 02:20:23,464
And indeed,

3904
02:20:23,525 --> 02:20:25,844
in closing among the other interesting things we'll play with

3905
02:20:25,844 --> 02:20:28,355
this week to come full circle is that of cryptography,

3906
02:20:28,365 --> 02:20:32,195
the art of scrambling information so as to have secure communication.

3907
02:20:32,325 --> 02:20:35,525
So important nowadays with passwords and credit card numbers

3908
02:20:35,525 --> 02:20:37,405
and personal messages that you might want to send.

3909
02:20:37,719 --> 02:20:40,030
And we'll have you explore through code some of

3910
02:20:40,030 --> 02:20:43,660
the algorithms via which you yourselves can encrypt information.

3911
02:20:43,809 --> 02:20:46,190
And there's a number of ways we can do this form of encryption,

3912
02:20:46,240 --> 02:20:48,019
and they all boil down to this mental model.

3913
02:20:48,150 --> 02:20:49,669
You've got some input like the message you want

3914
02:20:49,669 --> 02:20:52,089
to send and you want to encipher it somehow,

3915
02:20:52,150 --> 02:20:55,330
encrypt it somehow so that No one knows what message you've sent,

3916
02:20:55,509 --> 02:20:57,120
so you want your plain text,

3917
02:20:57,269 --> 02:21:00,179
which is the human readable version in English or any other language,

3918
02:21:00,410 --> 02:21:02,259
to become ciphertext ultimately.

3919
02:21:02,389 --> 02:21:04,509
So the code you'll be writing this week is

3920
02:21:04,509 --> 02:21:06,629
inside of this black box some kind of cipher,

3921
02:21:06,709 --> 02:21:08,870
an algorithm that encrypts information.

3922
02:21:09,150 --> 02:21:11,370
So that you can do exactly this.

3923
02:21:11,599 --> 02:21:15,019
Now the catch is that you can't just give it plain text and run it through an

3924
02:21:15,019 --> 02:21:18,150
algorithm and get ciphertext because you need to somehow

3925
02:21:18,150 --> 02:21:20,570
have a secret typically for encryption to work.

3926
02:21:20,740 --> 02:21:22,990
Like if I'm going to send a message to someone in back,

3927
02:21:23,179 --> 02:21:23,299
well,

3928
02:21:23,419 --> 02:21:26,019
I could just randomize the letters that I'm writing down,

3929
02:21:26,139 --> 02:21:28,740
but how would they know how to reverse that process?

3930
02:21:28,860 --> 02:21:30,849
Probably what we need to do is agree in advance that,

3931
02:21:30,860 --> 02:21:31,480
you know what,

3932
02:21:31,740 --> 02:21:33,299
I'm going to change every A to a B.

3933
02:21:33,435 --> 02:21:37,026
And every B to a C and a C to a D and a Z to an A.

3934
02:21:37,036 --> 02:21:39,385
I'll wrap back around at the end of the alphabet.

3935
02:21:39,545 --> 02:21:40,935
It's not very sophisticated,

3936
02:21:41,055 --> 02:21:45,255
but who no middle school teacher if they intercept two kids passing notes in class,

3937
02:21:45,425 --> 02:21:47,786
are going to waste time trying to figure out this cipher,

3938
02:21:47,866 --> 02:21:50,656
but it does presuppose that there's a secret between them,

3939
02:21:50,666 --> 02:21:51,826
the number one in that case,

3940
02:21:51,866 --> 02:21:54,616
because I'm changing every letter by one place.

3941
02:21:54,866 --> 02:21:55,826
So how might this work?

3942
02:21:55,866 --> 02:21:55,906
Well,

3943
02:21:55,946 --> 02:21:57,625
if I want to encrypt the word.

3944
02:21:57,791 --> 02:22:02,742
Him and my secret key with someone that I've come up with in advance is one,

3945
02:22:03,032 --> 02:22:06,582
I should send the cipher text IJ.

3946
02:22:07,671 --> 02:22:08,761
Now this is a simple cipher,

3947
02:22:08,832 --> 02:22:10,832
so I'm not really encrypting the punctuation,

3948
02:22:10,912 --> 02:22:12,232
which may or may not be a good thing,

3949
02:22:12,421 --> 02:22:14,982
but I am encrypting at least the alphabetical letters.

3950
02:22:15,152 --> 02:22:17,471
But what does the recipient then have to do to

3951
02:22:17,471 --> 02:22:20,211
decrypt this message when they see on paper IJ,

3952
02:22:20,912 --> 02:22:21,872
how do they know what I said?

3953
02:22:22,330 --> 02:22:22,450
Well,

3954
02:22:22,490 --> 02:22:23,599
they use that same key,

3955
02:22:23,769 --> 02:22:24,559
but subtract,

3956
02:22:24,690 --> 02:22:26,049
so B becomes A,

3957
02:22:26,250 --> 02:22:27,440
C becomes B,

3958
02:22:27,509 --> 02:22:28,450
A becomes Z,

3959
02:22:28,490 --> 02:22:29,209
and so forth,

3960
02:22:29,250 --> 02:22:31,250
essentially inverting the key from positive one.

3961
02:22:31,629 --> 02:22:32,570
To -1,

3962
02:22:32,740 --> 02:22:33,290
of course,

3963
02:22:33,500 --> 02:22:35,790
slightly more secure than

3964
02:22:36,259 --> 02:22:37,690
a cipher of 1.

3965
02:22:37,900 --> 02:22:39,490
A key of one would be 13.

3966
02:22:39,660 --> 02:22:41,370
And in fact in computing circles,

3967
02:22:41,500 --> 02:22:43,299
13 has special significance.

3968
02:22:43,349 --> 02:22:46,980
Rot 13 ROT 13 is an algorithm that's been used for

3969
02:22:46,980 --> 02:22:50,389
many years online just to sort of avoid spoilers like Reddit

3970
02:22:50,389 --> 02:22:53,019
might do this or other websites where they want you to

3971
02:22:53,019 --> 02:22:55,250
have to do some effort to see what the message says,

3972
02:22:55,480 --> 02:22:56,139
but it's not all that.

3973
02:22:56,275 --> 02:22:56,535
Hard,

3974
02:22:56,575 --> 02:22:59,544
you just have to click a button or write the code that actually does this,

3975
02:22:59,735 --> 02:23:01,134
but if you use 13 instead,

3976
02:23:01,174 --> 02:23:02,004
you wouldn't get

3977
02:23:03,054 --> 02:23:04,355
you wouldn't get IJ,

3978
02:23:04,455 --> 02:23:09,735
you'd get UV because you and V are 13 places away from H and I respectively.

3979
02:23:09,815 --> 02:23:10,054
But again,

3980
02:23:10,134 --> 02:23:11,924
we're not touching the punctuation

3981
02:23:12,214 --> 02:23:14,094
or we could send something more personal like I

3982
02:23:14,094 --> 02:23:16,964
love you and the message comes out like that.

3983
02:23:17,294 --> 02:23:20,075
Slightly more secure than that would be rot 26,

3984
02:23:20,134 --> 02:23:20,674
no.

3985
02:23:22,250 --> 02:23:22,759
No,

3986
02:23:23,009 --> 02:23:23,379
why?

3987
02:23:23,530 --> 02:23:24,799
Because it's the same thing.

3988
02:23:24,849 --> 02:23:27,250
It literally rotates all the way around A becomes A,

3989
02:23:27,330 --> 02:23:27,969
B becomes B.

3990
02:23:28,049 --> 02:23:29,339
So there's a limit to this.

3991
02:23:29,440 --> 02:23:30,559
But more seriously,

3992
02:23:30,730 --> 02:23:32,440
that speaks to just how

3993
02:23:33,330 --> 02:23:35,639
strong this encryption is or is not,

3994
02:23:35,799 --> 02:23:38,389
because if you think about this now from an adversary's perspective,

3995
02:23:38,450 --> 02:23:40,639
like the teacher in the room intercepting the slip of paper,

3996
02:23:40,769 --> 02:23:42,410
how much work do they need to do?

3997
02:23:42,650 --> 02:23:42,730
Well,

3998
02:23:42,780 --> 02:23:45,419
they just try all possibilities key of 1,

3999
02:23:45,809 --> 02:23:46,459
key of 2,

4000
02:23:46,610 --> 02:23:47,089
key of 3,

4001
02:23:47,950 --> 02:23:48,570
25,

4002
02:23:48,610 --> 02:23:49,480
and at some point.

4003
02:23:49,759 --> 02:23:52,219
will see clearly that they guessed the key,

4004
02:23:52,389 --> 02:23:54,540
which means that cipher is not very secure.

4005
02:23:54,709 --> 02:23:55,219
Nonetheless,

4006
02:23:55,269 --> 02:23:56,950
what we're talking about is historically known as

4007
02:23:56,950 --> 02:23:59,480
the Caesar cipher because back in the day

4008
02:23:59,830 --> 02:24:05,269
when Caesar was communicating by by by legends with his generals,

4009
02:24:05,429 --> 02:24:07,660
if you're the first human on Earth to come up

4010
02:24:07,660 --> 02:24:09,889
with encryption or come up with this specific cipher,

4011
02:24:09,910 --> 02:24:13,959
it doesn't really matter how complex it is if no one else knows what's going on

4012
02:24:13,959 --> 02:24:17,269
nowadays it's not hard at all to write some C code or any other language.

4013
02:24:17,379 --> 02:24:19,719
Which they could just brute force their way through this.

4014
02:24:19,889 --> 02:24:22,450
So there are much more sophisticated algorithms nowadays

4015
02:24:22,450 --> 02:24:25,370
than simple rotations of letters of the alphabet,

4016
02:24:25,610 --> 02:24:26,599
as we'll soon see.

4017
02:24:26,769 --> 02:24:27,929
But when it comes to decryption,

4018
02:24:27,969 --> 02:24:29,730
it really is just a matter of reversing that process.

4019
02:24:29,809 --> 02:24:31,360
So this message here,

4020
02:24:31,530 --> 02:24:34,889
if we rotate all the letters in the opposite direction by subtracting one,

4021
02:24:34,969 --> 02:24:36,719
will be our final letters for today.

4022
02:24:36,889 --> 02:24:38,839
There's a bit of a hint there which will reveal

4023
02:24:39,049 --> 02:24:41,250
that this message and our final words for us as the

4024
02:24:41,250 --> 02:24:44,889
clock strikes 4:15 is going to be the you becomes.

4025
02:24:45,480 --> 02:24:47,389
T and the I

4026
02:24:47,799 --> 02:24:48,519
becomes H.

4027
02:24:48,679 --> 02:24:48,870
I'm,

4028
02:24:49,040 --> 02:24:50,389
I'm the only one this is amusing.

4029
02:24:50,599 --> 02:24:52,830
H I I S

4030
02:24:53,200 --> 02:24:53,950
W

4031
02:24:54,799 --> 02:24:55,360
A

4032
02:24:55,919 --> 02:24:58,759
S C S 50 and this was CS 50.

4033
02:24:58,799 --> 02:24:59,750
We'll see you next time.