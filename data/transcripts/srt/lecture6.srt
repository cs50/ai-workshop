0
00:00:43,689 --> 00:00:44,599
All right,

1
00:00:44,799 --> 00:00:46,169
this is CS 50,

2
00:00:46,200 --> 00:00:47,759
and this is already week 6,

3
00:00:47,770 --> 00:00:50,130
wherein we transition away from C

4
00:00:50,360 --> 00:00:51,919
to a programming language called Python.

5
00:00:51,979 --> 00:00:53,400
And that's not to say that the past several

6
00:00:53,400 --> 00:00:55,680
weeks haven't been among the goals of the course.

7
00:00:55,720 --> 00:00:56,200
Indeed,

8
00:00:56,240 --> 00:00:57,080
in learning C,

9
00:00:57,159 --> 00:01:00,200
I very much think that you'll have at the end of this class

10
00:01:00,200 --> 00:01:03,159
so much more of a bottom up understanding of how computers work,

11
00:01:03,279 --> 00:01:04,760
of how programming languages work,

12
00:01:04,940 --> 00:01:07,269
and in particular you'll appreciate and understand better

13
00:01:07,559 --> 00:01:11,319
how Python and Java and C++ and Swift and so many other languages.

14
00:01:11,443 --> 00:01:14,163
are actually doing their thing nowadays.

15
00:01:14,282 --> 00:01:16,583
But recall that we started with Scratch some weeks ago,

16
00:01:16,633 --> 00:01:19,892
and in Scratch what was nice was that the first program we wrote,

17
00:01:19,913 --> 00:01:20,432
Hello World,

18
00:01:20,672 --> 00:01:22,273
was just all too accessible.

19
00:01:22,333 --> 00:01:24,432
All you had to do was interlock two puzzle pieces in

20
00:01:24,432 --> 00:01:27,513
order to make the cat in that case say Hello world.

21
00:01:27,593 --> 00:01:27,803
Well,

22
00:01:28,392 --> 00:01:28,873
thereafter,

23
00:01:28,922 --> 00:01:29,303
of course,

24
00:01:29,472 --> 00:01:31,992
we transitioned to C and recall that in week one we

25
00:01:31,992 --> 00:01:34,193
asked you to take on faith that you can sort of ignore

26
00:01:34,193 --> 00:01:36,432
that first line in a lot of these parentheses and the curly

27
00:01:36,432 --> 00:01:38,822
braces and really just focus on the essence of the program,

28
00:01:38,953 --> 00:01:42,325
which Clearly is still about hello world and printing it,

29
00:01:42,346 --> 00:01:45,216
albeit using a different function and a bit new syntax.

30
00:01:45,585 --> 00:01:45,856
Today,

31
00:01:45,945 --> 00:01:46,666
very excitingly,

32
00:01:46,795 --> 00:01:50,265
all of that is truly going to go away and be distilled into a

33
00:01:50,265 --> 00:01:53,456
single line of code when you indeed want to have the computer say something like

34
00:01:53,746 --> 00:01:54,396
Hello world.

35
00:01:54,466 --> 00:01:57,066
And this is what we mean by Python being a higher level language.

36
00:01:57,185 --> 00:01:59,176
So humans over the decades learned

37
00:01:59,706 --> 00:02:00,706
from earlier designs,

38
00:02:00,825 --> 00:02:01,865
earlier programming languages,

39
00:02:01,945 --> 00:02:02,736
what worked well,

40
00:02:02,945 --> 00:02:03,575
what did not.

41
00:02:03,736 --> 00:02:04,975
Computers got faster.

42
00:02:05,005 --> 00:02:06,026
Computers had more memory,

43
00:02:06,036 --> 00:02:06,865
and so you were able to start.

44
00:02:06,948 --> 00:02:11,139
Spending more of those resources in order to have the computer do more for you.

45
00:02:11,179 --> 00:02:14,608
And so you don't need to be as pedantic syntactically anymore.

46
00:02:14,779 --> 00:02:17,979
You don't need to write as much code anymore and frankly

47
00:02:17,979 --> 00:02:20,488
you can just start solving problems of interest to you,

48
00:02:20,539 --> 00:02:22,089
building products of interest to you,

49
00:02:22,339 --> 00:02:24,848
so much more readily by choosing the right tool for the job.

50
00:02:24,938 --> 00:02:25,779
And so in the real world,

51
00:02:25,819 --> 00:02:27,779
if you continue coding after CS 50,

52
00:02:27,858 --> 00:02:30,529
like sometimes C will be the right tool for the job,

53
00:02:30,819 --> 00:02:33,009
sometimes Python will be the right tool for the job,

54
00:02:33,059 --> 00:02:34,578
and sometimes it's going to be a different language.

55
00:02:34,792 --> 00:02:36,972
Together that you'll never have studied in school.

56
00:02:37,011 --> 00:02:38,651
And in fact what's compelling,

57
00:02:38,692 --> 00:02:39,121
I think,

58
00:02:39,322 --> 00:02:40,472
about this week 6,

59
00:02:40,572 --> 00:02:42,602
much like when I took the class back in the day,

60
00:02:42,852 --> 00:02:46,281
is that after CS 50 you'll have a taste of 12,

61
00:02:46,332 --> 00:02:48,121
maybe a few different programming languages,

62
00:02:48,132 --> 00:02:49,802
and that's going to be enough to bootstrap

63
00:02:49,802 --> 00:02:52,492
yourself and teach yourself new languages because you're

64
00:02:52,492 --> 00:02:53,891
going to start to recognize in the real

65
00:02:53,891 --> 00:02:56,891
world similarities with past languages that you've seen,

66
00:02:57,171 --> 00:02:59,602
programming paradigms that are still sort of with us,

67
00:02:59,692 --> 00:03:00,322
and the syntax,

68
00:03:00,371 --> 00:03:00,572
yeah,

69
00:03:00,651 --> 00:03:01,802
that's invariably going to change,

70
00:03:01,891 --> 00:03:02,371
but that's the.

71
00:03:02,455 --> 00:03:06,304
that you are going to Google or ask Chat GPT or some other AI about down the

72
00:03:06,304 --> 00:03:09,634
line so long as you know enough of it to sort of get real work done,

73
00:03:09,725 --> 00:03:12,524
you'll focus mostly ultimately on the ideas and the problems

74
00:03:12,524 --> 00:03:14,645
you want to solve and less on the syntax.

75
00:03:14,684 --> 00:03:17,324
And so among the goals for this week and this week's problem set

76
00:03:17,324 --> 00:03:20,835
and really the rest of the course is to get you more comfortable feeling

77
00:03:20,835 --> 00:03:23,845
uncomfortable in front of your keyboard because we're not going to give you

78
00:03:23,845 --> 00:03:26,675
and tell you everything you need to know for a language like Python.

79
00:03:26,725 --> 00:03:27,945
You're going to turn to the documentation.

80
00:03:28,005 --> 00:03:28,875
You're going to turn to the duck,

81
00:03:28,884 --> 00:03:30,125
and you're going to learn to to.

82
00:03:30,207 --> 00:03:32,908
Yourself ultimately a new language.

83
00:03:33,158 --> 00:03:36,598
So let's actually write our first program and compare and

84
00:03:36,598 --> 00:03:38,578
contrast with how we might do that in C.

85
00:03:39,158 --> 00:03:40,518
So recall that in C.

86
00:03:40,598 --> 00:03:41,947
We were in the habit for the first couple of

87
00:03:41,947 --> 00:03:44,807
weeks of doing make hello and make this build utility

88
00:03:44,807 --> 00:03:46,638
just kind of magically new to look for a file

89
00:03:46,638 --> 00:03:50,707
called hello.c and magically to create a program called hello,

90
00:03:50,917 --> 00:03:52,638
and then you could run it with hello.

91
00:03:52,748 --> 00:03:54,738
And then a week or so later we revealed

92
00:03:54,738 --> 00:03:57,757
that make is really just automating compilation of your.

93
00:03:57,960 --> 00:04:00,270
And with the actual compiler clang in this

94
00:04:00,270 --> 00:04:02,350
case and passing it command line arguments like

95
00:04:02,350 --> 00:04:06,701
0 to get a specific output like the file name hello instead of the default,

96
00:04:06,830 --> 00:04:10,391
which recall was a out passing in the name of the file you want to

97
00:04:10,391 --> 00:04:13,270
compile and turning on any libraries that you

98
00:04:13,270 --> 00:04:15,350
might want to compile into your program,

99
00:04:15,511 --> 00:04:18,031
link into your program beyond the standard ones.

100
00:04:18,071 --> 00:04:20,380
But then you could still run it in exactly the same way.

101
00:04:20,591 --> 00:04:21,420
Starting today,

102
00:04:21,510 --> 00:04:24,260
when you write Python code and then want to run it,

103
00:04:24,430 --> 00:04:25,591
you're simply going to run.

104
00:04:25,880 --> 00:04:27,660
The Python program itself.

105
00:04:27,890 --> 00:04:30,899
So just as Klang is a C compiler,

106
00:04:31,470 --> 00:04:36,040
Python is itself not only a programming language but a program as well.

107
00:04:36,109 --> 00:04:37,869
And with the Python program,

108
00:04:37,910 --> 00:04:40,299
which understands the Python programming language,

109
00:04:40,510 --> 00:04:44,309
can you run code that you'll have written in a file called hello.ie?

110
00:04:44,380 --> 00:04:47,440
And what this program is doing is a little bit different from what Clang is doing,

111
00:04:47,609 --> 00:04:49,369
but we'll see that difference before long.

112
00:04:49,450 --> 00:04:49,799
But first,

113
00:04:49,890 --> 00:04:52,690
let me go over to BS code and let's write our simplest,

114
00:04:52,850 --> 00:04:56,829
our first of Python programs by doing code hello.ie,

115
00:04:57,010 --> 00:04:59,929
and then in this file without any includes,

116
00:05:00,010 --> 00:05:01,140
any in main voids,

117
00:05:01,220 --> 00:05:03,600
I'm simply going to say print quote unquote,

118
00:05:03,890 --> 00:05:05,059
hello world,

119
00:05:05,250 --> 00:05:05,799
close quote.

120
00:05:06,130 --> 00:05:06,369
All right,

121
00:05:06,470 --> 00:05:07,380
now I'm not going to.

122
00:05:07,440 --> 00:05:07,980
Make.

123
00:05:08,140 --> 00:05:10,899
I'm instead just going to do Python of hello.ie,

124
00:05:11,029 --> 00:05:11,950
cross my fingers as always,

125
00:05:12,029 --> 00:05:12,859
and voila,

126
00:05:13,109 --> 00:05:14,670
my first program in Python.

127
00:05:14,750 --> 00:05:17,989
So it's sort of obvious that we got rid of the hash and clue.

128
00:05:18,029 --> 00:05:19,149
We got rid of the Imain void,

129
00:05:19,190 --> 00:05:20,309
no curly braces,

130
00:05:20,429 --> 00:05:21,820
only a couple of parentheses here,

131
00:05:21,869 --> 00:05:23,700
but what else is different to your eyes?

132
00:05:23,709 --> 00:05:25,299
That's a little more subtle here

133
00:05:25,790 --> 00:05:26,820
versus C.

134
00:05:26,869 --> 00:05:27,250
Yeah,

135
00:05:28,709 --> 00:05:28,829
yeah,

136
00:05:28,989 --> 00:05:29,670
so there's no F,

137
00:05:29,709 --> 00:05:32,149
so the print function is a little more human friendly.

138
00:05:32,190 --> 00:05:35,190
It's print instead of print F where the F did mean formatted,

139
00:05:35,230 --> 00:05:37,029
but we'll see that we still have that functionality.

140
00:05:38,459 --> 00:05:39,820
So no need for the line breaks,

141
00:05:40,029 --> 00:05:41,320
specifically the backslash n,

142
00:05:41,369 --> 00:05:43,399
and yet here's my cursor on the next line.

143
00:05:43,529 --> 00:05:45,839
So I dare say humans over the years realized

144
00:05:46,250 --> 00:05:49,959
we are more commonly wanting a new line than we don't want it.

145
00:05:50,010 --> 00:05:52,880
And so they made the default to actually give it to you automatically.

146
00:05:53,130 --> 00:05:54,579
And there's one more detail,

147
00:05:54,619 --> 00:05:54,970
yeah.

148
00:05:56,940 --> 00:05:58,209
So there's no semicolon,

149
00:05:58,250 --> 00:05:59,730
so I finished my thought at the end of the line,

150
00:05:59,809 --> 00:06:03,170
but I didn't need to explicitly terminate it with a semicolon.

151
00:06:03,190 --> 00:06:04,790
This is just with one program,

152
00:06:04,929 --> 00:06:06,049
all of these salient differences,

153
00:06:06,130 --> 00:06:09,649
but I'd argue that we got rid of all of the annoying stuff thus far anyway,

154
00:06:09,769 --> 00:06:13,160
so we can really focus on what this program itself is doing.

155
00:06:13,369 --> 00:06:15,730
But what's exciting with Python 2 is just

156
00:06:15,730 --> 00:06:17,970
how quickly you can solve certain problems,

157
00:06:18,010 --> 00:06:19,399
and this isn't true of just Python.

158
00:06:19,410 --> 00:06:22,600
It's really any higher level language than C.

159
00:06:22,880 --> 00:06:23,290
In fact,

160
00:06:23,410 --> 00:06:24,320
just for fun,

161
00:06:24,570 --> 00:06:26,329
let me go ahead and implement.

162
00:06:28,209 --> 00:06:29,450
Problem set 5,

163
00:06:29,489 --> 00:06:32,839
wherein you're challenged with implementing the fastest spell checker possible.

164
00:06:33,010 --> 00:06:34,880
So let me go back here to VS code.

165
00:06:34,929 --> 00:06:37,559
Let's close out hello.ie and clear my terminal window,

166
00:06:37,769 --> 00:06:38,959
and let me go ahead and do this.

167
00:06:39,089 --> 00:06:42,890
Let me first split my terminal by clicking this rectangular icon over here,

168
00:06:42,910 --> 00:06:44,649
and that's going to give me two terminal windows now,

169
00:06:44,690 --> 00:06:45,440
left and right,

170
00:06:45,730 --> 00:06:46,839
because in the first one at left,

171
00:06:46,890 --> 00:06:49,170
I'm going to CD into a directory I came with today,

172
00:06:49,209 --> 00:06:51,570
which is the staff's solution to.

173
00:06:51,825 --> 00:06:54,334
Problemset 5's spell checker in C.

174
00:06:54,464 --> 00:06:56,345
And on the right hand side here I'm going to CD

175
00:06:56,345 --> 00:06:59,105
into another directory I brought with me today called Python,

176
00:06:59,184 --> 00:07:02,625
inside of which is a translation of Problemset 5 into Python.

177
00:07:02,665 --> 00:07:03,255
In particular,

178
00:07:03,345 --> 00:07:06,024
I've implemented in advance a speller.pi file,

179
00:07:06,035 --> 00:07:09,375
which is the analog in Python of speller.cnc,

180
00:07:09,654 --> 00:07:11,355
and I've also prepared a dictionary.

181
00:07:11,845 --> 00:07:12,505
Pi file.

182
00:07:12,584 --> 00:07:13,385
Unfortunately,

183
00:07:13,424 --> 00:07:15,084
if we open up dictionary.i.

184
00:07:15,609 --> 00:07:17,869
You'll see that it's not actually implemented yet.

185
00:07:17,959 --> 00:07:19,399
So in dictionary.ie,

186
00:07:19,559 --> 00:07:21,230
let's implement in Python

187
00:07:21,559 --> 00:07:23,510
problem set 5 and see how long it takes.

188
00:07:23,720 --> 00:07:23,760
Well,

189
00:07:23,799 --> 00:07:25,980
the first thing I'm gonna do is declare a global variable,

190
00:07:26,000 --> 00:07:26,839
we'll call it words,

191
00:07:26,880 --> 00:07:30,100
and set that equal to the return value of a Python function called set,

192
00:07:30,239 --> 00:07:33,089
which essentially gives me a set object wherein I

193
00:07:33,089 --> 00:07:35,320
can store a whole bunch of words without duplicates.

194
00:07:35,440 --> 00:07:37,160
Python's gonna manage all of that for me.

195
00:07:37,276 --> 00:07:37,946
In effect,

196
00:07:38,026 --> 00:07:40,705
it's going to implement what I needed to implement

197
00:07:40,705 --> 00:07:43,256
myself in Problems at 5 a hash table.

198
00:07:43,466 --> 00:07:46,696
Now down here I'm going to go ahead and define a function called check,

199
00:07:46,906 --> 00:07:50,335
pass in as input a parameter called Word because

200
00:07:50,335 --> 00:07:52,055
of course that's how it was implemented in C.

201
00:07:52,265 --> 00:07:54,466
But notice the difference already in Python we use

202
00:07:54,466 --> 00:07:57,415
a new keyword called deaf to define a function,

203
00:07:57,626 --> 00:07:58,865
and we don't have to specify the.

204
00:07:58,941 --> 00:08:02,101
Type of the variable being passed in word in this case,

205
00:08:02,111 --> 00:08:05,282
and we also don't have to specify a return type for the function.

206
00:08:05,502 --> 00:08:06,932
Now inside of this checks function,

207
00:08:06,971 --> 00:08:08,161
it suffices to do this

208
00:08:08,372 --> 00:08:09,971
I'm going to return word.

209
00:08:10,492 --> 00:08:12,252
lower in words,

210
00:08:12,282 --> 00:08:15,011
which is effectively a boolean expression asking is the

211
00:08:15,011 --> 00:08:17,411
lower case version of this word in the set?

212
00:08:17,611 --> 00:08:17,971
If so,

213
00:08:18,171 --> 00:08:18,802
returned true,

214
00:08:19,011 --> 00:08:20,451
otherwise returned false.

215
00:08:21,260 --> 00:08:22,769
Done with the check function.

216
00:08:22,940 --> 00:08:25,320
Now let's go ahead and define another function called load,

217
00:08:25,380 --> 00:08:28,910
which recall took an argument of the dictionary that you want to load into memory.

218
00:08:28,980 --> 00:08:30,649
And let's go ahead now and do this

219
00:08:31,059 --> 00:08:33,539
with open dictionary as file,

220
00:08:33,590 --> 00:08:35,808
which effectively opens the dictionary,

221
00:08:35,900 --> 00:08:38,900
as in C we used FO in Python we use open.

222
00:08:39,219 --> 00:08:41,320
And it gives it a variable name of file.

223
00:08:41,820 --> 00:08:43,058
Then once that file is open,

224
00:08:43,179 --> 00:08:46,419
I'm gonna go ahead and update that entire set of

225
00:08:46,419 --> 00:08:50,010
words which starts out empty by taking the file,

226
00:08:50,460 --> 00:08:52,539
reading the entire contents top to bottom,

227
00:08:52,619 --> 00:08:53,210
left to right,

228
00:08:53,380 --> 00:08:55,539
and splitting all of the lines therein on the.

229
00:08:55,690 --> 00:08:58,590
New lines that terminate each of the strings,

230
00:08:58,599 --> 00:09:02,190
effectively updating the set with every word in that their dictionary.

231
00:09:02,599 --> 00:09:05,200
Then I'm gonna assume that it all just worked because there's a

232
00:09:05,200 --> 00:09:08,429
lot less effort for me to uh to perform myself in Python,

233
00:09:08,440 --> 00:09:12,349
and I'm just gonna go ahead and return true T in Python.

234
00:09:12,840 --> 00:09:13,119
Done.

235
00:09:13,739 --> 00:09:14,020
Next,

236
00:09:14,070 --> 00:09:17,059
let's go ahead and define that other function from Palm set 5 size,

237
00:09:17,099 --> 00:09:20,380
whose purpose in life was to tell me the size of the dictionary I had loaded.

238
00:09:20,539 --> 00:09:20,580
Well,

239
00:09:20,650 --> 00:09:21,130
in Python,

240
00:09:21,140 --> 00:09:21,729
that's pretty easy.

241
00:09:21,830 --> 00:09:23,130
I can just return the length,

242
00:09:23,219 --> 00:09:24,520
or LEN for short,

243
00:09:24,780 --> 00:09:27,059
of the set in which I've stored all those words.

244
00:09:27,690 --> 00:09:28,119
Done.

245
00:09:28,369 --> 00:09:31,049
And then lastly I'm gonna go ahead and define an unload function

246
00:09:31,049 --> 00:09:35,599
which recall was responsible for freeing any memory I myself had allocated.

247
00:09:35,770 --> 00:09:37,770
I don't seem to have done any of that in Python.

248
00:09:37,809 --> 00:09:38,159
In fact,

249
00:09:38,270 --> 00:09:39,719
that's managed for me now,

250
00:09:39,849 --> 00:09:41,320
so I'm gonna go ahead and simply

251
00:09:41,530 --> 00:09:44,119
say return true because there's no work to be done.

252
00:09:44,940 --> 00:09:47,530
And that's it in like 19 lines of code in Python,

253
00:09:47,729 --> 00:09:49,369
most of which are blank lines.

254
00:09:49,530 --> 00:09:53,599
I claim I have reimplemented Problem set 5 in Python.

255
00:09:53,849 --> 00:09:53,929
Well,

256
00:09:53,969 --> 00:09:55,369
let's take a look now at the difference.

257
00:09:55,530 --> 00:09:57,289
I'm going to go ahead and reopen my terminal window,

258
00:09:57,299 --> 00:09:59,880
and I'm gonna go ahead and maximize it so we can see more output.

259
00:10:00,049 --> 00:10:00,809
And now I'm gonna go.

260
00:10:00,895 --> 00:10:02,075
And run Python,

261
00:10:02,244 --> 00:10:04,405
which is going to be not only the name of the language but the

262
00:10:04,405 --> 00:10:07,635
name of the program we use today to start running our Python code,

263
00:10:07,724 --> 00:10:09,405
and I'm going to run it on speller.ie,

264
00:10:09,525 --> 00:10:10,705
which I brought with me today,

265
00:10:11,205 --> 00:10:14,655
specifically on the largest of problems that finds files,

266
00:10:14,844 --> 00:10:16,034
homes.text.

267
00:10:16,284 --> 00:10:16,724
Enter.

268
00:10:17,140 --> 00:10:18,969
And as with Problem set 5 itself,

269
00:10:19,010 --> 00:10:21,729
we'll see a whole bunch of misspelled words being printed to the screen,

270
00:10:21,809 --> 00:10:23,330
some of which might very well be misspelled,

271
00:10:23,369 --> 00:10:25,239
some of which are just not in the dictionary,

272
00:10:25,289 --> 00:10:28,400
some of which are simply possessives of words that are in the dictionary,

273
00:10:28,489 --> 00:10:31,059
but at the very end of this output I should see

274
00:10:31,369 --> 00:10:32,570
not only how many words were found,

275
00:10:32,609 --> 00:10:34,330
but the total time involved,

276
00:10:34,369 --> 00:10:37,270
which appears to be 1.87 seconds.

277
00:10:37,369 --> 00:10:37,809
Not bad,

278
00:10:37,929 --> 00:10:39,109
seeing as it only took me like what,

279
00:10:39,169 --> 00:10:42,000
a minute or two to write the actual code.

280
00:10:42,469 --> 00:10:43,640
But there is going to be a trade-off,

281
00:10:43,700 --> 00:10:44,109
we'll see,

282
00:10:44,179 --> 00:10:46,900
even though it took me much less human time

283
00:10:46,900 --> 00:10:49,650
and arguably was a lot easier to implement this

284
00:10:50,340 --> 00:10:54,710
this spell checker in Python than I dare say it was for most everyone in C,

285
00:10:54,900 --> 00:10:56,650
let's see what that tradeoff might be.

286
00:10:56,900 --> 00:11:01,059
Over in my left hand terminal window in which I'm in the C directory which

287
00:11:01,059 --> 00:11:05,130
I brought with me as the staff solution in C to problem set 5,

288
00:11:05,299 --> 00:11:07,859
let's go ahead and make that spell checker.

289
00:11:08,409 --> 00:11:11,119
Then let's go ahead and do slash speller

290
00:11:11,369 --> 00:11:13,380
and run it on the same file,

291
00:11:13,570 --> 00:11:13,809
uh,

292
00:11:13,849 --> 00:11:15,010
Holmes.text,

293
00:11:15,169 --> 00:11:18,039
and see how long the C implementation takes.

294
00:11:18,250 --> 00:11:18,690
Enter.

295
00:11:19,159 --> 00:11:20,940
And we see some of the same output

296
00:11:21,219 --> 00:11:22,909
might be slower sometimes just because of the cloud

297
00:11:22,909 --> 00:11:25,349
and there total time spent in the CPU,

298
00:11:25,429 --> 00:11:27,229
not necessarily printing everything to the screen,

299
00:11:27,270 --> 00:11:28,219
which might take longer,

300
00:11:28,469 --> 00:11:33,909
is only 1.32 seconds versus the 1.87 seconds in Python.

301
00:11:33,989 --> 00:11:34,280
Now,

302
00:11:34,349 --> 00:11:35,710
while only half a second,

303
00:11:35,750 --> 00:11:38,270
that's a decent percentage of the total amount of time

304
00:11:38,270 --> 00:11:40,710
spent running this spell checker in each of the windows,

305
00:11:40,750 --> 00:11:43,500
and so that it alone seems to be one of the trade-offs,

306
00:11:43,510 --> 00:11:45,469
even though it seems to be much faster.

307
00:11:45,586 --> 00:11:49,127
They're easier to implement a problem in Python,

308
00:11:49,286 --> 00:11:53,336
there's going to be trade-offs insofar as the code might very well run slower.

309
00:11:53,387 --> 00:11:54,367
And as we'll see today,

310
00:11:54,536 --> 00:11:57,747
that's in large part because whereas C is of course compiled.

311
00:11:57,896 --> 00:12:00,007
That's why Iran make and in turn clang,

312
00:12:00,166 --> 00:12:01,356
and then the zeros and ones,

313
00:12:01,377 --> 00:12:04,526
the so-called machine code is what you're running in Python generally,

314
00:12:04,687 --> 00:12:07,466
the the computer is interpreting your code,

315
00:12:07,617 --> 00:12:09,057
essentially reading it top to bottom,

316
00:12:09,137 --> 00:12:09,697
left to right,

317
00:12:10,057 --> 00:12:11,896
much like a human in between two.

318
00:12:12,013 --> 00:12:16,203
Other humans might slowly translate one spoken language to the other if

319
00:12:16,203 --> 00:12:19,124
those two people don't in fact speak the same language themselves.

320
00:12:19,203 --> 00:12:21,434
So there's a bit of overhead when using Python,

321
00:12:21,564 --> 00:12:23,434
but I will say

322
00:12:23,564 --> 00:12:26,153
that the Python community has been working on this

323
00:12:26,153 --> 00:12:28,533
problem for some time and so in general it's

324
00:12:28,533 --> 00:12:30,643
not necessarily going to be as significant a trade

325
00:12:30,643 --> 00:12:32,354
off because there's certain tricks we can do.

326
00:12:32,364 --> 00:12:33,633
And in fact underneath the hood,

327
00:12:33,763 --> 00:12:35,604
what the Python language can do for you

328
00:12:35,604 --> 00:12:38,323
and the specific interpreter you're using is technically.

329
00:12:38,450 --> 00:12:40,750
Semi-secretly compile your code for you into something

330
00:12:40,750 --> 00:12:42,270
called bytecode and then run that bytecode,

331
00:12:42,310 --> 00:12:45,120
which is more efficient than actually reinterpreting it again and again,

332
00:12:45,231 --> 00:12:47,661
but we'll see more of this over time.

333
00:12:47,950 --> 00:12:48,210
For now,

334
00:12:48,231 --> 00:12:51,101
let's take a look at maybe two other problems that we might solve,

335
00:12:51,231 --> 00:12:52,401
dare say more easily,

336
00:12:52,510 --> 00:12:56,221
more quickly than we could have in C for problem at 4.

337
00:12:56,471 --> 00:12:58,781
Let me go ahead and shrink down my terminal window here,

338
00:12:59,031 --> 00:13:00,661
close out dictionary.ie,

339
00:13:00,750 --> 00:13:04,181
close one of my terminal windows and CD back to my main directory,

340
00:13:04,310 --> 00:13:04,791
and let's go.

341
00:13:04,867 --> 00:13:08,408
Go ahead and open up that bridge bitmap photograph

342
00:13:08,617 --> 00:13:10,218
that we used in Problem set 4 and how

343
00:13:10,218 --> 00:13:13,247
to apply a number of Instagram-like filters there too.

344
00:13:13,458 --> 00:13:13,538
Well,

345
00:13:13,617 --> 00:13:15,737
now let's go ahead and implement maybe one of those filters,

346
00:13:15,778 --> 00:13:17,018
the blur filter,

347
00:13:17,098 --> 00:13:19,208
whose purpose in life is just to blur this image.

348
00:13:19,418 --> 00:13:19,478
Well,

349
00:13:19,497 --> 00:13:20,418
let's see how long this takes.

350
00:13:20,497 --> 00:13:21,848
Let me go ahead and open up,

351
00:13:22,228 --> 00:13:22,518
say,

352
00:13:22,617 --> 00:13:22,888
uh,

353
00:13:22,898 --> 00:13:24,078
blur.ie,

354
00:13:24,458 --> 00:13:27,297
which is now going to be a Python program for blurring images.

355
00:13:27,398 --> 00:13:28,418
It's empty initially,

356
00:13:28,538 --> 00:13:31,158
but I can pretty much write this.

357
00:13:31,294 --> 00:13:34,715
Quite quickly now let me go ahead and at the top of this file

358
00:13:35,125 --> 00:13:39,515
write the Python keyword from PIL for Python image library,

359
00:13:39,724 --> 00:13:43,405
import an object called Image and another

360
00:13:43,405 --> 00:13:46,484
one called Image filter in particular two features

361
00:13:46,484 --> 00:13:50,554
of the Python image library that's gonna make this so much easier to actually solve.

362
00:13:50,804 --> 00:13:53,455
And then let's go ahead and define a variable we'll call it before,

363
00:13:53,465 --> 00:13:56,655
representing the before version of this image and set that equal to image.

364
00:13:56,844 --> 00:13:57,395
open.

365
00:13:58,151 --> 00:14:02,331
bridge.bmp where that is of course is the name of the file we want to blur.

366
00:14:02,601 --> 00:14:04,432
Then let's go ahead and create a variable called

367
00:14:04,432 --> 00:14:08,421
after representing the after version of this same filter

368
00:14:08,671 --> 00:14:10,192
and set that equal to before.

369
00:14:10,762 --> 00:14:12,682
filter parenthesis,

370
00:14:12,791 --> 00:14:15,581
image filter.bo blur,

371
00:14:15,671 --> 00:14:17,231
and then just to be a little dramatic,

372
00:14:17,271 --> 00:14:20,031
I'm going to blur it more so than you needed to in problem set 4,

373
00:14:20,072 --> 00:14:21,901
but we'll see it more visibly now on the screen.

374
00:14:22,072 --> 00:14:24,031
Let's do an argument of 10.

375
00:14:24,280 --> 00:14:24,979
And then

376
00:14:25,150 --> 00:14:26,859
at the very end of this process,

377
00:14:26,909 --> 00:14:31,000
let's do after.save and save it in a file called say out.bmp.

378
00:14:32,270 --> 00:14:32,710
Done.

379
00:14:32,950 --> 00:14:34,429
So in just 4 lines of code,

380
00:14:34,469 --> 00:14:37,549
I claim I've implemented the blur function now in

381
00:14:37,549 --> 00:14:39,500
Python of what we did previously in C.

382
00:14:39,750 --> 00:14:41,020
Let me open my terminal window.

383
00:14:41,150 --> 00:14:44,469
Let me run the Python command this time on blur.ie.

384
00:14:44,630 --> 00:14:45,830
Cross my fingers as always.

385
00:14:46,250 --> 00:14:48,030
And indeed I've made a mistake.

386
00:14:48,239 --> 00:14:50,000
Perhaps even if you've never written Python before,

387
00:14:50,080 --> 00:14:53,000
you can see it and in fact we'll see a number of these errors,

388
00:14:53,039 --> 00:14:53,559
some intentional,

389
00:14:53,640 --> 00:14:54,400
some unintentional,

390
00:14:54,479 --> 00:14:58,000
but on line 4 what I intended to do was set equal to

391
00:14:58,640 --> 00:14:58,799
before.

392
00:14:59,080 --> 00:14:59,440
filter,

393
00:14:59,559 --> 00:15:01,190
that variable I created called after.

394
00:15:01,789 --> 00:15:01,919
All right,

395
00:15:02,000 --> 00:15:02,440
that's all right.

396
00:15:02,520 --> 00:15:03,880
Let's go back down to my terminal window,

397
00:15:04,000 --> 00:15:05,390
clear it to get rid of all that,

398
00:15:05,400 --> 00:15:09,479
and rerun Python of Blur.ie.ross my fingers even harder this time.

399
00:15:10,460 --> 00:15:12,729
Nothing bad seems to be happening.

400
00:15:12,940 --> 00:15:13,299
Indeed,

401
00:15:13,340 --> 00:15:15,150
now let's go ahead and open up out.

402
00:15:15,539 --> 00:15:17,340
BMP and before we reveal that,

403
00:15:17,419 --> 00:15:18,599
let's go back to the original,

404
00:15:18,900 --> 00:15:19,739
which is bridge.

405
00:15:19,940 --> 00:15:21,770
BMP and now dramatically,

406
00:15:21,799 --> 00:15:23,549
let's see the blurred version thereof.

407
00:15:24,590 --> 00:15:25,210
Voila,

408
00:15:25,390 --> 00:15:26,309
hopefully to your eyes too.

409
00:15:26,349 --> 00:15:28,500
It looks quite a bit blurry.

410
00:15:28,630 --> 00:15:28,669
Well,

411
00:15:28,750 --> 00:15:29,679
how about one more flourish?

412
00:15:29,750 --> 00:15:33,219
Those of you who are feeling more comfortable last week and implemented perhaps,

413
00:15:33,510 --> 00:15:34,010
uh,

414
00:15:34,030 --> 00:15:36,229
edge edge detection in see.

415
00:15:36,429 --> 00:15:36,469
Well,

416
00:15:36,510 --> 00:15:38,419
let's see if we can whip that up quite quickly too.

417
00:15:38,590 --> 00:15:43,429
Let's go ahead and write a file called edges.ie using that same bridge.

418
00:15:43,669 --> 00:15:44,500
BMP file,

419
00:15:44,510 --> 00:15:45,340
and in this file,

420
00:15:45,549 --> 00:15:47,159
let's go ahead and do the following.

421
00:15:47,390 --> 00:15:49,469
As before from the Python image library,

422
00:15:49,570 --> 00:15:50,700
let's import,

423
00:15:51,070 --> 00:15:51,260
uh,

424
00:15:51,270 --> 00:15:53,789
the image feature and the image filter feature.

425
00:15:53,890 --> 00:15:54,789
Then as before,

426
00:15:54,840 --> 00:15:56,549
let's create a variable called before.

427
00:15:56,760 --> 00:15:58,090
Set it equal to image.

428
00:15:58,359 --> 00:16:00,450
open passing in bridge.bmp.

429
00:16:00,599 --> 00:16:02,830
So so far the same as before.

430
00:16:03,080 --> 00:16:04,640
Now let's create a variable called after.

431
00:16:04,739 --> 00:16:05,750
Set it equal to before.

432
00:16:06,190 --> 00:16:11,080
filter passing in this time image filter.fi edges,

433
00:16:11,119 --> 00:16:12,390
which is different from box blur,

434
00:16:12,400 --> 00:16:16,109
and by definition it's going to find the image the edges of this here image,

435
00:16:16,119 --> 00:16:16,869
and then after,

436
00:16:17,000 --> 00:16:17,789
as before,

437
00:16:17,960 --> 00:16:21,400
let's do after.save of out.bmp and just clobber the

438
00:16:21,400 --> 00:16:23,239
version of the blurred file that we just created.

439
00:16:24,260 --> 00:16:24,929
All right,

440
00:16:25,140 --> 00:16:25,729
that's it.

441
00:16:25,840 --> 00:16:28,090
Let's go ahead and open up my terminal window now.

442
00:16:28,219 --> 00:16:30,059
Let's go ahead and again run Python,

443
00:16:30,099 --> 00:16:31,659
but this time on Edges.ie,

444
00:16:31,820 --> 00:16:33,049
cross my fingers real hard.

445
00:16:33,299 --> 00:16:34,049
So far so good,

446
00:16:34,059 --> 00:16:35,010
and that was quite fast.

447
00:16:35,179 --> 00:16:36,260
Recall that the bridge.

448
00:16:36,419 --> 00:16:38,289
BMP image looked like this,

449
00:16:38,500 --> 00:16:41,450
but now when we open up this new and improved version of Out.

450
00:16:41,659 --> 00:16:44,530
BMP thanks to Python and just 4 lines of code,

451
00:16:44,780 --> 00:16:47,539
we now have all of our edges detected.

452
00:16:48,640 --> 00:16:50,380
So what can we then learn

453
00:16:50,630 --> 00:16:51,780
from C itself?

454
00:16:51,950 --> 00:16:52,190
Well,

455
00:16:52,349 --> 00:16:53,349
C had of course functions,

456
00:16:53,390 --> 00:16:56,380
and functions were those actions or verbs that simply got worked on.

457
00:16:56,590 --> 00:16:58,429
And let's go ahead and compare side by side,

458
00:16:58,479 --> 00:17:00,309
much like we did with scratch and C.

459
00:17:00,630 --> 00:17:02,830
The idea is that today onward are still going to be the same.

460
00:17:03,109 --> 00:17:06,040
And how they could translate to Python.

461
00:17:06,118 --> 00:17:08,709
So on the left here we'll now have our friend scratch.

462
00:17:08,839 --> 00:17:10,880
This of course was one of the first puzzle pieces we saw.

463
00:17:10,920 --> 00:17:12,868
It's a purple puzzle piece saying say,

464
00:17:13,079 --> 00:17:16,439
and it was a function insofar as it said the value of its argument,

465
00:17:16,479 --> 00:17:17,890
which in this case is hello world.

466
00:17:18,000 --> 00:17:20,108
What we've already seen in Python what this looks like.

467
00:17:20,280 --> 00:17:22,199
It looks similar to the version in C,

468
00:17:22,358 --> 00:17:24,040
but it's no longer print F.

469
00:17:24,239 --> 00:17:25,618
There's no longer a semicolon,

470
00:17:25,640 --> 00:17:28,281
and there's no longer an Explicit new line.

471
00:17:28,442 --> 00:17:30,391
So in Python it's quite simply this.

472
00:17:30,722 --> 00:17:34,312
Meanwhile in Python there are a whole bunch of libraries as well.

473
00:17:34,442 --> 00:17:37,202
Now in C we had simply header files,

474
00:17:37,212 --> 00:17:40,281
and those header files gave you access to the prototypes of that is

475
00:17:40,281 --> 00:17:43,352
the signatures of the functions that you want to use from those libraries.

476
00:17:43,442 --> 00:17:46,281
Python uses somewhat different vernacular whereby Python

477
00:17:46,281 --> 00:17:48,521
has what are called modules and packages,

478
00:17:48,562 --> 00:17:50,911
and a package is just a collection of modules.

479
00:17:51,093 --> 00:17:51,644
But a lot,

480
00:17:51,673 --> 00:17:54,593
a module is just a library using Python Speak,

481
00:17:54,803 --> 00:17:55,473
so to speak.

482
00:17:55,683 --> 00:17:58,784
So anytime you hear someone discussing a module or a package in Python,

483
00:17:58,803 --> 00:18:00,404
they're just talking about using a library,

484
00:18:00,413 --> 00:18:03,833
and that library might come with the language itself just built in as standard,

485
00:18:03,963 --> 00:18:06,443
or it might be a third party library that you might

486
00:18:06,443 --> 00:18:08,843
download and install yourself much like I did a few weeks

487
00:18:08,843 --> 00:18:12,083
back when we installed the cow sayy program so that I

488
00:18:12,083 --> 00:18:14,953
could actually have a cow or other animals on the screen.

489
00:18:15,206 --> 00:18:16,115
Display text.

490
00:18:16,286 --> 00:18:19,566
So in C recall we had something like this include CS50.h,

491
00:18:19,586 --> 00:18:21,956
which was the header file preinstalled for you somewhere,

492
00:18:22,206 --> 00:18:26,875
but we will have for at least this week an analog of the CS50 library in

493
00:18:26,875 --> 00:18:31,515
C also in Python just to make this transition from C to Python a bit easier.

494
00:18:31,725 --> 00:18:33,765
These two though are meant to be training wheels

495
00:18:33,765 --> 00:18:35,446
that you can take off and should take off,

496
00:18:35,645 --> 00:18:35,826
you know,

497
00:18:35,885 --> 00:18:37,395
even within a week or so.

498
00:18:37,406 --> 00:18:38,885
It's just meant to smooth that transition.

499
00:18:39,098 --> 00:18:41,517
Clear what's the same and what's different.

500
00:18:41,728 --> 00:18:44,118
So in the CS 50 library for Python,

501
00:18:44,248 --> 00:18:48,157
we also have a function called get string whose purpose in life is to get a string.

502
00:18:48,368 --> 00:18:49,167
To access it though,

503
00:18:49,177 --> 00:18:52,557
you don't use hash include CS50.h. That's a C thing.

504
00:18:52,687 --> 00:18:56,228
In Python you would say from CS50 import get string.

505
00:18:56,317 --> 00:18:57,328
It's a little more verbose,

506
00:18:57,368 --> 00:19:00,547
but it's also a little more precise as to what you want from the library,

507
00:19:00,848 --> 00:19:02,927
especially if you don't want the whole thing loaded into memory.

508
00:19:03,290 --> 00:19:05,760
So here for instance is now a scratch program that

509
00:19:05,760 --> 00:19:08,880
was a little more interesting than just printing out HelloWorld.

510
00:19:09,000 --> 00:19:12,520
This was the first program we wrote that actually got some user input.

511
00:19:12,689 --> 00:19:13,079
So in fact,

512
00:19:13,199 --> 00:19:16,199
let me go back to VS Code and let's see if we can't

513
00:19:16,199 --> 00:19:20,199
resurrect this C program real quickly in the form of a new hello.c.

514
00:19:20,680 --> 00:19:22,599
So I'm going to run code of hello.c.

515
00:19:23,250 --> 00:19:23,839
And then in my,

516
00:19:24,119 --> 00:19:25,589
in my code tab,

517
00:19:25,719 --> 00:19:28,050
I'm going to do include CS50.

518
00:19:28,280 --> 00:19:28,709
H,

519
00:19:29,280 --> 00:19:31,030
include standardio.h,

520
00:19:31,180 --> 00:19:32,199
and then below that,

521
00:19:32,359 --> 00:19:35,589
I'm going to go ahead and whip up our familiar version of this,

522
00:19:35,719 --> 00:19:36,630
I made void,

523
00:19:36,800 --> 00:19:39,479
and then inside of the curly braces we'll bring back string.

524
00:19:39,859 --> 00:19:41,569
Even though we now know it's Chart star,

525
00:19:41,780 --> 00:19:43,069
we'll call our variable answer,

526
00:19:43,180 --> 00:19:44,459
set it equal to get string,

527
00:19:44,540 --> 00:19:45,300
ask the user,

528
00:19:45,310 --> 00:19:45,739
quote unquote,

529
00:19:45,819 --> 00:19:48,849
what's your name with a space just to move the cursor over.

530
00:19:49,099 --> 00:19:50,569
Still need my semicolon and C.

531
00:19:50,699 --> 00:19:51,339
And then after that,

532
00:19:51,420 --> 00:19:52,729
recall back in week one

533
00:19:52,979 --> 00:19:55,729
we did hello slashn.

534
00:19:56,119 --> 00:19:59,670
And then plugged in the variable answer so as to see Hello David,

535
00:19:59,829 --> 00:20:00,579
hello Kelly,

536
00:20:00,790 --> 00:20:01,739
or something else.

537
00:20:01,949 --> 00:20:02,510
Just to be safe,

538
00:20:02,630 --> 00:20:04,260
let me do make hello.

539
00:20:04,510 --> 00:20:05,630
All is well so far.

540
00:20:06,199 --> 00:20:06,479
hello,

541
00:20:06,589 --> 00:20:07,380
type my name,

542
00:20:07,550 --> 00:20:09,099
and this version in C

543
00:20:09,390 --> 00:20:11,099
seems to be working OK.

544
00:20:11,310 --> 00:20:12,209
So in C,

545
00:20:12,469 --> 00:20:16,380
these lines of code here translate pretty literally to what we just saw,

546
00:20:16,500 --> 00:20:18,469
although we got the answer variable in.

547
00:20:18,925 --> 00:20:19,444
for free.

548
00:20:19,525 --> 00:20:22,635
That blue puzzle piece just existed without our having to create it,

549
00:20:22,885 --> 00:20:25,125
but it's a decent number of hoops to jump through in

550
00:20:25,125 --> 00:20:27,515
order to just get user input and print it out.

551
00:20:27,685 --> 00:20:27,785
Well,

552
00:20:27,805 --> 00:20:28,484
in Python,

553
00:20:28,505 --> 00:20:33,035
this is going to get a little more succinct in that the Python version of this code

554
00:20:33,364 --> 00:20:35,114
is now going to look like this.

555
00:20:35,444 --> 00:20:36,915
PrintF is now print.

556
00:20:37,165 --> 00:20:38,515
The semicolons are gone,

557
00:20:38,724 --> 00:20:41,324
and what else seems a little bit different.

558
00:20:42,430 --> 00:20:42,439
Yeah.

559
00:20:45,520 --> 00:20:46,959
I don't need any placeholders.

560
00:20:47,030 --> 00:20:47,150
Yeah,

561
00:20:47,349 --> 00:20:49,300
so we don't need the percents anymore.

562
00:20:49,349 --> 00:20:49,790
In fact,

563
00:20:49,890 --> 00:20:51,319
I'm curiously using a plus,

564
00:20:51,390 --> 00:20:53,469
which if some of you studied Java or some other language,

565
00:20:53,510 --> 00:20:54,900
you might have actually seen this before.

566
00:20:55,109 --> 00:20:57,270
Even if you've never seen Python before,

567
00:20:57,349 --> 00:20:59,300
you've only seen C in CS 50,

568
00:20:59,469 --> 00:21:01,469
you can probably guess what the plus is doing,

569
00:21:01,550 --> 00:21:03,589
even if you don't know the technical vocab.

570
00:21:03,790 --> 00:21:05,459
What is the plus probably doing here?

571
00:21:06,579 --> 00:21:06,770
Yeah,

572
00:21:06,849 --> 00:21:09,300
so it's concatenating or joining together the thing on

573
00:21:09,300 --> 00:21:10,449
the left with the thing on the right,

574
00:21:10,489 --> 00:21:12,920
and we actually had that vernacular in the world of Scratch.

575
00:21:13,089 --> 00:21:15,290
We had the joint puzzle piece that joins hello,

576
00:21:15,329 --> 00:21:17,839
comma space and the value inside of answer.

577
00:21:18,089 --> 00:21:21,119
A plus in Python can do exactly the same thing.

578
00:21:21,250 --> 00:21:22,770
So it's a little more user friendly.

579
00:21:23,069 --> 00:21:24,150
Having to anticipate,

580
00:21:24,349 --> 00:21:26,500
let's put the placeholder here and then come back later

581
00:21:26,709 --> 00:21:27,670
and plug in the variable.

582
00:21:27,750 --> 00:21:30,030
Humans over time just realize that it's a lot easier to

583
00:21:30,030 --> 00:21:33,180
sort of do this in this way than bother with placeholders,

584
00:21:33,270 --> 00:21:35,550
though you can still use placeholders for other purposes.

585
00:21:35,670 --> 00:21:39,150
Another subtle difference between the C and Python version of these two lines.

586
00:21:41,849 --> 00:21:42,599
More subtle

587
00:21:43,420 --> 00:21:44,319
Than that

588
00:21:46,810 --> 00:21:47,650
What's missing?

589
00:21:48,849 --> 00:21:49,119
Yeah,

590
00:21:49,239 --> 00:21:49,709
I'm back.

591
00:21:50,750 --> 00:21:51,089
Uh,

592
00:21:51,119 --> 00:21:53,560
so the backslash N is again gone for Python,

593
00:21:53,599 --> 00:21:55,310
so that sort of happens for free,

594
00:21:55,520 --> 00:21:55,800
indeed,

595
00:21:55,810 --> 00:21:56,880
and one more difference.

596
00:21:59,660 --> 00:21:59,969
Yeah,

597
00:22:00,089 --> 00:22:02,050
we don't need to declare the type of answer.

598
00:22:02,130 --> 00:22:04,420
Recall that if you rewind in the C version,

599
00:22:04,449 --> 00:22:07,400
you needed to tell the compiler that this is a string,

600
00:22:07,410 --> 00:22:09,780
and last week we could have changed string to charge star,

601
00:22:09,930 --> 00:22:11,890
but we still had to tell the compiler

602
00:22:11,890 --> 00:22:13,859
what data type we're putting into that variable.

603
00:22:14,050 --> 00:22:16,920
In Python we can now get rid of that data type,

604
00:22:17,130 --> 00:22:19,530
and Python will just figure it out from context.

605
00:22:19,569 --> 00:22:20,839
If get string returns a string,

606
00:22:20,930 --> 00:22:23,089
well then obviously the variable should store a string.

607
00:22:23,189 --> 00:22:24,329
If a function returns an in,

608
00:22:24,369 --> 00:22:26,579
well then obviously the variable should store an in,

609
00:22:26,589 --> 00:22:27,209
and the length.

610
00:22:27,349 --> 00:22:30,060
It's just doing more of that decision making for you

611
00:22:30,060 --> 00:22:32,369
just to save you time and save you thought.

612
00:22:32,579 --> 00:22:34,300
There's a subtlety here though where we can

613
00:22:34,300 --> 00:22:35,780
make this program a little bit different.

614
00:22:35,819 --> 00:22:35,979
In fact,

615
00:22:36,060 --> 00:22:37,380
let's whip it up first in Python.

616
00:22:37,459 --> 00:22:38,969
Let me go back to VS code here,

617
00:22:39,300 --> 00:22:40,140
clear my terminal,

618
00:22:40,150 --> 00:22:43,699
and let's go ahead and create a program that again called Hello.ie.

619
00:22:44,060 --> 00:22:45,819
That'll open up my previous version thereof.

620
00:22:45,900 --> 00:22:47,619
And just so we can see these things side by side,

621
00:22:47,699 --> 00:22:52,050
I'm going to drag that tab over to the right of VS code and let go.

622
00:22:52,260 --> 00:22:54,939
And now you can see the C version still on the left and the Python.

623
00:22:55,040 --> 00:22:56,060
Version at the right.

624
00:22:56,270 --> 00:22:59,349
What I'm going to do here now in my Python version is change

625
00:22:59,349 --> 00:23:03,099
it to be quite like the version in C now at left.

626
00:23:03,390 --> 00:23:04,359
So as promised,

627
00:23:04,390 --> 00:23:07,540
I'm going to do from CS 50 import get string.

628
00:23:07,750 --> 00:23:11,219
Then below that I'm going to say simply answer equals get string,

629
00:23:11,469 --> 00:23:12,040
quote unquote,

630
00:23:12,150 --> 00:23:13,300
what's your name?

631
00:23:13,310 --> 00:23:14,449
question mark space

632
00:23:14,869 --> 00:23:15,760
no semicolon,

633
00:23:15,869 --> 00:23:16,979
but then on the next line,

634
00:23:17,069 --> 00:23:17,770
what I'm oops,

635
00:23:17,869 --> 00:23:19,380
but uh parenthesis,

636
00:23:19,630 --> 00:23:21,819
then on the next line I'm going to do print,

637
00:23:21,869 --> 00:23:22,589
quote unquote.

638
00:23:24,000 --> 00:23:25,540
space close quote

639
00:23:25,839 --> 00:23:27,109
plus answer.

640
00:23:27,400 --> 00:23:31,069
Down here I'm going to go ahead and run Python if hello.ie again,

641
00:23:31,160 --> 00:23:32,109
no compilation step.

642
00:23:32,199 --> 00:23:34,030
I'm just going to interpret it line by line.

643
00:23:34,239 --> 00:23:35,229
What's my name David?

644
00:23:35,400 --> 00:23:38,219
And it seems now to work exactly the same.

645
00:23:38,439 --> 00:23:41,119
Now it turns out in Python there's even more ways to solve problems like this,

646
00:23:41,199 --> 00:23:42,599
even trivial problems like this.

647
00:23:42,719 --> 00:23:44,599
So here we're using the plus sign,

648
00:23:44,640 --> 00:23:45,910
not as addition per se,

649
00:23:45,959 --> 00:23:47,430
but as the concatenation operator,

650
00:23:47,439 --> 00:23:48,630
the joint operation.

651
00:23:48,959 --> 00:23:49,760
If you want though,

652
00:23:49,859 --> 00:23:50,319
you can take it.

653
00:23:50,420 --> 00:23:54,680
Advantage of the fact that print in Python can take more than one argument.

654
00:23:54,729 --> 00:23:58,079
It can take 2 or 3 or 4 or even 0

655
00:23:58,410 --> 00:24:00,520
by simply changing the plus

656
00:24:00,890 --> 00:24:01,619
to a comma,

657
00:24:01,890 --> 00:24:04,130
getting rid of that seemingly superfluous space,

658
00:24:04,170 --> 00:24:06,290
and just give print two things to print because

659
00:24:06,290 --> 00:24:08,050
it turns out per the documentation of print,

660
00:24:08,060 --> 00:24:09,239
which we'll eventually see,

661
00:24:09,609 --> 00:24:13,359
it knows that if it takes +12 arguments by default,

662
00:24:13,449 --> 00:24:16,079
separate them for you by a single space,

663
00:24:16,150 --> 00:24:18,010
and that's something we can override as well.

664
00:24:18,109 --> 00:24:18,890
Which one is better?

665
00:24:19,069 --> 00:24:19,180
Like,

666
00:24:19,260 --> 00:24:19,459
uh,

667
00:24:19,619 --> 00:24:20,380
like I don't know,

668
00:24:20,459 --> 00:24:21,469
like they're sort of equivalent.

669
00:24:21,500 --> 00:24:22,459
It's such a trivial difference,

670
00:24:22,540 --> 00:24:25,810
but it speaks to the flexibility that you'll start to have

671
00:24:26,020 --> 00:24:28,219
whereby the language is a little less rigid than

672
00:24:28,219 --> 00:24:30,520
C was certainly when it comes to printing strings.

673
00:24:30,660 --> 00:24:30,979
So in fact,

674
00:24:31,020 --> 00:24:32,729
if I go back to VS code here

675
00:24:33,060 --> 00:24:36,380
and I go ahead and change that plus to a comma

676
00:24:36,380 --> 00:24:38,979
and get rid of the space inside of the quotes,

677
00:24:39,180 --> 00:24:41,219
I can rerun Pythonof hello.ie,

678
00:24:41,540 --> 00:24:42,500
type in my name,

679
00:24:42,719 --> 00:24:45,689
and we see exactly the same results there.

680
00:24:46,189 --> 00:24:48,099
But we can take this one step further,

681
00:24:48,140 --> 00:24:49,819
even though it's going to look a little cryptic.

682
00:24:49,859 --> 00:24:52,459
This is sort of the more pythonic way to do things,

683
00:24:52,500 --> 00:24:54,310
and that too is actually a term of art.

684
00:24:54,540 --> 00:24:56,859
To do something pythonically is to do it the

685
00:24:56,859 --> 00:24:59,420
way that most Python programmers would do it.

686
00:24:59,459 --> 00:25:00,180
It's not the only way.

687
00:25:00,209 --> 00:25:01,609
It's not necessarily the right way,

688
00:25:01,739 --> 00:25:04,050
but it's sort of the recommended way in the community.

689
00:25:04,219 --> 00:25:07,530
So here we have that latest version where I'm passing two arguments to print.

690
00:25:07,660 --> 00:25:08,989
The first is quote unquote hello,

691
00:25:09,020 --> 00:25:09,439
comma,

692
00:25:09,979 --> 00:25:12,589
and then the second of which is the value of answer.

693
00:25:12,819 --> 00:25:15,699
I could similarly write this same program.

694
00:25:16,239 --> 00:25:17,810
With this crazy syntax,

695
00:25:18,060 --> 00:25:19,260
it takes a little getting used to,

696
00:25:19,459 --> 00:25:22,130
but it turns out it's actually kind of nice overall.

697
00:25:22,420 --> 00:25:23,579
What's obviously different?

698
00:25:23,660 --> 00:25:23,770
Well,

699
00:25:23,939 --> 00:25:24,260
one,

700
00:25:24,420 --> 00:25:26,369
there's these weird curly braces are back.

701
00:25:26,420 --> 00:25:28,189
They're not part of the logic of the program.

702
00:25:28,260 --> 00:25:30,099
They're literally inside of the

703
00:25:30,380 --> 00:25:31,489
double quotes,

704
00:25:31,819 --> 00:25:33,699
but you can probably guess how this,

705
00:25:33,780 --> 00:25:37,449
what this does for me because there's one other crucial difference.

706
00:25:38,060 --> 00:25:39,609
What else has changed between

707
00:25:40,300 --> 00:25:41,089
before and after?

708
00:25:42,069 --> 00:25:42,300
Yeah,

709
00:25:42,390 --> 00:25:45,930
there's this weird F which is not part of print F.

710
00:25:46,160 --> 00:25:49,180
It's actually inside of the parenthesis and next to the double quotes.

711
00:25:49,219 --> 00:25:52,150
And even this one this came out was a little weird looking to people,

712
00:25:52,260 --> 00:25:52,619
but

713
00:25:52,900 --> 00:25:55,819
this is how you get this thing to be a formatted string,

714
00:25:55,939 --> 00:25:57,569
AKA an F string,

715
00:25:57,780 --> 00:26:00,630
as opposed to it being just a literal string of text.

716
00:26:00,859 --> 00:26:02,579
Now you can probably guess what it means to

717
00:26:02,579 --> 00:26:04,939
put the variable's name inside of the curly braces.

718
00:26:04,979 --> 00:26:09,609
It means the value of that variable is going to be substituted right there,

719
00:26:09,979 --> 00:26:11,150
similar in spirit to the percentage.

720
00:26:11,260 --> 00:26:12,449
S in C,

721
00:26:12,689 --> 00:26:14,729
but a little more explicit with the percents,

722
00:26:14,810 --> 00:26:16,689
you had to remember that that percents corresponds

723
00:26:16,689 --> 00:26:18,709
to this variable's value or something like that,

724
00:26:18,750 --> 00:26:20,800
which was just annoying if anything else,

725
00:26:21,170 --> 00:26:21,880
if anything,

726
00:26:22,290 --> 00:26:25,010
but this time you have a placeholder in curly

727
00:26:25,010 --> 00:26:27,520
braces that just says what you want there,

728
00:26:27,770 --> 00:26:28,920
that particular value,

729
00:26:29,000 --> 00:26:30,449
and what this means more technically is

730
00:26:30,449 --> 00:26:33,260
that the answer variable will be interpolated

731
00:26:33,619 --> 00:26:34,880
by the interpreter,

732
00:26:34,920 --> 00:26:37,619
which means its value will be plugged in right there.

733
00:26:37,770 --> 00:26:38,369
So let's try this.

734
00:26:38,489 --> 00:26:40,369
Let me go back over to VS code.

735
00:26:40,750 --> 00:26:42,180
And quite simply,

736
00:26:42,310 --> 00:26:44,219
on my last line of code here,

737
00:26:44,670 --> 00:26:47,920
let's change the input to print to be quote unquote,

738
00:26:48,229 --> 00:26:48,689
hello,

739
00:26:48,869 --> 00:26:49,390
comma,

740
00:26:49,500 --> 00:26:50,839
and then Curly brace,

741
00:26:51,270 --> 00:26:51,949
answer.

742
00:26:52,859 --> 00:26:53,250
Then

743
00:26:53,420 --> 00:26:54,250
close curly brace,

744
00:26:54,300 --> 00:26:55,010
close quote,

745
00:26:55,089 --> 00:26:55,680
and

746
00:26:56,020 --> 00:26:56,329
I've

747
00:26:56,540 --> 00:26:57,020
done this,

748
00:26:57,099 --> 00:26:57,859
this is intentional,

749
00:26:57,939 --> 00:26:58,380
but let's see.

750
00:26:58,540 --> 00:27:01,219
Let me go ahead and rerun Python of hello.ie DAVID.

751
00:27:01,260 --> 00:27:02,060
What are we about to see?

752
00:27:02,150 --> 00:27:03,170
Hello comma.

753
00:27:05,910 --> 00:27:06,569
Answer,

754
00:27:06,729 --> 00:27:07,760
so this is a bug,

755
00:27:07,969 --> 00:27:11,849
but just to demonstrate like what is going on and what's therefore missing,

756
00:27:11,890 --> 00:27:12,089
what,

757
00:27:12,290 --> 00:27:13,199
what did I forget?

758
00:27:13,410 --> 00:27:13,810
Yeah.

759
00:27:15,959 --> 00:27:16,209
Yeah,

760
00:27:16,329 --> 00:27:19,449
I didn't declare that this is a so-called F string or format string.

761
00:27:19,489 --> 00:27:21,599
The fix for this weirdly is just to put

762
00:27:21,890 --> 00:27:23,040
an F right there.

763
00:27:23,130 --> 00:27:25,930
And now if I rerun Pythono hello.ie,

764
00:27:26,170 --> 00:27:27,050
type in my name again,

765
00:27:27,290 --> 00:27:28,280
cross my fingers,

766
00:27:28,569 --> 00:27:31,359
now I see that the variable has indeed been interpolated

767
00:27:31,569 --> 00:27:33,010
and its value plugged in

768
00:27:33,369 --> 00:27:34,729
where I wanted it.

769
00:27:35,589 --> 00:27:35,900
All right,

770
00:27:36,060 --> 00:27:38,369
turns out we can take off one of these training wheels already.

771
00:27:38,660 --> 00:27:42,689
I propose that Get string just exists in the library just to smooth the transition,

772
00:27:42,859 --> 00:27:45,459
but honestly it's not really doing anything all that interesting.

773
00:27:45,540 --> 00:27:46,939
So let's take this first training wheel off.

774
00:27:46,979 --> 00:27:47,849
It turns out that

775
00:27:48,219 --> 00:27:51,650
Python comes with a function appropriately named input

776
00:27:51,859 --> 00:27:55,130
such that if you want to get input from the human via their keyboard,

777
00:27:55,260 --> 00:27:57,489
you can just use the input function.

778
00:27:57,619 --> 00:28:00,020
So we can already for this program get rid of the CS 50.

779
00:28:00,170 --> 00:28:04,410
Library because input essentially behaves just like the get string function.

780
00:28:04,530 --> 00:28:06,630
So if I go back to my Python version here,

781
00:28:06,849 --> 00:28:09,479
I can change get get string to input,

782
00:28:09,709 --> 00:28:13,079
and I can even go and delete this training wheel up there,

783
00:28:13,329 --> 00:28:15,489
rerun Pythono hello.ie in my terminal,

784
00:28:15,569 --> 00:28:16,560
DAVID enter,

785
00:28:16,890 --> 00:28:18,959
and we're still in business as well.

786
00:28:19,089 --> 00:28:24,489
So input is generally going to be the way you go about getting input now from the user.

787
00:28:24,939 --> 00:28:25,000
All right,

788
00:28:25,250 --> 00:28:27,010
let me pause here and see if there's any questions

789
00:28:27,010 --> 00:28:30,199
as we try to bridge these two worlds from C

790
00:28:30,489 --> 00:28:31,170
to Python.

791
00:28:31,939 --> 00:28:32,250
Yeah.

792
00:28:33,680 --> 00:28:33,880
uh,

793
00:28:33,959 --> 00:28:34,569
so in Python,

794
00:28:34,599 --> 00:28:35,640
we don't need a name.

795
00:28:38,439 --> 00:28:38,920
Good question.

796
00:28:38,959 --> 00:28:39,439
In Python,

797
00:28:39,500 --> 00:28:42,439
why don't we need the main function anymore because clearly that's

798
00:28:42,439 --> 00:28:45,189
been omnipresent in like every program we've written thus far,

799
00:28:45,199 --> 00:28:48,079
and here we have it in all of our Python programs thus far absent.

800
00:28:48,589 --> 00:28:52,380
It turns out that humans realize it's just so common that you want

801
00:28:52,380 --> 00:28:55,750
the file you're editing to be the main part of your program.

802
00:28:55,829 --> 00:28:55,949
Like,

803
00:28:56,020 --> 00:28:56,739
why bother

804
00:28:56,989 --> 00:29:01,180
adding the additional syntax of saying in main void or something analogous?

805
00:29:01,430 --> 00:29:04,500
It's just easier if you want to write two lines of code to get some work done.

806
00:29:04,630 --> 00:29:06,229
Why do you have to waste my time adding all

807
00:29:06,229 --> 00:29:09,069
of these this boilerplate code which we've been doing.

808
00:29:09,540 --> 00:29:10,400
Up until now,

809
00:29:10,479 --> 00:29:11,060
now that said,

810
00:29:11,180 --> 00:29:14,569
we're going to bring back Maine in a little bit because it will solve a problem,

811
00:29:14,660 --> 00:29:15,609
but generally speaking,

812
00:29:15,699 --> 00:29:17,609
what I'm doing here is indeed a program,

813
00:29:17,699 --> 00:29:20,339
but people in the real world would also call these scripts where a script

814
00:29:20,339 --> 00:29:22,859
is like a lightweight program that pretty much just reads top to bottom,

815
00:29:22,939 --> 00:29:23,300
left to right.

816
00:29:23,380 --> 00:29:24,689
It might be fairly lightweight.

817
00:29:24,819 --> 00:29:26,770
It's really synonymous with writing a program,

818
00:29:26,819 --> 00:29:27,180
but

819
00:29:27,579 --> 00:29:30,050
this is again one of the appeals of a language like Python.

820
00:29:30,060 --> 00:29:32,540
You can just get right in and get out and get the job done.

821
00:29:33,209 --> 00:29:35,329
Even Java has moved to this in recent years where

822
00:29:35,329 --> 00:29:37,160
you don't have to put everything in a class,

823
00:29:37,489 --> 00:29:37,760
uh,

824
00:29:37,770 --> 00:29:39,569
public static void main for those familiar,

825
00:29:39,650 --> 00:29:40,599
you can just write,

826
00:29:40,949 --> 00:29:41,319
uh,

827
00:29:41,530 --> 00:29:43,160
system.out.print line and

828
00:29:43,489 --> 00:29:44,130
get some work done.

829
00:29:44,949 --> 00:29:45,380
Yeah.

830
00:29:47,699 --> 00:29:48,150
Good question.

831
00:29:48,180 --> 00:29:49,579
Is input only for a string?

832
00:29:49,780 --> 00:29:50,010
Yes,

833
00:29:50,180 --> 00:29:50,500
right now,

834
00:29:50,579 --> 00:29:52,939
it will get input from the user via their keyboard

835
00:29:52,939 --> 00:29:55,410
and you'll get back a string just like get string,

836
00:29:55,619 --> 00:29:58,579
and we'll come back to why that's maybe not a good thing.

837
00:29:59,359 --> 00:29:59,939
All right,

838
00:30:00,140 --> 00:30:03,849
so what's more what we want to do at this point?

839
00:30:03,880 --> 00:30:04,030
Well,

840
00:30:04,349 --> 00:30:07,619
let's tease apart some differences now with C.

841
00:30:07,750 --> 00:30:08,930
So up until now,

842
00:30:08,949 --> 00:30:11,630
every argument we've ever passed into a function in C,

843
00:30:11,640 --> 00:30:12,099
and

844
00:30:12,510 --> 00:30:16,589
scratch for that matter is a so-called positional parameter,

845
00:30:16,599 --> 00:30:18,709
and a parameter is the same thing as an argument,

846
00:30:18,750 --> 00:30:22,069
but generally when you're looking at the function from the functions perspective,

847
00:30:22,079 --> 00:30:23,650
it's a parameter that it accepts,

848
00:30:23,790 --> 00:30:26,097
but when you're Calling the function and passing in an input,

849
00:30:26,107 --> 00:30:27,457
you call it typically an argument,

850
00:30:27,496 --> 00:30:29,567
but they refer to essentially the same thing,

851
00:30:29,697 --> 00:30:30,487
and all of the

852
00:30:30,786 --> 00:30:33,766
parameters we've been passing into functions thus far

853
00:30:34,136 --> 00:30:37,227
have been positional in the sense that the order matters.

854
00:30:37,256 --> 00:30:37,927
The first thing,

855
00:30:38,006 --> 00:30:38,857
then the second thing,

856
00:30:38,957 --> 00:30:39,607
then the third thing,

857
00:30:39,616 --> 00:30:40,136
and so forth.

858
00:30:40,177 --> 00:30:40,457
For instance,

859
00:30:40,496 --> 00:30:41,097
with print F,

860
00:30:41,187 --> 00:30:43,107
the first thing has to be the quoted string,

861
00:30:43,116 --> 00:30:44,246
maybe with the placeholder,

862
00:30:44,376 --> 00:30:46,886
and then if there's another argument after the comma,

863
00:30:47,097 --> 00:30:48,376
that can be the 2nd argument,

864
00:30:48,457 --> 00:30:49,136
the 3rd argument,

865
00:30:49,217 --> 00:30:49,376
and.

866
00:30:49,494 --> 00:30:50,274
So forth,

867
00:30:50,364 --> 00:30:52,374
but it turns out Python additionally

868
00:30:52,374 --> 00:30:55,333
supports what are called named parameters whereby

869
00:30:55,524 --> 00:30:57,803
you don't have to rely only on the order

870
00:30:57,803 --> 00:31:00,244
in which you're enumerating the arguments to a function,

871
00:31:00,343 --> 00:31:01,803
and that's helpful because

872
00:31:02,124 --> 00:31:02,803
some functions,

873
00:31:03,004 --> 00:31:04,234
especially in the real world,

874
00:31:04,323 --> 00:31:07,514
when you start using other people's libraries that have lots of functionality,

875
00:31:07,723 --> 00:31:09,563
they might not take just one or two arguments.

876
00:31:09,604 --> 00:31:11,443
They might take 4 arguments,

877
00:31:11,473 --> 00:31:12,364
10 arguments,

878
00:31:12,423 --> 00:31:13,313
maybe even more,

879
00:31:13,484 --> 00:31:14,404
and it can just be.

880
00:31:14,590 --> 00:31:17,431
Wieldy to have to remember the precise order of all those arguments,

881
00:31:17,470 --> 00:31:19,590
you're just asking for trouble if you're going to screw up or a

882
00:31:19,590 --> 00:31:22,671
colleague is going to get the order out of out of whack.

883
00:31:23,110 --> 00:31:27,620
So with name parameters you can actually be explicit with Python and tell it

884
00:31:27,990 --> 00:31:32,821
what argument you are trying to pass in by giving it an actual name.

885
00:31:33,031 --> 00:31:35,671
So let me go over to BS code here and propose that

886
00:31:35,671 --> 00:31:39,590
we use this for really the simplest of programs in order to

887
00:31:40,099 --> 00:31:41,089
Override

888
00:31:41,339 --> 00:31:42,540
that default

889
00:31:42,939 --> 00:31:46,489
new line that we seem to be getting for free just by calling print.

890
00:31:46,660 --> 00:31:47,060
In other words,

891
00:31:47,140 --> 00:31:49,170
let me go ahead here and clear my terminal window.

892
00:31:49,339 --> 00:31:53,060
Let me close hello.c and focus only on hello.ie for

893
00:31:53,060 --> 00:31:54,790
just a moment and let's make it much simpler,

894
00:31:54,819 --> 00:31:55,810
like the very first version,

895
00:31:55,819 --> 00:31:56,969
and just print out

896
00:31:57,300 --> 00:31:58,729
using Python's print function,

897
00:31:58,819 --> 00:31:59,770
not print F,

898
00:32:00,060 --> 00:32:01,189
quote unquote hello.

899
00:32:02,175 --> 00:32:02,805
close quote.

900
00:32:03,094 --> 00:32:05,484
And now here I'm going to do Pythono hello.ie.

901
00:32:05,604 --> 00:32:08,925
Enter and we still see that the cursor moves to the next line,

902
00:32:08,974 --> 00:32:10,444
the dollar sign moves to the next line,

903
00:32:10,714 --> 00:32:13,204
because I'm automatically getting a new line.

904
00:32:13,334 --> 00:32:13,395
Well,

905
00:32:13,454 --> 00:32:14,635
what if you don't want that?

906
00:32:14,775 --> 00:32:16,295
How can you override that behavior?

907
00:32:16,375 --> 00:32:16,454
Well,

908
00:32:16,494 --> 00:32:19,814
you can actually use a named parameter in Python,

909
00:32:19,824 --> 00:32:22,775
and I can go up here and add a second argument.

910
00:32:23,439 --> 00:32:25,689
That if it were just something like

911
00:32:26,729 --> 00:32:30,849
this that would literally print out the word this because it's just another string,

912
00:32:31,260 --> 00:32:34,500
but if I give it a name like end equals

913
00:32:34,819 --> 00:32:35,890
quote unquote,

914
00:32:36,189 --> 00:32:39,660
I can override the default behavior of the Python

915
00:32:39,660 --> 00:32:44,010
print function by changing the value of its end parameter

916
00:32:44,380 --> 00:32:46,020
to be the so-called empty string,

917
00:32:46,180 --> 00:32:46,739
quote unquote,

918
00:32:46,859 --> 00:32:48,489
which means literally there's nothing there.

919
00:32:49,170 --> 00:32:53,300
Watch what happens now if I run Python of hello.ie and hit enter,

920
00:32:53,849 --> 00:32:55,420
the dollar sign is weirdly

921
00:32:55,650 --> 00:32:58,250
and sort of in the ugly way on the same line just like

922
00:32:58,250 --> 00:33:01,079
it was when I made the mistake in C in week one of omitting

923
00:33:01,250 --> 00:33:02,170
the backslash N.

924
00:33:02,739 --> 00:33:03,930
That is to say,

925
00:33:04,060 --> 00:33:09,099
what the default value of this end parameter really is is quote unquote backslashn,

926
00:33:09,109 --> 00:33:11,650
and I can make it explicit by changing my code as such.

927
00:33:11,939 --> 00:33:14,890
I'm going to go ahead and rerun Pythono hello.ie,

928
00:33:15,300 --> 00:33:17,449
and now the cursors back on the next line.

929
00:33:17,660 --> 00:33:20,939
And not that this is that useful other than overriding that default,

930
00:33:20,979 --> 00:33:22,819
but you could do fun things like,

931
00:33:24,819 --> 00:33:27,260
if you really want print to be excited to print some.

932
00:33:27,369 --> 00:33:28,089
Things for you.

933
00:33:28,239 --> 00:33:31,030
And if I now run Python of hello.ie a third time,

934
00:33:31,239 --> 00:33:33,439
now you see that it's ending with exclamation

935
00:33:33,439 --> 00:33:36,349
looks a little stupid with the dollar sign,

936
00:33:36,520 --> 00:33:38,640
so you could even toss in a new line there,

937
00:33:38,880 --> 00:33:39,910
run it yet again,

938
00:33:40,040 --> 00:33:42,160
and now we sort of get both of those there.

939
00:33:42,239 --> 00:33:43,959
But I would say the common case is to

940
00:33:43,959 --> 00:33:48,550
use that end named parameter simply to override it.

941
00:33:48,719 --> 00:33:50,520
So how do you learn more about these kinds of things?

942
00:33:50,599 --> 00:33:50,810
Well,

943
00:33:51,079 --> 00:33:52,109
if you go to

944
00:33:52,430 --> 00:33:54,310
The official documentation for Python,

945
00:33:54,329 --> 00:33:56,520
which is a thing more so than with C,

946
00:33:56,689 --> 00:33:58,650
like if you want to learn more about Python and

947
00:33:58,650 --> 00:34:01,050
the functions it offers and the arguments it takes,

948
00:34:01,060 --> 00:34:04,369
you go to the official documentation docs.python.org.

949
00:34:04,449 --> 00:34:06,969
This is essentially analogous to the so-called manual pages

950
00:34:06,969 --> 00:34:09,679
or man pages that CS50 has a version of,

951
00:34:09,770 --> 00:34:13,129
but there is no one de facto source for those man pages.

952
00:34:13,280 --> 00:34:15,159
Several different versions of them exist in the wild,

953
00:34:15,250 --> 00:34:16,320
whereas Python itself.

954
00:34:16,375 --> 00:34:19,196
A community maintains its own official documentation.

955
00:34:19,364 --> 00:34:19,875
So for instance,

956
00:34:19,926 --> 00:34:23,775
if you go to a specific URL like this ending in functions.html,

957
00:34:23,844 --> 00:34:26,485
you'll see an exhaustive list of all of the functions

958
00:34:26,485 --> 00:34:29,364
that come with Python besides just the print function,

959
00:34:29,446 --> 00:34:30,916
and we'll see a bunch of more today.

960
00:34:31,125 --> 00:34:35,085
If specifically you scroll down to the print documentation,

961
00:34:35,284 --> 00:34:39,074
you'll see something that's a little arcane that looks like this,

962
00:34:39,284 --> 00:34:40,246
but this is represented.

963
00:34:40,411 --> 00:34:41,652
of a Python

964
00:34:42,081 --> 00:34:42,751
prototype,

965
00:34:42,882 --> 00:34:43,362
if you will,

966
00:34:43,440 --> 00:34:46,251
also called a signature that just tells you the name of

967
00:34:46,251 --> 00:34:49,940
a function and then how many and what type of arguments

968
00:34:50,322 --> 00:34:51,052
it takes.

969
00:34:51,081 --> 00:34:52,141
So how to read this?

970
00:34:52,281 --> 00:34:52,371
Well,

971
00:34:52,440 --> 00:34:53,882
the print function takes

972
00:34:54,241 --> 00:34:55,362
some number of objects.

973
00:34:55,460 --> 00:34:57,001
So in Python specifically,

974
00:34:57,121 --> 00:35:00,441
this syntax of star objects just means zero or more objects,

975
00:35:00,521 --> 00:35:01,122
whatever that is,

976
00:35:01,201 --> 00:35:03,511
like a number or a string or something else.

977
00:35:03,602 --> 00:35:04,362
The stuff you want to.

978
00:35:04,548 --> 00:35:05,177
Print out

979
00:35:05,518 --> 00:35:06,048
after that,

980
00:35:06,197 --> 00:35:08,387
if you start using named parameters,

981
00:35:08,397 --> 00:35:10,498
you can specify what the default separator

982
00:35:10,498 --> 00:35:13,518
is the separator between arguments to print.

983
00:35:13,597 --> 00:35:14,907
So recall that when I did

984
00:35:15,197 --> 00:35:16,337
quote unquote hello,

985
00:35:17,708 --> 00:35:18,427
quote unquote

986
00:35:18,917 --> 00:35:20,387
or quote unquote hello,

987
00:35:20,397 --> 00:35:24,998
comma answer it was separated automatically for us by a single space

988
00:35:24,998 --> 00:35:27,927
even without my hitting the space bar inside of my quotes.

989
00:35:27,958 --> 00:35:28,357
That's because.

990
00:35:28,483 --> 00:35:31,384
As the default value here is in fact a single space.

991
00:35:31,634 --> 00:35:35,354
The default value for and as promised is indeed backslashn.

992
00:35:35,634 --> 00:35:38,864
And then there's some other stuff related to file IO that print can also deal with,

993
00:35:38,874 --> 00:35:40,983
but more on that perhaps another time.

994
00:35:41,114 --> 00:35:42,983
There's one curiosity here in Python,

995
00:35:42,993 --> 00:35:47,263
it turns out that you can use double quotes or single quotes around strings,

996
00:35:47,273 --> 00:35:49,063
where in C it was much more regimented.

997
00:35:49,233 --> 00:35:52,394
Double quotes are for strings and single quotes are for.

998
00:35:53,320 --> 00:35:56,169
Chars characters only single characters.

999
00:35:56,239 --> 00:35:59,639
It doesn't matter in Python which one you use so long as you're

1000
00:35:59,639 --> 00:36:02,919
consistent and stylistically you should really pick one and go with it.

1001
00:36:03,120 --> 00:36:04,919
And the only time you should really alternate between

1002
00:36:04,919 --> 00:36:06,959
the two is maybe if you want to put like

1003
00:36:06,959 --> 00:36:09,689
an apostrophe for some human's name inside of double

1004
00:36:09,689 --> 00:36:11,989
quote inside of single quotes or something like that,

1005
00:36:12,239 --> 00:36:13,860
but generally you have a little more flexibility.

1006
00:36:14,195 --> 00:36:17,205
in Python and you'll see in different languages Python community

1007
00:36:17,205 --> 00:36:19,514
tends to use single quotes at least in the documentation.

1008
00:36:19,675 --> 00:36:22,344
The JavaScript world tends to use single quotes.

1009
00:36:22,475 --> 00:36:22,705
Um,

1010
00:36:22,715 --> 00:36:26,784
we in CS 50 often use double quotes just for consistency with what we do and see,

1011
00:36:26,915 --> 00:36:27,445
but any,

1012
00:36:27,594 --> 00:36:28,145
uh,

1013
00:36:28,155 --> 00:36:31,864
community or company would typically have its own style guide that dictates

1014
00:36:32,155 --> 00:36:35,024
which one you should use if only for consistency.

1015
00:36:35,594 --> 00:36:36,395
Questions

1016
00:36:36,955 --> 00:36:37,524
then

1017
00:36:38,034 --> 00:36:39,395
on this here print function.

1018
00:36:40,639 --> 00:36:43,469
As just representative of all of the docks

1019
00:36:43,760 --> 00:36:44,590
that you'll see.

1020
00:36:46,469 --> 00:36:46,750
All right,

1021
00:36:46,909 --> 00:36:47,020
well,

1022
00:36:47,030 --> 00:36:48,229
let's take a quick look at variables.

1023
00:36:48,310 --> 00:36:49,860
We've used these a few times already,

1024
00:36:49,919 --> 00:36:53,540
but let's focus in a little more detail on what's actually different in Scratch,

1025
00:36:53,669 --> 00:36:56,179
if you wanted to create a variable called counter and set it equal to 0,

1026
00:36:56,189 --> 00:36:57,979
you would use this orange puzzle piece here.

1027
00:36:58,189 --> 00:36:58,830
In C,

1028
00:36:58,979 --> 00:37:01,070
you would do something like this the type of the variable,

1029
00:37:01,080 --> 00:37:01,879
the name of the variable,

1030
00:37:01,949 --> 00:37:03,100
and then set it equal to

1031
00:37:03,290 --> 00:37:04,860
the initial value semicolon.

1032
00:37:04,989 --> 00:37:05,780
In Python,

1033
00:37:05,790 --> 00:37:07,659
it's going to be a little similar,

1034
00:37:07,709 --> 00:37:09,510
but you can probably guess where we're going with this.

1035
00:37:09,590 --> 00:37:12,030
How is this line of code probably about to change?

1036
00:37:12,800 --> 00:37:13,149
Yeah,

1037
00:37:16,389 --> 00:37:16,510
Good,

1038
00:37:16,590 --> 00:37:18,949
we're not going to bother with in or the data type more generally,

1039
00:37:18,989 --> 00:37:22,030
we're just gonna say counter because obviously like a smart interpreter can just

1040
00:37:22,030 --> 00:37:24,169
figure it out from context that you're putting a 0 in there.

1041
00:37:24,179 --> 00:37:25,270
It's obviously an integer,

1042
00:37:25,389 --> 00:37:26,780
and what else is about to go away?

1043
00:37:27,719 --> 00:37:28,709
The semicolon.

1044
00:37:28,790 --> 00:37:30,469
So this is the C version and voila,

1045
00:37:30,669 --> 00:37:33,870
this now is the Python version and this is as silly as this example is,

1046
00:37:33,909 --> 00:37:37,669
it's kind of representative of how languages like Python just tend to be a little

1047
00:37:37,669 --> 00:37:40,739
more programmer friendly because you just type less and get the same work done.

1048
00:37:40,989 --> 00:37:41,189
All right,

1049
00:37:41,310 --> 00:37:43,629
so if we wanted to do something now and scratch like.

1050
00:37:43,780 --> 00:37:45,169
Increment the counter by 1.

1051
00:37:45,209 --> 00:37:46,719
You would use this puzzle piece here.

1052
00:37:46,929 --> 00:37:48,810
In C we could do something like this in

1053
00:37:48,810 --> 00:37:50,800
Python it's going to be almost exactly the same,

1054
00:37:50,850 --> 00:37:53,000
except of course no semicolon.

1055
00:37:53,209 --> 00:37:55,669
In C we could alternatively do this,

1056
00:37:55,709 --> 00:37:58,060
and you can also do this in Python.

1057
00:37:58,449 --> 00:37:59,689
In C though,

1058
00:38:00,419 --> 00:38:02,580
You could also do what other technique?

1059
00:38:03,639 --> 00:38:04,310
Plus plus,

1060
00:38:04,639 --> 00:38:05,030
I'm sorry,

1061
00:38:05,120 --> 00:38:06,560
but Python has taken that away from us.

1062
00:38:06,719 --> 00:38:09,129
So if you got into the habit of using plus plus or minus minus,

1063
00:38:09,199 --> 00:38:09,560
that's great.

1064
00:38:09,840 --> 00:38:11,469
Use them and see all you want in Python,

1065
00:38:11,520 --> 00:38:12,429
they just don't exist,

1066
00:38:12,600 --> 00:38:16,149
so you'll see this more commonly instead as the heuristic.

1067
00:38:16,399 --> 00:38:16,639
All right,

1068
00:38:16,760 --> 00:38:19,790
what about the various types that exist in Python?

1069
00:38:20,120 --> 00:38:21,959
Because even though you don't have to

1070
00:38:21,959 --> 00:38:24,520
specify the types when declaring your variables,

1071
00:38:24,639 --> 00:38:27,500
they do in fact actually exist underneath the hood,

1072
00:38:27,510 --> 00:38:29,350
and it's worth knowing a little something about them because

1073
00:38:29,395 --> 00:38:32,946
Not knowing will lead to some form of bug.

1074
00:38:33,025 --> 00:38:35,065
So in C we had types like this bull,

1075
00:38:35,095 --> 00:38:35,426
char,

1076
00:38:35,506 --> 00:38:35,785
double,

1077
00:38:35,795 --> 00:38:36,736
float in long,

1078
00:38:36,785 --> 00:38:37,395
and string,

1079
00:38:37,426 --> 00:38:39,426
the last of which was thanks to the CS 50 library.

1080
00:38:39,436 --> 00:38:43,025
But last week we would have started calling a string chartar instead,

1081
00:38:43,105 --> 00:38:44,666
which it still is a data type,

1082
00:38:44,706 --> 00:38:46,125
the address of some char.

1083
00:38:46,545 --> 00:38:47,305
In Python,

1084
00:38:47,345 --> 00:38:49,105
we're going to whittle this list down to a

1085
00:38:49,105 --> 00:38:52,105
subset of those essentially whereby we still have bulls,

1086
00:38:52,226 --> 00:38:52,986
we still have floats,

1087
00:38:53,025 --> 00:38:53,865
we still have ints,

1088
00:38:53,875 --> 00:38:54,825
and we do have strings,

1089
00:38:54,865 --> 00:38:55,385
but they're literally.

1090
00:38:55,471 --> 00:38:58,562
Called ss STR so it's not a CS 50 thing.

1091
00:38:58,572 --> 00:39:01,372
The Python community calls strings STRs,

1092
00:39:01,572 --> 00:39:04,172
but absent from this list is any mention of star,

1093
00:39:04,372 --> 00:39:05,642
not to mention chartar,

1094
00:39:05,852 --> 00:39:08,241
there are no pointers in Python,

1095
00:39:08,251 --> 00:39:11,731
and indeed as powerful as I'd hope you found

1096
00:39:11,852 --> 00:39:14,031
weeks 4 and 5 to be,

1097
00:39:14,251 --> 00:39:17,971
I dare say you also found them incredibly frustrating and challenging

1098
00:39:17,971 --> 00:39:21,471
and want to yield bugs in your code because with that.

1099
00:39:21,528 --> 00:39:24,147
Power of memory management comes a whole slew

1100
00:39:24,147 --> 00:39:25,947
of potential mistakes that you can make,

1101
00:39:26,077 --> 00:39:28,758
and that's true not just for CS 50 students but for programmers,

1102
00:39:29,008 --> 00:39:29,718
adult programmers,

1103
00:39:29,877 --> 00:39:31,548
full time programmers around the world.

1104
00:39:31,637 --> 00:39:36,038
And so among the other features of languages like Python is they try to take away

1105
00:39:36,038 --> 00:39:38,558
certain features of languages like C that were

1106
00:39:38,558 --> 00:39:40,397
just too dangerous in the first place.

1107
00:39:40,468 --> 00:39:41,558
It might be wonderfully powerful.

1108
00:39:41,728 --> 00:39:43,318
It might help you solve problems more quickly,

1109
00:39:43,437 --> 00:39:44,208
more precisely,

1110
00:39:44,278 --> 00:39:47,308
but if they tend to do more damage than they're worth,

1111
00:39:47,357 --> 00:39:47,488
some.

1112
00:39:47,593 --> 00:39:50,093
it's worth just abstracting those details away.

1113
00:39:50,263 --> 00:39:50,624
Similarly,

1114
00:39:50,743 --> 00:39:51,884
Java has references,

1115
00:39:51,983 --> 00:39:52,934
as some of you might know,

1116
00:39:53,184 --> 00:39:54,664
but does not have pointers per se.

1117
00:39:54,743 --> 00:39:57,974
You can't go poking around arbitrary locations in memory

1118
00:39:58,184 --> 00:40:00,243
in the same way that you can with C.

1119
00:40:00,704 --> 00:40:02,664
So let's take some of these data types out for

1120
00:40:02,664 --> 00:40:04,464
a spin and see what's the same and what's different.

1121
00:40:04,543 --> 00:40:07,184
Let me go back to VS code here and let me propose that

1122
00:40:07,184 --> 00:40:10,503
we bring back one of our old calculators from a while back.

1123
00:40:10,624 --> 00:40:11,924
So let me clear my terminal,

1124
00:40:12,263 --> 00:40:13,343
close hello.ie.

1125
00:40:13,959 --> 00:40:18,989
And let me go ahead and open up a version of this program that I brought in advance,

1126
00:40:19,030 --> 00:40:21,699
which was our calculator version 0

1127
00:40:21,989 --> 00:40:22,770
from back then.

1128
00:40:22,989 --> 00:40:23,830
So just to remind you,

1129
00:40:23,909 --> 00:40:26,629
one of the first versions of our calculator had the

1130
00:40:26,629 --> 00:40:29,820
CS 50 library as well as the standard IO library,

1131
00:40:29,989 --> 00:40:33,659
and then we simply got an IT using GetIT in week 1.

1132
00:40:33,790 --> 00:40:36,229
We got another in in week one using GetIT,

1133
00:40:36,330 --> 00:40:38,300
and then we simply performed some additions.

1134
00:40:38,389 --> 00:40:40,927
It was a very Trivial calculator that we did very early on

1135
00:40:40,927 --> 00:40:43,997
just to demonstrate some of the operators and syntax of C.

1136
00:40:44,527 --> 00:40:44,687
Well,

1137
00:40:44,846 --> 00:40:48,406
let's go ahead and try converting this to Python by creating our own program,

1138
00:40:48,487 --> 00:40:49,547
calculator.i.

1139
00:40:49,927 --> 00:40:55,316
So in my terminal window I'm going to write code of calculator.i.

1140
00:40:55,767 --> 00:40:58,527
It's going to open another tab which I'm just going to drag over

1141
00:40:58,527 --> 00:41:00,997
to the right just so we can see both side by side.

1142
00:41:01,086 --> 00:41:02,116
I won't bother with,

1143
00:41:02,836 --> 00:41:03,517
say,

1144
00:41:03,717 --> 00:41:03,927
well,

1145
00:41:04,073 --> 00:41:04,983
Let's do it for parity here.

1146
00:41:05,063 --> 00:41:07,674
Let me copy the C code into the Python file,

1147
00:41:07,704 --> 00:41:09,894
even though this will not work in the same way.

1148
00:41:10,184 --> 00:41:13,214
But let's keep what we need and get rid of what we don't.

1149
00:41:13,424 --> 00:41:14,654
So instead of

1150
00:41:14,793 --> 00:41:17,414
the slash slash for comments in Python,

1151
00:41:17,573 --> 00:41:21,374
it turns out the convention is to use a single hash symbol like this.

1152
00:41:21,664 --> 00:41:22,894
So it's a minor difference.

1153
00:41:22,983 --> 00:41:24,464
It's half as many keystrokes,

1154
00:41:24,503 --> 00:41:25,253
so that's nice,

1155
00:41:25,384 --> 00:41:27,104
but we're not going to include anything like this.

1156
00:41:27,204 --> 00:41:29,063
But we are going to do from CS 50.

1157
00:41:29,240 --> 00:41:32,400
Let's import a function that I promised would exist called get in,

1158
00:41:32,601 --> 00:41:34,631
but we'll soon get rid of that training wheel as well.

1159
00:41:34,801 --> 00:41:36,950
We don't need main or this curly brace.

1160
00:41:37,160 --> 00:41:38,920
We don't need this curly brace,

1161
00:41:39,000 --> 00:41:40,960
and we don't need all of this indentation as a result.

1162
00:41:41,051 --> 00:41:43,031
So I'm going to move all of that over to the left.

1163
00:41:43,281 --> 00:41:47,831
I'm going to fix all of the comments to be Python comments by changing the slash slash

1164
00:41:48,200 --> 00:41:49,670
to hash symbols.

1165
00:41:49,960 --> 00:41:52,150
And now I'm going to change each of these three lines of code,

1166
00:41:52,160 --> 00:41:54,081
as you might expect to the Python version.

1167
00:41:54,330 --> 00:41:56,399
So you probably can guess already.

1168
00:41:56,439 --> 00:41:59,030
We can get rid of the in there and the in there.

1169
00:41:59,280 --> 00:42:02,189
We can get rid of the semicolon here and the semicolon here.

1170
00:42:02,399 --> 00:42:07,030
We can get rid of the F in print F here and we can get rid of the semicolon here.

1171
00:42:07,320 --> 00:42:09,149
And there's a few different ways we could do this,

1172
00:42:09,199 --> 00:42:11,000
but I dare say the simplest is going to be to

1173
00:42:11,000 --> 00:42:13,989
get rid of the format code altogether in that first argument

1174
00:42:14,120 --> 00:42:16,750
and just tell Python to print X plus Y.

1175
00:42:17,080 --> 00:42:18,320
So there's a few different ways we can do this,

1176
00:42:18,360 --> 00:42:22,000
but that's probably the most literal translation of the program at left.

1177
00:42:22,155 --> 00:42:23,425
To the program at right.

1178
00:42:23,705 --> 00:42:28,094
Let's reopen the terminal window and run Python of calculator.ie and hit enter.

1179
00:42:28,544 --> 00:42:30,304
Let's do something like X is 1,

1180
00:42:30,544 --> 00:42:31,145
Y is 2,

1181
00:42:31,185 --> 00:42:31,854
and hopefully,

1182
00:42:32,425 --> 00:42:34,534
we do in fact get 3.

1183
00:42:35,024 --> 00:42:35,344
All right,

1184
00:42:35,584 --> 00:42:37,504
so that's all fine and good,

1185
00:42:37,584 --> 00:42:40,584
but let's take off one of our training wheels now.

1186
00:42:40,665 --> 00:42:43,254
So let me get rid of our C version here

1187
00:42:43,504 --> 00:42:45,425
and focus just for the moment on Python.

1188
00:42:45,504 --> 00:42:49,824
Let's take away this C code and what was the function we can use to get user input.

1189
00:42:52,260 --> 00:42:52,419
Yeah,

1190
00:42:52,489 --> 00:42:53,800
it was called a little louder.

1191
00:42:54,330 --> 00:42:55,340
It's just called input.

1192
00:42:55,489 --> 00:43:00,620
So let's get rid of CS 50's get in already and use input instead.

1193
00:43:00,889 --> 00:43:01,129
All right,

1194
00:43:01,209 --> 00:43:03,340
so this program is much simpler already.

1195
00:43:03,570 --> 00:43:05,560
So let's go ahead and reopen the terminal window,

1196
00:43:05,810 --> 00:43:07,550
run Python of calculator.pi,

1197
00:43:08,409 --> 00:43:09,639
do one again for X,

1198
00:43:09,770 --> 00:43:10,610
2 again for Y,

1199
00:43:10,679 --> 00:43:11,489
and of course,

1200
00:43:11,570 --> 00:43:13,030
1 + 2 equals

1201
00:43:13,649 --> 00:43:14,580
12.

1202
00:43:15,909 --> 00:43:16,989
So what's

1203
00:43:17,199 --> 00:43:18,750
going on here?

1204
00:43:18,879 --> 00:43:21,159
Cause clearly this is a step backwards,

1205
00:43:21,239 --> 00:43:21,760
yeah.

1206
00:43:24,300 --> 00:43:24,530
Yeah,

1207
00:43:24,620 --> 00:43:26,060
so in the context of strings,

1208
00:43:26,199 --> 00:43:27,820
plus represents concatenation,

1209
00:43:27,860 --> 00:43:31,090
the joining of two arguments on the left and the right.

1210
00:43:31,459 --> 00:43:34,540
Here that seems to be what's happening because it's not 12 per se,

1211
00:43:34,620 --> 00:43:37,419
it's more literally +12 concatenated together,

1212
00:43:37,459 --> 00:43:38,139
but why is that?

1213
00:43:38,260 --> 00:43:38,300
Well,

1214
00:43:38,379 --> 00:43:40,580
apparently the input function indeed.

1215
00:43:40,669 --> 00:43:43,659
Returns a string that is those are the key strokes that came back from

1216
00:43:43,659 --> 00:43:47,489
the user might look like numbers in Arabic numerals to us 1 and 2,

1217
00:43:47,800 --> 00:43:50,250
but it's being treated as a string.

1218
00:43:50,419 --> 00:43:51,929
More technically like underneath the hood,

1219
00:43:52,060 --> 00:43:54,409
there is some char star stuff going on there,

1220
00:43:54,479 --> 00:43:57,169
even though we're not using that same terminology.

1221
00:43:57,500 --> 00:43:58,419
So intuitively,

1222
00:43:58,500 --> 00:44:00,209
what's going to be the solution

1223
00:44:00,899 --> 00:44:03,860
without just reverting to using the training wheel that

1224
00:44:03,860 --> 00:44:05,820
is the get in function from CS 50?

1225
00:44:05,899 --> 00:44:06,610
Put another way,

1226
00:44:06,780 --> 00:44:09,270
how did CS 50 probably implement get in,

1227
00:44:09,620 --> 00:44:10,409
might you think?

1228
00:44:10,969 --> 00:44:11,340
Yeah.

1229
00:44:14,020 --> 00:44:14,330
Yeah,

1230
00:44:14,489 --> 00:44:15,330
so we'recall that in C.

1231
00:44:15,370 --> 00:44:17,969
We could cast some data types to other data types,

1232
00:44:18,090 --> 00:44:20,850
typically ends to chars or charges to ends.

1233
00:44:20,969 --> 00:44:24,320
It's not quite as simple as casting in this case,

1234
00:44:24,489 --> 00:44:26,000
because underneath the hood,

1235
00:44:26,169 --> 00:44:27,399
thanks to our knowledge of C,

1236
00:44:27,689 --> 00:44:29,090
there's a bunch of stuff going on.

1237
00:44:29,129 --> 00:44:31,679
There's probably a 1 and there's a null character.

1238
00:44:31,810 --> 00:44:32,620
There's a 2,

1239
00:44:32,649 --> 00:44:33,679
and there's a null character,

1240
00:44:33,689 --> 00:44:37,745
so Not quite as literal as a char to an end or an end to a char,

1241
00:44:37,915 --> 00:44:42,794
so we're going to more properly convert the H string or the stirr to an end.

1242
00:44:42,875 --> 00:44:43,655
We're not casting,

1243
00:44:43,675 --> 00:44:44,475
but converting,

1244
00:44:44,625 --> 00:44:47,705
and converting just implies that there's a little more work that has to be done.

1245
00:44:47,915 --> 00:44:49,955
But thankfully Python can do this for us.

1246
00:44:50,074 --> 00:44:50,354
In fact,

1247
00:44:50,475 --> 00:44:53,705
let me go up to line 4 here and say,

1248
00:44:53,949 --> 00:44:55,909
A pass the,

1249
00:44:55,939 --> 00:44:56,060
well,

1250
00:44:56,139 --> 00:44:57,699
actually let's do it in this a couple ways.

1251
00:44:57,820 --> 00:44:59,129
Let's first convert

1252
00:44:59,419 --> 00:45:01,449
the X value to an integer.

1253
00:45:01,620 --> 00:45:04,570
Let's convert the Y value to an integer as well.

1254
00:45:04,860 --> 00:45:05,620
So funny enough,

1255
00:45:05,699 --> 00:45:08,020
it's very similar syntactically to casting,

1256
00:45:08,100 --> 00:45:08,649
but in C,

1257
00:45:08,659 --> 00:45:09,540
when you cast something,

1258
00:45:09,580 --> 00:45:11,850
you actually wrote the data type in parentheses.

1259
00:45:12,219 --> 00:45:14,889
Now the data type itself is a function

1260
00:45:15,139 --> 00:45:19,100
that takes an argument which is the stir or string that you want to convert.

1261
00:45:19,449 --> 00:45:21,000
So let me go back to my terminal,

1262
00:45:21,040 --> 00:45:22,840
do Python of calculator.ie,

1263
00:45:23,040 --> 00:45:23,399
enter,

1264
00:45:23,600 --> 00:45:24,080
type in 1,

1265
00:45:24,199 --> 00:45:24,800
type in 2,

1266
00:45:24,820 --> 00:45:25,750
and now

1267
00:45:26,159 --> 00:45:27,669
I get back my 3 answer.

1268
00:45:27,840 --> 00:45:28,600
Now as you might imagine,

1269
00:45:28,659 --> 00:45:29,320
just like in C,

1270
00:45:29,360 --> 00:45:33,159
we can kind of play around with where we're performing some of these operations,

1271
00:45:33,169 --> 00:45:34,080
and this looks,

1272
00:45:34,199 --> 00:45:34,360
you know,

1273
00:45:34,409 --> 00:45:37,760
arguably a little less obvious now as to what is being added.

1274
00:45:37,840 --> 00:45:39,800
So I really like the simplicity of X + Y.

1275
00:45:39,889 --> 00:45:41,209
It just does what it says.

1276
00:45:41,520 --> 00:45:43,840
So I could convert these in other ways.

1277
00:45:43,879 --> 00:45:45,459
I could say after line 4,

1278
00:45:45,560 --> 00:45:46,110
you know what,

1279
00:45:46,459 --> 00:45:47,080
rechange.

1280
00:45:47,186 --> 00:45:49,976
X to be the in version of X,

1281
00:45:50,266 --> 00:45:51,186
but generally speaking,

1282
00:45:51,266 --> 00:45:53,706
that's kind of wasting a line of code by just

1283
00:45:53,706 --> 00:45:55,266
doing something you could do on a single line.

1284
00:45:55,345 --> 00:45:56,305
So let me delete that

1285
00:45:56,506 --> 00:45:58,706
and instead just say that well if I know the

1286
00:45:58,706 --> 00:46:01,436
return value of the input function is a stir,

1287
00:46:01,785 --> 00:46:03,575
let's just pass that output

1288
00:46:03,825 --> 00:46:08,075
as the input to the end function and it'd be a little more pythonic.

1289
00:46:08,231 --> 00:46:08,852
So to speak,

1290
00:46:09,062 --> 00:46:10,491
to just pass the

1291
00:46:10,662 --> 00:46:13,951
input functions output as the input to in,

1292
00:46:14,181 --> 00:46:15,302
which is really hard to say,

1293
00:46:15,382 --> 00:46:15,812
but

1294
00:46:16,142 --> 00:46:16,991
we've done this in C,

1295
00:46:17,102 --> 00:46:19,382
just nesting function calls like this.

1296
00:46:19,622 --> 00:46:19,822
All right,

1297
00:46:19,902 --> 00:46:21,812
so if I run this one more time,

1298
00:46:21,902 --> 00:46:23,622
Pythonocalculator.pi type in 1,

1299
00:46:23,701 --> 00:46:24,291
type in 2,

1300
00:46:24,461 --> 00:46:26,281
we're back now in business.

1301
00:46:26,501 --> 00:46:29,271
Now what I won't trip over just yet is a subtlety that

1302
00:46:29,820 --> 00:46:33,500
Whereby I'm deliberately typing in actual numbers like 1 and 2,

1303
00:46:33,540 --> 00:46:35,830
but if you are following along at home or on your laptop,

1304
00:46:35,860 --> 00:46:38,260
if you were to type in cat and dog,

1305
00:46:38,340 --> 00:46:39,669
like bad things will happen,

1306
00:46:39,699 --> 00:46:40,850
but we'll come back to that

1307
00:46:41,500 --> 00:46:42,330
before long.

1308
00:46:43,050 --> 00:46:46,090
Our questions though on any of this conversion

1309
00:46:46,419 --> 00:46:48,139
of our strings to our.

1310
00:46:49,780 --> 00:46:51,520
Integers in this case.

1311
00:46:52,810 --> 00:46:53,050
All right,

1312
00:46:53,090 --> 00:46:53,239
well,

1313
00:46:53,330 --> 00:46:55,260
what more does Python offer to us?

1314
00:46:55,409 --> 00:46:55,719
Well,

1315
00:46:55,889 --> 00:46:57,530
in addition to these data types,

1316
00:46:57,610 --> 00:46:58,729
there's actually going to be a bunch of others,

1317
00:46:58,770 --> 00:47:00,439
a few of which we'll actually use today.

1318
00:47:00,610 --> 00:47:00,810
In fact,

1319
00:47:00,850 --> 00:47:03,879
we'll see ranges of numbers that's like that's a thing built into Python.

1320
00:47:04,010 --> 00:47:05,610
We'll see lists of numbers which is going to

1321
00:47:05,610 --> 00:47:07,959
be like a new and improved version of an array

1322
00:47:08,129 --> 00:47:10,570
that solves like all of last week's problems when

1323
00:47:10,570 --> 00:47:13,050
we talked about the downsides of using arrays.

1324
00:47:13,169 --> 00:47:15,449
There's going to be tups for things like X Y.

1325
00:47:15,594 --> 00:47:19,135
Coordinates or GPS coordinates or anything where you have collections of values.

1326
00:47:19,145 --> 00:47:24,225
There's going to bed or dictionaries whereby you can have key value pairs provided

1327
00:47:24,225 --> 00:47:27,665
to you without having to write a whole hash table yourself and you can have

1328
00:47:27,665 --> 00:47:32,064
sets which you can use to just contain unique sets of values that you just

1329
00:47:32,064 --> 00:47:35,215
want to check for membership and there's bunches of other data types as well.

1330
00:47:35,344 --> 00:47:37,024
And this is where languages like Python start

1331
00:47:37,024 --> 00:47:39,064
to get really powerful because all of the

1332
00:47:39,820 --> 00:47:43,320
Data structures we talked about in C we really

1333
00:47:43,320 --> 00:47:45,850
only got from the language itself in array.

1334
00:47:45,870 --> 00:47:47,290
Everything else we had to build,

1335
00:47:47,340 --> 00:47:49,610
or at least talk about building in class,

1336
00:47:49,840 --> 00:47:52,169
these now and more come with the language.

1337
00:47:52,419 --> 00:47:52,860
Meanwhile,

1338
00:47:52,969 --> 00:47:55,060
in the CS 50 library for Python,

1339
00:47:55,139 --> 00:47:55,850
just so you know,

1340
00:47:56,060 --> 00:47:57,340
there are a whole bunch of functions.

1341
00:47:57,379 --> 00:47:59,899
These were the C versions in Python it stands to.

1342
00:48:00,020 --> 00:48:03,000
And that we don't need as many because there's fewer data types in Python,

1343
00:48:03,050 --> 00:48:03,649
but get flow,

1344
00:48:03,750 --> 00:48:06,969
get in and get string do all exist in the CS 50 library for Python.

1345
00:48:07,010 --> 00:48:10,689
You're welcome and encouraged to use it because indeed among the goals for problems

1346
00:48:10,689 --> 00:48:16,739
set 6 are going to be to redo some of your C problem set problems

1347
00:48:16,929 --> 00:48:20,449
in Python where you can look at your own C code and hopefully.

1348
00:48:21,030 --> 00:48:21,219
Uh,

1349
00:48:21,229 --> 00:48:22,340
you like that solution

1350
00:48:22,550 --> 00:48:23,949
and figure out how to convert it line

1351
00:48:23,949 --> 00:48:26,780
by line essentially to the corresponding Python version,

1352
00:48:26,949 --> 00:48:28,870
but clearly we've seen ways of taking these

1353
00:48:28,870 --> 00:48:31,260
training wheels off quite quickly as well.

1354
00:48:31,429 --> 00:48:31,830
And in fact,

1355
00:48:31,939 --> 00:48:34,909
if you wanted to import all three of those functions for a larger program,

1356
00:48:34,949 --> 00:48:36,419
you could do this just following

1357
00:48:36,669 --> 00:48:37,139
the

1358
00:48:37,830 --> 00:48:39,340
approach that I took so already,

1359
00:48:39,510 --> 00:48:41,080
but you can also just separate them by com.

1360
00:48:41,370 --> 00:48:45,870
like this or it turns out you can also import the whole CS 50 library as you'll

1361
00:48:45,870 --> 00:48:48,110
see in some code and then just access the

1362
00:48:48,110 --> 00:48:50,870
functions within with slightly different syntax as well.

1363
00:48:51,139 --> 00:48:51,219
All right,

1364
00:48:51,270 --> 00:48:55,669
how about another construct from scratch and from C now in fact in Python.

1365
00:48:55,709 --> 00:48:57,100
So in Scratch,

1366
00:48:57,229 --> 00:49:00,790
if we wanted to do a comparison like is X less than Y where each of those are variables,

1367
00:49:00,870 --> 00:49:01,389
then say.

1368
00:49:01,479 --> 00:49:04,459
Much here in C it looked like this

1369
00:49:04,949 --> 00:49:08,860
and nicely enough you can probably guess already which what's going to change here.

1370
00:49:08,870 --> 00:49:10,500
Like the F is about to go away,

1371
00:49:10,669 --> 00:49:12,229
the backslash n is about to go away,

1372
00:49:12,310 --> 00:49:13,969
the semicolon is about to go away,

1373
00:49:14,030 --> 00:49:16,149
but some other stuff's about to go away as well.

1374
00:49:16,199 --> 00:49:18,870
Focus your attention on the syntax like parentheses and

1375
00:49:18,870 --> 00:49:21,590
curly braces because in Python it's just that.

1376
00:49:22,050 --> 00:49:23,409
So we got rid of the parentheses because

1377
00:49:23,409 --> 00:49:25,649
they didn't really add all that much logically.

1378
00:49:25,729 --> 00:49:27,129
We got rid of the curly braces,

1379
00:49:27,169 --> 00:49:29,399
which technically we could do in C

1380
00:49:29,649 --> 00:49:32,879
anytime there's a single line of code inside of a conditional,

1381
00:49:33,050 --> 00:49:36,959
but for consistency stylistically we always use them as well.

1382
00:49:37,449 --> 00:49:41,280
Python though does not have you use any of those curly braces at all,

1383
00:49:41,530 --> 00:49:45,100
but Python requires that you indent your code.

1384
00:49:45,267 --> 00:49:45,717
Properly.

1385
00:49:45,816 --> 00:49:47,376
So if you've ever been among those who are

1386
00:49:47,376 --> 00:49:50,416
writing out your program and like everything is just crazily

1387
00:49:50,416 --> 00:49:54,967
like left aligned and just a big mess until Style 50 swoops in and cleans it up for you,

1388
00:49:55,217 --> 00:49:57,846
you're not going to be able to write Python code like that anymore.

1389
00:49:57,937 --> 00:49:59,967
That's been such a societal problem

1390
00:50:00,297 --> 00:50:01,207
among programmers,

1391
00:50:01,376 --> 00:50:03,166
newbies and professionals alike,

1392
00:50:03,457 --> 00:50:06,447
that the language itself requires logically that if you want

1393
00:50:06,447 --> 00:50:08,576
this line of code to execute if this boolean.

1394
00:50:08,634 --> 00:50:09,614
Expression is true,

1395
00:50:09,783 --> 00:50:13,053
you've got to indent this line by convention 4 spaces.

1396
00:50:13,063 --> 00:50:16,854
You can't be lazy and leave it all left aligned and sort of fix it up later.

1397
00:50:16,983 --> 00:50:18,664
This has made Python code arguably more

1398
00:50:18,664 --> 00:50:21,773
readable because of these language-based requirements.

1399
00:50:21,904 --> 00:50:22,224
Meanwhile,

1400
00:50:22,343 --> 00:50:24,543
let's look at a ifE construct in Scratch,

1401
00:50:24,583 --> 00:50:26,604
which looked a little something like this and see,

1402
00:50:26,624 --> 00:50:27,464
it looked like this,

1403
00:50:27,503 --> 00:50:30,614
which is kind of a lot of lines just to express a simple idea.

1404
00:50:30,944 --> 00:50:31,864
All of those same things.

1405
00:50:32,000 --> 00:50:33,020
Going to go away

1406
00:50:33,510 --> 00:50:36,910
whereby in Python it looks like this instead and the only other difference

1407
00:50:36,910 --> 00:50:39,470
worth calling out is that because you don't have the curly braces,

1408
00:50:39,520 --> 00:50:44,301
you do have a colon which precedes the subsequent indentation as well.

1409
00:50:44,551 --> 00:50:44,871
Meanwhile,

1410
00:50:44,950 --> 00:50:48,111
if we've got an if if els in scratch in C,

1411
00:50:48,150 --> 00:50:49,440
of course it looked like this.

1412
00:50:49,670 --> 00:50:52,460
A lot of this is going to go away in the flash of a screen,

1413
00:50:52,551 --> 00:50:53,740
but there's going to be a curiosity,

1414
00:50:53,750 --> 00:50:55,190
which is not in fact a typo.

1415
00:50:55,919 --> 00:50:57,590
Notice what happens with the LSIF.

1416
00:50:58,159 --> 00:50:59,709
It's abbreviated L if,

1417
00:50:59,790 --> 00:51:00,800
and honestly to this day,

1418
00:51:00,879 --> 00:51:01,469
all these years later,

1419
00:51:01,520 --> 00:51:03,919
I can never remember if it's L if or LSI

1420
00:51:03,919 --> 00:51:07,629
because different languages use different shorthand spellings of this phrase.

1421
00:51:07,800 --> 00:51:09,469
It's LF in Python,

1422
00:51:09,879 --> 00:51:13,350
because that's maybe the most succinct you can make the two words themselves,

1423
00:51:13,439 --> 00:51:15,489
but everything else is effectively the same,

1424
00:51:15,679 --> 00:51:17,709
including the additional colon this time.

1425
00:51:17,840 --> 00:51:18,129
OK,

1426
00:51:18,600 --> 00:51:19,679
questions on.

1427
00:51:20,659 --> 00:51:22,530
Any of those conditionals and syntax,

1428
00:51:22,620 --> 00:51:22,899
yeah.

1429
00:51:25,709 --> 00:51:26,760
What a good question.

1430
00:51:26,800 --> 00:51:28,840
What language did they code Python in?

1431
00:51:29,000 --> 00:51:34,389
The interpreter we are using within VS Code is itself written in C,

1432
00:51:34,510 --> 00:51:35,830
AKA C Python.

1433
00:51:35,919 --> 00:51:36,229
However,

1434
00:51:36,360 --> 00:51:39,510
you can implement a Python interpreter really in any language,

1435
00:51:39,840 --> 00:51:42,239
including machine code like raw zeros and ones if

1436
00:51:42,239 --> 00:51:44,080
you have that much free time in assembly.

1437
00:51:44,219 --> 00:51:46,040
Language which we saw briefly weeks ago.

1438
00:51:46,290 --> 00:51:49,250
You could write an interpreter for Python in Python if you really

1439
00:51:49,250 --> 00:51:52,679
want to be meta about it or in C++ or in Java.

1440
00:51:52,889 --> 00:51:55,610
This is the thing about programming languages you can use any

1441
00:51:55,610 --> 00:51:59,520
language to create a compiler for or interpreter for another language.

1442
00:51:59,850 --> 00:52:02,360
What's going to vary is just how easy or difficult

1443
00:52:02,360 --> 00:52:04,570
it is and how much time it therefore takes you.

1444
00:52:05,830 --> 00:52:06,679
Good question.

1445
00:52:06,929 --> 00:52:07,979
Other questions

1446
00:52:08,290 --> 00:52:09,239
on any of these

1447
00:52:09,610 --> 00:52:10,570
here features.

1448
00:52:11,389 --> 00:52:11,899
All right,

1449
00:52:11,979 --> 00:52:12,100
well,

1450
00:52:12,139 --> 00:52:14,370
let's do something a little bit

1451
00:52:15,100 --> 00:52:17,699
different in Python visa VC

1452
00:52:17,939 --> 00:52:21,209
by opening up maybe a comparison program that we looked at

1453
00:52:21,500 --> 00:52:22,149
some time ago.

1454
00:52:22,260 --> 00:52:23,780
So let me go back to VS code here.

1455
00:52:23,860 --> 00:52:28,090
I'm going to close my calculator and I'm going to open up now from my

1456
00:52:28,820 --> 00:52:30,090
distribution code today

1457
00:52:30,300 --> 00:52:34,780
a version of our comparison program from a while back which was essentially the

1458
00:52:34,949 --> 00:52:34,959
Uh,

1459
00:52:35,620 --> 00:52:37,459
version 30 index thereof.

1460
00:52:37,580 --> 00:52:38,540
So this one has comments,

1461
00:52:38,620 --> 00:52:40,929
which the very first one in week 1 did not,

1462
00:52:41,100 --> 00:52:43,689
but notice as a refresher what this comparison program was doing.

1463
00:52:43,780 --> 00:52:46,199
It was including CS 50.H and standard.O.H.

1464
00:52:46,459 --> 00:52:49,800
It was prompting the user for two integers via get in X and Y.

1465
00:52:49,979 --> 00:52:53,469
It was then doing a very simple comparison comparing X against Y

1466
00:52:53,780 --> 00:52:54,939
to determine if it's less than,

1467
00:52:55,179 --> 00:52:55,580
greater than,

1468
00:52:55,689 --> 00:52:56,219
or

1469
00:52:57,379 --> 00:52:58,540
the same as.

1470
00:52:59,310 --> 00:53:02,479
X and uh the same or equal to the same.

1471
00:53:02,669 --> 00:53:02,860
So,

1472
00:53:03,040 --> 00:53:06,270
just so that we can go through the motions of converting one of these to the other,

1473
00:53:06,389 --> 00:53:07,080
let's do that

1474
00:53:07,350 --> 00:53:07,989
side by side.

1475
00:53:08,070 --> 00:53:10,419
Let me code a program called Compare.i.

1476
00:53:10,830 --> 00:53:11,909
Let me close my terminal,

1477
00:53:12,030 --> 00:53:14,149
drag the Python version over to the right here.

1478
00:53:14,590 --> 00:53:15,889
And without comments this time,

1479
00:53:15,899 --> 00:53:18,250
let's just do from CS 50 import

1480
00:53:18,659 --> 00:53:19,469
get in.

1481
00:53:20,060 --> 00:53:26,639
Then below that let's do x equals get in and ask the user for what's X question mark.

1482
00:53:26,909 --> 00:53:31,570
Then let's ask the user for Y using get in quote unquote what's why mark.

1483
00:53:31,820 --> 00:53:35,050
Then below that let's do if x less than Y call in.

1484
00:53:35,780 --> 00:53:43,139
Go ahead and print quote unquote X is less than Y L if X greater than Y,

1485
00:53:43,219 --> 00:53:48,129
go ahead and print quote unquote X is greater than Y else coin,

1486
00:53:49,139 --> 00:53:53,439
let's go ahead and print out quote unquote X is equal toy.

1487
00:53:53,939 --> 00:53:56,179
So I dare say these are now equivalents.

1488
00:53:56,310 --> 00:53:58,179
It's clearly fewer lines because a lot of

1489
00:53:58,179 --> 00:54:00,260
the lines that left were admittedly comments,

1490
00:54:00,340 --> 00:54:03,139
but also some curly braces and there's more syntax

1491
00:54:03,139 --> 00:54:04,889
like parentheses that we got rid of too.

1492
00:54:05,060 --> 00:54:06,250
Let me open my terminal window.

1493
00:54:06,360 --> 00:54:09,239
Let me run Python of compare.i.

1494
00:54:09,500 --> 00:54:14,110
We'll type in 1 and 21 is less than uh X is less than Y.

1495
00:54:14,179 --> 00:54:17,060
Let's do it again using 2 and 1.

1496
00:54:17,219 --> 00:54:18,340
X is greater than Y.

1497
00:54:18,379 --> 00:54:19,260
Let's do it one last time,

1498
00:54:19,270 --> 00:54:20,250
1 and 1,

1499
00:54:20,419 --> 00:54:23,080
and of course those two now are equal to.

1500
00:54:23,969 --> 00:54:24,600
Each other.

1501
00:54:25,239 --> 00:54:25,449
all right,

1502
00:54:25,610 --> 00:54:27,639
but why go down this road again because that

1503
00:54:27,639 --> 00:54:30,199
was kind of a simple exercise but recall that

1504
00:54:30,409 --> 00:54:34,199
we introduced this comparison of ants because it was so sort of stupidly simple,

1505
00:54:34,239 --> 00:54:36,959
even if the syntax of that week was completely new

1506
00:54:37,290 --> 00:54:40,489
but we ran into an issue pretty fast when we started comparing.

1507
00:54:40,635 --> 00:54:43,205
Strings and that was a problem we really only fixed in

1508
00:54:43,205 --> 00:54:46,695
week 4 when we finally revealed what a string actually is.

1509
00:54:46,784 --> 00:54:48,564
If we focus a bit more on Python strings,

1510
00:54:48,665 --> 00:54:53,945
it turns out that we can solve that problem much more easily in the world of Python.

1511
00:54:53,985 --> 00:54:54,385
In fact,

1512
00:54:54,645 --> 00:54:56,465
let me go back to VS code here.

1513
00:54:56,745 --> 00:54:59,655
Let me close these two versions of in comparison.

1514
00:54:59,824 --> 00:55:02,544
Let me open up at left a version of my program.

1515
00:55:02,929 --> 00:55:04,800
That I brought with me here

1516
00:55:05,090 --> 00:55:09,409
that contains a version from week 2 wherein we finally revealed

1517
00:55:09,409 --> 00:55:11,770
that a string is just a char star but recalled that

1518
00:55:11,770 --> 00:55:14,929
the solution in week 4 as well as in week 1

1519
00:55:14,929 --> 00:55:18,409
when we first encountered this problem was to use stom,

1520
00:55:18,570 --> 00:55:22,610
a function that whose purpose in life is to compare two strings character

1521
00:55:22,610 --> 00:55:24,929
by character by character using a 4 loop or something like that.

1522
00:55:25,022 --> 00:55:25,923
But they have knowledge,

1523
00:55:26,012 --> 00:55:26,292
therefore,

1524
00:55:26,373 --> 00:55:27,653
of how to navigate pointers,

1525
00:55:27,893 --> 00:55:29,202
how to look for the null character,

1526
00:55:29,252 --> 00:55:30,452
the backslash zero at the end,

1527
00:55:30,532 --> 00:55:33,943
and all of that came from our friend string.h.

1528
00:55:34,212 --> 00:55:34,333
Well,

1529
00:55:34,413 --> 00:55:37,522
how can we go about implementing the same idea in Python?

1530
00:55:37,532 --> 00:55:37,923
Well,

1531
00:55:38,193 --> 00:55:39,452
let's open up VS codes,

1532
00:55:39,583 --> 00:55:40,322
Terminal window,

1533
00:55:40,532 --> 00:55:43,683
open up a new program called Compare.ie,

1534
00:55:43,972 --> 00:55:44,802
but this time,

1535
00:55:44,812 --> 00:55:47,093
let's get rid of the integer version there.

1536
00:55:47,226 --> 00:55:49,375
Of let's get 2 ins from the user,

1537
00:55:49,416 --> 00:55:51,436
and I won't even use any CS 50 training wheels.

1538
00:55:51,496 --> 00:55:55,246
Let's just use the input function to get S and ask the user for

1539
00:55:55,535 --> 00:55:56,926
a value of S.

1540
00:55:57,416 --> 00:55:59,885
So S colon close quote with a space,

1541
00:56:00,095 --> 00:56:02,966
T equals input ask the user for a variable T.

1542
00:56:03,176 --> 00:56:06,966
And then let's just ask the question if S equals equals t,

1543
00:56:07,216 --> 00:56:09,295
then print out quote unquote same.

1544
00:56:09,800 --> 00:56:10,229
Else,

1545
00:56:10,600 --> 00:56:12,159
go ahead and print out

1546
00:56:12,469 --> 00:56:13,760
quote unquote different.

1547
00:56:14,040 --> 00:56:15,330
Let me move these side by side,

1548
00:56:15,399 --> 00:56:16,669
just so you can see the difference.

1549
00:56:17,040 --> 00:56:21,350
Notice how much code we have to write and how much we needed to understand

1550
00:56:21,520 --> 00:56:24,399
in order to compare something as trivial as two strings and see.

1551
00:56:24,719 --> 00:56:27,709
But in Python we're literally just using equals equals

1552
00:56:27,909 --> 00:56:29,290
and let's see if it actually works.

1553
00:56:29,389 --> 00:56:31,979
So Python of compare.pi enter.

1554
00:56:32,270 --> 00:56:36,379
Let's type in maybe cat for S and dog for T,

1555
00:56:36,629 --> 00:56:37,669
and those are in fact different,

1556
00:56:37,830 --> 00:56:39,580
but we would have gotten the same answer in C.

1557
00:56:39,909 --> 00:56:42,360
Let's rerun Pythonfcompaed.pi and type in cat,

1558
00:56:42,550 --> 00:56:43,629
type in cat again.

1559
00:56:43,919 --> 00:56:46,060
And now it's detecting them the same.

1560
00:56:46,310 --> 00:56:47,270
So wonderfully,

1561
00:56:47,310 --> 00:56:50,909
Python has solved that seemingly annoying problem of not taking

1562
00:56:50,909 --> 00:56:53,870
us literally like don't compare the pointer against the pointer.

1563
00:56:54,030 --> 00:56:56,629
Compare what a reasonable programmer probably really

1564
00:56:56,629 --> 00:56:58,870
cares about the values of those strings.

1565
00:56:58,909 --> 00:57:01,629
So the equal equals is doing all of the 4 loop or the Y loop,

1566
00:57:01,729 --> 00:57:04,590
iterating over those things character by character and

1567
00:57:04,590 --> 00:57:07,419
actually giving us the answer we want.

1568
00:57:07,709 --> 00:57:09,550
So what else gets easier in Python?

1569
00:57:09,683 --> 00:57:11,512
Well let's focus a bit more on these strings.

1570
00:57:11,593 --> 00:57:13,143
Let me go back into VS code here.

1571
00:57:13,312 --> 00:57:16,742
Let me close out our two comparison programs and clear my terminal,

1572
00:57:16,833 --> 00:57:20,022
and let me go ahead and open up a prior program that we wrote,

1573
00:57:20,072 --> 00:57:21,933
that one called Agree.c,

1574
00:57:21,992 --> 00:57:23,873
and namely in the staff version of the code online,

1575
00:57:23,952 --> 00:57:25,232
this was agree2.c,

1576
00:57:25,272 --> 00:57:26,302
which is where we left it.

1577
00:57:26,472 --> 00:57:29,062
Now recall in this C program that we did the following.

1578
00:57:29,232 --> 00:57:29,663
We first,

1579
00:57:29,762 --> 00:57:31,302
using CS50's GetHA function,

1580
00:57:31,393 --> 00:57:32,712
prompted the user for a char,

1581
00:57:32,812 --> 00:57:34,913
hopefully Y or N for yes or no,

1582
00:57:34,952 --> 00:57:35,353
respectively.

1583
00:57:35,666 --> 00:57:38,676
And then we used a Boolean expression and

1584
00:57:38,676 --> 00:57:40,996
actually the combination of two using the two vertical

1585
00:57:40,996 --> 00:57:43,956
bars to ask whether the inputted character is capital

1586
00:57:43,956 --> 00:57:47,006
Y or the inputted character is lowercase y.

1587
00:57:47,035 --> 00:57:47,545
And if so,

1588
00:57:47,555 --> 00:57:50,105
we went ahead and printed out that the user agreed.

1589
00:57:50,275 --> 00:57:51,486
Otherwise if they type in

1590
00:57:51,595 --> 00:57:52,746
anything else for that character,

1591
00:57:52,795 --> 00:57:53,906
we simply print it out,

1592
00:57:54,075 --> 00:57:54,785
not agreed.

1593
00:57:54,956 --> 00:57:55,016
Well,

1594
00:57:55,075 --> 00:57:58,125
how can we go about implementing that same program in Python,

1595
00:57:58,166 --> 00:57:58,466
for instance,

1596
00:57:58,476 --> 00:58:00,236
in a file called agree.ie?

1597
00:58:00,555 --> 00:58:00,605
Well,

1598
00:58:00,676 --> 00:58:01,115
let me go ahead.

1599
00:58:01,208 --> 00:58:02,999
And open up my terminal window again.

1600
00:58:03,198 --> 00:58:05,718
Let's create a file called agree.i.

1601
00:58:05,918 --> 00:58:06,358
As before,

1602
00:58:06,398 --> 00:58:09,868
let me go ahead and drag it over to the right so we can see these two things side by side,

1603
00:58:09,918 --> 00:58:11,749
and let me go ahead and do this.

1604
00:58:11,878 --> 00:58:13,519
I'm going to set a variable,

1605
00:58:13,708 --> 00:58:13,989
say,

1606
00:58:13,999 --> 00:58:16,188
called S equal to

1607
00:58:16,438 --> 00:58:17,928
the return value of input,

1608
00:58:18,118 --> 00:58:18,638
quote unquote.

1609
00:58:18,799 --> 00:58:21,908
Do you agree there by asking the user the same question as before.

1610
00:58:22,158 --> 00:58:25,289
No need to use the CS 50 library because the input function here suffices.

1611
00:58:25,299 --> 00:58:26,648
And instead of using C,

1612
00:58:26,678 --> 00:58:29,842
I Deliberately using S because it turns out in Python there

1613
00:58:29,842 --> 00:58:32,672
is no way to get a single character per se,

1614
00:58:32,721 --> 00:58:34,231
but you can get a string

1615
00:58:34,441 --> 00:58:35,991
that has a single character.

1616
00:58:36,082 --> 00:58:36,362
Indeed,

1617
00:58:36,402 --> 00:58:38,431
char is not a data type in Python,

1618
00:58:38,602 --> 00:58:40,872
but once we have this input from the user,

1619
00:58:41,001 --> 00:58:42,481
let's now go ahead and implement a

1620
00:58:42,481 --> 00:58:44,872
conditional using one or more Boolean expressions.

1621
00:58:45,082 --> 00:58:45,142
Well,

1622
00:58:45,201 --> 00:58:48,681
let's ask if S equals equals quote unquote Y

1623
00:58:50,562 --> 00:58:52,642
or S equals equals.

1624
00:58:52,735 --> 00:58:53,705
Or Casey,

1625
00:58:53,965 --> 00:58:56,715
then let's go ahead and print out as before,

1626
00:58:56,725 --> 00:58:58,235
quote unquote agreed.

1627
00:58:58,324 --> 00:59:00,284
And now notice what's different this time.

1628
00:59:00,364 --> 00:59:04,445
I'm literally using the word or instead of the two vertical bars because in

1629
00:59:04,445 --> 00:59:06,965
the spirit of Python things tend to be a little more English like,

1630
00:59:07,004 --> 00:59:07,804
a little more readable,

1631
00:59:07,885 --> 00:59:08,334
top to bottom,

1632
00:59:08,405 --> 00:59:08,764
left to right,

1633
00:59:08,834 --> 00:59:11,354
and indeed or hits that nail on the head.

1634
00:59:11,685 --> 00:59:12,375
Otherwise,

1635
00:59:12,445 --> 00:59:15,044
if it is not in capital Y or a lowercase y,

1636
00:59:15,125 --> 00:59:16,395
let's go ahead and print out,

1637
00:59:16,405 --> 00:59:18,324
quote unquote not agreed.

1638
00:59:18,810 --> 00:59:19,510
And that's it

1639
00:59:19,639 --> 00:59:22,830
for converting this program from C here into Python.

1640
00:59:23,000 --> 00:59:25,909
But of course this isn't the most robust version of the program

1641
00:59:25,909 --> 00:59:28,830
because it would be nice if the user could type in something like

1642
00:59:29,120 --> 00:59:29,590
yes,

1643
00:59:29,959 --> 00:59:32,040
YES capitalize maybe in different ways.

1644
00:59:32,120 --> 00:59:34,429
So how might we go about implementing

1645
00:59:34,879 --> 00:59:35,360
that?

1646
00:59:35,439 --> 00:59:35,560
Well,

1647
00:59:35,639 --> 00:59:36,959
we could do this in a few ways.

1648
00:59:37,010 --> 00:59:37,360
I could,

1649
00:59:37,399 --> 00:59:37,909
of course,

1650
00:59:37,959 --> 00:59:41,149
and let's go ahead and get rid of my C version now and focus just on the Python.

1651
00:59:41,360 --> 00:59:43,120
I could do something like this and just start

1652
00:59:43,120 --> 00:59:47,149
oring together more possibilities like or S equals.

1653
00:59:47,356 --> 00:59:51,237
Quote unquote yes or S equals equals quote

1654
00:59:51,237 --> 00:59:54,316
unquote yes very emphatically or and so forth,

1655
00:59:54,326 --> 00:59:56,836
but you can imagine that this doesn't scale very well.

1656
00:59:56,876 --> 00:59:58,957
If I want to consider all the possible permutations,

1657
00:59:59,037 --> 01:00:01,066
maybe of the caps lock key being up or down,

1658
01:00:01,237 --> 01:00:03,477
that's quite a few possibilities to enumerate.

1659
01:00:03,556 --> 01:00:04,866
So perhaps we could do this

1660
01:00:05,076 --> 01:00:06,297
a little bit differently.

1661
01:00:06,356 --> 01:00:11,427
And in fact we can by maybe storing all of the possibilities in a so-called list.

1662
01:00:11,556 --> 01:00:13,517
So whereas C had of course arrays,

1663
01:00:13,717 --> 01:00:15,437
Python has what are called lists which.

1664
01:00:15,604 --> 01:00:19,704
Effectively underneath the hood are indeed linked lists as we explored in week 5.

1665
01:00:19,874 --> 01:00:22,874
Now a linked list of course can dynamically grow and even shrink,

1666
01:00:22,914 --> 01:00:25,144
and that's indeed what Python does for us.

1667
01:00:25,333 --> 01:00:28,224
I can simply create a list of values from the get-go,

1668
01:00:28,233 --> 01:00:29,204
or as we'll eventually see,

1669
01:00:29,243 --> 01:00:30,243
I can add things to it,

1670
01:00:30,354 --> 01:00:31,104
remove things from it,

1671
01:00:31,194 --> 01:00:33,664
and all of the underlying memory gets managed for me.

1672
01:00:33,753 --> 01:00:37,743
And in fact with lists we get a whole bunch of features that can make this possible.

1673
01:00:37,954 --> 01:00:38,354
But for now,

1674
01:00:38,394 --> 01:00:42,033
let's use them simply as statically initialized list with values I

1675
01:00:42,033 --> 01:00:43,874
know from the get-go that I want and I'm gonna go.

1676
01:00:44,000 --> 01:00:44,781
And do this

1677
01:00:45,071 --> 01:00:46,010
in VS code.

1678
01:00:46,020 --> 01:00:49,450
I'm going to delete most of this Boolean expression,

1679
01:00:49,500 --> 01:00:51,311
the combination of all of those phrases,

1680
01:00:51,391 --> 01:00:56,051
and I'm going to simply say if S is in using a Python keyword in,

1681
01:00:56,391 --> 01:00:59,091
literally the following list of values unquotey,

1682
01:01:00,710 --> 01:01:01,141
yes.

1683
01:01:01,270 --> 01:01:02,831
And for now I'm going to use just those two,

1684
01:01:02,910 --> 01:01:03,990
but let's see how it works.

1685
01:01:04,111 --> 01:01:06,020
Let me open up my terminal window again.

1686
01:01:06,230 --> 01:01:09,341
Let me run Pythonore.ie really for the first time,

1687
01:01:09,391 --> 01:01:12,270
but let me claim that it would have worked even in the previous version.

1688
01:01:12,909 --> 01:01:13,310
Enter.

1689
01:01:13,429 --> 01:01:15,239
I'm going to go ahead and type in lowercase y,

1690
01:01:15,469 --> 01:01:16,219
and I've agreed.

1691
01:01:16,340 --> 01:01:19,179
I'm gonna go ahead and run it again and type in lowercase n,

1692
01:01:19,389 --> 01:01:20,459
and I've not agreed.

1693
01:01:20,550 --> 01:01:23,300
I'm gonna go ahead and run it again and I'm going to type in all caps,

1694
01:01:23,310 --> 01:01:23,590
yes,

1695
01:01:23,669 --> 01:01:24,739
because I really agree,

1696
01:01:25,469 --> 01:01:28,540
and yet I don't because there is a bug still in this version.

1697
01:01:28,629 --> 01:01:29,989
So even though up here.

1698
01:01:30,379 --> 01:01:31,689
In my Python implementation,

1699
01:01:31,760 --> 01:01:33,770
I do have a list of values that I'm looking for.

1700
01:01:33,929 --> 01:01:36,250
Python's gonna look literally for those values,

1701
01:01:36,370 --> 01:01:38,959
so lowercase y and lower cases.

1702
01:01:39,090 --> 01:01:43,840
So how can I go about tolerating different capitalizations by the user?

1703
01:01:44,040 --> 01:01:44,050
Well,

1704
01:01:44,060 --> 01:01:45,560
I can do this in a few different ways.

1705
01:01:45,610 --> 01:01:46,129
I could,

1706
01:01:46,179 --> 01:01:46,879
for instance,

1707
01:01:46,969 --> 01:01:49,310
after getting the user's input in a variable called S,

1708
01:01:49,510 --> 01:01:51,360
I could updates to be

1709
01:01:51,649 --> 01:01:52,570
S.lo,

1710
01:01:52,729 --> 01:01:55,169
which is going to have the effect of lower casing the

1711
01:01:55,169 --> 01:01:58,320
word for me and then updating the value itself of S.

1712
01:01:58,449 --> 01:01:59,770
And now I think this will work.

1713
01:01:59,874 --> 01:02:01,533
Even for an uppercase version,

1714
01:02:01,773 --> 01:02:05,364
let me go ahead and run Pythonore.ie emphatically type in yes enter,

1715
01:02:05,573 --> 01:02:09,854
and yet this time I've agreed because I forced the user's input to lowercase and

1716
01:02:09,854 --> 01:02:12,013
then I have compared against the canonical

1717
01:02:12,013 --> 01:02:13,573
forms I've written which are all lowercase.

1718
01:02:13,773 --> 01:02:14,694
I could have done the opposite.

1719
01:02:14,773 --> 01:02:16,733
I could have forced the user's input to uppercase and then

1720
01:02:16,733 --> 01:02:20,374
enumerated in my Python list in between those square brackets,

1721
01:02:20,624 --> 01:02:23,063
capital Y and YES,

1722
01:02:23,293 --> 01:02:25,164
but either approach here is fine.

1723
01:02:25,404 --> 01:02:27,614
Now technically I don't need this additional line here.

1724
01:02:27,733 --> 01:02:29,253
I can go ahead and delete.

1725
01:02:29,347 --> 01:02:32,137
that line wherein I lowercased it and in Python I can

1726
01:02:32,137 --> 01:02:36,417
actually chain some of these function calls together by saying input.

1727
01:02:36,738 --> 01:02:39,417
lower so that the return value of input ultimately

1728
01:02:39,417 --> 01:02:42,208
gets forced to lowercase by using dotlo here.

1729
01:02:42,617 --> 01:02:43,857
Alternatively still,

1730
01:02:43,937 --> 01:02:47,687
I could just lowercase the very at the very moment I'm actually comparing it,

1731
01:02:47,697 --> 01:02:49,427
and down here I could do s.

1732
01:02:49,718 --> 01:02:55,968
lower and then compare the lower case version of what's going on toy or yes.

1733
01:02:56,097 --> 01:02:57,417
Now what's really this all about?

1734
01:02:57,538 --> 01:02:57,617
Well,

1735
01:02:57,657 --> 01:02:58,738
this is actually an example.

1736
01:02:58,832 --> 01:03:02,791
Of what's generally known as object oriented programming or OOP for short,

1737
01:03:02,981 --> 01:03:08,181
whereby in Python and a lot of other languages now you can have variables and data

1738
01:03:08,181 --> 01:03:13,731
types more generally that have not only values associated with them like why or yes,

1739
01:03:13,981 --> 01:03:16,461
but also functionality built in.

1740
01:03:16,471 --> 01:03:17,342
In other words,

1741
01:03:17,422 --> 01:03:19,862
whereas in C we would have used a function from like

1742
01:03:19,862 --> 01:03:22,931
the C type library called 2 upper or 2 lower,

1743
01:03:23,102 --> 01:03:25,662
and we would have passed as an argument to those functions

1744
01:03:25,662 --> 01:03:28,181
the very character that we wanted to force to uppercase.

1745
01:03:28,506 --> 01:03:30,885
Or to lower case well in Python and

1746
01:03:30,885 --> 01:03:33,595
indeed object oriented programming languages in general,

1747
01:03:33,986 --> 01:03:37,345
the developers behind the language recognize that sometimes there's

1748
01:03:37,345 --> 01:03:40,865
functionality that's inherently related to the values in question.

1749
01:03:40,906 --> 01:03:41,345
Indeed,

1750
01:03:41,506 --> 01:03:42,746
when we're dealing with strings,

1751
01:03:42,785 --> 01:03:46,325
it's pretty reasonable to want to sometimes uppercase them or lowercase them,

1752
01:03:46,545 --> 01:03:49,865
capitalize them or do any number of other things and so built into

1753
01:03:49,865 --> 01:03:54,335
the string type in Python is in fact the lower function itself,

1754
01:03:54,385 --> 01:03:55,855
as well as a whole bunch of others.

1755
01:03:55,865 --> 01:03:56,105
In fact,

1756
01:03:56,186 --> 01:03:56,976
at this URL here,

1757
01:03:56,986 --> 01:03:57,666
can you see the document.

1758
01:03:58,270 --> 01:04:00,870
for all of the string functions built into Python and

1759
01:04:00,870 --> 01:04:04,340
more technically when a function is built into a data type

1760
01:04:04,510 --> 01:04:07,760
and you access it via this dot notation instead of by

1761
01:04:07,760 --> 01:04:11,100
calling some global function and passing an argument into it,

1762
01:04:11,350 --> 01:04:12,870
you are using what are called methods.

1763
01:04:12,879 --> 01:04:16,909
So methods are simply functions that are inside of objects and

1764
01:04:16,909 --> 01:04:20,340
in this case the object in question itself is a string.

1765
01:04:20,469 --> 01:04:24,350
So what's really happening with this here example when I'm checking whether

1766
01:04:24,350 --> 01:04:27,149
the user has agreed or not is I'm taking that value that's.

1767
01:04:27,283 --> 01:04:28,154
Strings,

1768
01:04:28,233 --> 01:04:30,634
which is technically now an object in memory,

1769
01:04:30,714 --> 01:04:33,464
and inside of that object is not only the user's input

1770
01:04:33,464 --> 01:04:36,513
but some built in functionality otherwise known now as methods,

1771
01:04:36,523 --> 01:04:38,394
and those methods were written by the same

1772
01:04:38,394 --> 01:04:41,583
people who invented the string data type itself.

1773
01:04:41,714 --> 01:04:43,194
So this is just the first of these examples,

1774
01:04:43,233 --> 01:04:44,124
but we'll see yet others.

1775
01:04:44,194 --> 01:04:46,293
But notice the syntax is actually quite similar to C,

1776
01:04:46,434 --> 01:04:49,144
just isn't C when you wanted to go inside of a structure.

1777
01:04:49,384 --> 01:04:51,874
You can similarly go inside of an object in

1778
01:04:51,874 --> 01:04:54,503
Python and access not just the values ultimately,

1779
01:04:54,513 --> 01:04:56,674
but also these built in methods.

1780
01:04:57,669 --> 01:04:58,030
All right,

1781
01:04:58,189 --> 01:05:02,149
how about another comparison of C to Python again involving strings?

1782
01:05:02,189 --> 01:05:02,229
Well,

1783
01:05:02,270 --> 01:05:06,209
let me go ahead and reopen and clear my terminal and close out of agree.ie.

1784
01:05:06,629 --> 01:05:11,149
Let me go ahead and open up a version of copying strings from a couple of

1785
01:05:11,149 --> 01:05:14,030
weeks back whereby we finally started solving it

1786
01:05:14,030 --> 01:05:16,219
correctly by doing some proper memory management.

1787
01:05:16,350 --> 01:05:19,310
So here in the staff version of Copy 5.c we have not

1788
01:05:19,310 --> 01:05:21,580
only a commented version of what we did a couple weeks back,

1789
01:05:21,750 --> 01:05:25,149
but we also have a reminder of how what was involved in.

1790
01:05:25,375 --> 01:05:26,736
Copying strings and C.

1791
01:05:26,966 --> 01:05:30,486
Recall for instance that we prompted the user in this example using CS 50's

1792
01:05:30,486 --> 01:05:33,916
get string function for a string that they wanted to make a copy of,

1793
01:05:33,966 --> 01:05:35,805
and then we did some error checking ultimately to make

1794
01:05:35,805 --> 01:05:37,635
sure that there was enough memory and nothing went wrong.

1795
01:05:38,045 --> 01:05:41,686
Then recall that the right solution to this problem in C was not to

1796
01:05:41,686 --> 01:05:46,125
just use the assignment operator and assume that S can be copied into T,

1797
01:05:46,325 --> 01:05:50,196
but rather to allocate using Malock enough memory for

1798
01:05:50,196 --> 01:05:52,595
the copy plus one more byte for the null character

1799
01:05:52,885 --> 01:05:53,085
again.

1800
01:05:53,231 --> 01:05:55,991
Making sure that all is well by checking the return value of that

1801
01:05:56,261 --> 01:06:00,731
and then actually copying character by character by character

1802
01:06:01,021 --> 01:06:06,021
the characters from S into the chunk of memory now known as T or ultimately recall

1803
01:06:06,021 --> 01:06:10,011
we used the built in stir copy function which does all of that looping for us.

1804
01:06:10,261 --> 01:06:12,622
And then when it came time to capitalize just the copy,

1805
01:06:12,662 --> 01:06:13,852
we did a quick sanity check.

1806
01:06:13,981 --> 01:06:15,931
Is the length of T greater than 0,

1807
01:06:15,941 --> 01:06:17,382
otherwise there's nothing to capitalize?

1808
01:06:17,392 --> 01:06:18,011
And if so,

1809
01:06:18,221 --> 01:06:20,981
go ahead and use the C type libraries to upper function.

1810
01:06:21,260 --> 01:06:27,560
Passing as input that specific character T 0 and then updating T 0 itself.

1811
01:06:27,770 --> 01:06:30,290
So here's an example of procedural programming

1812
01:06:30,290 --> 01:06:32,719
in contrast with object oriented programming again,

1813
01:06:32,929 --> 01:06:39,290
I'm passing the argument to be uh uppercase into the two upper function as opposed

1814
01:06:39,290 --> 01:06:43,840
to simply going to that character and asking it via some dot operator to,

1815
01:06:43,850 --> 01:06:44,209
for instance,

1816
01:06:44,290 --> 01:06:45,610
uppercase itself.

1817
01:06:46,120 --> 01:06:48,719
Now I went ahead in the C version and printed out the two strings.

1818
01:06:48,760 --> 01:06:52,030
I freed up my copy of memory that I myself had allocated,

1819
01:06:52,280 --> 01:06:53,629
and that was it for this program.

1820
01:06:53,719 --> 01:06:55,620
So it was a decent amount of work we're calling

1821
01:06:55,620 --> 01:06:58,669
C to actually go about just copying a string.

1822
01:06:58,919 --> 01:06:59,040
Well,

1823
01:06:59,159 --> 01:07:00,600
as with so many things in Python,

1824
01:07:00,610 --> 01:07:01,760
it's going to be so much easier.

1825
01:07:01,919 --> 01:07:02,790
Let me go ahead and do this.

1826
01:07:02,929 --> 01:07:04,229
Let me open my terminal window.

1827
01:07:04,360 --> 01:07:06,760
Let me create a file called copy.ie.

1828
01:07:07,239 --> 01:07:10,229
Let me move it over to the right hand side so we can see them side by side,

1829
01:07:10,239 --> 01:07:11,510
closing my terminal window,

1830
01:07:11,719 --> 01:07:13,040
and let's do roughly the same.

1831
01:07:13,100 --> 01:07:14,560
Let's create a variable called S,

1832
01:07:14,800 --> 01:07:15,000
set it.

1833
01:07:15,155 --> 01:07:17,024
Equal to on the right hand side,

1834
01:07:17,145 --> 01:07:20,435
the return value of Python's own input function because we don't really need

1835
01:07:20,435 --> 01:07:24,084
CS 50's own get string function and ask the user for S.

1836
01:07:24,435 --> 01:07:27,504
Then let's go ahead and create a second variable called T,

1837
01:07:27,715 --> 01:07:31,435
set it equal to literally S.capitalize,

1838
01:07:31,495 --> 01:07:32,354
whose purpose in life,

1839
01:07:32,425 --> 01:07:35,304
if we read Python's documentation for string methods,

1840
01:07:35,314 --> 01:07:38,754
will be to uppercase the first letter of the

1841
01:07:38,754 --> 01:07:41,504
word that the user has presumably just typed in.

1842
01:07:41,794 --> 01:07:44,145
Then I'm going to go ahead and print out as before.

1843
01:07:44,580 --> 01:07:45,929
The user's input,

1844
01:07:45,939 --> 01:07:47,449
and I can do this in a couple of different ways,

1845
01:07:47,530 --> 01:07:51,449
but I'm going to use one of our format strings and say S colon and then

1846
01:07:51,449 --> 01:07:56,000
interpolate that variables by using my curly braces to say put the value of S here.

1847
01:07:56,179 --> 01:07:59,239
Then I'm going to go ahead and print out T by saying T colon,

1848
01:07:59,370 --> 01:08:01,810
interpolate its value here inside of quotes,

1849
01:08:02,010 --> 01:08:03,229
close parenthesis.

1850
01:08:03,409 --> 01:08:04,560
So let's see if this works.

1851
01:08:04,610 --> 01:08:08,399
Let me go ahead now and run Python of copy.ie.

1852
01:08:08,750 --> 01:08:10,570
I'm going to go ahead and type in,

1853
01:08:10,689 --> 01:08:11,770
say cat and all.

1854
01:08:12,052 --> 01:08:16,251
Case and hit enter and now notices remains in all lower case,

1855
01:08:16,291 --> 01:08:20,562
but the copy indeed has been capitalized alone.

1856
01:08:21,051 --> 01:08:21,251
All right,

1857
01:08:21,291 --> 01:08:23,091
well let's take a look at one other

1858
01:08:23,091 --> 01:08:27,452
example involving strings between C and Python equivalents.

1859
01:08:27,791 --> 01:08:27,801
Uh,

1860
01:08:27,812 --> 01:08:30,421
let me go ahead and remind us that a few weeks back too,

1861
01:08:30,691 --> 01:08:33,731
we created this uppercase program whose purpose in life was

1862
01:08:33,731 --> 01:08:36,242
to prompt the user using Get string for a string,

1863
01:08:36,452 --> 01:08:36,770
saying,

1864
01:08:36,801 --> 01:08:37,921
Here's the before string,

1865
01:08:38,091 --> 01:08:39,131
then it prints out after.

1866
01:08:39,332 --> 01:08:41,372
Because the purpose in life of this program was

1867
01:08:41,372 --> 01:08:44,482
to uppercase all of the characters in the string,

1868
01:08:44,732 --> 01:08:46,803
not just capitalize the first one.

1869
01:08:47,091 --> 01:08:48,082
So as you might expect,

1870
01:08:48,131 --> 01:08:51,643
we used a loop a few weeks back and we iterated from zero on up

1871
01:08:51,643 --> 01:08:55,921
to the length of the string using plus plus to increment I in each iteration,

1872
01:08:56,042 --> 01:08:59,723
and then each time we went ahead and printed out one character at a time.

1873
01:08:59,853 --> 01:09:00,562
So strictly speaking,

1874
01:09:00,612 --> 01:09:04,042
we didn't change the string from lower case perhaps to uppercase,

1875
01:09:04,212 --> 01:09:06,412
we just changed each letter uppercase and print.

1876
01:09:06,545 --> 01:09:08,314
It out right away.

1877
01:09:08,536 --> 01:09:08,616
Well,

1878
01:09:08,694 --> 01:09:10,895
how might we do something similar in Python?

1879
01:09:10,975 --> 01:09:11,015
Well,

1880
01:09:11,136 --> 01:09:11,456
here too,

1881
01:09:11,536 --> 01:09:13,045
we have a couple of different approaches.

1882
01:09:13,215 --> 01:09:15,425
Let me go ahead and open up my terminal now,

1883
01:09:15,694 --> 01:09:17,136
run a code of,

1884
01:09:17,175 --> 01:09:17,604
say,

1885
01:09:17,895 --> 01:09:18,524
uppercase.

1886
01:09:18,895 --> 01:09:19,286
i,

1887
01:09:19,774 --> 01:09:20,685
close my terminal window,

1888
01:09:20,694 --> 01:09:23,206
and let's drag this to the right so we can see them side by side,

1889
01:09:23,335 --> 01:09:24,965
and let's do roughly the same.

1890
01:09:25,175 --> 01:09:28,274
Let me create a variable this time called before,

1891
01:09:28,935 --> 01:09:30,895
set that equal to the return value of input

1892
01:09:30,895 --> 01:09:33,774
and just prompt the user for that before string.

1893
01:09:34,180 --> 01:09:35,069
Then after that,

1894
01:09:35,180 --> 01:09:37,979
let's go ahead and print out preemptively after

1895
01:09:37,979 --> 01:09:40,729
colon space space just to align everything nicely,

1896
01:09:40,899 --> 01:09:44,609
but let me not print a new line yet because I want to go ahead and see

1897
01:09:44,939 --> 01:09:47,049
uh the following string on that same line.

1898
01:09:47,259 --> 01:09:50,540
And then let's go ahead and do this analogously to the C version first,

1899
01:09:50,580 --> 01:09:51,810
but then tighten things up.

1900
01:09:52,020 --> 01:09:55,660
Here's how we can iterate in Python over every character in a string.

1901
01:09:55,740 --> 01:09:56,459
I don't need to bother.

1902
01:09:56,562 --> 01:09:59,461
I and indexing into the string or anything like that,

1903
01:09:59,671 --> 01:10:01,111
I can using a Python 4 loop,

1904
01:10:01,191 --> 01:10:03,801
simply say for each character C

1905
01:10:04,111 --> 01:10:05,782
in that string called before,

1906
01:10:06,071 --> 01:10:10,541
go ahead and print out the uppercase version of that character,

1907
01:10:10,631 --> 01:10:12,472
but don't yet print out a new line.

1908
01:10:12,512 --> 01:10:14,001
But at the very end of this loop,

1909
01:10:14,151 --> 01:10:15,861
go ahead and print out nothing but

1910
01:10:16,191 --> 01:10:17,021
a new line.

1911
01:10:17,271 --> 01:10:18,551
Let me go ahead and open my terminal,

1912
01:10:18,832 --> 01:10:18,992
run.

1913
01:10:19,094 --> 01:10:23,454
Python of uppercase.ie enter type in cat in all lower case,

1914
01:10:23,644 --> 01:10:24,554
cross my fingers,

1915
01:10:24,724 --> 01:10:27,494
and after each and every one of the characters

1916
01:10:27,804 --> 01:10:28,394
is uppercase.

1917
01:10:28,483 --> 01:10:29,324
And what's nice about this,

1918
01:10:29,363 --> 01:10:30,204
if nothing else,

1919
01:10:30,443 --> 01:10:33,804
is that this 4 loop in Python there on line 3 is pretty elegant,

1920
01:10:33,844 --> 01:10:37,554
whereby you implicitly get access to each character in the string because

1921
01:10:37,554 --> 01:10:41,523
that's how Python knows how to iterate over a string object.

1922
01:10:41,625 --> 01:10:44,536
But it turns out we don't have to do this quite as analogously in

1923
01:10:44,536 --> 01:10:47,485
Python as we did in see we don't have to do it character by character

1924
01:10:47,735 --> 01:10:50,416
in so far as Python is object oriented and

1925
01:10:50,416 --> 01:10:53,875
these strings are objects and those objects have methods.

1926
01:10:53,976 --> 01:10:57,806
Those methods will actually operate on the entire string at once,

1927
01:10:58,096 --> 01:11:01,726
unlike the more pedantic work we had to do character by character in C.

1928
01:11:01,936 --> 01:11:02,335
So in fact,

1929
01:11:02,375 --> 01:11:03,976
let me go ahead and close the C version here.

1930
01:11:04,680 --> 01:11:04,990
Uh,

1931
01:11:05,160 --> 01:11:06,509
clear my terminal and hide it,

1932
01:11:06,640 --> 01:11:08,790
and let's go ahead and make this quite simpler.

1933
01:11:09,040 --> 01:11:11,490
Let's get rid of the 4 loop altogether

1934
01:11:11,759 --> 01:11:15,229
and let's simply and let's get rid of that print statement altogether,

1935
01:11:15,439 --> 01:11:18,470
leaving only the before variable and getting the user's input.

1936
01:11:18,640 --> 01:11:20,509
And now let's create an after variable,

1937
01:11:20,520 --> 01:11:22,049
set it equal to 4.

1938
01:11:22,799 --> 01:11:23,189
upper,

1939
01:11:23,680 --> 01:11:28,080
thereby upper casing the entire string called before and setting the return value.

1940
01:11:28,365 --> 01:11:28,705
To

1941
01:11:28,825 --> 01:11:33,004
the after variable and then let's go ahead and print using our old friend F string,

1942
01:11:33,254 --> 01:11:33,495
uh,

1943
01:11:33,504 --> 01:11:34,294
after colo uh space

1944
01:11:34,915 --> 01:11:35,464
space,

1945
01:11:35,504 --> 01:11:37,455
and then interpolate the value of

1946
01:11:37,745 --> 01:11:39,214
that after version.

1947
01:11:39,345 --> 01:11:41,495
So now we're down to just 3 lines at that.

1948
01:11:41,745 --> 01:11:45,584
Let me go ahead and reopen my terminal python of uppercase.ie enter,

1949
01:11:45,705 --> 01:11:47,185
type in cat in all lower case,

1950
01:11:47,544 --> 01:11:48,375
and voila,

1951
01:11:48,504 --> 01:11:50,095
now I have capitalized

1952
01:11:50,384 --> 01:11:51,705
the cat all at once.

1953
01:11:53,229 --> 01:11:53,830
All right,

1954
01:11:54,189 --> 01:11:56,680
before we take a break for some fruit by the foot,

1955
01:11:56,910 --> 01:12:00,620
let's go ahead and take a look at Python's implementation of loops further.

1956
01:12:01,109 --> 01:12:02,390
So in Scratch,

1957
01:12:02,509 --> 01:12:04,709
recall that we implemented a loop with something like this.

1958
01:12:04,790 --> 01:12:06,549
If I wanted to me meow 3 times on the screen,

1959
01:12:06,629 --> 01:12:08,060
I would literally use a repeat block.

1960
01:12:08,140 --> 01:12:08,669
In C,

1961
01:12:08,750 --> 01:12:11,140
it was a little clunkier to mimic that same idea.

1962
01:12:11,149 --> 01:12:14,950
Like we could implement a variable called I and set it equal to 0.

1963
01:12:15,069 --> 01:12:18,060
Then we could ask a Boolean expression is I less than 3?

1964
01:12:18,069 --> 01:12:18,509
If so,

1965
01:12:18,560 --> 01:12:20,790
print me out and then increment I using our old.

1966
01:12:21,064 --> 01:12:21,604
plus friend,

1967
01:12:21,884 --> 01:12:23,194
which in Python is now gone.

1968
01:12:23,365 --> 01:12:25,875
In Python we can do this almost the same,

1969
01:12:26,165 --> 01:12:28,174
except I don't think we need the data type.

1970
01:12:28,365 --> 01:12:29,814
I don't think we need the semicolon.

1971
01:12:29,884 --> 01:12:32,365
We don't need the parentheses while still exists.

1972
01:12:32,444 --> 01:12:33,634
We don't need the curly braces,

1973
01:12:33,645 --> 01:12:35,115
and we can't use the plus plus.

1974
01:12:35,245 --> 01:12:36,004
We don't need the F.

1975
01:12:36,044 --> 01:12:36,205
I mean,

1976
01:12:36,245 --> 01:12:39,645
we're mostly just trimming clutter from this here implementation.

1977
01:12:39,705 --> 01:12:40,805
So this is the C version.

1978
01:12:41,250 --> 01:12:43,020
This now is the Python version,

1979
01:12:43,089 --> 01:12:43,729
a little tighter,

1980
01:12:43,779 --> 01:12:44,959
a little easier to read.

1981
01:12:45,129 --> 01:12:48,500
It's pretty much the minimal syntax available to get the job done.

1982
01:12:48,729 --> 01:12:51,759
So how can we actually have a cat meow in this case?

1983
01:12:51,970 --> 01:12:52,029
Well,

1984
01:12:52,129 --> 01:12:53,310
let me go into

1985
01:12:53,830 --> 01:12:54,600
VS code

1986
01:12:54,810 --> 01:12:57,689
and I'll stop doing everything side by side and just stipulate that we've

1987
01:12:57,689 --> 01:13:02,209
done most of these examples previously in C and in my first cat,

1988
01:13:02,290 --> 01:13:02,370
well,

1989
01:13:02,410 --> 01:13:05,790
I could certainly do it the easy way and let me go ahead and create cat.ie

1990
01:13:06,330 --> 01:13:08,299
and like we always started in the past with,

1991
01:13:08,370 --> 01:13:11,169
I could just do meow and then our old friend copy paste,

1992
01:13:11,180 --> 01:13:13,009
and this of course was bad for bunches of reasons,

1993
01:13:13,049 --> 01:13:14,279
but it gets the job done.

1994
01:13:14,529 --> 01:13:15,290
In Python,

1995
01:13:15,330 --> 01:13:16,089
if I want to do this,

1996
01:13:16,209 --> 01:13:16,299
well,

1997
01:13:16,370 --> 01:13:16,850
I can just borrow.

1998
01:13:16,959 --> 01:13:18,740
That same inspiration and I could say

1999
01:13:18,990 --> 01:13:20,580
set i equal to 0,

2000
01:13:20,709 --> 01:13:24,549
then do while I is less than 3,

2001
01:13:24,709 --> 01:13:25,270
colon,

2002
01:13:25,310 --> 01:13:27,509
then go ahead and print out meow,

2003
01:13:27,689 --> 01:13:34,180
and then go ahead and do I equal or rather I plus equals 1 is maybe the most succinct way

2004
01:13:34,430 --> 01:13:36,100
to express that same idea.

2005
01:13:36,229 --> 01:13:36,430
All right,

2006
01:13:36,470 --> 01:13:37,470
just to confirm that this works,

2007
01:13:37,549 --> 01:13:40,100
python of cat.pi enter meow meow meow.

2008
01:13:40,799 --> 01:13:41,069
All right,

2009
01:13:41,169 --> 01:13:44,759
so how else can we do this and how can we do this more pythonically?

2010
01:13:44,950 --> 01:13:46,459
This is perfectly correct.

2011
01:13:47,930 --> 01:13:49,759
Many people might implement it this way,

2012
01:13:50,089 --> 01:13:54,479
but it's not quite as succinct as we could alternatively do in Python,

2013
01:13:54,569 --> 01:13:54,850
yeah.

2014
01:13:58,459 --> 01:13:58,859
Yeah,

2015
01:13:59,060 --> 01:14:01,060
so we could maybe use a 4 loop,

2016
01:14:01,100 --> 01:14:03,939
and in fact let's let's go there because we don't quite have the

2017
01:14:03,939 --> 01:14:06,359
same types of 4 loops in Python as we did in C.

2018
01:14:06,459 --> 01:14:08,310
While loops are essentially the same,

2019
01:14:08,399 --> 01:14:12,140
but 4 loops are actually a little bit different and actually a little bit better.

2020
01:14:12,220 --> 01:14:14,009
So let me go into my code here,

2021
01:14:14,220 --> 01:14:15,649
delete all 4 of these lines,

2022
01:14:15,660 --> 01:14:17,169
and literally just say 4,

2023
01:14:17,500 --> 01:14:18,870
I in

2024
01:14:19,100 --> 01:14:22,509
this list of values 01 and 2 colo,

2025
01:14:22,830 --> 01:14:23,569
print,

2026
01:14:23,819 --> 01:14:24,200
meow.

2027
01:14:24,759 --> 01:14:25,430
In other words,

2028
01:14:25,509 --> 01:14:26,740
in 4 loops and Python,

2029
01:14:26,750 --> 01:14:27,649
you don't have the parentheses,

2030
01:14:27,790 --> 01:14:29,000
you don't have the two semicolons,

2031
01:14:29,029 --> 01:14:32,020
you don't have the initialization and the Boolean expression and the update.

2032
01:14:32,270 --> 01:14:34,779
You just say a little more English like

2033
01:14:35,109 --> 01:14:39,620
for each i in the following list or for each value of I in the following list.

2034
01:14:39,629 --> 01:14:41,750
And what Python will do for us is automatically

2035
01:14:41,750 --> 01:14:44,080
on the first iteration set i equal to 0.

2036
01:14:44,109 --> 01:14:45,839
On the second iteration set I to 1.

2037
01:14:45,910 --> 01:14:47,939
On the 3rd iteration set i to 2,

2038
01:14:48,109 --> 01:14:49,660
and then there's only 3 things in the list,

2039
01:14:49,870 --> 01:14:50,509
so that's it.

2040
01:14:50,810 --> 01:14:53,359
And so just as before with the Y and the yes

2041
01:14:53,359 --> 01:14:57,140
example where I use square brackets similar to arrays and C,

2042
01:14:57,359 --> 01:15:00,229
I was using a Python list of strings in that case.

2043
01:15:00,439 --> 01:15:04,950
Here I'm using a Python list of integers 01 and 2,

2044
01:15:05,160 --> 01:15:07,370
and they're integers in the sense that they have no quotes around them,

2045
01:15:07,439 --> 01:15:08,950
so they're obviously not strings,

2046
01:15:08,959 --> 01:15:10,589
and I'm printing out meow this many times.

2047
01:15:10,680 --> 01:15:12,790
And indeed if I do Python of Cai again.

2048
01:15:13,069 --> 01:15:14,459
I get meow meow meow.

2049
01:15:14,970 --> 01:15:15,959
This is correct.

2050
01:15:16,089 --> 01:15:17,759
This is arguably better,

2051
01:15:17,850 --> 01:15:20,810
at least in the sense that it's two lines of code instead of 4,

2052
01:15:20,959 --> 01:15:23,799
and it's arguably more readable as well,

2053
01:15:24,250 --> 01:15:26,290
but what do you not like

2054
01:15:26,649 --> 01:15:27,759
about this perhaps,

2055
01:15:28,089 --> 01:15:29,720
even if you're only seeing it for the first time.

2056
01:15:33,870 --> 01:15:34,140
Yeah,

2057
01:15:34,180 --> 01:15:36,060
it's going to be a lot more difficult to do things more

2058
01:15:36,060 --> 01:15:39,569
than 3 times because we're calling Python and Scratch at least,

2059
01:15:39,609 --> 01:15:40,450
and in C

2060
01:15:40,779 --> 01:15:43,620
we had the ability to either express ourselves literally or at least in

2061
01:15:43,620 --> 01:15:46,700
C we could just change that 3 to any number we want 30,

2062
01:15:46,819 --> 01:15:47,379
300,

2063
01:15:47,450 --> 01:15:48,049
no big deal.

2064
01:15:48,100 --> 01:15:51,649
It's a super simple change even though it was kind of annoying to type all of this out.

2065
01:15:51,859 --> 01:15:51,959
Well,

2066
01:15:51,979 --> 01:15:52,819
in Python.

2067
01:15:52,950 --> 01:15:53,180
Yeah,

2068
01:15:53,339 --> 01:15:56,459
I could do this and say for 1 and 01 and 2

2069
01:15:56,459 --> 01:15:59,729
just to mimic the numbers that we'd be setting i equal to in

2070
01:15:59,859 --> 01:16:00,729
the C version.

2071
01:16:00,859 --> 01:16:01,240
Frankly,

2072
01:16:01,279 --> 01:16:02,250
this can be any list.

2073
01:16:02,299 --> 01:16:04,649
It could be 123456,

2074
01:16:05,140 --> 01:16:05,299
cat,

2075
01:16:05,379 --> 01:16:05,589
dog,

2076
01:16:05,600 --> 01:16:05,970
bird,

2077
01:16:06,060 --> 01:16:07,970
or any three things whatsoever,

2078
01:16:08,060 --> 01:16:11,899
but I'm just using 01 and 2 for consistency with the way C would have done it.

2079
01:16:12,169 --> 01:16:14,430
But slightly better than this is to use one of those

2080
01:16:14,430 --> 01:16:17,310
other data types that was briefly on the screen earlier.

2081
01:16:17,520 --> 01:16:22,839
We have not just floats and ins and stirrs and lists and tups.

2082
01:16:22,919 --> 01:16:24,629
We also have what are called ranges,

2083
01:16:24,839 --> 01:16:28,919
and range is not only a data type in Python but more literally a function

2084
01:16:28,919 --> 01:16:32,629
that you can call to get a range of values from zero on up.

2085
01:16:32,839 --> 01:16:35,060
So I can change this list of three values

2086
01:16:35,060 --> 01:16:37,569
to a function call to a function called range,

2087
01:16:37,680 --> 01:16:39,229
passing how many things I want,

2088
01:16:39,279 --> 01:16:39,850
and by default.

2089
01:16:39,905 --> 01:16:40,985
Per the documentation,

2090
01:16:41,175 --> 01:16:43,295
I'll get back a list of numbers 01,

2091
01:16:43,306 --> 01:16:43,925
and 2.

2092
01:16:44,096 --> 01:16:44,695
And nicely,

2093
01:16:44,775 --> 01:16:45,936
Python's pretty smart about this.

2094
01:16:46,036 --> 01:16:48,335
It technically doesn't hand you back all of the numbers at once,

2095
01:16:48,416 --> 01:16:51,445
whether it's 3 or 30 or 300 or 3 million.

2096
01:16:51,655 --> 01:16:53,855
It sort of hands them back to you one at a time

2097
01:16:53,855 --> 01:16:57,605
so you're not using more memory just because you're doing more iterations.

2098
01:16:57,855 --> 01:17:00,056
So now if I do want to iterate 4 times,

2099
01:17:00,235 --> 01:17:00,775
5 times,

2100
01:17:00,826 --> 01:17:01,326
30 times,

2101
01:17:01,375 --> 01:17:02,186
300 times,

2102
01:17:02,375 --> 01:17:04,525
I again can just change this single value.

2103
01:17:04,655 --> 01:17:05,775
And if you want to be fancy too,

2104
01:17:05,855 --> 01:17:07,076
you can skip numbers.

2105
01:17:07,096 --> 01:17:07,585
You can go.

2106
01:17:07,642 --> 01:17:10,341
Count all the way through odd numbers or even numbers.

2107
01:17:10,432 --> 01:17:11,912
You can change the incrementation factor,

2108
01:17:11,952 --> 01:17:15,582
but the default and the most canonical is indeed just to count up like that.

2109
01:17:15,711 --> 01:17:17,262
So if I go back to VS code here

2110
01:17:17,512 --> 01:17:18,622
and improve this,

2111
01:17:18,912 --> 01:17:22,421
I can change that hard coded list to just range of 3,

2112
01:17:22,671 --> 01:17:23,432
clear my terminal,

2113
01:17:23,551 --> 01:17:24,941
run this cat one more time,

2114
01:17:25,191 --> 01:17:27,702
and now I'm back in business as well.

2115
01:17:27,841 --> 01:17:28,111
In fact,

2116
01:17:28,191 --> 01:17:29,032
this is so common,

2117
01:17:29,071 --> 01:17:31,182
let me throw up one alternative to this.

2118
01:17:31,551 --> 01:17:33,461
You'll notice that in the previous example,

2119
01:17:33,591 --> 01:17:35,501
both in VS code and on the screen,

2120
01:17:35,872 --> 01:17:36,271
um.

2121
01:17:36,910 --> 01:17:40,140
I am not actually using I in any way.

2122
01:17:40,310 --> 01:17:40,589
In fact,

2123
01:17:40,669 --> 01:17:44,020
if you look back at how we converted the scratch to Python code,

2124
01:17:44,509 --> 01:17:47,379
I'm using I because when you use a 4 loop in Python,

2125
01:17:47,390 --> 01:17:49,299
you have to give it a variable

2126
01:17:49,669 --> 01:17:52,270
in some list or range of values.

2127
01:17:52,350 --> 01:17:53,419
That's just the way it is.

2128
01:17:53,549 --> 01:17:56,580
But I'm technically not using or printing I anywhere,

2129
01:17:56,830 --> 01:17:57,500
and that's fine.

2130
01:17:57,549 --> 01:18:01,459
And so it's arguably Pythonic too if you have a variable out of necessity,

2131
01:18:01,520 --> 01:18:04,140
but you're not actually going to use it for anything useful,

2132
01:18:04,430 --> 01:18:04,549
just.

2133
01:18:04,680 --> 01:18:06,189
Call it an underscore instead.

2134
01:18:06,319 --> 01:18:07,910
And even though this is weird looking,

2135
01:18:08,080 --> 01:18:11,799
an underscore is a valid symbol for a variable name in Python,

2136
01:18:11,839 --> 01:18:14,350
so it is Pythonic to just use this just

2137
01:18:14,350 --> 01:18:16,709
to signal to yourself later and to colleagues that,

2138
01:18:16,720 --> 01:18:16,839
yeah,

2139
01:18:16,919 --> 01:18:18,430
I'm using a variable because I have to,

2140
01:18:18,520 --> 01:18:20,910
but it's not one I'm actually going to use elsewhere.

2141
01:18:21,000 --> 01:18:24,910
It's a minor subtlety and not strictly necessary but

2142
01:18:25,560 --> 01:18:26,830
perhaps commonly done.

2143
01:18:27,740 --> 01:18:28,189
All right,

2144
01:18:28,459 --> 01:18:31,180
how about a couple final versions of cats then.

2145
01:18:31,259 --> 01:18:34,649
So recall that if we wanted to do something in scratch forever,

2146
01:18:34,740 --> 01:18:35,819
we had a forever block,

2147
01:18:35,859 --> 01:18:36,959
which literally did that.

2148
01:18:37,100 --> 01:18:37,220
Well,

2149
01:18:37,299 --> 01:18:40,339
in C we couldn't quite translate that literally.

2150
01:18:40,459 --> 01:18:44,660
So the closest approximation was probably this while true,

2151
01:18:44,779 --> 01:18:47,850
whereby you have a boolean expression that by definition is always true,

2152
01:18:48,060 --> 01:18:49,290
so the loop is never going to stop,

2153
01:18:49,339 --> 01:18:51,180
thereby infinite if you wanted to print out.

2154
01:18:51,330 --> 01:18:53,470
Meow meow meow on the screen ad nauseam.

2155
01:18:53,680 --> 01:18:55,629
In Python you can do it almost the same,

2156
01:18:55,720 --> 01:18:57,479
but the curly braces are about to go,

2157
01:18:57,520 --> 01:18:58,359
the F is about to go,

2158
01:18:58,399 --> 01:18:59,160
the backslash N,

2159
01:18:59,240 --> 01:18:59,919
the semicolon,

2160
01:18:59,930 --> 01:19:00,990
and the parentheses.

2161
01:19:01,209 --> 01:19:01,799
But

2162
01:19:02,160 --> 01:19:05,560
for whatever reason in C we lowercase true and false.

2163
01:19:05,640 --> 01:19:08,319
In Python we capitalize true and false.

2164
01:19:08,359 --> 01:19:09,459
So a minor subtlety,

2165
01:19:09,600 --> 01:19:11,240
but it's now indeed capital T.

2166
01:19:11,520 --> 01:19:14,870
But the indentation has to be the same and the colon has to be there as well.

2167
01:19:15,250 --> 01:19:16,529
So with that

2168
01:19:16,669 --> 01:19:19,790
we can of course induce intentionally or otherwise some

2169
01:19:20,109 --> 01:19:21,229
infinite loops.

2170
01:19:21,270 --> 01:19:26,439
As with C you can break out of them if need be with control C to interrupt the process.

2171
01:19:26,669 --> 01:19:30,390
But let's just see lastly with this cat how we can make it a

2172
01:19:30,390 --> 01:19:34,220
little more abstract like the final versions of our cat in scratch and see.

2173
01:19:34,629 --> 01:19:37,339
So let me propose to open up here

2174
01:19:38,350 --> 01:19:42,620
in a pro version of CAT that we looked at that we wrote in the past.

2175
01:19:43,080 --> 01:19:44,950
It was version 12 at the time,

2176
01:19:45,120 --> 01:19:46,850
which looked a little something like this.

2177
01:19:47,120 --> 01:19:49,919
This was one of the final versions of our cat in C

2178
01:19:50,319 --> 01:19:54,990
that simply allowed me in Maine to call meow function that took an argument,

2179
01:19:55,000 --> 01:19:56,790
which is the number of times I wanted to meow.

2180
01:19:57,080 --> 01:20:00,120
This in C is how we implemented that helper function,

2181
01:20:00,240 --> 01:20:00,910
so to speak,

2182
01:20:01,120 --> 01:20:02,000
that returned nothing,

2183
01:20:02,200 --> 01:20:03,450
so its return type was void,

2184
01:20:03,520 --> 01:20:03,770
but

2185
01:20:03,884 --> 01:20:07,004
take an integer called N as its input and then

2186
01:20:07,004 --> 01:20:09,274
there was a 4 loop inside of there that printed

2187
01:20:09,524 --> 01:20:11,305
meow that many times.

2188
01:20:11,365 --> 01:20:12,365
So long story short,

2189
01:20:12,604 --> 01:20:16,245
this was how both in Scratch and in C we invented our own functions.

2190
01:20:16,365 --> 01:20:16,484
Well,

2191
01:20:16,564 --> 01:20:18,475
how can we do this now in Python?

2192
01:20:18,645 --> 01:20:18,725
Well,

2193
01:20:18,845 --> 01:20:20,924
let me bring this version of CAT over to the right here,

2194
01:20:21,044 --> 01:20:22,435
delete that previous version,

2195
01:20:22,595 --> 01:20:23,075
and

2196
01:20:23,375 --> 01:20:24,564
let me propose that.

2197
01:20:25,120 --> 01:20:27,649
We do this for I in

2198
01:20:27,959 --> 01:20:29,229
range of 3.

2199
01:20:29,520 --> 01:20:31,520
Let's go ahead and assume for the moment that there is

2200
01:20:31,520 --> 01:20:34,589
a meow function in Scratch whose purpose in life is to just

2201
01:20:34,839 --> 01:20:35,990
meow on the screen.

2202
01:20:36,160 --> 01:20:36,220
Well,

2203
01:20:36,240 --> 01:20:37,569
that of course does not exist.

2204
01:20:37,799 --> 01:20:40,069
So in Python I'm going to use a trick

2205
01:20:40,330 --> 01:20:42,549
that allows me to define my own function,

2206
01:20:42,600 --> 01:20:45,600
and the keyword for this is literally deaf for define.

2207
01:20:45,890 --> 01:20:49,520
The name of the function and then parentheses if it takes no arguments.

2208
01:20:49,600 --> 01:20:51,470
You don't need the void keyword

2209
01:20:51,759 --> 01:20:53,319
even if it takes no inputs.

2210
01:20:53,399 --> 01:20:56,080
So let's do a simpler version of the cat first that takes no arguments,

2211
01:20:56,120 --> 01:20:57,870
and then we'll add back that argument.

2212
01:20:58,049 --> 01:20:58,379
How do,

2213
01:20:58,479 --> 01:20:59,279
how does a cat meow?

2214
01:20:59,319 --> 01:21:01,779
It literally just says meow on the screen.

2215
01:21:02,200 --> 01:21:04,000
So already we seem to be an improvement.

2216
01:21:04,040 --> 01:21:08,470
I've got like 4 lines of actual code here versus like 20 or so on the left hand side.

2217
01:21:08,680 --> 01:21:11,319
Let's go ahead and run Pythonoca.ie.

2218
01:21:12,060 --> 01:21:12,740
Enter

2219
01:21:13,020 --> 01:21:15,299
and we see the first of our errors,

2220
01:21:15,399 --> 01:21:18,169
which is remarkable because usually I would have messed up by now.

2221
01:21:18,540 --> 01:21:23,020
So here we have in Python the equivalent of like a compiler error message.

2222
01:21:23,060 --> 01:21:24,290
The program has not run.

2223
01:21:24,540 --> 01:21:25,430
It's tried to run.

2224
01:21:25,459 --> 01:21:26,459
It's tried to be interpreted,

2225
01:21:26,470 --> 01:21:27,779
but it encountered some error.

2226
01:21:27,979 --> 01:21:30,500
These are generally called trace backs in the sense that you.

2227
01:21:30,555 --> 01:21:33,064
See a trace back in time of everything the

2228
01:21:33,064 --> 01:21:35,334
program was trying to do just before it failed.

2229
01:21:35,464 --> 01:21:36,575
So if you call it the function,

2230
01:21:36,584 --> 01:21:37,225
which called the function,

2231
01:21:37,265 --> 01:21:37,834
which called the function,

2232
01:21:37,875 --> 01:21:39,774
you'd see all of those function calls on the screen.

2233
01:21:40,024 --> 01:21:41,305
I've just tried to call one function,

2234
01:21:41,384 --> 01:21:42,935
so it's a relatively short error.

2235
01:21:43,185 --> 01:21:44,274
This is clearly a problem,

2236
01:21:44,305 --> 01:21:46,455
and here's the type of problem name error.

2237
01:21:46,625 --> 01:21:49,134
The name meow is not defined.

2238
01:21:49,785 --> 01:21:50,544
So intuitively,

2239
01:21:50,625 --> 01:21:52,455
even if you're seeing Python for the first time,

2240
01:21:52,865 --> 01:21:56,185
why is meow not defined even though it's literally defined.

2241
01:21:57,020 --> 01:21:58,129
Right there,

2242
01:21:59,930 --> 01:21:59,939
yeah.

2243
01:22:00,700 --> 01:22:01,089
Yeah,

2244
01:22:01,209 --> 01:22:03,330
as smart as Python is vis a visc,

2245
01:22:04,169 --> 01:22:07,879
still kind of naive in that meow doesn't exist until line 4.

2246
01:22:08,049 --> 01:22:10,580
So if you try to use it on line 2 too soon.

2247
01:22:10,930 --> 01:22:11,169
All right,

2248
01:22:11,330 --> 01:22:13,290
so in C we fix this problem

2249
01:22:13,669 --> 01:22:14,160
by

2250
01:22:14,290 --> 01:22:17,250
initially just kind of hacking things together by just,

2251
01:22:17,330 --> 01:22:17,529
all right,

2252
01:22:17,609 --> 01:22:17,720
well,

2253
01:22:17,729 --> 01:22:19,399
let's just define it up here

2254
01:22:19,689 --> 01:22:22,279
and then move that down there and that's totally reasonable.

2255
01:22:22,290 --> 01:22:25,839
And in fact if I clear my terminal and rerun Python of Capi,

2256
01:22:26,109 --> 01:22:27,325
we're Back in business,

2257
01:22:27,555 --> 01:22:29,504
but I'd argue you can only do that so many times,

2258
01:22:29,714 --> 01:22:31,475
especially once you've got a bunch of functions.

2259
01:22:31,595 --> 01:22:34,435
You don't want to relegate like the main part of your program,

2260
01:22:34,475 --> 01:22:36,935
which really this loop is to the very bottom of the screen,

2261
01:22:36,995 --> 01:22:38,964
if only because like that's the first thing you care about.

2262
01:22:38,975 --> 01:22:40,314
I want to see at the top of the screen that's

2263
01:22:40,314 --> 01:22:41,964
the whole point of putting main at the very top.

2264
01:22:42,640 --> 01:22:44,299
So what was the solution in C?

2265
01:22:44,379 --> 01:22:45,410
The solution in C

2266
01:22:45,620 --> 01:22:48,890
was to put the prototype for the function at the top of the file.

2267
01:22:49,220 --> 01:22:51,609
That though is not a thing in Python.

2268
01:22:51,620 --> 01:22:53,669
You don't just copy that first line of code,

2269
01:22:53,899 --> 01:22:55,009
put it at the top of the file,

2270
01:22:55,100 --> 01:22:56,229
add a semicolon,

2271
01:22:56,299 --> 01:22:56,850
and then

2272
01:22:57,020 --> 01:22:57,700
it works.

2273
01:22:58,120 --> 01:22:58,970
Instead,

2274
01:22:59,060 --> 01:23:01,439
the Pythonic way to solve this problem,

2275
01:23:01,500 --> 01:23:02,569
for better or for worse

2276
01:23:02,779 --> 01:23:04,970
is to actually put your code in

2277
01:23:05,259 --> 01:23:06,479
a main function.

2278
01:23:06,830 --> 01:23:10,169
Main and Python has no special significance in this sense.

2279
01:23:10,200 --> 01:23:13,379
It's just convention to borrow the name that so many

2280
01:23:13,379 --> 01:23:16,660
other languages use as the main function in those languages,

2281
01:23:16,899 --> 01:23:20,020
but you just wrap your function in a function main so that

2282
01:23:20,180 --> 01:23:21,450
you're defining main,

2283
01:23:21,859 --> 01:23:26,660
then you're defining meow before you're actually using the meow function per se.

2284
01:23:27,410 --> 01:23:29,500
But I have made a mistake.

2285
01:23:29,750 --> 01:23:32,740
If I run Python of cattai now,

2286
01:23:33,069 --> 01:23:34,620
cross my fingers for good measure,

2287
01:23:34,750 --> 01:23:35,250
and

2288
01:23:36,009 --> 01:23:37,799
Now the program does nothing.

2289
01:23:39,259 --> 01:23:40,209
Why is that?

2290
01:23:43,359 --> 01:23:43,750
Yeah,

2291
01:23:43,959 --> 01:23:44,470
why is that?

2292
01:23:46,149 --> 01:23:46,359
Oh,

2293
01:23:46,479 --> 01:23:46,560
sorry,

2294
01:23:46,640 --> 01:23:46,979
go ahead.

2295
01:23:48,870 --> 01:23:49,359
Yeah,

2296
01:23:49,500 --> 01:23:49,939
curiously,

2297
01:23:49,979 --> 01:23:51,290
I never called the main function.

2298
01:23:51,379 --> 01:23:55,899
So whereas in C and in Java and C++ and a bunch of other languages,

2299
01:23:56,020 --> 01:23:57,100
Maine is special.

2300
01:23:57,180 --> 01:24:00,339
Like Ma is the function by definition that is

2301
01:24:00,339 --> 01:24:03,660
automatically called Python has no such special magic.

2302
01:24:03,669 --> 01:24:05,700
It's not going to call Maine for you just because you created it.

2303
01:24:05,740 --> 01:24:05,939
In fact,

2304
01:24:06,020 --> 01:24:08,180
I didn't even call that main function Main.

2305
01:24:08,580 --> 01:24:09,770
It's just a convention,

2306
01:24:09,939 --> 01:24:11,979
but the solution is exactly that.

2307
01:24:12,092 --> 01:24:12,203
Well,

2308
01:24:12,243 --> 01:24:15,632
if the problem is that Maine wasn't called at the bottom of this file,

2309
01:24:15,683 --> 01:24:17,763
what I can do is just literally call Maine,

2310
01:24:17,803 --> 01:24:19,442
which we would never have done in C,

2311
01:24:19,562 --> 01:24:21,752
but this is conventional to do in Python,

2312
01:24:22,042 --> 01:24:27,353
so that after you've defined Maine up here and then define Mao down here,

2313
01:24:27,603 --> 01:24:29,123
now you can call Maine,

2314
01:24:29,402 --> 01:24:31,402
which in turn will call meow,

2315
01:24:31,643 --> 01:24:32,962
but at that point in the story,

2316
01:24:33,002 --> 01:24:35,152
both of those functions functions exist.

2317
01:24:35,315 --> 01:24:38,456
So if I go down here and run cat.ie again,

2318
01:24:38,706 --> 01:24:40,545
now I see my meow,

2319
01:24:40,706 --> 01:24:41,025
meow,

2320
01:24:41,065 --> 01:24:41,405
meow.

2321
01:24:41,786 --> 01:24:44,746
Now let me add one final flourish because this version of the code in

2322
01:24:44,746 --> 01:24:48,815
C recall actually let me specify how many times I want to meow,

2323
01:24:49,105 --> 01:24:50,255
whereas here

2324
01:24:50,465 --> 01:24:52,436
I actually have my 4 loop in Maine

2325
01:24:52,866 --> 01:24:53,655
at the right,

2326
01:24:53,905 --> 01:24:55,496
and I'm calling meow that many times.

2327
01:24:55,706 --> 01:24:55,826
Well,

2328
01:24:55,925 --> 01:24:58,416
what if I want to get rid of this loop over here?

2329
01:24:58,709 --> 01:25:03,810
And deindent meow here and pass in literally the number 3 here.

2330
01:25:04,060 --> 01:25:04,259
Well,

2331
01:25:04,379 --> 01:25:07,540
in Python you can just say inside of the definition

2332
01:25:07,540 --> 01:25:09,859
of a function that it takes an argument like N.

2333
01:25:10,180 --> 01:25:11,740
You don't have to specify the data type.

2334
01:25:11,859 --> 01:25:13,529
Python's smart enough to figure it out.

2335
01:25:13,939 --> 01:25:18,979
Then in your function you can use that as with 4 i in range of n.

2336
01:25:19,509 --> 01:25:20,970
Go ahead and print meow.

2337
01:25:21,270 --> 01:25:25,589
So now the right hand version of this program is pretty much equivalent to

2338
01:25:25,589 --> 01:25:29,700
the left hand version of this program as always using fewer lines of code.

2339
01:25:29,870 --> 01:25:32,790
Let me go ahead and run Python of cat up i meow meow meow.

2340
01:25:32,830 --> 01:25:33,220
We're good.

2341
01:25:33,310 --> 01:25:34,990
And then let me make one final change,

2342
01:25:35,000 --> 01:25:38,740
if only because most every documentation you see online or website you.

2343
01:25:38,830 --> 01:25:42,779
Orals on Python will actually have you not just literally call Maine at the bottom,

2344
01:25:42,990 --> 01:25:45,750
but you'll do this crazy syntax that is solves a

2345
01:25:45,750 --> 01:25:47,700
problem that we won't trip over in this class,

2346
01:25:47,950 --> 01:25:52,020
but typically it's Pythonic to actually call Maine after asking the question if

2347
01:25:52,509 --> 01:25:58,979
name equals equals quote unquote_ma__ colon Ma.

2348
01:25:59,290 --> 01:26:02,629
This is a stupid mouthful of code that even I had to think about

2349
01:26:02,629 --> 01:26:05,020
when I was typing it out if I got all the underscores correct,

2350
01:26:05,240 --> 01:26:06,549
but long story short.

2351
01:26:06,890 --> 01:26:09,270
This convention of using a conditional before you

2352
01:26:09,270 --> 01:26:12,319
call main allows you to write more modular

2353
01:26:12,319 --> 01:26:14,509
code in Python so that some of your

2354
01:26:14,509 --> 01:26:17,879
files don't actually do anything other than define,

2355
01:26:17,910 --> 01:26:18,270
define,

2356
01:26:18,350 --> 01:26:18,669
define,

2357
01:26:18,750 --> 01:26:19,859
defined functions

2358
01:26:20,029 --> 01:26:22,470
that you can then import into other files you write.

2359
01:26:22,549 --> 01:26:22,950
So in short,

2360
01:26:22,959 --> 01:26:25,140
this is the right way to do it even though in CS

2361
01:26:25,140 --> 01:26:28,759
50 it is unlikely that we are to trip over this bug.

2362
01:26:29,620 --> 01:26:30,620
Questions now

2363
01:26:30,910 --> 01:26:33,819
on that last piece of how we define functions in

2364
01:26:34,310 --> 01:26:35,180
Python,

2365
01:26:35,430 --> 01:26:35,709
yeah.

2366
01:26:38,100 --> 01:26:38,379
Ah,

2367
01:26:38,560 --> 01:26:39,140
good question.

2368
01:26:39,220 --> 01:26:39,580
Good eye.

2369
01:26:39,700 --> 01:26:42,220
Why do I have two lines between my functions in Python?

2370
01:26:42,259 --> 01:26:44,220
As you will see via Style 50,

2371
01:26:44,299 --> 01:26:45,259
it is Pythonic,

2372
01:26:45,299 --> 01:26:46,729
that is Python convention,

2373
01:26:46,939 --> 01:26:50,069
to separate functions in your code by two lines,

2374
01:26:50,140 --> 01:26:52,060
whereas there is no such convention in C.

2375
01:26:52,189 --> 01:26:54,600
So I'm trying to be consistent with what the world does,

2376
01:26:54,859 --> 01:26:55,100
yeah.

2377
01:26:59,370 --> 01:27:00,950
If you want to count backwards in a loop,

2378
01:27:01,029 --> 01:27:01,799
can you do that?

2379
01:27:01,970 --> 01:27:02,470
Absolutely.

2380
01:27:02,589 --> 01:27:04,750
You could use the range function in a different way.

2381
01:27:04,910 --> 01:27:07,819
Start start with a much larger value and count down.

2382
01:27:08,189 --> 01:27:10,549
How but you can alternatively do that with a while loop.

2383
01:27:10,589 --> 01:27:11,830
I would say that yeah,

2384
01:27:11,910 --> 01:27:12,740
you can make that work,

2385
01:27:12,750 --> 01:27:13,540
but you shouldn't.

2386
01:27:13,609 --> 01:27:16,910
It's just people don't do that unless it does actually solve a problem for you.

2387
01:27:17,810 --> 01:27:18,919
Other questions on this.

2388
01:27:20,839 --> 01:27:21,040
All right,

2389
01:27:21,160 --> 01:27:21,240
well,

2390
01:27:21,319 --> 01:27:22,000
when we looked at C,

2391
01:27:22,029 --> 01:27:25,330
recall there was a bunch of things that ultimately like we couldn't do well.

2392
01:27:25,359 --> 01:27:27,959
We ran into issues of like full loading point precision and

2393
01:27:27,959 --> 01:27:31,870
integer overflow and truncation and like all of these world's problems.

2394
01:27:32,569 --> 01:27:32,580
Um,

2395
01:27:32,600 --> 01:27:33,549
there's still going to be some of those,

2396
01:27:33,600 --> 01:27:33,919
but first,

2397
01:27:33,959 --> 01:27:36,520
let's take a fruit by the foot brake and we'll be back in 10.

2398
01:27:36,629 --> 01:27:37,910
Help yourself to seconds today.

2399
01:27:38,919 --> 01:27:38,930
All

2400
01:27:39,870 --> 01:27:40,189
right,

2401
01:27:40,430 --> 01:27:41,060
so we're back,

2402
01:27:41,229 --> 01:27:44,629
and let's use our remaining time together to focus not only on

2403
01:27:44,629 --> 01:27:47,669
some of the problems that Python can solve more readily than C,

2404
01:27:47,750 --> 01:27:49,259
but also some of the problems that remain.

2405
01:27:49,390 --> 01:27:53,589
So here was a program early on in our discussion of C

2406
01:27:53,870 --> 01:27:56,589
that had this weird bug whereby when we implemented a

2407
01:27:56,589 --> 01:27:59,319
relatively simple calculator to divide two numbers x divide.

2408
01:27:59,683 --> 01:28:04,792
By we experienced what we called truncation at the time whereby 1 divided by 3

2409
01:28:05,002 --> 01:28:08,123
was curiously 0 and like something like 4 divided

2410
01:28:08,123 --> 01:28:12,442
by 3 was curiously 1 and we were losing everything

2411
01:28:12,442 --> 01:28:14,763
after the decimal point and this was true even if

2412
01:28:14,763 --> 01:28:19,913
we tried using floats because with truncation recall everything.

2413
01:28:20,065 --> 01:28:23,505
the decimal point with integer math is simply discarded.

2414
01:28:23,596 --> 01:28:25,255
So if you do in divided by in,

2415
01:28:25,436 --> 01:28:27,855
you're going to lose what is after the decimal point.

2416
01:28:27,945 --> 01:28:32,145
So let's take a look in Python at whether this is still actually a problem.

2417
01:28:32,255 --> 01:28:34,565
So let me go back into BS code here.

2418
01:28:34,735 --> 01:28:36,775
We'll close out the C version thereof,

2419
01:28:36,866 --> 01:28:40,375
and let's go ahead and create our own program called Calculator.i.

2420
01:28:40,866 --> 01:28:42,045
And in this version,

2421
01:28:42,175 --> 01:28:47,215
let's modify the original which just did some addition and instead have it do some.

2422
01:28:47,649 --> 01:28:48,729
Division instead.

2423
01:28:48,810 --> 01:28:54,529
I'll get rid of my outdated comments and perform now division instead of uh addition

2424
01:28:54,810 --> 01:28:56,600
by doing X divided by Y.

2425
01:28:56,750 --> 01:28:58,290
Python of calculator.pi,

2426
01:28:58,370 --> 01:29:00,560
let's try 1 and let's try 3.

2427
01:29:00,890 --> 01:29:01,600
And oh,

2428
01:29:01,839 --> 01:29:03,509
our fractions are actually back.

2429
01:29:03,640 --> 01:29:05,509
So it turns out in Python,

2430
01:29:05,580 --> 01:29:07,549
even when you're manipulating integers,

2431
01:29:07,580 --> 01:29:09,640
if you divide one by the other and the

2432
01:29:09,640 --> 01:29:12,509
result logically should actually be a floating point value,

2433
01:29:12,799 --> 01:29:14,839
that's what in fact you're going to get back

2434
01:29:14,839 --> 01:29:16,319
and you don't have to jump through the same hoops

2435
01:29:16,319 --> 01:29:18,879
that we did before to actually force things to float

2436
01:29:18,879 --> 01:29:21,069
and then do floating point arithmetic and so forth.

2437
01:29:21,279 --> 01:29:21,640
In fact,

2438
01:29:21,680 --> 01:29:22,962
if you Want the old behavior,

2439
01:29:23,002 --> 01:29:26,562
it's still actually there and you can use two slashes in Python to

2440
01:29:26,562 --> 01:29:29,672
use the old integer division as opposed to what we're seeing here.

2441
01:29:29,803 --> 01:29:31,083
But a typical programmer,

2442
01:29:31,123 --> 01:29:32,143
I dare say nowadays,

2443
01:29:32,283 --> 01:29:34,672
would want it to behave in exactly the same way.

2444
01:29:34,763 --> 01:29:37,312
So truncation seems to be less,

2445
01:29:37,362 --> 01:29:39,232
therefore of an issue for us.

2446
01:29:39,573 --> 01:29:39,683
All right,

2447
01:29:39,763 --> 01:29:39,873
well,

2448
01:29:39,922 --> 01:29:41,803
what other problems did we encounter at the time?

2449
01:29:41,882 --> 01:29:44,855
We'll recall we had issues of Floating point in precision

2450
01:29:45,286 --> 01:29:49,085
whereby even when we divided something simple like 1 divided by 3 and

2451
01:29:49,085 --> 01:29:50,366
in grade school we learned that was

2452
01:29:50,366 --> 01:29:53,916
like 0.3333333 repeating infinitely many times,

2453
01:29:53,965 --> 01:29:57,436
we started seeing weird numbers that were not 3 at the end of that

2454
01:29:57,686 --> 01:29:59,315
value back in the day and see

2455
01:29:59,766 --> 01:30:01,965
unfortunately that's a problem that's still with us.

2456
01:30:02,005 --> 01:30:02,326
In fact,

2457
01:30:02,405 --> 01:30:04,206
if I use this same program here.

2458
01:30:04,720 --> 01:30:09,220
Let me go into VS code and instead of printing out just X divided by Y,

2459
01:30:09,439 --> 01:30:11,040
let's go ahead and do this temporarily.

2460
01:30:11,100 --> 01:30:15,359
Let me give myself a variable called Z and set it equal to x divided by Y

2461
01:30:15,359 --> 01:30:19,390
only because it'll be a little easier to see the formatting trick I'm going to use.

2462
01:30:19,640 --> 01:30:23,020
Let's go ahead and print out a format string that prints out Z,

2463
01:30:23,240 --> 01:30:24,000
and for the moment,

2464
01:30:24,009 --> 01:30:26,240
let me just claim that this is going to do the exact same thing.

2465
01:30:26,319 --> 01:30:28,270
It's just completely gratuitous that I'm using an F

2466
01:30:28,270 --> 01:30:30,339
string now as opposed to just printing out Z,

2467
01:30:30,479 --> 01:30:32,819
but I do 1 divided by 3,

2468
01:30:33,029 --> 01:30:35,350
we're still seeing 0.333,

2469
01:30:35,430 --> 01:30:38,540
but we're only seeing just over 10 or so digits here.

2470
01:30:38,669 --> 01:30:40,430
What if we want to see like 50 digits

2471
01:30:40,430 --> 01:30:43,500
and really start poking around at what's being represented?

2472
01:30:43,669 --> 01:30:43,709
Well,

2473
01:30:43,750 --> 01:30:45,020
the syntax is a little weird,

2474
01:30:45,189 --> 01:30:47,399
but in Python using an F string,

2475
01:30:47,430 --> 01:30:51,979
you can do tricks similar to what we did with the percent F with print F and C.

2476
01:30:52,189 --> 01:30:55,990
And if after my variables name in this set of curly braces,

2477
01:30:56,029 --> 01:30:57,009
I do a colon.

2478
01:30:57,189 --> 01:31:01,339
And then a dot because I want to see numbers after the decimal point and say something

2479
01:31:01,339 --> 01:31:05,770
arbitrary like show me 50 digits after the decimal point and treat this as a float.

2480
01:31:06,020 --> 01:31:09,580
This is a crazy incantation I do think of a format string even

2481
01:31:09,580 --> 01:31:11,589
I am sort of cheating off of the paper in front of me,

2482
01:31:11,779 --> 01:31:16,089
but this is how you format strings if you want to see them with a little more

2483
01:31:16,339 --> 01:31:16,979
precision

2484
01:31:17,299 --> 01:31:21,540
or so I think if I rerun Python of calculator.ie and do 1 divided by 3,

2485
01:31:21,629 --> 01:31:22,330
darn it,

2486
01:31:22,609 --> 01:31:24,870
we're still in the same mess that we were before.

2487
01:31:24,939 --> 01:31:25,779
Now why is this?

2488
01:31:25,819 --> 01:31:25,899
Well,

2489
01:31:25,979 --> 01:31:26,339
it's still.

2490
01:31:26,439 --> 01:31:29,700
The case that I'm running the code on the same kinds of computers that I did before,

2491
01:31:29,910 --> 01:31:32,950
it's still the case that these computers only have a finite amount of memory.

2492
01:31:33,020 --> 01:31:36,169
And so even though I'm manipulating clearly floating point values,

2493
01:31:36,350 --> 01:31:37,990
Python is only allocating,

2494
01:31:38,069 --> 01:31:38,259
say,

2495
01:31:38,270 --> 01:31:41,779
64 bits to those float variables,

2496
01:31:41,790 --> 01:31:44,899
and so there's only so much precision that's possible.

2497
01:31:44,910 --> 01:31:48,589
And so what we're seeing is essentially the closest representation to

2498
01:31:48,589 --> 01:31:52,029
an infinite number of 3s that we can represent using binary,

2499
01:31:52,109 --> 01:31:54,609
using a floating point representation therein.

2500
01:31:54,790 --> 01:31:55,549
So still a problem.

2501
01:31:55,870 --> 01:32:00,160
But I do think in Python you'll find that there's so many more libraries out there,

2502
01:32:00,319 --> 01:32:03,759
third party software that comes not just with the language itself but from others,

2503
01:32:03,879 --> 01:32:07,759
whereby you can use libraries for more precise scientific computing that

2504
01:32:07,759 --> 01:32:10,799
essentially implement their own versions of floating point values so that

2505
01:32:10,799 --> 01:32:14,240
you can use not 64 but 128 or more bits than

2506
01:32:14,240 --> 01:32:18,109
that when it really matters to some level of precision.

2507
01:32:18,399 --> 01:32:19,149
Thankfully though,

2508
01:32:19,359 --> 01:32:21,000
one problem is at least solved for us,

2509
01:32:21,160 --> 01:32:22,620
namely integer overflow.

2510
01:32:22,689 --> 01:32:24,799
So recall that this was another problem we ran into.

2511
01:32:25,310 --> 01:32:28,549
Whereby if you try counting higher than say 4 billion or

2512
01:32:28,549 --> 01:32:31,379
even higher than 2 billion if you're representing negative numbers,

2513
01:32:31,390 --> 01:32:34,939
which haves the total range that you have available to you in the positive range,

2514
01:32:35,229 --> 01:32:38,399
we ran into the situation where it somehow wrapped around,

2515
01:32:38,470 --> 01:32:38,990
became negative,

2516
01:32:39,000 --> 01:32:41,299
and then even ended up being zero as a result.

2517
01:32:41,549 --> 01:32:41,669
Well,

2518
01:32:41,750 --> 01:32:46,270
Python wonderfully nowadays just gives you more and more bits.

2519
01:32:46,373 --> 01:32:49,612
As needed if your integers are getting larger and larger,

2520
01:32:49,683 --> 01:32:51,442
so this is a wonderful feature and that we've at

2521
01:32:51,442 --> 01:32:54,603
least addressed one fundamental limitation we ran into in C

2522
01:32:54,842 --> 01:32:58,473
and this time the language itself provides us a solution.

2523
01:32:58,723 --> 01:33:00,272
Python 2 has some pretty

2524
01:33:00,672 --> 01:33:02,292
handy features as well.

2525
01:33:02,442 --> 01:33:04,623
One of them is what are called exceptions,

2526
01:33:04,632 --> 01:33:07,482
and so an exception in Python is.

2527
01:33:07,585 --> 01:33:12,965
A way of handling error conditions without relying on return values alone.

2528
01:33:13,056 --> 01:33:16,605
So recall that and see if you ever wanted to signify that something went wrong,

2529
01:33:16,815 --> 01:33:19,295
you have to return like most recently like null,

2530
01:33:19,416 --> 01:33:20,226
N U L L,

2531
01:33:20,295 --> 01:33:21,925
which was a special sentinel value.

2532
01:33:22,096 --> 01:33:25,375
Technically it's just the zero address and by checking for that you can make

2533
01:33:25,375 --> 01:33:28,695
sure that you know if you're getting back a valid pointer or not.

2534
01:33:28,930 --> 01:33:30,180
And in other functions,

2535
01:33:30,240 --> 01:33:33,629
if something went wrong you might similarly have to check the return value,

2536
01:33:33,759 --> 01:33:37,470
maybe checking for 0 or -1 or 1 or something like that,

2537
01:33:37,600 --> 01:33:40,509
but return values were the only way in C

2538
01:33:40,759 --> 01:33:43,689
that functions could communicate back to the programmer

2539
01:33:43,839 --> 01:33:44,959
that something went wrong,

2540
01:33:45,040 --> 01:33:48,870
and this is problematic because if you imagine implementing a function

2541
01:33:49,279 --> 01:33:51,160
that's supposed to return maybe an integer,

2542
01:33:51,319 --> 01:33:52,040
whether positive,

2543
01:33:52,080 --> 01:33:52,439
negative,

2544
01:33:52,450 --> 01:33:53,040
or zero.

2545
01:33:53,390 --> 01:33:56,540
It's kind of unfortunate sometimes if you have to steal one of

2546
01:33:56,540 --> 01:33:59,290
those values and say uh uh you can't use this value.

2547
01:33:59,459 --> 01:34:01,939
It's fine in the world of pointers because the world decided

2548
01:34:01,939 --> 01:34:05,169
years ago we're never going to use the actual address OX0,

2549
01:34:05,220 --> 01:34:06,250
the zero address,

2550
01:34:06,419 --> 01:34:09,330
but that's still technically costing us one or more bytes of space.

2551
01:34:09,540 --> 01:34:11,100
But in general it's a bit annoying if

2552
01:34:11,100 --> 01:34:14,509
your function can't truly return all possible values.

2553
01:34:14,740 --> 01:34:16,220
Think about a function like get string.

2554
01:34:16,259 --> 01:34:17,850
If something went wrong in get string,

2555
01:34:18,120 --> 01:34:19,459
what do you want to return?

2556
01:34:19,540 --> 01:34:19,640
Well,

2557
01:34:19,770 --> 01:34:21,740
we saw in the CS 50.

2558
01:34:21,819 --> 01:34:24,959
Library we do in fact return null once we introduce that.

2559
01:34:25,450 --> 01:34:26,540
But in general,

2560
01:34:26,569 --> 01:34:29,819
wouldn't it be nice if functions could somehow signal out of band,

2561
01:34:29,890 --> 01:34:30,399
so to speak,

2562
01:34:30,450 --> 01:34:31,640
that something went wrong.

2563
01:34:31,850 --> 01:34:32,919
So by that I mean this.

2564
01:34:32,930 --> 01:34:37,200
Let's go into a new program that's inspired by one of our programs today,

2565
01:34:37,450 --> 01:34:40,189
and in VS code I'm going to go ahead and close my calculator,

2566
01:34:40,410 --> 01:34:41,479
open my terminal window,

2567
01:34:41,490 --> 01:34:43,629
and create a new program called Integer.i.

2568
01:34:44,009 --> 01:34:45,049
So in integer.ie,

2569
01:34:45,129 --> 01:34:48,080
let's just play around with some integers and see what we can break.

2570
01:34:48,250 --> 01:34:50,089
So here I'll define a variable.

2571
01:34:50,279 --> 01:34:53,589
And and set it equal to the input function which comes with Python,

2572
01:34:53,720 --> 01:34:55,790
just asking the human for some input.

2573
01:34:56,240 --> 01:34:58,109
Then I'm going to go ahead and ask a question.

2574
01:34:58,279 --> 01:35:00,919
Is the user's input numeric?

2575
01:35:00,930 --> 01:35:05,149
And it turns out if you read the documentation for strings in Python,

2576
01:35:05,359 --> 01:35:07,160
they come with not just an upper function,

2577
01:35:07,200 --> 01:35:08,080
a lower function,

2578
01:35:08,660 --> 01:35:09,319
aka methods,

2579
01:35:09,439 --> 01:35:12,560
but also it is numeric function or method that tells you

2580
01:35:12,560 --> 01:35:15,270
whether or not the string itself happens to be numeric.

2581
01:35:15,359 --> 01:35:15,649
That is,

2582
01:35:15,660 --> 01:35:16,589
looks like a number.

2583
01:35:16,910 --> 01:35:17,080
All right,

2584
01:35:17,160 --> 01:35:18,609
so I think if I do that.

2585
01:35:19,140 --> 01:35:20,740
I could then do something like this.

2586
01:35:20,819 --> 01:35:21,779
If N is numeric,

2587
01:35:21,859 --> 01:35:23,069
I'm gonna go ahead and claim

2588
01:35:23,339 --> 01:35:24,970
that in fact it is an integer.

2589
01:35:25,240 --> 01:35:26,509
Else if it's not numeric,

2590
01:35:26,580 --> 01:35:28,220
I'm going to claim that it's not an integer.

2591
01:35:28,299 --> 01:35:29,290
I have no idea what it is.

2592
01:35:29,339 --> 01:35:29,879
Maybe it's cat,

2593
01:35:29,979 --> 01:35:30,529
maybe it's dog,

2594
01:35:30,620 --> 01:35:32,450
maybe it's a mix of numbers and letters,

2595
01:35:32,540 --> 01:35:35,450
but it's definitely not an integer as defined by

2596
01:35:35,450 --> 01:35:37,640
a sequence of decimal digits in this case.

2597
01:35:37,930 --> 01:35:38,060
All right,

2598
01:35:38,100 --> 01:35:39,020
so let's try this out.

2599
01:35:39,140 --> 01:35:39,839
Python.

2600
01:35:41,140 --> 01:35:44,209
Of integer.pi enter we'll type in 1.

2601
01:35:44,410 --> 01:35:45,049
That's an integer.

2602
01:35:45,129 --> 01:35:45,930
We'll type in 2.

2603
01:35:46,049 --> 01:35:46,609
That's an integer.

2604
01:35:46,649 --> 01:35:47,370
We'll type in 0.

2605
01:35:47,490 --> 01:35:49,029
That's an integer type in cat,

2606
01:35:49,330 --> 01:35:50,169
not an integer.

2607
01:35:50,290 --> 01:35:52,279
So that seems to in fact work.

2608
01:35:52,729 --> 01:35:58,000
But what if I wanted to immediately convert this to an end as we did in the past?

2609
01:35:58,080 --> 01:35:59,330
And so let me modify this a.

2610
01:35:59,464 --> 01:36:00,225
Bit here

2611
01:36:00,455 --> 01:36:02,924
and say instead this N equals

2612
01:36:03,334 --> 01:36:04,845
not just input

2613
01:36:05,595 --> 01:36:07,575
sing the user for an integer

2614
01:36:07,854 --> 01:36:10,365
or rather let's just ask them more generally for input,

2615
01:36:10,575 --> 01:36:13,604
but let's assume that we want to convert this input

2616
01:36:13,604 --> 01:36:16,555
to an end and actually we can go ahead and say

2617
01:36:16,774 --> 01:36:17,685
integer here.

2618
01:36:18,299 --> 01:36:18,620
All right,

2619
01:36:18,779 --> 01:36:19,140
well,

2620
01:36:19,299 --> 01:36:22,060
here I'm going to go ahead and just print out the claim that yep,

2621
01:36:22,220 --> 01:36:24,979
this is an integer because if we get to line 2,

2622
01:36:25,180 --> 01:36:25,399
well,

2623
01:36:25,500 --> 01:36:28,290
clearly we've handled the user's input correctly.

2624
01:36:28,459 --> 01:36:29,169
In other words,

2625
01:36:29,339 --> 01:36:32,470
how can I get rid of constantly checking the return sorry,

2626
01:36:33,339 --> 01:36:36,459
how can I get away from constantly checking the return values

2627
01:36:36,459 --> 01:36:39,580
of functions to make sure it is what I expect?

2628
01:36:40,069 --> 01:36:40,339
All right,

2629
01:36:40,419 --> 01:36:40,540
well,

2630
01:36:40,580 --> 01:36:42,959
let's go ahead and run Python of integer.ie now.

2631
01:36:43,009 --> 01:36:43,379
Enter,

2632
01:36:43,500 --> 01:36:44,140
type in 1.

2633
01:36:44,459 --> 01:36:45,660
It tells me it's an integer.

2634
01:36:45,729 --> 01:36:46,250
Type in 2,

2635
01:36:46,370 --> 01:36:48,419
tells me it's an integer 0 tells me it's an integer.

2636
01:36:48,569 --> 01:36:49,520
Type in cat.

2637
01:36:49,890 --> 01:36:52,080
Notice this time what goes wrong.

2638
01:36:52,529 --> 01:36:56,009
Whereas last time we saw this kind of trace back error message,

2639
01:36:56,020 --> 01:37:00,160
it was a name error because I was using the meow function name too early.

2640
01:37:00,410 --> 01:37:01,879
Now I'm getting a value error,

2641
01:37:01,890 --> 01:37:03,930
which is a different type of error that relates

2642
01:37:03,930 --> 01:37:07,450
to invalid literal for in with base 10A.

2643
01:37:07,770 --> 01:37:08,609
Now that's a mouthful,

2644
01:37:08,770 --> 01:37:11,580
so unfortunately Python's error messages aren't all that much better than.

2645
01:37:12,117 --> 01:37:13,026
error messages,

2646
01:37:13,037 --> 01:37:13,466
but

2647
01:37:13,997 --> 01:37:14,546
clearly

2648
01:37:14,836 --> 01:37:16,997
the interpreter does not like the fact that I'm

2649
01:37:16,997 --> 01:37:20,637
passing something to in related to base 10,

2650
01:37:20,716 --> 01:37:23,077
but that's quote unquote CA and really the best you

2651
01:37:23,077 --> 01:37:24,747
can do with this kind of error is realize like,

2652
01:37:24,836 --> 01:37:25,276
OK,

2653
01:37:25,356 --> 01:37:28,026
it's clearly the case that cat is not an integer,

2654
01:37:28,157 --> 01:37:30,557
so it's having trouble converting cat to an integer.

2655
01:37:30,566 --> 01:37:31,986
It makes no logical sense.

2656
01:37:32,497 --> 01:37:32,637
All right,

2657
01:37:32,836 --> 01:37:34,586
so what's the gist of the problem?

2658
01:37:34,646 --> 01:37:34,727
Well,

2659
01:37:34,836 --> 01:37:37,046
I'm just blindly converting

2660
01:37:37,227 --> 01:37:39,077
the user's input to an integer.

2661
01:37:39,383 --> 01:37:41,193
Even if it's not input,

2662
01:37:41,664 --> 01:37:42,824
even if it's not an integer.

2663
01:37:42,914 --> 01:37:42,983
Well,

2664
01:37:43,104 --> 01:37:43,264
all right,

2665
01:37:43,344 --> 01:37:43,423
well,

2666
01:37:43,463 --> 01:37:45,344
I could rewind to the previous version of my function,

2667
01:37:45,463 --> 01:37:46,934
use the is numeric function,

2668
01:37:47,144 --> 01:37:48,624
and then conditionally convert it,

2669
01:37:48,664 --> 01:37:50,463
but I'm trying to move away from

2670
01:37:50,463 --> 01:37:53,213
constantly checking return values of error messages.

2671
01:37:53,224 --> 01:37:55,293
And wouldn't it be nice if I could somehow

2672
01:37:55,744 --> 01:37:58,293
catch this value error and just deal with it

2673
01:37:58,583 --> 01:37:59,733
if it happens?

2674
01:38:00,003 --> 01:38:05,344
And in fact you can with Python exceptions which exist in other languages as well,

2675
01:38:05,503 --> 01:38:06,383
Java among them.

2676
01:38:06,500 --> 01:38:10,351
You have the ability to sort of listen for errors happening

2677
01:38:10,351 --> 01:38:14,880
inside of functions without having to rely on return values alone.

2678
01:38:15,130 --> 01:38:16,690
So let me go back to VS code here,

2679
01:38:16,851 --> 01:38:18,980
clear my terminal just to simplify things a bit,

2680
01:38:19,210 --> 01:38:21,761
and let me literally say to the interpreter,

2681
01:38:22,011 --> 01:38:26,121
please try to execute the following two lines of code,

2682
01:38:26,761 --> 01:38:30,011
except if something goes wrong like a value error,

2683
01:38:30,250 --> 01:38:32,960
in which case go ahead and print out something like

2684
01:38:33,331 --> 01:38:33,980
not

2685
01:38:34,331 --> 01:38:34,971
integer.

2686
01:38:35,479 --> 01:38:39,109
So wouldn't it be nice if you could just wrap all of the code you've written in CS 50

2687
01:38:39,109 --> 01:38:41,229
thus far with try and sort of ask the

2688
01:38:41,229 --> 01:38:43,859
computer politely like please try to execute this code,

2689
01:38:44,029 --> 01:38:46,819
but that really is the semantics behind it.

2690
01:38:47,180 --> 01:38:50,100
Try to execute these lines of code except if there's an error,

2691
01:38:50,350 --> 01:38:52,140
then do this other thing instead

2692
01:38:52,390 --> 01:38:56,020
and therefore you don't have to check any return values.

2693
01:38:56,109 --> 01:38:59,549
You can just blindly pass the output of the input function.

2694
01:39:00,100 --> 01:39:02,000
As the input to the IT function

2695
01:39:02,419 --> 01:39:04,609
knowing that if something goes wrong inside of there,

2696
01:39:04,819 --> 01:39:08,129
Python is going to execute this code instead,

2697
01:39:08,419 --> 01:39:09,890
except when something goes wrong.

2698
01:39:10,100 --> 01:39:12,580
So let me go ahead and run Python of integer.ie now.

2699
01:39:12,620 --> 01:39:13,609
I'll type in one,

2700
01:39:13,859 --> 01:39:17,529
and that works because it's trying to execute line 2 and succeeding.

2701
01:39:17,580 --> 01:39:19,770
It's trying to execute line 3 and succeeding,

2702
01:39:19,939 --> 01:39:22,100
so lines 4 and 4 never actually kick in.

2703
01:39:22,399 --> 01:39:25,220
But if I try again here with cat,

2704
01:39:25,629 --> 01:39:27,540
line 2 is going to fail.

2705
01:39:28,009 --> 01:39:31,149
Li 3 is never going to get reached because Python

2706
01:39:31,149 --> 01:39:34,189
is immediately going to jump to this exception handler,

2707
01:39:34,390 --> 01:39:35,100
so to speak,

2708
01:39:35,310 --> 01:39:40,189
thereby catching the error or the exception and printing not integer instead.

2709
01:39:40,529 --> 01:39:42,569
So it's a little bit of a weird convention.

2710
01:39:42,640 --> 01:39:44,180
It's different from what C offers,

2711
01:39:44,259 --> 01:39:47,899
but a lot of newer languages nowadays do offer this because it's a better

2712
01:39:47,899 --> 01:39:52,169
way of just writing code that you know should work 99% of the time.

2713
01:39:52,259 --> 01:39:53,990
But if something does go wrong

2714
01:39:54,220 --> 01:39:55,060
out of memory,

2715
01:39:55,129 --> 01:39:57,649
the human types something wrong in or something like that,

2716
01:39:57,790 --> 01:40:00,419
you can handle all of those exceptional cases,

2717
01:40:00,459 --> 01:40:01,930
exceptional in a bad sense,

2718
01:40:02,299 --> 01:40:02,890
using

2719
01:40:03,339 --> 01:40:04,850
this accept keyword

2720
01:40:05,419 --> 01:40:05,930
instead.

2721
01:40:06,660 --> 01:40:07,819
Questions on.

2722
01:40:08,740 --> 01:40:10,279
Any of this here technique.

2723
01:40:12,750 --> 01:40:13,120
Yeah.

2724
01:40:18,759 --> 01:40:19,549
A really good question.

2725
01:40:19,560 --> 01:40:19,959
In this case,

2726
01:40:19,970 --> 01:40:21,120
I used a value error.

2727
01:40:21,200 --> 01:40:24,629
Do I need to define every possible thing that can go wrong?

2728
01:40:24,799 --> 01:40:25,799
Short answer yes.

2729
01:40:25,919 --> 01:40:27,520
Now there aren't terribly many.

2730
01:40:27,600 --> 01:40:30,390
There's some standard ones and they're all capitalized in this way,

2731
01:40:30,399 --> 01:40:30,930
capital letter,

2732
01:40:30,959 --> 01:40:31,479
capital letter,

2733
01:40:31,520 --> 01:40:34,229
something error typically you can even invent your own,

2734
01:40:34,839 --> 01:40:38,629
and it's good practice to enumerate the kinds of things that you think can go wrong.

2735
01:40:38,729 --> 01:40:39,689
Value error is pretty.

2736
01:40:39,746 --> 01:40:40,155
Generic,

2737
01:40:40,416 --> 01:40:41,866
but there could be memory related errors.

2738
01:40:41,936 --> 01:40:43,686
There could be file not found related errors.

2739
01:40:43,735 --> 01:40:45,536
There's a bunch of different exceptions that are all

2740
01:40:45,536 --> 01:40:47,925
documented in Python that you can listen for.

2741
01:40:48,215 --> 01:40:48,806
That said,

2742
01:40:48,936 --> 01:40:51,965
as nice as Python's documentation is overall,

2743
01:40:52,375 --> 01:40:55,735
it is not good at documenting four specific functions,

2744
01:40:55,855 --> 01:40:57,416
what exceptions they can throw,

2745
01:40:57,425 --> 01:41:00,695
and I've never understood this after all of these years that no human has gone.

2746
01:41:00,841 --> 01:41:03,671
The documentation and painstakingly enumerated all of

2747
01:41:03,671 --> 01:41:05,301
the possible things that can go wrong.

2748
01:41:05,551 --> 01:41:08,421
What's too often the case in the real world with some of my own code

2749
01:41:08,421 --> 01:41:12,222
included is if you encounter an exception that you didn't think was going to happen,

2750
01:41:12,512 --> 01:41:16,312
you go in and improve your code and add to this list of accept clauses.

2751
01:41:16,352 --> 01:41:17,702
What else might go wrong?

2752
01:41:17,972 --> 01:41:18,861
It shouldn't be that way,

2753
01:41:18,872 --> 01:41:21,791
and different libraries are better about documenting these things.

2754
01:41:23,259 --> 01:41:23,819
All right,

2755
01:41:24,060 --> 01:41:24,410
well,

2756
01:41:24,580 --> 01:41:25,649
with that in mind,

2757
01:41:25,859 --> 01:41:29,009
let me propose that in the CS 50 library for Python,

2758
01:41:29,140 --> 01:41:30,540
get in and get float,

2759
01:41:30,689 --> 01:41:32,140
they work just like the C library,

2760
01:41:32,160 --> 01:41:35,129
whereby if you type in cat or dog or bird into those functions,

2761
01:41:35,299 --> 01:41:36,220
they just reprompt you.

2762
01:41:36,279 --> 01:41:37,290
They just reprompt you.

2763
01:41:37,459 --> 01:41:38,339
And long story short,

2764
01:41:38,399 --> 01:41:40,740
this is the kind of code we wrote in Python.

2765
01:41:40,750 --> 01:41:42,259
Try to get input from the user,

2766
01:41:42,299 --> 01:41:43,729
except if something goes wrong,

2767
01:41:44,100 --> 01:41:44,970
prompt them again,

2768
01:41:45,180 --> 01:41:45,890
prompt them again.

2769
01:41:46,060 --> 01:41:48,339
So we too are using precisely these features even though

2770
01:41:48,339 --> 01:41:51,330
it wasn't something that was available to us in C.

2771
01:41:52,129 --> 01:41:52,370
All right,

2772
01:41:52,450 --> 01:41:54,120
but something else that we didn't see was play

2773
01:41:54,120 --> 01:41:55,609
around with Mario in a few different forms.

2774
01:41:55,649 --> 01:41:57,240
And in Lecture recall a few weeks back,

2775
01:41:57,330 --> 01:41:59,490
we experimented with like using some Asky arts,

2776
01:41:59,569 --> 01:42:03,490
some very simple text to print out something like this pyramid of height 3.

2777
01:42:03,529 --> 01:42:03,609
Well,

2778
01:42:03,689 --> 01:42:06,009
how can we go about printing something like this?

2779
01:42:06,169 --> 01:42:06,330
Well,

2780
01:42:06,450 --> 01:42:08,609
I would propose that if I go back to BS code here,

2781
01:42:08,689 --> 01:42:10,330
let's close out my integer examples,

2782
01:42:10,490 --> 01:42:13,080
code up a new version of Mario and Mario.ie.

2783
01:42:13,490 --> 01:42:14,520
This one's kind of simple.

2784
01:42:14,600 --> 01:42:17,859
I can say something like 4 I in range of 3,

2785
01:42:17,930 --> 01:42:19,000
go ahead and print out,

2786
01:42:19,009 --> 01:42:21,609
quote unquote a hash down in my terminal window.

2787
01:42:21,854 --> 01:42:25,125
Python of Mario.3 and I've got really the closest analog to

2788
01:42:25,125 --> 01:42:28,725
3 bricks stacked on top of each other in this way.

2789
01:42:29,254 --> 01:42:29,685
But

2790
01:42:29,935 --> 01:42:35,055
in C and eventually our implementation of Mario started to get a little fancy,

2791
01:42:35,095 --> 01:42:39,165
and we started to prompt the user for the height of the of the wall

2792
01:42:39,455 --> 01:42:43,845
and therefore we could have not just 3 but maybe 4 or even more bricks being printed.

2793
01:42:44,055 --> 01:42:47,964
So let me actually open up that version from a few weeks back

2794
01:42:48,294 --> 01:42:51,325
whereby from week 1 we had a version of Mario.

2795
01:42:51,939 --> 01:42:53,410
That looked like

2796
01:42:53,660 --> 01:42:54,370
this

2797
01:42:54,939 --> 01:42:55,609
whereby

2798
01:42:55,859 --> 01:42:58,129
we after including some header files,

2799
01:42:58,379 --> 01:43:00,580
declared in main a variable called N.

2800
01:43:00,839 --> 01:43:03,209
Then we saw a new construct at the time,

2801
01:43:03,259 --> 01:43:05,500
a do while loop that just keeps using get in,

2802
01:43:05,580 --> 01:43:05,899
get in,

2803
01:43:05,939 --> 01:43:06,370
get in,

2804
01:43:06,419 --> 01:43:07,970
so long as n is not

2805
01:43:08,979 --> 01:43:10,129
1 or greater.

2806
01:43:10,689 --> 01:43:11,169
Equivalently,

2807
01:43:11,250 --> 01:43:12,839
so long as n is less than 1

2808
01:43:13,089 --> 01:43:14,799
and kept prompting the user again and again,

2809
01:43:14,930 --> 01:43:17,520
the reason for having N up here recall was issues of scope.

2810
01:43:17,729 --> 01:43:20,450
This therefore it's accessible lower in the function as

2811
01:43:20,450 --> 01:43:22,580
opposed to it being confined to those curly braces.

2812
01:43:22,729 --> 01:43:26,109
And then down here we used a 4 loop to actually print out that many hashes.

2813
01:43:26,250 --> 01:43:27,120
So in short,

2814
01:43:27,410 --> 01:43:29,850
the do while loop solve the problem in C,

2815
01:43:29,930 --> 01:43:32,919
whereby you want to get user input at least once

2816
01:43:33,149 --> 01:43:36,609
and maybe again and again and again if they don't cooperate the first time.

2817
01:43:36,734 --> 01:43:38,604
And that's where do wild loops really shine.

2818
01:43:38,685 --> 01:43:41,165
Do something at least once and maybe again,

2819
01:43:41,254 --> 01:43:42,115
again and again.

2820
01:43:42,325 --> 01:43:46,205
Otherwise it's a little more annoying to do it with wild loops or 4 loops.

2821
01:43:46,325 --> 01:43:47,274
Unfortunately,

2822
01:43:47,484 --> 01:43:50,475
Python does not offer a do while loop.

2823
01:43:50,645 --> 01:43:52,805
And so here too we have an opportunity to

2824
01:43:52,805 --> 01:43:54,875
introduce you to what the world would call Pythonic.

2825
01:43:55,125 --> 01:43:57,475
What is Python's solution there too?

2826
01:43:57,685 --> 01:43:57,725
Well,

2827
01:43:57,765 --> 01:44:00,115
on the right hand side here in Mario.ie,

2828
01:44:00,245 --> 01:44:01,634
let's change this a little bit

2829
01:44:01,765 --> 01:44:02,995
and let's do from,

2830
01:44:03,524 --> 01:44:03,834
uh,

2831
01:44:03,845 --> 01:44:06,165
let's go ahead and do.

2832
01:44:06,640 --> 01:44:07,040
Uh,

2833
01:44:07,120 --> 01:44:07,470
while,

2834
01:44:07,839 --> 01:44:08,270
whoops,

2835
01:44:08,520 --> 01:44:09,490
while true,

2836
01:44:09,779 --> 01:44:10,540
capital T,

2837
01:44:10,959 --> 01:44:12,729
go ahead and use a variable N,

2838
01:44:12,919 --> 01:44:14,689
set it equal to in

2839
01:44:15,080 --> 01:44:15,790
input.

2840
01:44:16,629 --> 01:44:17,240
Height

2841
01:44:17,549 --> 01:44:19,779
asking the human for the height of the wall,

2842
01:44:19,990 --> 01:44:22,229
and I'm going to just cross my fingers that they're not going to type

2843
01:44:22,229 --> 01:44:24,859
in cat or dog or something that's not an in in this case.

2844
01:44:25,029 --> 01:44:26,620
I'm going to say if N

2845
01:44:26,910 --> 01:44:28,240
is greater than 0,

2846
01:44:28,350 --> 01:44:30,109
that is a positive number that's useful,

2847
01:44:30,120 --> 01:44:30,979
we can proceed.

2848
01:44:31,149 --> 01:44:33,370
I'm going to now break out of this loop

2849
01:44:33,589 --> 01:44:37,459
and then lower in the file I'm going to say for I in range of N,

2850
01:44:37,830 --> 01:44:38,509
go ahead and print.

2851
01:44:38,615 --> 01:44:40,044
Out the hashes.

2852
01:44:40,245 --> 01:44:42,205
So we still have that same lesson as before

2853
01:44:42,205 --> 01:44:44,225
like the Python version seems to be shorter,

2854
01:44:44,325 --> 01:44:44,884
more concise,

2855
01:44:44,924 --> 01:44:46,995
even if you ignore the comments on the left hand side,

2856
01:44:47,075 --> 01:44:49,794
and I've completely avoided using a do while loop,

2857
01:44:50,044 --> 01:44:52,075
but there are a few things that are different

2858
01:44:52,075 --> 01:44:56,274
nonetheless that feel like versus C shouldn't even work.

2859
01:44:56,564 --> 01:44:58,615
Like what's weird about this solution,

2860
01:44:58,625 --> 01:45:00,645
even though I think it's actually correct.

2861
01:45:03,180 --> 01:45:03,649
Yeah.

2862
01:45:05,660 --> 01:45:06,830
I have 2.

2863
01:45:09,060 --> 01:45:09,379
OK,

2864
01:45:09,580 --> 01:45:10,850
so it's not correct.

2865
01:45:11,009 --> 01:45:12,899
That's one of the first things to point out.

2866
01:45:13,180 --> 01:45:17,609
So too many prepositions for this was supposed to say for I in range.

2867
01:45:17,859 --> 01:45:18,299
OK,

2868
01:45:18,580 --> 01:45:20,410
so now that this program is correct,

2869
01:45:20,620 --> 01:45:21,049
what

2870
01:45:21,299 --> 01:45:24,020
looks weird to you and probably could break it,

2871
01:45:24,060 --> 01:45:24,339
yeah.

2872
01:45:27,100 --> 01:45:27,490
Yeah,

2873
01:45:27,660 --> 01:45:29,250
so the N variable should be,

2874
01:45:29,379 --> 01:45:31,259
it seems to be scoped to the Y loop,

2875
01:45:31,339 --> 01:45:33,540
at least insofar as it's indented inside the Y loop,

2876
01:45:33,580 --> 01:45:36,490
which feels analogous to being inside of curly braces and C.

2877
01:45:36,740 --> 01:45:39,779
And so it seems weird that I'm presuming to use N on

2878
01:45:39,779 --> 01:45:42,979
line 6 even though it was only defined on line 2.

2879
01:45:43,330 --> 01:45:46,069
It turns out this is possible in Python.

2880
01:45:46,089 --> 01:45:51,779
The issue of scope that we encountered in C is not as rigorously enforced,

2881
01:45:51,919 --> 01:45:52,950
we'll say for today,

2882
01:45:53,240 --> 01:45:57,270
such that when you define N up here you can actually use it down here

2883
01:45:57,479 --> 01:46:01,109
and you can think of this as being a little reasonable because if there's no more

2884
01:46:01,810 --> 01:46:02,080
specific.

2885
01:46:02,169 --> 01:46:04,830
of what data type N is and no more semicolon,

2886
01:46:05,080 --> 01:46:07,680
just imagine it would look kind of stupid if you just put a

2887
01:46:07,680 --> 01:46:11,000
blank end there and hit enter just so it kind of exists.

2888
01:46:11,120 --> 01:46:13,040
There's no way to express the idea of create this

2889
01:46:13,040 --> 01:46:15,839
variable in advance without actually assigning it a value,

2890
01:46:15,879 --> 01:46:17,240
whereas in C we could do that.

2891
01:46:17,279 --> 01:46:17,819
So this

2892
01:46:18,080 --> 01:46:19,950
is in fact OK

2893
01:46:20,160 --> 01:46:21,049
and correct.

2894
01:46:21,560 --> 01:46:22,560
What else is going on here?

2895
01:46:22,680 --> 01:46:22,759
Well,

2896
01:46:23,000 --> 01:46:25,879
instead of a do while we're kind of just implementing the idea of it.

2897
01:46:25,919 --> 01:46:28,040
I'm just blindly inducing deliberately in infinite

2898
01:46:28,040 --> 01:46:29,879
loop like do the following forever.

2899
01:46:30,209 --> 01:46:32,200
But then as soon as I have the answer I want,

2900
01:46:32,250 --> 01:46:34,080
like a positive integer from the human,

2901
01:46:34,410 --> 01:46:35,370
break out of this loop,

2902
01:46:35,450 --> 01:46:37,439
and this is indeed the Pythonic way

2903
01:46:37,689 --> 01:46:41,689
to say get user input because this will minimally ask the user for a height once

2904
01:46:41,970 --> 01:46:42,850
and maybe

2905
01:46:43,250 --> 01:46:44,569
more and more times.

2906
01:46:45,189 --> 01:46:46,259
So no do while loops,

2907
01:46:46,339 --> 01:46:47,700
only while loops and 4 loops,

2908
01:46:47,779 --> 01:46:50,250
and only while loops are really the same as in C.

2909
01:46:50,390 --> 01:46:51,729
Even 4 loops we've seen

2910
01:46:52,060 --> 01:46:53,049
are a bit different.

2911
01:46:53,459 --> 01:46:53,740
All right,

2912
01:46:53,819 --> 01:46:53,979
well,

2913
01:46:54,020 --> 01:46:55,700
how about instead of just that Mario example,

2914
01:46:56,819 --> 01:47:01,459
recall this one where we wanted to print like 4 question marks in the sky side by side.

2915
01:47:01,580 --> 01:47:02,890
We can do this in a few different ways.

2916
01:47:02,970 --> 01:47:04,100
Let me go back to VS code,

2917
01:47:04,250 --> 01:47:05,169
close the C version,

2918
01:47:05,180 --> 01:47:07,850
and let's just completely change Mario.ie to implement this now.

2919
01:47:07,970 --> 01:47:10,080
I want 4 question marks in the sky,

2920
01:47:10,290 --> 01:47:12,319
so I think I can do something like 4 I

2921
01:47:12,720 --> 01:47:14,600
in range of 4.

2922
01:47:14,910 --> 01:47:17,770
Go ahead and just print out quote unquote question mark.

2923
01:47:18,509 --> 01:47:19,649
Do you like this

2924
01:47:19,839 --> 01:47:20,720
Python?

2925
01:47:21,509 --> 01:47:23,140
Of Mario.ie,

2926
01:47:23,470 --> 01:47:24,299
Should I run it?

2927
01:47:24,549 --> 01:47:24,779
No.

2928
01:47:24,910 --> 01:47:25,419
why?

2929
01:47:27,529 --> 01:47:28,609
This is how I did it in C,

2930
01:47:28,720 --> 01:47:29,000
yeah.

2931
01:47:32,100 --> 01:47:32,370
Yeah,

2932
01:47:32,490 --> 01:47:34,879
I've got to edit the end value,

2933
01:47:34,970 --> 01:47:37,129
the named parameter for the print function,

2934
01:47:37,169 --> 01:47:39,649
because otherwise if I hit enter they're all on different lines,

2935
01:47:39,729 --> 01:47:42,370
which is not the effect I want when all four

2936
01:47:42,370 --> 01:47:44,379
question marks are meant to be side by side.

2937
01:47:44,640 --> 01:47:44,689
All right,

2938
01:47:44,790 --> 01:47:44,879
well,

2939
01:47:44,890 --> 01:47:45,649
that's an easy fix.

2940
01:47:45,729 --> 01:47:49,319
I can pass the named parameter called and into the print function,

2941
01:47:49,490 --> 01:47:53,100
set it equal to quote unquote with double quotes or with single quotes,

2942
01:47:53,129 --> 01:47:54,970
as always stylistically I would be consistent.

2943
01:47:55,009 --> 01:47:56,169
So I'm going to use double quotes even

2944
01:47:56,169 --> 01:47:58,330
though the documentation is consistent with its single.

2945
01:47:58,470 --> 01:47:58,850
Quotes.

2946
01:47:59,100 --> 01:48:02,100
Now I'm going to rerun Mario of Python Mario.ie,

2947
01:48:02,419 --> 01:48:04,259
and I'm so close now they're on the same line,

2948
01:48:04,299 --> 01:48:06,379
but the stupid cursor didn't move to the next line.

2949
01:48:06,500 --> 01:48:07,169
That's fine.

2950
01:48:07,379 --> 01:48:08,180
How to fix this?

2951
01:48:08,250 --> 01:48:08,339
Well,

2952
01:48:08,500 --> 01:48:09,319
just logically,

2953
01:48:09,540 --> 01:48:11,529
I can put a blank print statement below,

2954
01:48:11,620 --> 01:48:13,490
and even though I'm not passing anything in,

2955
01:48:13,700 --> 01:48:16,490
you get a new line for free when calling print.

2956
01:48:16,729 --> 01:48:17,180
So

2957
01:48:17,459 --> 01:48:19,419
even though I'm not passing in any arguments,

2958
01:48:19,569 --> 01:48:21,970
I am getting the aesthetic effect that I want.

2959
01:48:22,040 --> 01:48:23,850
So that is a perfectly reasonable way

2960
01:48:24,140 --> 01:48:24,660
to do it.

2961
01:48:25,279 --> 01:48:27,120
Now if you feel yourself becoming a bit of a

2962
01:48:27,120 --> 01:48:30,790
geek though in learning about Python and previously see,

2963
01:48:31,000 --> 01:48:35,189
you can even solve this problem even more pythonically by saying print,

2964
01:48:35,520 --> 01:48:38,870
quote unquote question mark 4

2965
01:48:39,279 --> 01:48:43,169
using multiplications similar in spirit to the plus operator for concatenation

2966
01:48:43,169 --> 01:48:47,479
and now multiply the exclamation point by itself 4 times.

2967
01:48:47,564 --> 01:48:49,714
So now if I go down here and run Python of Mara.

2968
01:48:49,995 --> 01:48:50,194
i,

2969
01:48:50,205 --> 01:48:54,305
I got a very elegant solution to exactly that same problem

2970
01:48:54,555 --> 01:48:56,265
even more concisely

2971
01:48:56,475 --> 01:48:57,674
than my previous version.

2972
01:48:57,875 --> 01:48:59,685
What if I want to do something in two dimensions?

2973
01:48:59,754 --> 01:49:02,555
We'll recall that we moved to the underground of Mario Brothers here

2974
01:49:02,555 --> 01:49:05,104
and we had like a 3 by 3 grid of bricks.

2975
01:49:05,314 --> 01:49:05,955
How can we do that?

2976
01:49:06,095 --> 01:49:06,154
Well,

2977
01:49:06,354 --> 01:49:06,475
see,

2978
01:49:06,595 --> 01:49:09,875
we had nested 4 loops using I and J back in the day.

2979
01:49:10,359 --> 01:49:12,180
And I can do the same thing in Python.

2980
01:49:12,350 --> 01:49:13,979
Let me go back into VS code here

2981
01:49:14,149 --> 01:49:17,740
and let me do one outer loop for I in range of 3.

2982
01:49:18,069 --> 01:49:21,899
Then let me do an inner loop for J in range of 3.

2983
01:49:22,149 --> 01:49:24,669
Then let me go ahead and print out a hash,

2984
01:49:24,870 --> 01:49:27,229
but let me learn from my past mistakes.

2985
01:49:27,430 --> 01:49:29,799
I don't want to print out a new line every time,

2986
01:49:29,870 --> 01:49:30,500
so let's

2987
01:49:30,790 --> 01:49:32,060
override that default.

2988
01:49:32,229 --> 01:49:33,850
But after each row,

2989
01:49:33,950 --> 01:49:37,939
let's print a new line so that down here I can go and Mario.ie,

2990
01:49:38,029 --> 01:49:38,439
run it,

2991
01:49:38,549 --> 01:49:39,870
and I've got my 3 by 3.

2992
01:49:40,163 --> 01:49:40,803
of bricks.

2993
01:49:40,922 --> 01:49:44,272
I could change this a little bit and call this row

2994
01:49:44,562 --> 01:49:45,522
and column,

2995
01:49:45,643 --> 01:49:46,643
even though here too,

2996
01:49:46,683 --> 01:49:50,632
even more so I'm not literally using row and column anywhere explicitly,

2997
01:49:50,683 --> 01:49:51,073
but

2998
01:49:51,243 --> 01:49:53,522
semantically it kind of explains maybe a

2999
01:49:53,522 --> 01:49:56,112
little clearer to the reader what's actually

3000
01:49:56,323 --> 01:49:57,103
going on.

3001
01:49:57,323 --> 01:49:58,192
So that might help,

3002
01:49:58,402 --> 01:50:00,112
but we can tighten this up too,

3003
01:50:00,323 --> 01:50:00,473
right,

3004
01:50:00,482 --> 01:50:01,962
if I just want to print a 3 by 3.

3005
01:50:02,235 --> 01:50:02,246
Well,

3006
01:50:02,715 --> 01:50:05,545
I know that the top thing here will iterate 3 times,

3007
01:50:05,755 --> 01:50:08,675
and I know how to very elegantly print things out with a one liner,

3008
01:50:08,715 --> 01:50:11,746
so I could just print out a hash times 3 in this case.

3009
01:50:11,996 --> 01:50:15,116
And then down here I can go to Pythonomaiodai and voila,

3010
01:50:15,395 --> 01:50:16,516
I'm back in business too.

3011
01:50:16,636 --> 01:50:18,355
So it's just sort of easier to do these kinds

3012
01:50:18,355 --> 01:50:21,025
of things and express yourself all the more succinctly.

3013
01:50:21,275 --> 01:50:21,386
Well,

3014
01:50:21,636 --> 01:50:22,436
what else can we do?

3015
01:50:22,516 --> 01:50:22,565
Well,

3016
01:50:22,596 --> 01:50:24,036
it turns out in Python.

3017
01:50:24,609 --> 01:50:26,479
That unlike arrays,

3018
01:50:26,490 --> 01:50:29,359
you can ask lists how long they are,

3019
01:50:29,529 --> 01:50:32,799
so you don't have to keep around a variable of how large an array is.

3020
01:50:32,810 --> 01:50:36,729
You can just add stuff to a list and then ask Python how long is this list,

3021
01:50:36,810 --> 01:50:38,080
how many elements are in it.

3022
01:50:38,290 --> 01:50:38,930
Case in point,

3023
01:50:39,009 --> 01:50:41,799
let me go back to BS code and clear out Mario.ie

3024
01:50:41,799 --> 01:50:45,560
and let's reimplement from a few weeks back the notion of calculating

3025
01:50:45,939 --> 01:50:49,000
like in the average quiz score that you might have in a class.

3026
01:50:49,100 --> 01:50:50,169
So in score.ie,

3027
01:50:50,729 --> 01:50:53,089
Let's go ahead and create a program that's got a list

3028
01:50:53,089 --> 01:50:55,970
called scores of three scores that we've seen before 72,

3029
01:50:56,049 --> 01:50:56,490
73,

3030
01:50:56,569 --> 01:50:57,509
and 33

3031
01:50:57,649 --> 01:51:00,649
and recall that we tried a few weeks back and see to average these together.

3032
01:51:00,689 --> 01:51:01,419
And to do that,

3033
01:51:01,649 --> 01:51:02,959
we had to add them all together.

3034
01:51:03,049 --> 01:51:06,189
We had to divide by the total number of elements in the list.

3035
01:51:06,370 --> 01:51:07,080
It wasn't that hard.

3036
01:51:07,169 --> 01:51:10,729
It was sort of like grade school arithmetic to calculate an average.

3037
01:51:10,913 --> 01:51:13,183
But Python has more functions available to us,

3038
01:51:13,263 --> 01:51:14,172
not just length,

3039
01:51:14,342 --> 01:51:15,573
but even summation.

3040
01:51:15,783 --> 01:51:17,152
So let me go ahead and do this.

3041
01:51:17,382 --> 01:51:20,522
Let me say that my average variable shall be

3042
01:51:20,772 --> 01:51:21,692
the sum

3043
01:51:21,973 --> 01:51:25,933
of those scores divided by the length of those scores.

3044
01:51:26,022 --> 01:51:27,663
And indeed per the documentation,

3045
01:51:27,743 --> 01:51:29,152
Python has a lang function,

3046
01:51:29,223 --> 01:51:30,143
LEN for short,

3047
01:51:30,382 --> 01:51:31,062
a sum function.

3048
01:51:31,246 --> 01:51:35,465
In which takes the which adds together all of the elements in that list.

3049
01:51:35,636 --> 01:51:38,186
And so down here now I can say something like print

3050
01:51:38,186 --> 01:51:41,306
with an F string or format string that the average is

3051
01:51:41,596 --> 01:51:44,956
whatever that value is and I don't have to do any loops or math myself.

3052
01:51:45,036 --> 01:51:49,516
I can just call the function like I could in Excel or Google Sheets or Apple Numbers,

3053
01:51:49,556 --> 01:51:51,195
Python of score.ie.

3054
01:51:51,890 --> 01:51:55,279
Enter and my average is in fact 59.3333 and

3055
01:51:55,279 --> 01:51:58,189
then some weird imprecision at the end there.

3056
01:51:58,359 --> 01:52:00,399
And in fact just for consistency with our C code,

3057
01:52:00,479 --> 01:52:01,390
let me rename this.

3058
01:52:01,589 --> 01:52:04,270
I'm going to rename score to scores plural.

3059
01:52:04,359 --> 01:52:05,350
That's going to close the window,

3060
01:52:05,379 --> 01:52:09,149
but now at least you'll see online that we have a program indeed called Scores.

3061
01:52:09,399 --> 01:52:09,520
Well,

3062
01:52:09,680 --> 01:52:12,520
this is not that interesting because I've just hard coded my 72,

3063
01:52:12,600 --> 01:52:13,109
my 73,

3064
01:52:13,120 --> 01:52:13,600
and 33.

3065
01:52:13,680 --> 01:52:15,830
What if we want the human to be able to type that in?

3066
01:52:16,040 --> 01:52:16,279
Well,

3067
01:52:16,399 --> 01:52:17,640
I think we can do that too.

3068
01:52:17,759 --> 01:52:19,160
So let me actually open up.

3069
01:52:19,540 --> 01:52:22,009
That version of the file now pluralized.

3070
01:52:22,259 --> 01:52:26,270
Let me go ahead and not initialize the list for the human,

3071
01:52:26,459 --> 01:52:28,410
but let me set it equal to an empty list

3072
01:52:28,410 --> 01:52:31,109
just using an open square bracket and closed square bracket

3073
01:52:31,379 --> 01:52:33,049
like an array that has nothing in it,

3074
01:52:33,100 --> 01:52:35,569
but this one is literally a size 0 at the moment.

3075
01:52:35,750 --> 01:52:38,330
And now let me do 4 I in range of

3076
01:52:38,500 --> 01:52:41,339
let's just for now ask the user for 3 scores,

3077
01:52:41,350 --> 01:52:44,490
even though we could certainly ask the user how many scores do they want to input

3078
01:52:44,740 --> 01:52:46,620
and then use that number instead.

3079
01:52:47,000 --> 01:52:48,830
So in each of these iterations,

3080
01:52:48,910 --> 01:52:52,870
let's ask the user for a score using something like in

3081
01:52:53,189 --> 01:52:54,740
input score.

3082
01:52:55,109 --> 01:52:58,540
I'm going to set aside the reality that if the user types in cat or dog,

3083
01:52:58,629 --> 01:53:00,310
the whole thing's going to break and therefore I

3084
01:53:00,310 --> 01:53:02,240
should really add my try and my accept,

3085
01:53:02,270 --> 01:53:04,700
but I'm going to discard that error checking and focus

3086
01:53:04,700 --> 01:53:06,750
only on the essence of this program for now.

3087
01:53:07,500 --> 01:53:08,580
Now after line 3,

3088
01:53:08,620 --> 01:53:10,149
if I have in a score variable,

3089
01:53:10,379 --> 01:53:12,009
the user's quiz score,

3090
01:53:12,220 --> 01:53:14,370
how do I put it into that array?

3091
01:53:14,620 --> 01:53:14,839
Well,

3092
01:53:14,979 --> 01:53:16,009
in in that list,

3093
01:53:16,100 --> 01:53:16,180
well,

3094
01:53:16,259 --> 01:53:18,459
with an array I had to use the square bracket notation,

3095
01:53:18,620 --> 01:53:19,850
keep track of how big it is,

3096
01:53:19,859 --> 01:53:21,970
and use like bracket I or something like that.

3097
01:53:22,299 --> 01:53:23,970
No longer in Python

3098
01:53:24,459 --> 01:53:25,569
because a

3099
01:53:26,080 --> 01:53:26,089
A

3100
01:53:27,049 --> 01:53:27,589
list

3101
01:53:27,830 --> 01:53:28,859
is an object

3102
01:53:29,020 --> 01:53:31,029
that has not only data but functions,

3103
01:53:31,370 --> 01:53:32,859
aka methods associated with it.

3104
01:53:33,149 --> 01:53:34,879
I can just call a method

3105
01:53:35,109 --> 01:53:37,790
that comes with every Python list called a pan.

3106
01:53:38,189 --> 01:53:42,370
And pass in that score using that same dot notation as before.

3107
01:53:42,580 --> 01:53:45,069
The rest of my code can stay exactly the same.

3108
01:53:45,259 --> 01:53:49,569
If I now run Python of scores.ie and I type in 72,

3109
01:53:49,729 --> 01:53:50,640
73,

3110
01:53:50,660 --> 01:53:51,899
33

3111
01:53:52,060 --> 01:53:52,970
manually though,

3112
01:53:53,180 --> 01:53:58,049
I still get that same average and notice I did not need to decide in advance how big

3113
01:53:58,339 --> 01:54:01,209
that list of scores was going to be.

3114
01:54:01,700 --> 01:54:03,049
Questions on

3115
01:54:03,459 --> 01:54:04,609
what we've just done

3116
01:54:04,899 --> 01:54:05,939
with lists.

3117
01:54:08,200 --> 01:54:08,500
No.

3118
01:54:08,669 --> 01:54:08,839
All right,

3119
01:54:08,959 --> 01:54:12,279
even cooler for some definition of cool is that we

3120
01:54:12,279 --> 01:54:16,259
can now implement hash tables or more generically dictionaries,

3121
01:54:16,270 --> 01:54:20,399
sets of key value pairs by just using a data type that comes with Python.

3122
01:54:20,439 --> 01:54:22,100
I claimed last week that like Python,

3123
01:54:22,520 --> 01:54:24,520
the dictionaries are sort of hash tables in

3124
01:54:24,520 --> 01:54:26,450
particular are sort of the Swiss Army knives of

3125
01:54:26,450 --> 01:54:28,240
data structures and that they just let you associate

3126
01:54:28,240 --> 01:54:30,549
some piece of data with others with Python,

3127
01:54:30,560 --> 01:54:32,240
you do not need to jump through the hoops that you

3128
01:54:32,240 --> 01:54:34,919
needed to with problem set 5 implementing your own spell.

3129
01:54:35,185 --> 01:54:36,165
in your own hash table,

3130
01:54:36,435 --> 01:54:39,044
you just create a dict object in Python,

3131
01:54:39,055 --> 01:54:39,924
a dictionary

3132
01:54:40,214 --> 01:54:43,334
that gives you the ability to associate keys with values.

3133
01:54:43,495 --> 01:54:44,444
So case in point,

3134
01:54:44,615 --> 01:54:45,214
let's do this.

3135
01:54:45,254 --> 01:54:48,325
Let me go back into VS code and close outscores.ie,

3136
01:54:48,415 --> 01:54:52,794
and let's create a new and improved version of our phone book in phonebook.ie.

3137
01:54:53,234 --> 01:54:56,375
Let's go ahead and come up with a list of names just to demonstrate how we could store

3138
01:54:56,375 --> 01:54:58,455
a bunch of names in the phonebook irrespective of

3139
01:54:58,455 --> 01:55:02,214
numbers and set those equal to say Kelly's name.

3140
01:55:02,729 --> 01:55:06,930
And my name and John Harvard's name just by putting

3141
01:55:06,930 --> 01:55:10,450
4 quoted strings or stirrs inside of this list.

3142
01:55:10,700 --> 01:55:13,580
Now let's ask the human using the input function for the

3143
01:55:13,580 --> 01:55:16,169
name that they want to search for in this list,

3144
01:55:16,299 --> 01:55:19,009
and now let's implement linear search using Python.

3145
01:55:19,180 --> 01:55:20,339
I can do this in a bunch of ways,

3146
01:55:20,419 --> 01:55:20,939
but one way.

3147
01:55:21,055 --> 01:55:22,765
is to say for each

3148
01:55:23,575 --> 01:55:25,044
name we'll call it N

3149
01:55:25,334 --> 01:55:29,845
in names go ahead and ask the question if the name I'm looking for

3150
01:55:30,174 --> 01:55:33,805
equals the current name in the list that I'm iterating over,

3151
01:55:34,055 --> 01:55:37,194
go ahead and print out just something generic like found

3152
01:55:37,455 --> 01:55:39,134
and then break out of this loop.

3153
01:55:40,149 --> 01:55:43,439
And let's see if we can find Kelly or David or John or someone else.

3154
01:55:43,609 --> 01:55:45,939
Python of phonebook.ie enter,

3155
01:55:46,290 --> 01:55:48,200
searching for the name say David enter,

3156
01:55:48,450 --> 01:55:50,120
and it was in fact found.

3157
01:55:50,370 --> 01:55:52,490
Let me go ahead and search for someone else's name that's not in there,

3158
01:55:52,569 --> 01:55:53,089
Brian.

3159
01:55:53,350 --> 01:55:54,060
And now

3160
01:55:54,180 --> 01:55:55,490
it's not in fact found,

3161
01:55:55,540 --> 01:55:59,089
although it's not all that enlightening to just ignore the question altogether,

3162
01:55:59,259 --> 01:56:03,310
it would be nice to say not found and here where is where and see

3163
01:56:03,700 --> 01:56:08,569
it would be kind of non-obvious to do this and see if you wanted to print out found

3164
01:56:08,569 --> 01:56:10,580
or if you get through the whole list and

3165
01:56:10,580 --> 01:56:13,600
you still haven't found the user print not found,

3166
01:56:13,819 --> 01:56:16,890
you'd have to like keep track with the variable of whether or not you found the person

3167
01:56:16,890 --> 01:56:20,779
or you'd have to return from the code prematurely just to get out of it logically.

3168
01:56:21,279 --> 01:56:25,459
Turns out somewhat weirdly but wonderfully usefully for loops

3169
01:56:25,459 --> 01:56:29,870
in Python can have ETS clauses associated with them,

3170
01:56:30,120 --> 01:56:33,750
whereby I can say down here print not found.

3171
01:56:33,959 --> 01:56:36,200
If I run this version of the program and search

3172
01:56:36,200 --> 01:56:38,509
for someone who's not in the phone book like Brian,

3173
01:56:38,839 --> 01:56:42,229
now I actually see not found semantically it's a little weird,

3174
01:56:42,359 --> 01:56:43,950
but essentially what's happening is

3175
01:56:44,359 --> 01:56:48,279
if you get through this whole loop and you never call break.

3176
01:56:49,000 --> 01:56:49,509
Then

3177
01:56:49,680 --> 01:56:51,560
you've not actually broken out of the loop,

3178
01:56:51,640 --> 01:56:52,399
so you're going to hit the

3179
01:56:52,850 --> 01:56:54,799
ETS and in that case you're going to print out

3180
01:56:55,120 --> 01:56:55,680
not found,

3181
01:56:55,759 --> 01:56:58,799
and this is such a common thing to like do this kind of bookkeeping and keep

3182
01:56:58,799 --> 01:57:01,459
track of whether or not something has happened inside of a for loop and if so,

3183
01:57:01,479 --> 01:57:01,759
do this,

3184
01:57:01,839 --> 01:57:02,720
Els do that.

3185
01:57:03,040 --> 01:57:05,750
ELTS literally handles that scenario in Python,

3186
01:57:05,759 --> 01:57:06,720
and this is the

3187
01:57:07,120 --> 01:57:11,910
most unlike thing that we've perhaps seen in terms of features with regard to

3188
01:57:12,240 --> 01:57:13,720
at least loops.

3189
01:57:14,229 --> 01:57:14,250
All right,

3190
01:57:15,060 --> 01:57:17,540
well this is great that I've kind of implemented linear search,

3191
01:57:17,649 --> 01:57:18,259
but like

3192
01:57:18,540 --> 01:57:20,580
we did that in C and it's getting a little tedious.

3193
01:57:20,660 --> 01:57:21,299
Can't we do better?

3194
01:57:21,379 --> 01:57:22,169
We actually can.

3195
01:57:22,220 --> 01:57:24,250
Let me clear my terminal and tighten this up

3196
01:57:24,950 --> 01:57:25,689
instead of

3197
01:57:25,899 --> 01:57:29,819
iterating over every name in names just like we keep iterating over in.

3198
01:57:30,234 --> 01:57:34,504
In ranges and checking for each name if it equals the thing we're looking at,

3199
01:57:34,634 --> 01:57:36,964
you can actually do something much more clever.

3200
01:57:36,995 --> 01:57:40,625
You can just literally ask Python if the name you're looking for

3201
01:57:40,875 --> 01:57:43,145
is in the names list,

3202
01:57:43,395 --> 01:57:43,865
then

3203
01:57:44,194 --> 01:57:45,634
go ahead and print out.

3204
01:57:46,049 --> 01:57:49,100
A found else print not found.

3205
01:57:49,270 --> 01:57:51,740
And so this is where Python 2 gets kind of cool.

3206
01:57:52,029 --> 01:57:55,049
In line 5 you have just a simple if

3207
01:57:55,049 --> 01:57:57,709
condition with a Boolean expression name and names.

3208
01:57:57,910 --> 01:58:00,020
How does Python know if name is in names?

3209
01:58:00,109 --> 01:58:05,310
It uses linear search presumably to search over the whole list of names looking for

3210
01:58:05,310 --> 01:58:08,830
what you care about and then tells you true or false if it found it.

3211
01:58:09,029 --> 01:58:12,939
You don't have to write the code to iterate over it with a Y loop or for loop or whatnot.

3212
01:58:13,020 --> 01:58:13,209
You.

3213
01:58:13,265 --> 01:58:14,245
Just say what you mean.

3214
01:58:14,334 --> 01:58:18,964
And so here too it's a little more English like if name in names question mark

3215
01:58:19,214 --> 01:58:22,245
then print found much more so than it would be pronounceable

3216
01:58:22,615 --> 01:58:23,285
in

3217
01:58:23,854 --> 01:58:24,285
C.

3218
01:58:24,615 --> 01:58:27,765
So that's one other cool feature that we now have at our disposal.

3219
01:58:27,935 --> 01:58:28,654
What's yet another?

3220
01:58:28,714 --> 01:58:28,785
Well,

3221
01:58:28,854 --> 01:58:31,575
when it comes to dictionary objects in C,

3222
01:58:32,055 --> 01:58:33,125
or rather in Python,

3223
01:58:33,294 --> 01:58:36,694
a dict object really just gives you a set of key value pairs,

3224
01:58:36,734 --> 01:58:38,535
and we've seen this kind of chart before whereby

3225
01:58:38,535 --> 01:58:40,375
we might have name and number and name and.

3226
01:58:40,490 --> 01:58:41,810
Number and name and number.

3227
01:58:41,959 --> 01:58:43,589
How do we translate this to code?

3228
01:58:43,600 --> 01:58:44,430
Because in C,

3229
01:58:44,680 --> 01:58:45,959
as with problem set 5,

3230
01:58:46,000 --> 01:58:49,000
it was going to be quite an undertaking to be able to store a whole

3231
01:58:49,000 --> 01:58:51,830
bunch of things in memory in the form of something like a hash table.

3232
01:58:52,080 --> 01:58:52,279
Well,

3233
01:58:52,359 --> 01:58:56,200
in Python we can actually define a dictionary ourselves,

3234
01:58:56,319 --> 01:59:00,109
so these square brackets represent a list,

3235
01:59:00,290 --> 01:59:04,250
but I can alternatively use curly braces for a very new purpose.

3236
01:59:04,319 --> 01:59:07,640
I'm going to go ahead and hit enter just to move the second curly brace to a new line.

3237
01:59:07,714 --> 01:59:11,104
And I am going to now enumerate a bunch of key value pairs,

3238
01:59:11,225 --> 01:59:11,604
namely,

3239
01:59:11,625 --> 01:59:13,495
quote unquote Kelly for the first key,

3240
01:59:13,865 --> 01:59:14,495
Colin,

3241
01:59:14,705 --> 01:59:16,125
then we'll do plus 1,

3242
01:59:16,225 --> 01:59:18,294
617495,

3243
01:59:18,535 --> 01:59:20,055
1000 as the number.

3244
01:59:20,424 --> 01:59:23,854
Then I'm going to go ahead and do quote unquote David for the second key,

3245
01:59:24,104 --> 01:59:25,305
and since we both work here,

3246
01:59:25,384 --> 01:59:28,415
I'm going to go ahead and just use that same number as we've done it before.

3247
01:59:28,665 --> 01:59:34,895
Then a third key for John Harvard Colin and for John we'll use + 1949.

3248
01:59:35,560 --> 01:59:37,669
4,682,750,

3249
01:59:37,680 --> 01:59:39,410
which is fun to call or text.

3250
01:59:39,790 --> 01:59:40,379
This now,

3251
01:59:40,439 --> 01:59:42,229
even though it's syntactically a little different,

3252
01:59:42,439 --> 01:59:45,029
gives me the equivalent of this chart here

3253
01:59:45,430 --> 01:59:47,959
key value pairs where the keys are the

3254
01:59:47,959 --> 01:59:51,959
staff names and the values are the staff numbers

3255
01:59:52,160 --> 01:59:53,640
that implements all of that,

3256
01:59:53,649 --> 01:59:54,490
a hash table,

3257
01:59:54,560 --> 01:59:55,310
if you will,

3258
01:59:55,680 --> 01:59:57,830
in Python's own syntax.

3259
01:59:58,000 --> 01:59:59,430
So how do I now use this?

3260
01:59:59,790 --> 02:00:03,009
Turns out I can actually use it in exactly the same way.

3261
02:00:03,180 --> 02:00:05,490
I'm going to go ahead and generalize this now to people

3262
02:00:05,490 --> 02:00:07,819
because it contains not just names but names and numbers.

3263
02:00:07,939 --> 02:00:10,569
So I'm going to change this variable down here to people too.

3264
02:00:10,859 --> 02:00:12,140
But notice the syntax now.

3265
02:00:12,229 --> 02:00:15,160
I can still ask the human for a name they want to look up.

3266
02:00:15,500 --> 02:00:19,649
I can now still say if the name is in the people dictionary,

3267
02:00:19,819 --> 02:00:23,350
and by definition Python's going to interpret that preposition in

3268
02:00:23,580 --> 02:00:24,060
as meaning.

3269
02:00:24,149 --> 02:00:27,569
Is the following key in the dictionary

3270
02:00:27,859 --> 02:00:28,490
and if so,

3271
02:00:28,500 --> 02:00:30,049
it's going to return true.

3272
02:00:30,259 --> 02:00:33,620
But what's cool about this is that besides just making this work as

3273
02:00:33,620 --> 02:00:37,589
follows Python a phonebook.ie and let's type in David and there's my number.

3274
02:00:37,600 --> 02:00:37,700
Oh,

3275
02:00:37,859 --> 02:00:38,629
that's not my number.

3276
02:00:38,640 --> 02:00:39,470
It just says found.

3277
02:00:39,660 --> 02:00:41,950
Let's run it again and type in say Brian,

3278
02:00:42,220 --> 02:00:42,660
not found.

3279
02:00:42,740 --> 02:00:42,899
OK,

3280
02:00:42,939 --> 02:00:43,700
that's as expected,

3281
02:00:43,740 --> 02:00:46,729
but I'd like to know what my number is or Kelly's number or John's number.

3282
02:00:46,859 --> 02:00:47,020
Well,

3283
02:00:47,060 --> 02:00:48,299
that's an easy fix too.

3284
02:00:48,870 --> 02:00:50,299
Inside of this conditional,

3285
02:00:50,350 --> 02:00:54,299
I can say something like this number equals people

3286
02:00:54,709 --> 02:00:55,560
bracket

3287
02:00:55,870 --> 02:00:56,419
name.

3288
02:00:56,689 --> 02:00:58,430
And we've not seen this before,

3289
02:00:58,640 --> 02:01:01,120
but we have seen square brackets in C,

3290
02:01:01,200 --> 02:01:02,589
when we had arrays,

3291
02:01:02,640 --> 02:01:07,709
this square bracket notation is how you indexed into an array to get a specific

3292
02:01:08,120 --> 02:01:08,870
value

3293
02:01:09,359 --> 02:01:10,879
0123,

3294
02:01:10,890 --> 02:01:11,390
4th.

3295
02:01:11,569 --> 02:01:13,319
What's amazing about dictionaries,

3296
02:01:13,439 --> 02:01:15,669
not just in Python but in other languages as well,

3297
02:01:15,959 --> 02:01:20,270
you can now index into a dictionary just as you can index into an array,

3298
02:01:20,479 --> 02:01:23,319
but whereas in array you use numeric indices.

3299
02:01:24,000 --> 02:01:27,200
In dictionaries you use string indices.

3300
02:01:27,270 --> 02:01:30,419
You can use strings to look up their corresponding value.

3301
02:01:30,589 --> 02:01:31,500
So to be clear,

3302
02:01:31,910 --> 02:01:36,299
name at this point is given to us by the human's input.

3303
02:01:36,390 --> 02:01:37,790
So if I typed in DAVID,

3304
02:01:37,910 --> 02:01:39,060
name equals David.

3305
02:01:39,229 --> 02:01:41,589
So this is like saying people square bracket,

3306
02:01:41,709 --> 02:01:45,509
quote unquote David find David's number that stores the answer.

3307
02:01:45,930 --> 02:01:50,250
From this two column chart in the variable called number and

3308
02:01:50,250 --> 02:01:52,040
all that remains is for me to print it out,

3309
02:01:52,129 --> 02:01:54,000
which I can do using an old F string now.

3310
02:01:54,129 --> 02:01:55,450
Let me go down into my print statement,

3311
02:01:55,529 --> 02:01:56,569
change this to an F string,

3312
02:01:56,770 --> 02:01:57,560
add a colon,

3313
02:01:57,810 --> 02:01:59,979
add the number variable to be interpolated,

3314
02:02:00,250 --> 02:02:02,919
rerun this program as Pythonfhonebook.ie,

3315
02:02:03,009 --> 02:02:03,680
type in my name,

3316
02:02:03,799 --> 02:02:04,399
and

3317
02:02:04,810 --> 02:02:07,160
there's my number as found.

3318
02:02:07,649 --> 02:02:10,209
And this is incredibly powerful and why again.

3319
02:02:11,899 --> 02:02:13,879
hash tables and in turn more generally dictionaries

3320
02:02:13,879 --> 02:02:15,439
are sort of the Swiss Army knife being

3321
02:02:15,439 --> 02:02:17,359
able just to look up data with such

3322
02:02:17,359 --> 02:02:20,470
simple syntax is wonderfully useful and powerful.

3323
02:02:20,629 --> 02:02:22,509
And in fact we can even do more than this,

3324
02:02:22,560 --> 02:02:23,040
for instance,

3325
02:02:23,120 --> 02:02:26,870
let me propose that if you think about other incarnations of

3326
02:02:27,959 --> 02:02:28,879
key value pairs,

3327
02:02:28,919 --> 02:02:29,979
you see them all the time,

3328
02:02:30,040 --> 02:02:30,359
for instance,

3329
02:02:30,370 --> 02:02:32,160
in like spreadsheets like here's a.

3330
02:02:32,306 --> 02:02:36,226
screenshot of Google Sheets whereby I've got the beginnings of a spreadsheet with

3331
02:02:36,826 --> 02:02:38,465
names and numbers.

3332
02:02:38,545 --> 02:02:42,425
But in this model I want to actually associate some metadata with my data.

3333
02:02:42,505 --> 02:02:44,815
So the data I care about is the actual names and numbers.

3334
02:02:44,985 --> 02:02:49,096
But you could imagine having a third column like email address and maybe home

3335
02:02:49,096 --> 02:02:53,395
address or any number of other pieces of data associated with these 3 people.

3336
02:02:53,545 --> 02:02:55,731
For now I've Got two columns or two attributes,

3337
02:02:55,852 --> 02:02:56,852
names and numbers.

3338
02:02:57,012 --> 02:02:58,291
Each of the rows in a spreadsheet,

3339
02:02:58,301 --> 02:03:00,381
as most anyone knows who's used a spreadsheet before,

3340
02:03:00,702 --> 02:03:04,051
represents different records or different pieces of data like this is Kelly,

3341
02:03:04,332 --> 02:03:05,001
this is David,

3342
02:03:05,091 --> 02:03:05,782
this is John,

3343
02:03:05,892 --> 02:03:06,682
and so forth.

3344
02:03:06,832 --> 02:03:11,361
We can implement this idea using dictionaries and lists together.

3345
02:03:11,541 --> 02:03:13,771
So the syntax is going to be a little strange at first,

3346
02:03:13,852 --> 02:03:15,961
but let me go back to VS code here

3347
02:03:16,211 --> 02:03:17,722
and let me change my people

3348
02:03:18,492 --> 02:03:19,282
dictionary

3349
02:03:19,532 --> 02:03:21,771
to be a people list.

3350
02:03:22,549 --> 02:03:26,740
Between square brackets and the elements of this list now are going to be

3351
02:03:27,229 --> 02:03:28,899
uh dictionaries themselves.

3352
02:03:28,990 --> 02:03:32,549
I'm going to use some curly braces inside of these square brackets

3353
02:03:32,549 --> 02:03:36,020
and say that the name of one person is quote unquote Kelly,

3354
02:03:36,189 --> 02:03:42,870
and the number for that person is quote unquote plus 1617495 1000.

3355
02:03:43,495 --> 02:03:44,444
Close quote.

3356
02:03:44,774 --> 02:03:47,535
Then comma on the outside of the curly braces.

3357
02:03:47,814 --> 02:03:52,625
Then I'm gonna have another quote unquote name Colin D A V I D comma,

3358
02:03:52,854 --> 02:03:53,964
then another number,

3359
02:03:54,294 --> 02:03:54,694
Colin.

3360
02:03:54,774 --> 02:03:57,285
I'm gonna borrow the same phone number because we both work here.

3361
02:03:57,694 --> 02:03:58,725
Then lastly,

3362
02:03:59,165 --> 02:04:00,535
comma and finally,

3363
02:04:00,615 --> 02:04:03,455
quote unquote name Colin quote unquote John.

3364
02:04:03,910 --> 02:04:04,540
And then,

3365
02:04:04,790 --> 02:04:05,600
lastly,

3366
02:04:05,790 --> 02:04:07,680
a quote unquote number

3367
02:04:07,910 --> 02:04:15,100
for John Coen + 1 9,494,682,750.

3368
02:04:15,569 --> 02:04:15,600
Whew.

3369
02:04:16,609 --> 02:04:16,839
All right,

3370
02:04:17,000 --> 02:04:18,560
so what's going on here now?

3371
02:04:18,640 --> 02:04:21,339
Our people variable is now not just a simple

3372
02:04:21,339 --> 02:04:24,060
dictionary with just individual key value pairs name,

3373
02:04:24,080 --> 02:04:24,330
number,

3374
02:04:24,339 --> 02:04:24,450
name,

3375
02:04:24,520 --> 02:04:24,790
number,

3376
02:04:24,799 --> 02:04:24,899
name,

3377
02:04:24,950 --> 02:04:25,259
number.

3378
02:04:25,520 --> 02:04:29,129
We now have a more generalized way of storing not just a name

3379
02:04:29,680 --> 02:04:30,520
or a number,

3380
02:04:30,600 --> 02:04:34,390
but an email address or a home address or any number of other values.

3381
02:04:34,399 --> 02:04:37,600
How will the commas just separate the key value pairs now.

3382
02:04:37,640 --> 02:04:39,709
So if I do have email addresses for us,

3383
02:04:39,879 --> 02:04:40,700
I can put comma,

3384
02:04:40,799 --> 02:04:41,520
quote unquote email.

3385
02:04:41,775 --> 02:04:42,175
Colin,

3386
02:04:42,255 --> 02:04:46,695
like male at Harvard.edu and I can just keep adding these key value pairs to

3387
02:04:46,695 --> 02:04:51,496
each of the dictionaries because the dictionary is a collection of key value pairs.

3388
02:04:51,616 --> 02:04:53,815
So it stands to reason that I can associate name with David,

3389
02:04:53,855 --> 02:04:54,666
number with the number,

3390
02:04:54,905 --> 02:04:56,366
email with mail at harvard.edu,

3391
02:04:56,416 --> 02:04:57,166
and so forth,

3392
02:04:57,525 --> 02:04:58,806
effectively implementing

3393
02:04:59,136 --> 02:05:01,806
this idea now in the computer's memory

3394
02:05:01,806 --> 02:05:04,246
and at the risk of significantly oversimplifying,

3395
02:05:04,416 --> 02:05:07,616
this is what Google and Microsoft and Apple are doing with their spreadsheet soft.

3396
02:05:07,762 --> 02:05:08,861
Where they have written code

3397
02:05:09,111 --> 02:05:12,622
that presents to you a nice table with a graphical user interface on the screen,

3398
02:05:12,671 --> 02:05:15,271
but underneath the hood what they effectively have is

3399
02:05:15,271 --> 02:05:18,461
lists of dictionaries representing each of those rows,

3400
02:05:18,472 --> 02:05:21,071
and we're going to come back to this when we start experimenting before

3401
02:05:21,071 --> 02:05:24,702
long with our own databases in the back rows of data from databases,

3402
02:05:24,872 --> 02:05:29,501
we are going to store that data in lists of dictionaries for the same reason as well.

3403
02:05:29,791 --> 02:05:30,591
So how can we use this?

3404
02:05:30,671 --> 02:05:30,771
Well,

3405
02:05:30,912 --> 02:05:33,711
let me hide my terminal for a second and tweak the program just a little bit.

3406
02:05:34,140 --> 02:05:37,299
I'm still going to get the name of a person to look up their number.

3407
02:05:37,490 --> 02:05:39,120
I'm still going to,

3408
02:05:39,359 --> 02:05:39,689
uh,

3409
02:05:39,810 --> 02:05:40,720
how about

3410
02:05:41,049 --> 02:05:43,330
iterate over this because I've lost the ability,

3411
02:05:43,370 --> 02:05:44,479
at least for now,

3412
02:05:44,689 --> 02:05:48,720
to just ask a question like is this name in the structure because it's a list.

3413
02:05:48,729 --> 02:05:51,279
I do now need to iterate a little bit differently,

3414
02:05:51,410 --> 02:05:53,040
so I'm going to do for each person

3415
02:05:53,330 --> 02:05:54,720
in the people list,

3416
02:05:55,089 --> 02:05:58,200
go ahead and check is the current person's

3417
02:05:58,520 --> 02:05:59,089
name.

3418
02:05:59,819 --> 02:06:03,259
Equal to the name I'm looking for and if so,

3419
02:06:03,339 --> 02:06:07,450
go ahead and create a variable called number set it equal to that person's

3420
02:06:07,799 --> 02:06:08,569
number,

3421
02:06:08,859 --> 02:06:13,419
and then go ahead and print out for instance found colon then

3422
02:06:13,419 --> 02:06:17,890
in my curly braces that specific number and then after all that

3423
02:06:18,180 --> 02:06:19,089
break out of this.

3424
02:06:19,259 --> 02:06:20,140
So this is a mouthful,

3425
02:06:20,220 --> 02:06:20,689
but.

3426
02:06:21,169 --> 02:06:25,089
Recall that it's all the same syntax we've seen before in smaller parts.

3427
02:06:25,330 --> 02:06:28,080
Square brackets and square brackets means here comes a list.

3428
02:06:28,330 --> 02:06:30,520
What are the elements of this list?dict,

3429
02:06:30,549 --> 02:06:31,089
dict,

3430
02:06:31,100 --> 02:06:33,729
dict three dictionaries back to back to back,

3431
02:06:34,049 --> 02:06:36,770
each of which has a key and a value and

3432
02:06:36,770 --> 02:06:39,720
a key and a value called name and number respectively.

3433
02:06:39,850 --> 02:06:43,970
The second one temporarily has name and number and email as keys plus.

3434
02:06:44,075 --> 02:06:46,734
3 values and the third one has keys of

3435
02:06:46,734 --> 02:06:49,734
name and number as well with their corresponding values.

3436
02:06:49,854 --> 02:06:50,325
So

3437
02:06:50,654 --> 02:06:54,084
when I iterate over each person in the people list,

3438
02:06:54,375 --> 02:06:58,765
that means on each iteration person is going to be set to this dictionary,

3439
02:06:59,015 --> 02:07:00,084
then this dictionary,

3440
02:07:00,254 --> 02:07:01,404
then this dictionary.

3441
02:07:01,615 --> 02:07:06,935
On each iteration I'm asking this question Is that current person's name key?

3442
02:07:07,399 --> 02:07:07,540
Uh,

3443
02:07:07,580 --> 02:07:07,859
is,

3444
02:07:07,899 --> 02:07:08,140
rather,

3445
02:07:08,250 --> 02:07:13,450
is the value of that person's name key equal to the name I'm looking for,

3446
02:07:13,740 --> 02:07:14,649
and if so,

3447
02:07:14,859 --> 02:07:16,390
grab a variable called number,

3448
02:07:16,660 --> 02:07:20,009
set it equal to the value of that person's number key,

3449
02:07:20,259 --> 02:07:21,410
and then just print it out.

3450
02:07:21,700 --> 02:07:23,120
And if we wanted to email instead,

3451
02:07:23,200 --> 02:07:25,799
I tweak the word uh number to email.

3452
02:07:25,839 --> 02:07:28,430
If I wanna look up anything else you can tweak that code there,

3453
02:07:28,640 --> 02:07:31,450
but being able to index into dictionaries

3454
02:07:31,450 --> 02:07:34,390
using strings is sort of the fundamentally

3455
02:07:34,720 --> 02:07:36,529
powerful new technique

3456
02:07:37,160 --> 02:07:38,200
that we have here.

3457
02:07:40,419 --> 02:07:41,740
Question now

3458
02:07:42,299 --> 02:07:43,209
on any of this,

3459
02:07:43,220 --> 02:07:43,779
yeah.

3460
02:07:48,120 --> 02:07:48,549
Good question.

3461
02:07:48,589 --> 02:07:50,830
If you wanted both name and number on the screen,

3462
02:07:50,950 --> 02:07:51,589
do you concatenate?

3463
02:07:51,669 --> 02:07:51,819
Sure,

3464
02:07:51,910 --> 02:07:53,629
you could do that or print them out by passing a

3465
02:07:53,629 --> 02:07:56,700
comma into the print function and printing one out each way.

3466
02:07:57,069 --> 02:07:57,470
Absolutely,

3467
02:07:57,589 --> 02:07:58,660
however you want to format it.

3468
02:07:58,750 --> 02:07:59,140
And actually,

3469
02:07:59,149 --> 02:08:00,000
just as an aside too,

3470
02:08:00,109 --> 02:08:01,939
even though this becomes a little less readable,

3471
02:08:02,109 --> 02:08:05,109
this is a little silly that on line 11 I'm declaring a variable

3472
02:08:05,109 --> 02:08:08,430
called number only to use it one line later and then never again.

3473
02:08:08,959 --> 02:08:11,689
Technically with those curly braces and format strings,

3474
02:08:11,720 --> 02:08:13,790
I could just take this code on the right,

3475
02:08:14,080 --> 02:08:16,029
plug it into those curly braces,

3476
02:08:16,040 --> 02:08:17,890
and get rid of this variable altogether.

3477
02:08:18,250 --> 02:08:19,319
Just at some point though,

3478
02:08:19,399 --> 02:08:23,549
F strings start to get a little too hard to read with quotes inside of quotes,

3479
02:08:23,560 --> 02:08:24,330
and so like

3480
02:08:24,680 --> 02:08:27,240
I kind of prefer being a little more pedantic about it and

3481
02:08:27,240 --> 02:08:31,149
explicitly putting it in a variable and then interpolating just that variable,

3482
02:08:31,399 --> 02:08:33,069
but you could do it in different ways

3483
02:08:33,319 --> 02:08:33,669
still.

3484
02:08:34,910 --> 02:08:35,419
All right,

3485
02:08:35,700 --> 02:08:37,939
a couple of final features of Python that will

3486
02:08:37,939 --> 02:08:39,490
get us on our way with doing other things.

3487
02:08:39,620 --> 02:08:43,089
Turns out there's a whole bunch of libraries that come with the language itself

3488
02:08:43,250 --> 02:08:44,990
that you nonetheless have to import,

3489
02:08:45,129 --> 02:08:46,569
even though they're not third party.

3490
02:08:46,660 --> 02:08:47,580
You don't have to install them.

3491
02:08:47,620 --> 02:08:50,790
You just need to add them to your code by importing them.

3492
02:08:50,879 --> 02:08:51,850
One of them is SIS,

3493
02:08:51,859 --> 02:08:54,209
and among the things that the SIS library has

3494
02:08:54,459 --> 02:08:58,060
in Python is the ability to give you access to command line arguments.

3495
02:08:58,080 --> 02:08:58,600
After all,

3496
02:08:58,819 --> 02:08:59,569
we've lost

3497
02:08:59,979 --> 02:09:02,100
access to command line arguments because there's no more main,

3498
02:09:02,140 --> 02:09:02,660
at least by.

3499
02:09:03,055 --> 02:09:04,095
There's no in main void.

3500
02:09:04,134 --> 02:09:08,285
There's no in Main RVRC stuff going on in our code,

3501
02:09:08,734 --> 02:09:13,564
but all of that functionality is still available in a library called SIS.

3502
02:09:13,734 --> 02:09:14,615
So how do we use this?

3503
02:09:14,645 --> 02:09:14,694
Well,

3504
02:09:14,774 --> 02:09:16,404
let me go back to VS code here now.

3505
02:09:16,575 --> 02:09:19,604
Let me create a relatively simple program called greet.ie,

3506
02:09:19,734 --> 02:09:20,964
similar to a few weeks back,

3507
02:09:21,044 --> 02:09:23,654
that's just going to greet the user using command line

3508
02:09:23,654 --> 02:09:26,404
arguments instead of get string or the input function.

3509
02:09:26,575 --> 02:09:30,575
I'm going to do this by saying from the SIS library import RV.

3510
02:09:30,959 --> 02:09:31,790
In this case,

3511
02:09:31,939 --> 02:09:33,779
RV is essentially just the list.

3512
02:09:33,899 --> 02:09:37,049
It is a list of the command line arguments that the human has typed.

3513
02:09:37,220 --> 02:09:38,169
It's a list,

3514
02:09:38,419 --> 02:09:42,339
which means you can just ask the length function LEN what its length is.

3515
02:09:42,459 --> 02:09:44,140
So there's no need for RGC anymore.

3516
02:09:44,220 --> 02:09:46,850
You can just literally ask RV how long it is,

3517
02:09:46,899 --> 02:09:47,930
which is kind of nice.

3518
02:09:48,180 --> 02:09:51,220
So I'm going to say this if the length of RGV.

3519
02:09:52,020 --> 02:09:52,250
Uh,

3520
02:09:52,259 --> 02:09:54,279
equals equals 2,

3521
02:09:54,459 --> 02:09:56,689
which means the human type two words at the prompt.

3522
02:09:56,740 --> 02:09:57,169
OK,

3523
02:09:57,339 --> 02:09:58,339
let's go ahead and greet them,

3524
02:09:58,379 --> 02:10:00,370
assuming that's their name and say hello,

3525
02:10:00,660 --> 02:10:01,319
comma,

3526
02:10:01,660 --> 02:10:03,689
and then whatever their name is.

3527
02:10:03,939 --> 02:10:06,339
Let me make this a format string and to be pedantic,

3528
02:10:06,419 --> 02:10:10,740
let me create a variable called name and set it equal to RV1.

3529
02:10:11,254 --> 02:10:13,924
Which is going to be the second word that the human typed in,

3530
02:10:13,975 --> 02:10:15,805
as has been our convention in the past,

3531
02:10:15,975 --> 02:10:18,854
else if they didn't type exactly two command line arguments,

3532
02:10:18,935 --> 02:10:20,274
let's just go ahead and print out

3533
02:10:20,495 --> 02:10:22,904
something like hello world as generic.

3534
02:10:23,254 --> 02:10:25,234
Let me run Pythonogreet.ie,

3535
02:10:25,415 --> 02:10:25,595
E,

3536
02:10:26,214 --> 02:10:27,524
and you see hello world,

3537
02:10:27,854 --> 02:10:29,794
because I apparently did not type in

3538
02:10:30,285 --> 02:10:31,524
exactly two words,

3539
02:10:31,654 --> 02:10:32,325
and yet I did.

3540
02:10:32,495 --> 02:10:33,725
So let's see where this is going.

3541
02:10:33,935 --> 02:10:38,765
Let me rerun Pythonogreet.ie but type in my name David at the command line.

3542
02:10:39,055 --> 02:10:39,654
Enter.

3543
02:10:40,279 --> 02:10:40,930
And

3544
02:10:41,160 --> 02:10:41,629
huh,

3545
02:10:41,919 --> 02:10:43,040
I screwed up unintentionally.

3546
02:10:43,160 --> 02:10:44,009
What did I do wrong?

3547
02:10:45,040 --> 02:10:45,229
All right,

3548
02:10:45,240 --> 02:10:46,259
print F is not a thing.

3549
02:10:46,390 --> 02:10:47,540
So that's an easy fix.

3550
02:10:47,750 --> 02:10:48,580
Let's delete it.

3551
02:10:48,790 --> 02:10:50,229
Let me clear my terminal window,

3552
02:10:50,279 --> 02:10:52,620
rerun Python of greetie David,

3553
02:10:52,629 --> 02:10:53,080
enter,

3554
02:10:53,350 --> 02:10:54,740
and now I get hello David.

3555
02:10:54,870 --> 02:10:56,370
The only thing that's weird here

3556
02:10:56,709 --> 02:10:59,979
is that I typed in 3 words at the prompt,

3557
02:11:00,069 --> 02:11:01,549
and yet I'm checking for 2.

3558
02:11:01,930 --> 02:11:03,120
And it's a bit subtle,

3559
02:11:03,319 --> 02:11:05,029
but with Python and RV,

3560
02:11:05,240 --> 02:11:07,000
it ignores the Python interpreter.

3561
02:11:07,040 --> 02:11:08,799
It goes without saying that you're using the

3562
02:11:08,799 --> 02:11:10,689
Python interpreter to run a Python program.

3563
02:11:10,759 --> 02:11:12,589
So the only things that are being counted

3564
02:11:12,589 --> 02:11:16,189
are the words after the Python interpreter itself.

3565
02:11:16,399 --> 02:11:18,359
So when I type greet.ie and David,

3566
02:11:18,479 --> 02:11:19,270
that's 2,

3567
02:11:19,439 --> 02:11:21,029
when I only typed greet.ie,

3568
02:11:21,379 --> 02:11:22,359
that's 1.

3569
02:11:23,359 --> 02:11:24,069
Instead

3570
02:11:24,870 --> 02:11:25,390
All right,

3571
02:11:25,589 --> 02:11:26,740
so now that I've done that,

3572
02:11:26,810 --> 02:11:29,069
I have access to my command line arguments again.

3573
02:11:29,149 --> 02:11:30,549
What about my exit statuses?

3574
02:11:30,629 --> 02:11:31,830
This was getting a little low level,

3575
02:11:31,870 --> 02:11:35,430
but in recent C programs we've had you all returning 0 on success,

3576
02:11:35,589 --> 02:11:36,779
returning 1 on error.

3577
02:11:37,109 --> 02:11:38,069
Can we still do that?

3578
02:11:38,180 --> 02:11:38,270
Well,

3579
02:11:38,359 --> 02:11:38,620
yes,

3580
02:11:38,689 --> 02:11:38,979
and in fact,

3581
02:11:38,990 --> 02:11:41,229
the SIS library is used for that as well.

3582
02:11:41,350 --> 02:11:43,140
So if I want to actually add

3583
02:11:43,390 --> 02:11:46,390
some exit statuses to a program to facilitate Check

3584
02:11:46,390 --> 02:11:48,259
50 and automated tests in the real world,

3585
02:11:48,430 --> 02:11:50,020
I can do that with a program called,

3586
02:11:50,069 --> 02:11:52,470
let's call this exit.ie.

3587
02:11:53,040 --> 02:11:54,160
And in exit up I,

3588
02:11:54,169 --> 02:11:57,009
I'm similarly going to import uh CIS,

3589
02:11:57,049 --> 02:11:58,040
but in a different way,

3590
02:11:58,250 --> 02:12:00,479
I'm gonna give myself access to.

3591
02:12:01,549 --> 02:12:02,439
Well,

3592
02:12:02,750 --> 02:12:03,140
yes,

3593
02:12:03,270 --> 02:12:05,859
let's go ahead and import the whole library just to demonstrate how

3594
02:12:05,859 --> 02:12:10,040
you can access things inside of it without explicitly saying from SIS,

3595
02:12:10,149 --> 02:12:11,740
import such and such.

3596
02:12:12,089 --> 02:12:12,779
as before,

3597
02:12:12,870 --> 02:12:13,370
if

3598
02:12:13,669 --> 02:12:17,100
uh the length of sys.orgv.

3599
02:12:17,839 --> 02:12:19,149
So this is a little bit different,

3600
02:12:19,189 --> 02:12:21,430
but I'm asking the same kind of question,

3601
02:12:21,470 --> 02:12:22,580
does not equal to.

3602
02:12:22,750 --> 02:12:24,899
I want to go ahead and print out to the user

3603
02:12:25,250 --> 02:12:26,910
missing command line argument,

3604
02:12:26,990 --> 02:12:29,180
which is something we did a while back as well.

3605
02:12:29,430 --> 02:12:33,529
And then I want to exit with code 1 CIs.exit

3606
02:12:34,060 --> 02:12:34,540
1.

3607
02:12:35,490 --> 02:12:36,950
El if I don't run into that issue,

3608
02:12:37,069 --> 02:12:37,859
I'm going to go ahead,

3609
02:12:37,870 --> 02:12:38,109
actually,

3610
02:12:38,189 --> 02:12:39,290
let's not even bother with the NELTS.

3611
02:12:39,299 --> 02:12:41,459
Let's for parity with our C version,

3612
02:12:41,629 --> 02:12:43,140
let's do this print

3613
02:12:45,100 --> 02:12:45,870
Fo hello.

3614
02:12:46,649 --> 02:12:48,100
Uh,

3615
02:12:48,330 --> 02:12:53,000
sis.RV1 close quotes.exit.

3616
02:12:53,450 --> 02:12:53,689
All right,

3617
02:12:53,930 --> 02:12:54,729
that's a whole mouthful,

3618
02:12:54,770 --> 02:12:56,040
but what's really going on?

3619
02:12:56,370 --> 02:13:00,270
So I could have done from sys import RV,

3620
02:13:00,810 --> 02:13:01,290
but

3621
02:13:01,569 --> 02:13:03,839
I don't need to enumerate every single

3622
02:13:04,049 --> 02:13:07,049
variable or every single function that I want from a library.

3623
02:13:07,129 --> 02:13:09,729
I can also just more generally say import the whole library.

3624
02:13:09,770 --> 02:13:10,959
Give me access to everything,

3625
02:13:11,009 --> 02:13:12,810
and then I'll tell you what I want from it later.

3626
02:13:13,370 --> 02:13:13,819
Therefore,

3627
02:13:13,930 --> 02:13:14,839
on line 3,

3628
02:13:14,850 --> 02:13:16,479
I can still access RV.

3629
02:13:16,649 --> 02:13:21,990
I just have to scope it to the SIS library so that I say sI.RV means go inside of

3630
02:13:21,990 --> 02:13:25,000
that library and find me RGV instead of elevating it

3631
02:13:25,000 --> 02:13:27,600
to a variable unto itself in my own code.

3632
02:13:27,930 --> 02:13:29,370
Why am I saying not equal to 2?

3633
02:13:29,410 --> 02:13:29,609
Well,

3634
02:13:29,729 --> 02:13:33,129
if they don't give me two words after the interpreter's name,

3635
02:13:33,209 --> 02:13:36,250
I want to yell at them and say missing command line argument and then exit 1.

3636
02:13:36,290 --> 02:13:38,040
I'm not going to give them a default hello world anymore.

3637
02:13:38,169 --> 02:13:39,319
I want them to give me their name.

3638
02:13:39,970 --> 02:13:40,370
Meanwhile,

3639
02:13:40,450 --> 02:13:42,609
if I get this far and I haven't exited from the program,

3640
02:13:42,689 --> 02:13:45,850
I can print out sI.RV1,

3641
02:13:45,890 --> 02:13:48,600
which is going to be David in the example I typed before,

3642
02:13:48,649 --> 02:13:49,799
and this means success,

3643
02:13:50,089 --> 02:13:51,439
so sys.exit

3644
02:13:51,879 --> 02:13:53,839
0 signifies success.

3645
02:13:53,970 --> 02:13:55,600
It's more syntax than before

3646
02:13:56,060 --> 02:13:56,850
than it was in C,

3647
02:13:56,970 --> 02:14:00,640
but we have the exact same functionality available to us

3648
02:14:00,930 --> 02:14:02,689
as we have in the past.

3649
02:14:03,359 --> 02:14:05,240
How about one other example that we've had in the past?

3650
02:14:05,279 --> 02:14:07,109
Let's convert it to Python as well.

3651
02:14:07,319 --> 02:14:09,319
So you have a few more tools in your toolkit.

3652
02:14:09,560 --> 02:14:13,029
How about implementing a version of this phone book that actually persists?

3653
02:14:13,040 --> 02:14:15,009
So instead of hard coding into it,

3654
02:14:15,240 --> 02:14:17,430
Kelly and David and John in this way,

3655
02:14:17,560 --> 02:14:19,950
let's actually let the user type in a name and a number just like

3656
02:14:19,950 --> 02:14:22,720
on your iPhone or Android phone and add it to a text file,

3657
02:14:22,759 --> 02:14:27,279
like a CSV file as we did before using comma separated values.

3658
02:14:27,399 --> 02:14:27,479
Well,

3659
02:14:27,520 --> 02:14:28,270
it turns out

3660
02:14:28,439 --> 02:14:31,959
that Python comes with a library to handle CSV files.

3661
02:14:32,000 --> 02:14:32,319
We don't need.

3662
02:14:32,540 --> 02:14:36,649
Hackishly implement our own CSV support by printing the commas ourselves.

3663
02:14:36,899 --> 02:14:37,259
Instead,

3664
02:14:37,299 --> 02:14:39,560
we can import the CSV library.

3665
02:14:39,819 --> 02:14:40,540
We can then create,

3666
02:14:40,549 --> 02:14:40,649
say,

3667
02:14:40,660 --> 02:14:41,979
a variable called file,

3668
02:14:42,020 --> 02:14:47,569
set it equal to open and open a file called phonebook.csv in a pend mode.

3669
02:14:47,740 --> 02:14:49,290
So this is almost the same as C,

3670
02:14:49,339 --> 02:14:51,540
except it's open instead of F open,

3671
02:14:51,580 --> 02:14:53,169
which we saw a couple of weeks back.

3672
02:14:53,419 --> 02:14:56,899
Now let's ask the user via the input function for the name they want to

3673
02:14:56,899 --> 02:15:01,020
add to their contacts and the number that they want to add to their contacts,

3674
02:15:01,060 --> 02:15:01,649
and then

3675
02:15:02,080 --> 02:15:03,379
And so after that,

3676
02:15:03,589 --> 02:15:04,620
let's go ahead and do this,

3677
02:15:04,709 --> 02:15:08,160
which is a bit of muscle memory to remember,

3678
02:15:08,430 --> 02:15:10,359
but I'm going to create a variable called writer,

3679
02:15:10,470 --> 02:15:11,859
but I could call it anything I want.

3680
02:15:12,229 --> 02:15:14,640
Set it equal to csv.writer,

3681
02:15:14,950 --> 02:15:17,339
which means there's a function called writer

3682
02:15:17,549 --> 02:15:20,669
in the CSV library that I'm simply accessing it

3683
02:15:20,669 --> 02:15:22,720
because I didn't import it explicitly by name,

3684
02:15:22,819 --> 02:15:24,319
and I'm going to pass it that file.

3685
02:15:24,509 --> 02:15:25,779
This tells Python,

3686
02:15:26,149 --> 02:15:29,540
turn that file into a CSV that can be written to.

3687
02:15:29,870 --> 02:15:33,049
The next line of code I'm going to literally say writer.

3688
02:15:33,660 --> 02:15:34,689
write row.

3689
02:15:35,109 --> 02:15:36,549
Write row is a method,

3690
02:15:37,000 --> 02:15:37,770
aka function

3691
02:15:38,020 --> 02:15:40,330
associated with this writer object,

3692
02:15:40,379 --> 02:15:43,379
and I know that only because I did actually read the documentation

3693
02:15:43,939 --> 02:15:45,759
for the CSV library.

3694
02:15:46,140 --> 02:15:47,120
What do I want to write?

3695
02:15:47,259 --> 02:15:47,379
Well,

3696
02:15:47,540 --> 02:15:49,569
I want to write out a list of values,

3697
02:15:49,709 --> 02:15:51,140
namely a name.

3698
02:15:51,450 --> 02:15:54,200
And a number and I'm using square brackets to

3699
02:15:54,200 --> 02:15:56,270
tell the right row function that here you go,

3700
02:15:56,399 --> 02:15:58,080
here's a list of values,

3701
02:15:58,270 --> 02:16:00,279
2 of them a name and a number.

3702
02:16:00,479 --> 02:16:01,160
After all that,

3703
02:16:01,259 --> 02:16:04,319
I'm going to do file.close and just close the whole file.

3704
02:16:04,720 --> 02:16:04,919
All right,

3705
02:16:05,000 --> 02:16:06,479
so where does this actually get me?

3706
02:16:06,520 --> 02:16:07,009
Well,

3707
02:16:07,399 --> 02:16:09,060
let me go ahead and open up phonebook.

3708
02:16:09,359 --> 02:16:09,950
CSV,

3709
02:16:10,000 --> 02:16:11,270
which is initially empty.

3710
02:16:11,479 --> 02:16:13,160
I'll move this over to the right hand side.

3711
02:16:14,270 --> 02:16:18,689
But when I now run this program with Python of phonebook.ie,

3712
02:16:20,209 --> 02:16:21,899
I'll type in say Kelly's name,

3713
02:16:22,049 --> 02:16:27,529
E + 16,174,951,000 enter and voila,

3714
02:16:27,580 --> 02:16:32,160
it ends up in the CSV using a little bit less code than we had to last time with C.

3715
02:16:32,450 --> 02:16:38,250
Let's run it once more and I'll type in my name and I'll again use +1 617495 1000 enter.

3716
02:16:38,570 --> 02:16:40,160
It's being appended to that file as well.

3717
02:16:40,190 --> 02:16:43,410
And one last time for John + 19494.

3718
02:16:43,549 --> 02:16:46,599
682,750 enter voila.

3719
02:16:46,690 --> 02:16:50,558
So it's pretty easy that is to say in Python to start creating files like this,

3720
02:16:50,690 --> 02:16:52,440
but this isn't really Pythonic.

3721
02:16:52,650 --> 02:16:54,580
Let me in fact close the CSV file,

3722
02:16:54,650 --> 02:16:55,599
hide my terminal,

3723
02:16:55,769 --> 02:16:58,360
and propose that we can tighten up this code a bit too.

3724
02:16:58,570 --> 02:17:01,638
I don't need to open up the file way up here.

3725
02:17:01,808 --> 02:17:05,330
I can go ahead and get my variables values this way first.

3726
02:17:05,410 --> 02:17:05,679
And in fact,

3727
02:17:05,730 --> 02:17:07,450
I could have done that code a little later anyway.

3728
02:17:07,799 --> 02:17:09,730
But I can do this in Python.

3729
02:17:09,900 --> 02:17:14,250
I can say with the following file opened phonebook.

3730
02:17:14,540 --> 02:17:18,929
CSV in a pended mode and refer to it as a variable called file,

3731
02:17:19,339 --> 02:17:20,490
do this stuff

3732
02:17:20,740 --> 02:17:22,370
and close the file yourself.

3733
02:17:22,700 --> 02:17:26,700
So this program's suddenly significantly shorter because this one line has the

3734
02:17:26,700 --> 02:17:28,888
effect of opening the file for me in a pen mode,

3735
02:17:29,019 --> 02:17:30,360
assign it to a variable,

3736
02:17:30,540 --> 02:17:31,250
do this stuff,

3737
02:17:31,259 --> 02:17:31,500
and.

3738
02:17:31,599 --> 02:17:34,230
As soon as the program's indentation ends and

3739
02:17:34,230 --> 02:17:36,500
there's code over here or no code whatsoever,

3740
02:17:36,709 --> 02:17:38,480
the file gets closed for me automatically.

3741
02:17:38,580 --> 02:17:40,709
This just helps us avoid like memory leaks and like

3742
02:17:40,709 --> 02:17:43,750
stupid mistakes we've made in C because you forget to close

3743
02:17:43,750 --> 02:17:45,629
a file that you have to open and you don't

3744
02:17:45,629 --> 02:17:47,709
necessarily notice unless you run Valgrind or something on it.

3745
02:17:47,910 --> 02:17:51,179
Python tries to avoid this by giving you a new keyword with

3746
02:17:51,429 --> 02:17:55,620
that doesn't really make sense semantically except with the following file open

3747
02:17:55,870 --> 02:17:57,589
and it will close the file for you.

3748
02:17:57,669 --> 02:17:59,870
So that's 2 among the features that you sort of get.

3749
02:18:00,539 --> 02:18:01,329
With Python,

3750
02:18:01,458 --> 02:18:04,088
the catch though is that the CSV is fairly simplistic.

3751
02:18:04,218 --> 02:18:04,727
In particular,

3752
02:18:04,779 --> 02:18:09,008
it's missing a header row that actually indicates what is in each of the columns.

3753
02:18:09,018 --> 02:18:09,329
In fact,

3754
02:18:09,378 --> 02:18:11,579
if I go ahead and run code of phonebook.

3755
02:18:11,818 --> 02:18:12,449
CSV,

3756
02:18:12,539 --> 02:18:15,409
we'll see again that the file contains just one row for Kelly,

3757
02:18:15,579 --> 02:18:15,968
for me,

3758
02:18:16,218 --> 02:18:16,848
and for John,

3759
02:18:16,898 --> 02:18:18,699
whereas ideally it would look a little

3760
02:18:18,699 --> 02:18:20,449
something more like this Google Sheet version,

3761
02:18:20,458 --> 02:18:24,018
which actually has at the very first row something saying name and number,

3762
02:18:24,039 --> 02:18:25,768
which then describes the data therein,

3763
02:18:25,779 --> 02:18:27,739
after which are the three actual rows.

3764
02:18:27,829 --> 02:18:28,579
Now the simplest.

3765
02:18:28,900 --> 02:18:32,490
here frankly would probably be to just start with

3766
02:18:32,740 --> 02:18:35,259
name number at the top of the file and then

3767
02:18:35,259 --> 02:18:38,429
assume that my phonebook.ie program is just going to append,

3768
02:18:38,620 --> 02:18:39,099
append,

3769
02:18:39,179 --> 02:18:43,370
append additional rows to the file containing the names and numbers respectively.

3770
02:18:43,459 --> 02:18:44,780
I could have done that from the get-go,

3771
02:18:44,790 --> 02:18:48,099
and in fact that would be better than putting some code inside

3772
02:18:48,099 --> 02:18:51,540
of phonebook.ie that writes out that specific row because after all,

3773
02:18:51,580 --> 02:18:54,169
if I'm running this program again and again,

3774
02:18:54,259 --> 02:18:58,178
I don't want the header row to appear again and again and And unless I

3775
02:18:58,178 --> 02:19:01,088
complicate the program a little bit to ensure that I only do that once.

3776
02:19:01,298 --> 02:19:04,378
But assuming that I do go into phonebook.csv and from the

3777
02:19:04,378 --> 02:19:07,249
get-go do have a file that contains name and number,

3778
02:19:07,458 --> 02:19:11,489
we can actually start to improve upon the implementation of Phonebook.ie

3779
02:19:12,058 --> 02:19:15,329
because we can take advantage of the fact that my dictionary

3780
02:19:15,699 --> 02:19:19,928
can actually that my writer can actually read that same header.

3781
02:19:20,018 --> 02:19:20,218
In fact,

3782
02:19:20,298 --> 02:19:23,999
let me put these files side by side here and then in phonebook.ie,

3783
02:19:24,058 --> 02:19:25,648
let's go ahead and transition away.

3784
02:19:25,709 --> 02:19:30,218
From using a writer to using a so-called dictionary writer or dict writer for short,

3785
02:19:30,459 --> 02:19:32,730
capital D W and then let me go ahead

3786
02:19:32,730 --> 02:19:37,110
and specify one additional argument to this particular function,

3787
02:19:37,299 --> 02:19:38,540
namely field names,

3788
02:19:38,570 --> 02:19:40,980
which I know exists because I looked it up in the documentation,

3789
02:19:41,058 --> 02:19:44,620
and the value of this argument is supposed to be a list of the fields

3790
02:19:44,620 --> 02:19:47,820
that are presumed to exist in the CSV that we're about to write to.

3791
02:19:47,860 --> 02:19:49,410
So I'm going to do quote unquote name,

3792
02:19:50,099 --> 02:19:50,929
unquote number.

3793
02:19:51,169 --> 02:19:52,059
The lines a bit long,

3794
02:19:52,139 --> 02:19:53,049
so it's scrolling there,

3795
02:19:53,059 --> 02:19:54,139
but if I scroll back to the left.

3796
02:19:54,230 --> 02:19:56,410
We see that the line is otherwise unchanged,

3797
02:19:56,540 --> 02:19:59,570
but when I go down now to right each respective row,

3798
02:19:59,740 --> 02:20:02,650
notice that I don't have to rely on this list,

3799
02:20:02,700 --> 02:20:07,339
which just assumes somewhat naively that name will always be in the first column

3800
02:20:07,339 --> 02:20:10,370
or column 0 and number will always be in the second or column 1.

3801
02:20:10,580 --> 02:20:11,019
After all,

3802
02:20:11,099 --> 02:20:13,049
if someone were to move that data around,

3803
02:20:13,099 --> 02:20:16,410
at least in the spreadsheet using Excel or Google Sheets or something else,

3804
02:20:16,620 --> 02:20:18,820
my code would end up being fairly fragile because at

3805
02:20:18,820 --> 02:20:22,009
the moment it's just assuming blindly that name goes first,

3806
02:20:22,259 --> 02:20:22,620
followed by.

3807
02:20:22,750 --> 02:20:23,250
Number,

3808
02:20:23,459 --> 02:20:27,459
but once we have that header row in there and tell dict writer about it,

3809
02:20:27,660 --> 02:20:32,099
we can actually now pass in not a list but an actual dictionary of key value pairs and

3810
02:20:32,099 --> 02:20:34,900
let the dictionary writer figure out where in the

3811
02:20:34,900 --> 02:20:37,450
file which column those values should go in.

3812
02:20:37,660 --> 02:20:38,709
So inside of this dictionary,

3813
02:20:38,740 --> 02:20:40,070
I'm going to have one key called name,

3814
02:20:40,099 --> 02:20:42,650
the value of which is indeed the name the user typed in.

3815
02:20:42,740 --> 02:20:45,059
The second key of which is going to be quote unquote number,

3816
02:20:45,099 --> 02:20:47,570
the value of which is the number that the user typed in.

3817
02:20:47,700 --> 02:20:49,860
And let me go back actually now and fix a typo from earlier.

3818
02:20:49,900 --> 02:20:51,139
We're only asking the user for.

3819
02:20:51,370 --> 02:20:51,750
Number.

3820
02:20:51,900 --> 02:20:53,700
So all this time I should have just requested

3821
02:20:53,700 --> 02:20:56,690
one number aesthetically with my input function there.

3822
02:20:57,059 --> 02:21:00,089
Now notice I have the file ready to go.

3823
02:21:00,179 --> 02:21:00,459
Indeed,

3824
02:21:00,469 --> 02:21:01,730
name and number are there.

3825
02:21:01,900 --> 02:21:04,980
That matches the field names I've provided to my code and it

3826
02:21:04,980 --> 02:21:08,639
matches the key value pairs that I'm subsequently passing to right row.

3827
02:21:08,940 --> 02:21:10,179
So let's go ahead and give this a try.

3828
02:21:10,259 --> 02:21:13,919
Let me go ahead and run again with this otherwise empty CSV file,

3829
02:21:14,139 --> 02:21:15,049
say for the header

3830
02:21:15,660 --> 02:21:19,580
phonebook.ie with Python of phonebook.ie.

3831
02:21:20,139 --> 02:21:20,549
Enter.

3832
02:21:20,650 --> 02:21:21,849
I'm gonna now go ahead and type in,

3833
02:21:21,860 --> 02:21:22,490
say the first name,

3834
02:21:22,519 --> 02:21:23,610
which was Kelly before,

3835
02:21:23,740 --> 02:21:28,339
plus 1617495 1000 and watch what happens at top right.

3836
02:21:28,980 --> 02:21:31,059
Kelly and her number end up in the file,

3837
02:21:31,120 --> 02:21:33,860
even though I didn't actually specify explicitly as with

3838
02:21:33,860 --> 02:21:37,360
the list or numeric indices which value goes where.

3839
02:21:37,540 --> 02:21:42,650
Let's run it once more and put in myself again plus 1617495 1000.

3840
02:21:42,679 --> 02:21:44,870
Enter and there again I am.

3841
02:21:44,980 --> 02:21:45,580
And lastly,

3842
02:21:45,620 --> 02:21:46,339
just for good measure,

3843
02:21:46,419 --> 02:21:48,219
let's go ahead and put John back in the file with.

3844
02:21:48,419 --> 02:21:52,059
Plus 1949468-2750,

3845
02:21:52,099 --> 02:21:53,929
which if you still haven't called or texted,

3846
02:21:54,179 --> 02:21:54,929
do feel free.

3847
02:21:55,099 --> 02:21:56,820
Enter and voila in phonebook.

3848
02:21:56,940 --> 02:22:00,030
CSV we have all of those same rows and code that's a little

3849
02:22:00,030 --> 02:22:03,889
more resilient now against any changes we might subsequently make there too.

3850
02:22:04,309 --> 02:22:04,419
All right,

3851
02:22:04,500 --> 02:22:07,820
how about now some final flourishes using some other features of

3852
02:22:07,820 --> 02:22:10,450
Python that we did see a glimpse of some time ago,

3853
02:22:10,700 --> 02:22:13,969
namely the ability to install libraries of our own choice.

3854
02:22:14,059 --> 02:22:15,860
So up until now in CS50.dv,

3855
02:22:15,900 --> 02:22:16,769
we CS 50.

3856
02:22:16,830 --> 02:22:18,849
have pre-installed most of what you need,

3857
02:22:19,219 --> 02:22:21,860
including back in the earliest weeks of the

3858
02:22:21,860 --> 02:22:24,339
class when we had that Calay program that I

3859
02:22:24,339 --> 02:22:26,139
wrote that was using a third party library that

3860
02:22:26,139 --> 02:22:28,690
I had installed into my codespace in advance.

3861
02:22:28,860 --> 02:22:28,980
Well,

3862
02:22:29,019 --> 02:22:31,700
you can use a program called PIP to

3863
02:22:31,700 --> 02:22:35,139
install Python packages into your own code space and

3864
02:22:35,139 --> 02:22:38,730
if you're using your own Mac and PC onto your own Macs and PCs as well,

3865
02:22:38,780 --> 02:22:41,969
if those libraries are freely available as open source

3866
02:22:41,969 --> 02:22:45,219
online and in the repository from which the Python.

3867
02:22:45,860 --> 02:22:46,049
Uh,

3868
02:22:46,089 --> 02:22:47,660
PI program actually draws.

3869
02:22:47,780 --> 02:22:51,900
Let me go back to VS code and let me go ahead and create a new program called Cow.i.

3870
02:22:52,099 --> 02:22:53,059
And with this program,

3871
02:22:53,139 --> 02:22:55,809
I'm going to go ahead and import that library CalSay,

3872
02:22:56,120 --> 02:22:59,740
and after that I'm going to call coa.cal quote unquote,

3873
02:22:59,940 --> 02:23:02,650
say this is CS 50 to have a cute little cow on the screen,

3874
02:23:02,820 --> 02:23:03,849
say exactly that.

3875
02:23:04,059 --> 02:23:06,660
Now in a previous lecture I had pre-installed this library,

3876
02:23:06,820 --> 02:23:09,169
but suppose I had forgotten to do so today.

3877
02:23:09,379 --> 02:23:12,169
Let's see what other type of error we'll see on the screen.

3878
02:23:12,219 --> 02:23:12,309
Well,

3879
02:23:12,339 --> 02:23:14,450
let me go ahead and run Python of cow.ie.

3880
02:23:14,605 --> 02:23:17,115
Enter and there's another one of those trace backs.

3881
02:23:17,174 --> 02:23:19,754
This one's a little more straightforward than the name error

3882
02:23:19,754 --> 02:23:21,504
and the value error we saw in the past.

3883
02:23:21,674 --> 02:23:24,144
This is a literally module not found error,

3884
02:23:24,325 --> 02:23:25,834
no module named CalSay.

3885
02:23:25,915 --> 02:23:25,995
Well,

3886
02:23:26,075 --> 02:23:27,785
this is where the PI command comes in.

3887
02:23:27,995 --> 02:23:31,915
If something hasn't been preinstalled for you in CS50.dev or

3888
02:23:31,915 --> 02:23:33,905
in the real world on whatever system you're using,

3889
02:23:33,995 --> 02:23:37,275
you can use PI install CalSay,

3890
02:23:37,285 --> 02:23:38,955
and assuming you've spelled it correctly and

3891
02:23:38,955 --> 02:23:40,584
assuming the library is publicly available,

3892
02:23:40,714 --> 02:23:43,355
hitting E will result in Pip automatically download.

3893
02:23:43,500 --> 02:23:46,599
In the latest version installing it in this case into your code space,

3894
02:23:46,900 --> 02:23:49,009
and solving hopefully that problem.

3895
02:23:49,089 --> 02:23:50,480
Let me clear my terminal window.

3896
02:23:50,719 --> 02:23:52,419
Run Python of cow.ie again,

3897
02:23:52,650 --> 02:23:53,860
definitely cross my fingers,

3898
02:23:53,870 --> 02:23:54,320
and

3899
02:23:54,610 --> 02:23:55,849
there's the most adorable cow,

3900
02:23:55,889 --> 02:23:57,570
and if we full screen the terminal,

3901
02:23:57,610 --> 02:24:00,940
we'll see that he's indeed saying this is CS 50.

3902
02:24:01,129 --> 02:24:03,759
Now that's just one of the things we can install with Coway.

3903
02:24:03,769 --> 02:24:07,450
I could also install libraries onto my own Mac and PC.

3904
02:24:07,530 --> 02:24:07,730
In fact,

3905
02:24:07,750 --> 02:24:09,650
in just a moment I'm going to switch over to another

3906
02:24:09,650 --> 02:24:12,290
computer here where I have a terminal window open on my.

3907
02:24:12,394 --> 02:24:16,254
My own actual Mac and I'm doing this because I'd like to play around with some speech,

3908
02:24:16,655 --> 02:24:19,334
some text to speech library functionality

3909
02:24:19,495 --> 02:24:22,584
which you can't really do in CS50.dev because it's browser

3910
02:24:22,584 --> 02:24:24,495
based and when you run code in the cloud,

3911
02:24:24,535 --> 02:24:28,214
it's not going to pass the audio along to your speakers on your laptop or desktop.

3912
02:24:28,464 --> 02:24:32,094
But if I'm running Python and my own code on my own computer,

3913
02:24:32,144 --> 02:24:34,514
a Mac in this case or a PC in someone else's case,

3914
02:24:34,785 --> 02:24:36,665
I can install that kind of library,

3915
02:24:36,875 --> 02:24:37,735
speech to text,

3916
02:24:37,945 --> 02:24:41,105
and have my own code on my own computer use my own.

3917
02:24:41,290 --> 02:24:44,589
Speakers to verbalize some string quite like that.

3918
02:24:44,799 --> 02:24:46,120
So how can I go about doing this?

3919
02:24:46,160 --> 02:24:46,709
Well,

3920
02:24:46,959 --> 02:24:48,200
I read some documentation,

3921
02:24:48,280 --> 02:24:52,160
I'm going to go ahead and install with PI a library called Pi

3922
02:24:52,580 --> 02:24:55,910
to Text to Speech version 3.

3923
02:24:56,080 --> 02:25:00,200
Hitting Enter goes and spines and downloads as needed the library if

3924
02:25:00,200 --> 02:25:02,790
it's not already installed and then brings me back to my terminal.

3925
02:25:02,879 --> 02:25:05,309
And I'm going to use an older school program here called

3926
02:25:05,309 --> 02:25:08,750
Vim or VI to actually implement a Cal program on this computer

3927
02:25:09,040 --> 02:25:10,129
whereby I'm going to go.

3928
02:25:10,184 --> 02:25:12,815
Head and write some code using this library without

3929
02:25:12,815 --> 02:25:15,634
VS code but with just another text editor instead.

3930
02:25:15,855 --> 02:25:17,575
To do this at the very top of my file,

3931
02:25:17,584 --> 02:25:19,485
I'm going to import this library

3932
02:25:19,735 --> 02:25:21,134
called Python Text to Speech,

3933
02:25:21,334 --> 02:25:25,695
so PY TT SX3 for version 3,

3934
02:25:25,775 --> 02:25:28,924
and then I'm going to use only 3 lines of code to synthesize some voice.

3935
02:25:29,054 --> 02:25:31,205
I'm going to say a variable called engine,

3936
02:25:31,455 --> 02:25:34,445
set it equal to pittsX3.

3937
02:25:34,594 --> 02:25:36,575
in it because the documentation taught me that I need

3938
02:25:36,575 --> 02:25:38,974
to initialize the library the first time I use it.

3939
02:25:39,219 --> 02:25:41,049
I can then use this variable called engine

3940
02:25:41,049 --> 02:25:43,690
to actually say something quite like scratch,

3941
02:25:43,769 --> 02:25:45,759
albeit verbally instead of pictorally,

3942
02:25:45,929 --> 02:25:47,669
like this is CS 50,

3943
02:25:47,950 --> 02:25:48,599
quote unquote,

3944
02:25:48,730 --> 02:25:52,849
and then lastly I can use engine.ru and wait

3945
02:25:52,849 --> 02:25:54,969
similar to some scratch blocks so that the whole

3946
02:25:55,070 --> 02:25:58,160
Expression is actually verbalized before my program actually quits.

3947
02:25:58,299 --> 02:25:58,410
Now,

3948
02:25:58,419 --> 02:25:59,309
the first time I run this,

3949
02:25:59,320 --> 02:26:02,019
it might take a moment for the library indeed to initialize itself,

3950
02:26:02,099 --> 02:26:04,889
but on my own Mac here I'm going to run Pythono cow.ie.

3951
02:26:05,120 --> 02:26:06,860
If we could raise the volume just a little bit,

3952
02:26:07,019 --> 02:26:08,570
hopefully we'll not see

3953
02:26:08,900 --> 02:26:10,740
but hear this cow's greeting.

3954
02:26:11,759 --> 02:26:12,879
This is CS 50.

3955
02:26:14,059 --> 02:26:15,580
It was very much in a rush to say it,

3956
02:26:15,620 --> 02:26:17,290
but after initializing for that long,

3957
02:26:17,339 --> 02:26:19,620
and if we ran it again and again and added some optimizations,

3958
02:26:19,660 --> 02:26:21,540
we could get it talking much more quickly than that.

3959
02:26:21,740 --> 02:26:24,660
But we now have a version of the program that indeed verbalizes what

3960
02:26:24,660 --> 02:26:28,849
string or stir it is that I've passed into it here CS 5.

3961
02:26:29,519 --> 02:26:30,929
It's really in a rush to finish there.

3962
02:26:31,179 --> 02:26:31,230
All right,

3963
02:26:31,349 --> 02:26:34,820
let's try one final flourish of another library that's fun to play around with,

3964
02:26:34,870 --> 02:26:38,940
if only because it'll motivate some of the things you can now do in Python yourself.

3965
02:26:39,169 --> 02:26:43,419
Let me go into VS code in my code space because this one does not require my speakers.

3966
02:26:43,549 --> 02:26:45,540
I'll close that first version of the cow,

3967
02:26:45,669 --> 02:26:47,910
and I'm going to go ahead and create a QR code

3968
02:26:47,910 --> 02:26:53,280
generator after installing with PI a library called QR code,

3969
02:26:53,309 --> 02:26:54,379
which I read about online,

3970
02:26:54,429 --> 02:26:56,629
and now it's Installed in my code space.

3971
02:26:56,759 --> 02:27:00,320
I'm going to now go ahead and create a file called qr.ie.

3972
02:27:00,759 --> 02:27:02,790
So let's go ahead and code up QR.ie,

3973
02:27:02,799 --> 02:27:04,400
and I want to generate my own QR codes.

3974
02:27:04,480 --> 02:27:05,830
Most of you in the are in the habit.

3975
02:27:05,839 --> 02:27:07,790
If you've ever generated a QR code before,

3976
02:27:07,919 --> 02:27:10,599
you probably just Google around for some generator online for

3977
02:27:10,599 --> 02:27:12,790
which someone else wrote code to generate the QR code,

3978
02:27:12,910 --> 02:27:16,830
but I can do that for myself and actually generate my own images.

3979
02:27:16,919 --> 02:27:19,509
I'm going to go ahead and import the library that I just installed,

3980
02:27:19,679 --> 02:27:20,919
import QR code.

3981
02:27:21,089 --> 02:27:23,360
And then below that I'm going to create a variable called,

3982
02:27:23,490 --> 02:27:23,969
for instance,

3983
02:27:23,980 --> 02:27:28,959
image and set that equal to this library's QR code.make function,

3984
02:27:29,169 --> 02:27:31,519
no relation to the make that we use for C,

3985
02:27:31,690 --> 02:27:33,919
and I'm going to make a QR code containing a URL,

3986
02:27:33,969 --> 02:27:35,209
maybe of one of the lecture videos.

3987
02:27:35,330 --> 02:27:37,719
So let's do HTTPS call in slash

3988
02:27:38,169 --> 02:27:39,929
Youtube.com,

3989
02:27:40,009 --> 02:27:40,959
the short version,

3990
02:27:41,169 --> 02:27:46,530
and then XVFZJO5PG.

3991
02:27:48,110 --> 02:27:48,700
Uh,

3992
02:27:49,150 --> 02:27:51,700
GG 0 if I got that just right.

3993
02:27:52,190 --> 02:27:55,179
Then after that I'm going to go ahead and call image.save

3994
02:27:55,179 --> 02:28:00,049
to save that URL as a file called qr.png quote unquote,

3995
02:28:00,179 --> 02:28:02,910
and then PNG will be the format which is portable network graphic,

3996
02:28:02,950 --> 02:28:05,790
which is akin to a JPEG or a GIF but with different features.

3997
02:28:05,910 --> 02:28:07,669
I'm just going to double check my writing here so we

3998
02:28:07,669 --> 02:28:11,379
go to the right lecture video and I think we are

3999
02:28:11,629 --> 02:28:12,459
indeed good.

4000
02:28:12,589 --> 02:28:16,469
And what that should do after running my code is leave me with today's final flur.

4001
02:28:16,790 --> 02:28:20,580
a ping file in my code space that when opened is going

4002
02:28:20,580 --> 02:28:22,969
to be QR code that you can scan with your phone.

4003
02:28:23,099 --> 02:28:24,919
So if you'd like to get ready for this final flourish,

4004
02:28:25,179 --> 02:28:28,450
I'm going to go ahead and run Pythonoqr.ie and hit enter.

4005
02:28:28,940 --> 02:28:29,839
Thankfully it worked.

4006
02:28:30,019 --> 02:28:31,610
I'm going to now open up

4007
02:28:32,259 --> 02:28:35,900
QR.png and close my terminal window and for our

4008
02:28:35,900 --> 02:28:37,969
final moments together this year in week 6,

4009
02:28:37,980 --> 02:28:40,129
after which we'll ultimately transition to

4010
02:28:40,339 --> 02:28:42,830
yet more languages and problems to be solved.

4011
02:28:43,099 --> 02:28:45,059
Here is a final code for you to scan.

4012
02:28:45,599 --> 02:28:47,509
Of today's here lecture.

4013
02:28:52,900 --> 02:28:53,299
All right,

4014
02:28:53,379 --> 02:28:54,089
that's it for today.

4015
02:28:54,209 --> 02:28:55,910
We'll see you next time.