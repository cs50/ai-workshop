0
00:00:43,650 --> 00:00:43,659
All

1
00:00:44,560 --> 00:00:45,080
right,

2
00:00:45,319 --> 00:00:46,950
this is CS 50,

3
00:00:47,049 --> 00:00:49,509
and this is already week 7 where

4
00:00:49,580 --> 00:00:51,799
wherein we introduce another programming language,

5
00:00:51,840 --> 00:00:56,310
this time known as structured query language or SQL or SQL for short.

6
00:00:56,520 --> 00:00:57,290
Now SQL,

7
00:00:57,319 --> 00:00:57,919
as we'll see,

8
00:00:57,930 --> 00:01:00,880
is a different sort of programming language that allows us to solve like a lot of

9
00:01:00,880 --> 00:01:02,610
the same kinds of problems that we've been

10
00:01:02,610 --> 00:01:04,040
dabbling with over the past several weeks,

11
00:01:04,120 --> 00:01:04,459
but

12
00:01:04,720 --> 00:01:06,059
arguably in a lot of contexts,

13
00:01:06,120 --> 00:01:08,559
it allows us to solve those problems more easily.

14
00:01:08,599 --> 00:01:08,879
Indeed,

15
00:01:08,959 --> 00:01:09,529
among the goals for.

16
00:01:09,739 --> 00:01:12,629
Today are to demonstrate that sometimes there's multiple tools

17
00:01:12,629 --> 00:01:14,360
that you can use to solve the same problem,

18
00:01:14,389 --> 00:01:18,029
whether it's C or Python or today's SQL but we'll also see

19
00:01:18,029 --> 00:01:22,260
that SQL allows us a different sort of approach to solving problems,

20
00:01:22,269 --> 00:01:25,949
whereas C very much so and Python to a large extent are

21
00:01:25,949 --> 00:01:28,949
very much procedural programming languages whereby

22
00:01:28,949 --> 00:01:30,069
you have to write these procedures,

23
00:01:30,160 --> 00:01:32,819
functions step by step that tell the computer what to do,

24
00:01:33,150 --> 00:01:35,260
including loops and conditionals and all of that.

25
00:01:35,550 --> 00:01:38,019
SQL is said to be a declarative programming language,

26
00:01:38,059 --> 00:01:41,540
which is a different sort of paradigm whereby when you want to solve some problem you

27
00:01:41,540 --> 00:01:44,419
essentially declare what problem you want to solve

28
00:01:44,419 --> 00:01:46,250
or you declare what question you have,

29
00:01:46,379 --> 00:01:49,169
and it's up to the programming language to figure out using

30
00:01:49,169 --> 00:01:52,089
loops and conditionals and all of those lower level building blocks,

31
00:01:52,139 --> 00:01:53,459
how to get you the answer.

32
00:01:53,500 --> 00:01:56,620
So ultimately today is all about teaching you yet another language,

33
00:01:56,739 --> 00:01:59,220
mostly so that you can learn again to teach

34
00:01:59,220 --> 00:02:01,379
yourself new languages and to appreciate that when.

35
00:02:01,500 --> 00:02:04,620
You exit a class like CS 15 or out there in the real world

36
00:02:04,620 --> 00:02:07,800
really isn't all that big a deal to pick up new programming languages,

37
00:02:08,089 --> 00:02:10,089
especially when in advance you've seen

38
00:02:10,089 --> 00:02:12,639
different programming paradigms like procedural,

39
00:02:12,889 --> 00:02:14,119
like object oriented,

40
00:02:14,399 --> 00:02:16,199
like today declarative as well.

41
00:02:16,369 --> 00:02:19,009
But today ultimately is also about data and so to get us started,

42
00:02:19,050 --> 00:02:21,050
we thought we'd collect some real world data by

43
00:02:21,050 --> 00:02:22,929
asking all of you a couple of questions.

44
00:02:23,050 --> 00:02:27,320
So if on your laptop or phone you would like to pull up this URL here.

45
00:02:28,270 --> 00:02:31,649
It will also exists in just a moment in QR code form.

46
00:02:31,699 --> 00:02:33,449
So if you'd like to go to that URL there

47
00:02:33,449 --> 00:02:36,490
or simply scan this here QR code with your phone,

48
00:02:36,699 --> 00:02:38,500
that's going to lead you to a Google form.

49
00:02:38,550 --> 00:02:39,300
For those unfamiliar,

50
00:02:39,419 --> 00:02:40,429
Google has lots of tools,

51
00:02:40,539 --> 00:02:41,410
among which are,

52
00:02:41,630 --> 00:02:41,949
uh,

53
00:02:41,960 --> 00:02:45,300
is a tool via which you can ask people questions via forms.

54
00:02:45,339 --> 00:02:47,570
Microsoft has something similar as well,

55
00:02:47,820 --> 00:02:49,380
and at that URL.

56
00:02:50,024 --> 00:02:53,085
What you'll soon see is a form

57
00:02:53,414 --> 00:02:56,294
that looks a little something like this among

58
00:02:56,294 --> 00:02:58,565
whose questions are which is your favorite language,

59
00:02:58,574 --> 00:03:00,645
at least among those we've studied thus far.

60
00:03:00,854 --> 00:03:04,304
So go ahead and anonymously answer the questions you see on this form

61
00:03:04,735 --> 00:03:08,205
you'll see which is your favorite language and also which is your favorite

62
00:03:08,574 --> 00:03:11,604
problem in problem sets thus far.

63
00:03:11,949 --> 00:03:13,169
And meanwhile,

64
00:03:13,380 --> 00:03:13,949
as you might know,

65
00:03:14,020 --> 00:03:16,330
if you've used Google Forms yourself to collect data,

66
00:03:16,380 --> 00:03:18,110
we can move from questions here

67
00:03:18,380 --> 00:03:19,850
to actual responses.

68
00:03:19,860 --> 00:03:21,130
And as people start to buzz in,

69
00:03:21,220 --> 00:03:24,000
we'll see that the data set here is starting to update in real time,

70
00:03:24,009 --> 00:03:26,699
and Google gives us these nice graphical user interfaces

71
00:03:26,699 --> 00:03:28,500
or GUIs via which we can analyze the data.

72
00:03:28,539 --> 00:03:28,949
And so far,

73
00:03:29,020 --> 00:03:33,139
Python is easily the winner with 70% plus of you preferring it,

74
00:03:33,149 --> 00:03:34,289
11% of you,

75
00:03:34,660 --> 00:03:35,830
wishing we were still in scratch,

76
00:03:36,779 --> 00:03:38,330
and 18% of you in C,

77
00:03:38,619 --> 00:03:40,369
and you'll see the responses are coming in here,

78
00:03:40,429 --> 00:03:41,520
but for our purposes.

79
00:03:41,671 --> 00:03:41,811
Today,

80
00:03:41,850 --> 00:03:44,960
what's more interesting than the actual answers to these questions

81
00:03:44,960 --> 00:03:47,091
is how we can get at the raw data.

82
00:03:47,151 --> 00:03:48,690
So among the things you can do in Google

83
00:03:48,690 --> 00:03:51,610
Sheets is quite literally click View in sheets,

84
00:03:51,690 --> 00:03:53,201
which is in Google Forms,

85
00:03:53,210 --> 00:03:54,690
is click on View in sheets,

86
00:03:54,731 --> 00:03:58,011
and what this is going to allow me to do is access the underlying raw data.

87
00:03:58,091 --> 00:04:00,011
Now because Google has forms and spreadsheets,

88
00:04:00,050 --> 00:04:02,001
they sort of tied these two products together.

89
00:04:02,130 --> 00:04:05,291
But what's especially nice about Google spreadsheets is that

90
00:04:05,531 --> 00:04:08,011
I can also download the raw data as a file.

91
00:04:08,050 --> 00:04:09,610
I can download it as an Excel file,

92
00:04:09,651 --> 00:04:10,210
a text file,

93
00:04:10,251 --> 00:04:10,701
a PDF,

94
00:04:10,770 --> 00:04:15,682
but for Today we're going to download it in a very common format known as CSV for

95
00:04:16,161 --> 00:04:17,122
separated values.

96
00:04:17,161 --> 00:04:17,511
And indeed,

97
00:04:17,522 --> 00:04:19,152
if I go to the file menu download

98
00:04:19,502 --> 00:04:20,281
separated values,

99
00:04:20,361 --> 00:04:22,272
this is perhaps the most

100
00:04:22,891 --> 00:04:23,502
straightforward,

101
00:04:23,641 --> 00:04:27,562
easiest way to get raw data out of any kind of tabular data

102
00:04:27,562 --> 00:04:30,552
like this to load it into code that we are about to write.

103
00:04:30,881 --> 00:04:32,122
So if you haven't buzzed in already,

104
00:04:32,161 --> 00:04:32,791
that's fine,

105
00:04:32,881 --> 00:04:33,761
but at this point in time,

106
00:04:33,802 --> 00:04:34,721
now that I've clicked the button,

107
00:04:34,761 --> 00:04:39,712
I now have a CSV file in my Mac downloads folder which if I go ahead and open up here,

108
00:04:39,881 --> 00:04:40,731
I can see that indeed.

109
00:04:40,842 --> 00:04:44,553
I've got this long named file favorite form responses1.csv.

110
00:04:44,792 --> 00:04:47,653
I'm going to shorten that file name to just favorites.csv.

111
00:04:47,933 --> 00:04:53,083
And what I'm going to go ahead and do is open up VS code and in my File Explorer,

112
00:04:53,153 --> 00:04:56,882
I'm going to literally just drag and drop favorites.csv from my Mac.

113
00:04:57,072 --> 00:05:00,912
That's going to have the effect of uploading the file as it was at that moment

114
00:05:00,912 --> 00:05:05,923
in time so that we can now begin to write some code using this file.

115
00:05:06,032 --> 00:05:08,662
And VS Code is automatically gone ahead and opened it up for me.

116
00:05:08,792 --> 00:05:12,354
And what you're looking at here is what we're Start to call a flat file database.

117
00:05:12,463 --> 00:05:16,694
It's a very lightweight database in the sense that it stores a lot of data,

118
00:05:16,864 --> 00:05:19,584
and it's a flat file in the sense that it's literally just a text file.

119
00:05:19,653 --> 00:05:20,574
And by convention,

120
00:05:20,623 --> 00:05:24,903
the way the data is stored in this file is indeed by separating values with commas.

121
00:05:24,944 --> 00:05:26,223
There are other conventions as well,

122
00:05:26,234 --> 00:05:28,294
but CSV is probably the de facto standard.

123
00:05:28,424 --> 00:05:30,973
But TSV is a thing for tab separated values.

124
00:05:30,984 --> 00:05:31,584
PSV,

125
00:05:31,664 --> 00:05:34,574
which is pipe separated values where you might have a vertical bar.

126
00:05:34,773 --> 00:05:37,664
Essentially these file formats try to use a character that

127
00:05:37,664 --> 00:05:39,984
might not appear in the actual data so as to.

128
00:05:40,105 --> 00:05:42,095
Separate your rows and columns.

129
00:05:42,174 --> 00:05:45,404
So indeed if I switch back to VS code here and we take a look at the data,

130
00:05:45,575 --> 00:05:49,274
you'll see that from Google Sheets I've been given three columns time stamp,

131
00:05:49,355 --> 00:05:51,125
which was automatically generated for me,

132
00:05:51,255 --> 00:05:53,364
the language as well as the problem,

133
00:05:53,575 --> 00:05:57,045
and what I see here is that we had a few respondents buzz in a little early,

134
00:05:57,295 --> 00:05:58,404
very excited for today's data,

135
00:05:58,454 --> 00:06:01,285
but here's the rest of them from like 1:30 p.m. Eastern onward,

136
00:06:01,454 --> 00:06:02,885
and you'll see separating

137
00:06:03,154 --> 00:06:06,575
separated via commas are effectively three columns of data.

138
00:06:06,635 --> 00:06:09,204
So everything before the first column represents a time stamp.

139
00:06:09,415 --> 00:06:09,654
Every.

140
00:06:09,925 --> 00:06:13,805
Between the 1st and 2nd comma represents the choice of language that

141
00:06:13,805 --> 00:06:16,716
you all buzzed in with and then everything after the 2nd comma

142
00:06:17,246 --> 00:06:18,205
represents the problem.

143
00:06:18,325 --> 00:06:20,605
Now it's kind of jagged edges.

144
00:06:20,645 --> 00:06:23,555
It doesn't line up in nice rows and columns because some answers are longer,

145
00:06:23,686 --> 00:06:24,526
some answers are shorter,

146
00:06:24,605 --> 00:06:26,196
but the commas are sufficient

147
00:06:26,365 --> 00:06:30,985
to tell the code we write where one column ends and the next one begins.

148
00:06:31,126 --> 00:06:33,605
So how do we go about writing code like this if we'd now like

149
00:06:33,605 --> 00:06:37,406
to ask some questions about the data like what is the most popular language,

150
00:06:37,446 --> 00:06:39,045
what is the most popular problem,

151
00:06:39,055 --> 00:06:39,286
or.

152
00:06:39,516 --> 00:06:40,036
Conversely,

153
00:06:40,117 --> 00:06:41,346
the least of each of those,

154
00:06:41,476 --> 00:06:41,766
well,

155
00:06:41,957 --> 00:06:44,907
we could look at the original data in Google forms,

156
00:06:45,036 --> 00:06:46,397
and that's where we got the pie chart.

157
00:06:46,437 --> 00:06:50,296
But how is Google figuring out what the most popular answers are and what

158
00:06:50,747 --> 00:06:52,907
uh pie charts it wants to depict?

159
00:06:53,157 --> 00:06:53,346
Well,

160
00:06:53,636 --> 00:06:56,707
they probably wrote some code not unlike what we're about to do,

161
00:06:56,717 --> 00:06:59,756
although we'll start with just a command line environment as always.

162
00:06:59,877 --> 00:07:01,036
So within VS code,

163
00:07:01,046 --> 00:07:02,516
I'm going to go ahead and do this.

164
00:07:02,636 --> 00:07:06,307
I'm going to go ahead and open up a program called Favorites.ie

165
00:07:06,636 --> 00:07:08,916
and let's write a program whose purpose in life is to open the.

166
00:07:08,997 --> 00:07:09,678
CSV file.

167
00:07:09,907 --> 00:07:10,828
Read it top to bottom,

168
00:07:10,907 --> 00:07:11,388
left to right,

169
00:07:11,567 --> 00:07:12,548
and then crunch some numbers,

170
00:07:12,597 --> 00:07:15,778
figure out what the most popular answers are to those questions.

171
00:07:16,028 --> 00:07:19,548
So I'm going to go ahead and import a package that comes with Python,

172
00:07:19,588 --> 00:07:21,347
a library called the CSV library,

173
00:07:21,627 --> 00:07:22,268
and nicely enough,

174
00:07:22,278 --> 00:07:25,308
this is just code that someone else wrote years ago that figures out how

175
00:07:25,308 --> 00:07:28,898
to read data from a file separating it via comma so that you and I

176
00:07:29,148 --> 00:07:31,018
don't have to write all of that ourselves.

177
00:07:31,227 --> 00:07:32,187
Then I'm going to use this

178
00:07:32,187 --> 00:07:36,727
Pythonic convention with open quote unquote favorites.csv

179
00:07:37,268 --> 00:07:38,217
as file.

180
00:07:38,628 --> 00:07:41,618
If I want to be super explicit that I intend only to read this file,

181
00:07:41,739 --> 00:07:42,648
which is the default,

182
00:07:42,819 --> 00:07:46,368
I'm going to go ahead and explicitly say quote unquote R just like we did in C

183
00:07:46,618 --> 00:07:49,648
when using F open to open a file and read mode.

184
00:07:49,799 --> 00:07:50,898
And now I'm going to do this.

185
00:07:51,019 --> 00:07:54,938
I'm going to go ahead and say reader equals csV.reader

186
00:07:55,528 --> 00:07:55,989
file.

187
00:07:56,178 --> 00:08:01,259
So this is a Python convention whereby the CSV library comes with a function called

188
00:08:01,259 --> 00:08:06,449
Reader that takes as its sole argument here a file that has already been opened,

189
00:08:06,528 --> 00:08:08,890
and what that reader will do is Figure out where all of

190
00:08:08,890 --> 00:08:12,100
the commas are so that I can iterate over this reader in a

191
00:08:12,100 --> 00:08:17,049
loop and get back row after row after row without me having to

192
00:08:17,049 --> 00:08:19,600
write all of the code to figure out where those commas are.

193
00:08:19,850 --> 00:08:25,040
So what I'm going to do in this loop here in this block of code is for each row

194
00:08:25,369 --> 00:08:26,359
in that reader,

195
00:08:26,529 --> 00:08:28,959
let's go ahead and just print out maybe

196
00:08:28,959 --> 00:08:32,450
the second column which was the language column.

197
00:08:32,489 --> 00:08:36,159
So I'm going to go ahead and say print row 1

198
00:08:36,719 --> 00:08:37,808
because what we'll see.

199
00:08:38,109 --> 00:08:39,558
Is that this reader,

200
00:08:39,698 --> 00:08:41,039
which again comes with Python,

201
00:08:41,258 --> 00:08:41,898
hands me

202
00:08:42,138 --> 00:08:42,847
a list,

203
00:08:42,979 --> 00:08:43,609
a list,

204
00:08:43,717 --> 00:08:49,129
a list for each of the rows wherein bracket 0 would represent the first column,

205
00:08:49,479 --> 00:08:50,809
1 would represent the 2nd,

206
00:08:50,859 --> 00:08:54,768
2 would represent the third because everything is 0 indexed in Python.

207
00:08:55,059 --> 00:08:55,338
All right,

208
00:08:55,419 --> 00:08:56,939
so let's see what the effect is here.

209
00:08:57,075 --> 00:08:58,705
Let me maximize my terminal window,

210
00:08:58,804 --> 00:09:00,594
run Pythonofas.ie,

211
00:09:01,065 --> 00:09:02,734
cross my finger that I got this right,

212
00:09:02,864 --> 00:09:03,905
and voila.

213
00:09:04,104 --> 00:09:06,905
There is every language that was selected by you all

214
00:09:06,905 --> 00:09:10,335
in the form from top to bottom by default chronologically.

215
00:09:10,465 --> 00:09:10,965
But

216
00:09:11,304 --> 00:09:12,505
there's a bit of a bug,

217
00:09:12,544 --> 00:09:13,195
I dare say.

218
00:09:13,224 --> 00:09:16,054
Let me scroll up and up and up in this output

219
00:09:16,784 --> 00:09:18,614
through all of these answers

220
00:09:19,224 --> 00:09:22,974
until I get to the very top where I ran the program myself,

221
00:09:23,065 --> 00:09:23,854
which is here,

222
00:09:23,945 --> 00:09:25,304
Pythonofavos.ie.

223
00:09:25,385 --> 00:09:26,705
There's a minor bug here.

224
00:09:27,760 --> 00:09:29,030
What's the bug in the output?

225
00:09:29,080 --> 00:09:29,359
yeah.

226
00:09:30,590 --> 00:09:30,859
Yeah,

227
00:09:30,979 --> 00:09:32,690
it accidentally includes the header,

228
00:09:32,750 --> 00:09:35,859
which is a bug in the sense that I really just wanted to see the languages,

229
00:09:36,020 --> 00:09:37,859
but the code is doing what I told it to,

230
00:09:37,940 --> 00:09:39,690
which is just print out every row.

231
00:09:39,820 --> 00:09:41,179
So there's a few ways we could ignore this.

232
00:09:41,260 --> 00:09:44,340
Let me go ahead and minimize my terminal window and let me go ahead and say,

233
00:09:44,460 --> 00:09:44,500
well,

234
00:09:44,739 --> 00:09:45,250
you know what,

235
00:09:45,419 --> 00:09:46,739
after we create this reader,

236
00:09:46,789 --> 00:09:48,500
let's just skip to the next.

237
00:09:49,140 --> 00:09:49,619
Uh,

238
00:09:49,820 --> 00:09:52,299
let's just skip to the next row and ignore

239
00:09:52,299 --> 00:09:56,190
it effectively and then begin iterating over everything thereafter.

240
00:09:56,380 --> 00:09:59,450
And so what happens now is if I re-maximize my window,

241
00:09:59,659 --> 00:10:02,849
rerun Python of favorites.ie,

242
00:10:03,140 --> 00:10:03,679
enter,

243
00:10:03,940 --> 00:10:08,690
and now scroll up again to the beginning of this incarnation of the program,

244
00:10:08,840 --> 00:10:14,219
you'll see that the very first thing I see after my program was run was indeed Python,

245
00:10:14,229 --> 00:10:14,619
Python,

246
00:10:14,659 --> 00:10:15,109
Python,

247
00:10:15,179 --> 00:10:15,729
Python,

248
00:10:15,739 --> 00:10:16,530
and so forth.

249
00:10:16,580 --> 00:10:18,299
No more quote unquote language.

250
00:10:19,067 --> 00:10:19,817
So how is that?

251
00:10:19,927 --> 00:10:19,997
Well,

252
00:10:20,067 --> 00:10:22,807
this is a feature we haven't quite seen

253
00:10:23,577 --> 00:10:25,447
before or talked about in much detail,

254
00:10:25,617 --> 00:10:28,257
but this reader is is stateful in some sense,

255
00:10:28,296 --> 00:10:31,617
and this was actually true of all of the file IO we didn't see whereby

256
00:10:31,617 --> 00:10:35,206
when you were using Fread or some other function to read data from the file,

257
00:10:35,577 --> 00:10:39,617
something was remembering where it was in the file so that

258
00:10:39,617 --> 00:10:42,086
you didn't get the same bytes again and again and again.

259
00:10:42,257 --> 00:10:44,497
It was more like a cassette tape,

260
00:10:44,536 --> 00:10:46,166
an old school cassette tape if you will,

261
00:10:46,296 --> 00:10:47,697
or a scrubber.

262
00:10:47,823 --> 00:10:51,054
Along the bar along the bottom of like any streaming video whereby

263
00:10:51,054 --> 00:10:53,294
when you just read some data it grabs the next chunk,

264
00:10:53,333 --> 00:10:53,854
the next chunk,

265
00:10:53,893 --> 00:10:54,374
the next chunk,

266
00:10:54,414 --> 00:10:55,013
the next drunk,

267
00:10:55,294 --> 00:10:58,453
and something inside of the computer's memory remembers where it is.

268
00:10:58,504 --> 00:11:02,864
So this says skip to the next row and thus when you do 4 row in reader,

269
00:11:03,013 --> 00:11:05,164
you get everything but the first row

270
00:11:05,453 --> 00:11:06,653
because the reader is stateful.

271
00:11:06,734 --> 00:11:08,244
It remembers where it is

272
00:11:08,533 --> 00:11:09,374
in memory.

273
00:11:09,684 --> 00:11:09,794
All right,

274
00:11:09,854 --> 00:11:12,093
well thus far this isn't all that useful because

275
00:11:12,093 --> 00:11:14,374
all I'm doing is just printing out the data,

276
00:11:14,414 --> 00:11:16,963
but let's take a step toward making this program a little more useful.

277
00:11:17,221 --> 00:11:17,721
Particular,

278
00:11:17,890 --> 00:11:21,810
let's just be a little more pedantic and specify that what I'm really doing

279
00:11:22,171 --> 00:11:27,161
here inside of this loop is figuring out what the current row's favorite is.

280
00:11:27,370 --> 00:11:31,560
So I'm going to create a variable called favorite and set that equal to row 1.

281
00:11:31,690 --> 00:11:32,241
And then,

282
00:11:32,291 --> 00:11:34,010
even though this doesn't change the functionality,

283
00:11:34,091 --> 00:11:36,560
I'm going to print that favorite just because semantically,

284
00:11:36,671 --> 00:11:37,520
stylistically,

285
00:11:37,531 --> 00:11:40,841
it's nice to know what row 1 is

286
00:11:41,171 --> 00:11:43,370
as by defining a variable that tells me or

287
00:11:43,370 --> 00:11:45,041
anyone else who reads this code in the future

288
00:11:45,330 --> 00:11:46,450
what it's actually doing.

289
00:11:46,799 --> 00:11:46,820
All right,

290
00:11:47,630 --> 00:11:50,109
but readers are only so useful,

291
00:11:50,119 --> 00:11:50,590
and in fact,

292
00:11:50,630 --> 00:11:52,820
if I were to open up this CSV file maybe

293
00:11:52,820 --> 00:11:55,739
in Microsoft Excel or Apple Numbers or Google Sheets again,

294
00:11:55,950 --> 00:11:59,390
you could imagine someone kind of moving the data by just dragging one of the columns

295
00:11:59,390 --> 00:12:04,229
to the left or the right such that now it's no longer time stamp language problem,

296
00:12:04,309 --> 00:12:07,909
maybe it's time stamp problem language or maybe time stamp is all.

297
00:12:08,020 --> 00:12:08,809
way over to the right,

298
00:12:08,849 --> 00:12:11,729
you can imagine therefore that the indices we're using

299
00:12:11,729 --> 00:12:14,690
01 and 2 could be a little fragile because if

300
00:12:14,690 --> 00:12:16,729
someone changes the data on me now my code

301
00:12:16,729 --> 00:12:19,460
is just going to break because I am blindly assuming

302
00:12:19,770 --> 00:12:21,250
that the second column,

303
00:12:21,289 --> 00:12:24,159
aka 1 is going to be

304
00:12:24,609 --> 00:12:26,090
the language column,

305
00:12:26,130 --> 00:12:27,440
but that might not be the case.

306
00:12:27,570 --> 00:12:29,090
But there's an alternative to this.

307
00:12:29,409 --> 00:12:30,960
And you might recall having seen this before,

308
00:12:31,039 --> 00:12:34,159
I'm going to go into favorites.ie and tweak my code a little bit,

309
00:12:34,210 --> 00:12:35,309
not just to use a reader,

310
00:12:35,520 --> 00:12:36,760
but a dictionary reader.

311
00:12:36,880 --> 00:12:39,869
So I'm going to change this to dict reader instead of just reader.

312
00:12:40,080 --> 00:12:44,030
And then the upside of using a dictionary reader is that every time

313
00:12:44,200 --> 00:12:47,450
I go through this loop reading row by row by row,

314
00:12:47,719 --> 00:12:48,549
each row

315
00:12:48,719 --> 00:12:51,200
that I'm handed by this reader is not going to

316
00:12:51,200 --> 00:12:53,960
be a list anymore that's numerically indexed with zeros and

317
00:12:54,080 --> 00:12:55,270
ones and twos.

318
00:12:55,280 --> 00:12:56,789
Each row is going to be,

319
00:12:56,849 --> 00:12:57,559
as you might guess,

320
00:12:57,679 --> 00:12:58,200
a

321
00:12:59,159 --> 00:13:00,140
A dictionary,

322
00:13:00,179 --> 00:13:01,869
which is a collection of key value pairs,

323
00:13:01,900 --> 00:13:05,580
which means now we can use words as our indices instead of just numbers,

324
00:13:05,659 --> 00:13:08,010
which is to say if I switch from reader,

325
00:13:08,140 --> 00:13:10,140
which gives me lists to dict reader,

326
00:13:10,179 --> 00:13:11,609
which gives me dictionaries,

327
00:13:11,780 --> 00:13:14,260
I can change this line 10 now.

328
00:13:14,419 --> 00:13:17,799
And say I specifically want the language column

329
00:13:18,049 --> 00:13:21,489
wherever it is all the way to the left or the middle or the right so in

330
00:13:21,489 --> 00:13:23,530
general using a dictionary reader is probably just going

331
00:13:23,530 --> 00:13:26,640
to be more robust because it's resilient against changes

332
00:13:26,890 --> 00:13:29,640
in that actual numeric ordering.

333
00:13:30,090 --> 00:13:30,099
Alright,

334
00:13:30,130 --> 00:13:31,450
let me pause here to see first if

335
00:13:31,450 --> 00:13:34,130
there's any questions on this exercise whose purpose

336
00:13:34,130 --> 00:13:38,960
in life is just to demonstrate how we can download the CSV data then iterate over it

337
00:13:39,409 --> 00:13:40,919
line by line without actually

338
00:13:41,169 --> 00:13:42,289
analyzing it yet.

339
00:13:45,070 --> 00:13:45,299
No,

340
00:13:45,400 --> 00:13:45,789
OK,

341
00:13:46,030 --> 00:13:49,090
so let's ask maybe the most natural question,

342
00:13:49,099 --> 00:13:51,789
which is like how many people prefer Python?

343
00:13:51,830 --> 00:13:55,239
How many people prefer C or scratch in turn?

344
00:13:55,270 --> 00:13:55,669
In other words,

345
00:13:55,750 --> 00:13:58,460
how can we recreate in our own code what Google

346
00:13:58,460 --> 00:14:01,349
Forms is doing for us graphically with those pie charts?

347
00:14:01,510 --> 00:14:01,900
Well,

348
00:14:02,190 --> 00:14:03,789
I think what we could do is write some

349
00:14:03,789 --> 00:14:07,150
code logically that essentially relies on this mental model.

350
00:14:07,270 --> 00:14:09,989
What I have here is an opportunity to use a bunch of key value

351
00:14:09,989 --> 00:14:13,169
pairs because if I want to know how many instances of Python there are.

352
00:14:13,250 --> 00:14:14,770
and C and scratch.

353
00:14:14,900 --> 00:14:14,940
Well,

354
00:14:15,020 --> 00:14:16,570
those might as well be three keys,

355
00:14:16,619 --> 00:14:19,500
the values of which are hopefully going to be 3 numbers that

356
00:14:19,500 --> 00:14:22,700
represent the counts of the popularity of each of those languages.

357
00:14:22,739 --> 00:14:23,330
So in memory,

358
00:14:23,500 --> 00:14:25,609
I essentially want to construct something that looks like this

359
00:14:25,609 --> 00:14:27,450
and would if I were doing this on a chalkboard,

360
00:14:27,580 --> 00:14:29,369
but recall that this mental model

361
00:14:29,659 --> 00:14:33,140
maps perfectly to the notion of a Python dictionary,

362
00:14:33,179 --> 00:14:35,900
because a dictionary in Python is indeed key value pairs,

363
00:14:35,940 --> 00:14:39,570
and we've seen it already because that's how the dictionary reader works.

364
00:14:39,659 --> 00:14:41,460
But we could certainly use our own.

365
00:14:41,880 --> 00:14:42,109
Uh,

366
00:14:42,119 --> 00:14:45,020
dictionaries to solve the same problem ourselves.

367
00:14:45,159 --> 00:14:48,669
So the goal at hand is to count the number of people who said Python

368
00:14:48,840 --> 00:14:50,789
and C and scratch respectively.

369
00:14:51,000 --> 00:14:51,760
So how to do this?

370
00:14:51,840 --> 00:14:51,880
Well,

371
00:14:51,960 --> 00:14:53,309
I think what I could do

372
00:14:53,679 --> 00:14:54,150
is,

373
00:14:54,400 --> 00:14:57,830
I actually let me delete this line because we are using a dictionary reader,

374
00:14:57,840 --> 00:14:59,719
we no longer need to skip the first row.

375
00:14:59,729 --> 00:15:03,030
It is automatically consumed by the dictionary reader for us,

376
00:15:03,239 --> 00:15:06,169
so this now would be the better version of the dictionary reader.

377
00:15:06,500 --> 00:15:07,169
Let's go ahead and do this.

378
00:15:07,289 --> 00:15:09,359
Let me declare some variables first

379
00:15:09,650 --> 00:15:14,030
that will store for me the total number of people who said Python,

380
00:15:14,169 --> 00:15:14,570
scratch,

381
00:15:14,580 --> 00:15:15,570
and C respectively.

382
00:15:15,690 --> 00:15:17,599
So I could say scratch equals 0,

383
00:15:18,130 --> 00:15:19,400
C equals 0,

384
00:15:19,650 --> 00:15:20,969
Python equals 0,

385
00:15:20,979 --> 00:15:23,530
and I could just set 3 variables equal to 00,

386
00:15:23,539 --> 00:15:24,169
and 0.

387
00:15:24,330 --> 00:15:25,289
If you haven't seen it before,

388
00:15:25,369 --> 00:15:28,299
there are some pythonic tricks you can do here if you've got 3

389
00:15:28,299 --> 00:15:30,960
variables that you want to initialize all at once because it's that simple.

390
00:15:31,229 --> 00:15:32,909
You could alternatively do scratch,

391
00:15:33,340 --> 00:15:33,530
C,

392
00:15:34,020 --> 00:15:36,409
Python equals 0.0.0.

393
00:15:36,619 --> 00:15:38,780
This too would have the intended effect and it looks

394
00:15:38,780 --> 00:15:41,210
a little better because it's all a simple one liner.

395
00:15:41,460 --> 00:15:43,330
But what do I want to do now?

396
00:15:43,460 --> 00:15:43,580
Well,

397
00:15:43,700 --> 00:15:44,489
down here,

398
00:15:44,659 --> 00:15:47,530
let's go ahead and do a simple conditional before

399
00:15:47,530 --> 00:15:49,770
we enhance this by using an actual dictionary.

400
00:15:49,940 --> 00:15:55,210
Let me go ahead and say if the current favorite in that reader equals equals scratch,

401
00:15:55,500 --> 00:15:55,859
well,

402
00:15:55,960 --> 00:15:58,830
Let's go ahead and increment the scratch variable by

403
00:15:58,830 --> 00:16:01,619
doing plus equals 1 as we saw last time.

404
00:16:02,119 --> 00:16:04,039
El if the favorite

405
00:16:04,229 --> 00:16:06,619
in the current row equals equals unquotec,

406
00:16:06,989 --> 00:16:07,190
well,

407
00:16:07,270 --> 00:16:10,659
let's go ahead and then increment the C variable by 1.

408
00:16:11,630 --> 00:16:14,500
E if the favorite equals equals Python,

409
00:16:14,710 --> 00:16:17,820
then let's go ahead and increment plus equals

410
00:16:18,150 --> 00:16:20,590
Python by 1 instead.

411
00:16:20,989 --> 00:16:23,510
I could technically get away with saying else here,

412
00:16:23,710 --> 00:16:27,520
but I'm consciously this time not trying to over optimize this

413
00:16:27,520 --> 00:16:30,989
because if someone changes the form maybe next semester and whatnot,

414
00:16:31,030 --> 00:16:32,419
and we're asking about 1/4 language,

415
00:16:32,469 --> 00:16:33,619
I wouldn't want my code

416
00:16:33,830 --> 00:16:37,590
to assume that anything that isn't scratch or C must be Python.

417
00:16:37,724 --> 00:16:39,465
When there could be some future 4th language.

418
00:16:39,554 --> 00:16:41,664
So this is a little more robust and in this case

419
00:16:41,664 --> 00:16:45,025
we'll just ignore anything that isn't scratch or C or Python.

420
00:16:45,234 --> 00:16:45,525
All right,

421
00:16:45,674 --> 00:16:46,465
at the end of this,

422
00:16:46,594 --> 00:16:48,234
let's go ahead and not just print out the favorite,

423
00:16:48,315 --> 00:16:49,775
but outside of the 4 loop,

424
00:16:49,914 --> 00:16:51,145
let's go ahead and print out,

425
00:16:51,195 --> 00:16:51,945
for instance,

426
00:16:52,195 --> 00:16:54,585
the scratch count is this,

427
00:16:55,155 --> 00:16:58,585
then let's go ahead and print out the C count

428
00:16:58,994 --> 00:17:00,265
is this,

429
00:17:00,674 --> 00:17:05,145
and then let's print out the Python count is this,

430
00:17:05,395 --> 00:17:07,354
but of course there's a subtle bug here.

431
00:17:07,839 --> 00:17:08,209
Yeah.

432
00:17:09,050 --> 00:17:09,250
Uh,

433
00:17:09,410 --> 00:17:10,410
so I didn't format these things.

434
00:17:10,449 --> 00:17:11,209
It's F strings,

435
00:17:11,250 --> 00:17:14,250
so I need the little F over here to the left of each of these strings.

436
00:17:14,400 --> 00:17:14,760
All right,

437
00:17:15,170 --> 00:17:17,280
so let me go ahead and maximize my terminal window,

438
00:17:17,489 --> 00:17:19,689
run Python of this version of favorite stoppi

439
00:17:19,689 --> 00:17:22,000
and hopefully what we'll see is not every row

440
00:17:22,339 --> 00:17:23,089
again and again and again,

441
00:17:23,209 --> 00:17:24,780
but 3 lines of output,

442
00:17:24,810 --> 00:17:27,209
giving me the total counts instead.

443
00:17:27,839 --> 00:17:28,079
All right,

444
00:17:28,160 --> 00:17:30,079
this seems to line up with the rough percentages

445
00:17:30,079 --> 00:17:32,000
that we saw coming in earlier on Google Forms,

446
00:17:32,050 --> 00:17:33,479
109 of you like Python,

447
00:17:33,560 --> 00:17:37,709
followed by 58 of you and C and 24 of you preferring scratch instead.

448
00:17:38,180 --> 00:17:38,359
All right,

449
00:17:38,479 --> 00:17:41,790
but why does this perhaps rub you the wrong way?

450
00:17:41,959 --> 00:17:44,569
I already alluded to the fact that we're going to get rid of this,

451
00:17:44,959 --> 00:17:46,790
but why is this not the best design?

452
00:17:46,920 --> 00:17:48,319
Just using three variables like this,

453
00:17:48,400 --> 00:17:48,760
yeah.

454
00:17:54,800 --> 00:17:54,810
Yeah,

455
00:17:55,500 --> 00:17:55,689
exactly.

456
00:17:55,770 --> 00:17:57,099
If we were to add a bunch more languages,

457
00:17:57,180 --> 00:17:57,699
a 4th 1,

458
00:17:57,780 --> 00:17:58,260
a 5th 1,

459
00:17:58,339 --> 00:17:59,140
a 6th 1,

460
00:17:59,219 --> 00:17:59,939
a 10th 1,

461
00:18:00,020 --> 00:18:00,819
a 20th 1,

462
00:18:00,979 --> 00:18:02,439
like having that many variables,

463
00:18:02,449 --> 00:18:05,410
it's just certainly going to look unwieldy and it's just not gonna,

464
00:18:05,500 --> 00:18:06,709
it shouldn't rub you the right way.

465
00:18:06,760 --> 00:18:09,979
At that point we should really be graduating to some proper data structure

466
00:18:09,979 --> 00:18:13,089
whether it was an array in C or better still in Python,

467
00:18:13,219 --> 00:18:14,390
an actual dictionary.

468
00:18:14,459 --> 00:18:15,439
So let's do that instead.

469
00:18:15,739 --> 00:18:18,140
Let me go ahead and in a newer version of this file,

470
00:18:18,180 --> 00:18:19,020
let's get rid of these.

471
00:18:19,503 --> 00:18:23,412
variables and let's just have a generic variable called counts

472
00:18:23,412 --> 00:18:26,772
for instance and set it equal to an empty dictionary

473
00:18:26,772 --> 00:18:29,103
and just using two curly braces will give me an

474
00:18:29,103 --> 00:18:31,493
empty dictionary or if you want to be more pedantic,

475
00:18:31,623 --> 00:18:33,542
you can actually call the dict function which

476
00:18:33,542 --> 00:18:35,812
will return to you an empty dictionary.

477
00:18:36,022 --> 00:18:38,743
I'd argue though that most people would probably just use the double

478
00:18:38,743 --> 00:18:42,692
curly braces like this to indicate that here comes a dictionary for me

479
00:18:43,022 --> 00:18:43,223
now.

480
00:18:43,365 --> 00:18:44,225
Do I use this?

481
00:18:44,286 --> 00:18:44,395
Well,

482
00:18:44,515 --> 00:18:47,906
I don't need to update three separate variables.

483
00:18:47,916 --> 00:18:50,105
I think I could just do something like this.

484
00:18:50,375 --> 00:18:52,235
I could say once I've determined what the

485
00:18:52,235 --> 00:18:54,745
current row's favorite value is for language,

486
00:18:54,916 --> 00:18:56,436
I could say counts,

487
00:18:56,595 --> 00:18:57,916
bracket favorite,

488
00:18:58,115 --> 00:19:01,426
so use the current string as an index into the dictionary,

489
00:19:01,536 --> 00:19:04,706
so it's going to be quote unquote scratch or C or Python,

490
00:19:04,916 --> 00:19:07,475
and then just increment that by 1.

491
00:19:07,755 --> 00:19:10,586
And then down here we don't have these variables anymore,

492
00:19:10,635 --> 00:19:12,586
so I'm going to go ahead and instead say.

493
00:19:13,050 --> 00:19:13,420
Uh,

494
00:19:13,469 --> 00:19:13,910
how about this?

495
00:19:13,949 --> 00:19:18,060
We'll use a loop for each favorite in those counts,

496
00:19:18,349 --> 00:19:20,140
let's go ahead and print out,

497
00:19:20,510 --> 00:19:20,819
uh,

498
00:19:20,829 --> 00:19:23,900
how about the favorite value

499
00:19:24,109 --> 00:19:25,219
and the counts

500
00:19:25,510 --> 00:19:27,630
thereof without any F string for now.

501
00:19:28,130 --> 00:19:28,479
OK,

502
00:19:28,589 --> 00:19:31,489
so the only thing that's different is I'm using a dictionary

503
00:19:31,489 --> 00:19:35,430
here which is essentially the code version of this two column chart

504
00:19:35,760 --> 00:19:39,359
whose keys are going to be the favorite strings,

505
00:19:39,569 --> 00:19:41,510
scratch or C or Python,

506
00:19:41,640 --> 00:19:43,689
the values of which are going to be the actual counts,

507
00:19:43,760 --> 00:19:46,479
and I'm just doing some simple math by plus plusing or

508
00:19:46,479 --> 00:19:49,400
incrementing the count each time I see a certain language.

509
00:19:49,760 --> 00:19:52,270
Unfortunately this code is not quite going to work.

510
00:19:52,439 --> 00:19:55,530
Let me go ahead and run Pythonofavours.ie and

511
00:19:56,130 --> 00:19:56,689
Dang it,

512
00:19:56,849 --> 00:19:58,180
there's a key error.

513
00:19:58,849 --> 00:20:01,439
Let me minimize the terminal window so we can see both at once.

514
00:20:01,770 --> 00:20:03,069
Why is

515
00:20:03,369 --> 00:20:05,520
there a key error apparently

516
00:20:05,910 --> 00:20:07,349
on line 11,

517
00:20:07,530 --> 00:20:10,040
wherein I'm indexing into the counts

518
00:20:10,319 --> 00:20:12,079
array uh dictionary.

519
00:20:13,520 --> 00:20:14,020
What's going on?

520
00:20:14,099 --> 00:20:14,469
Yeah,

521
00:20:17,119 --> 00:20:17,199
yeah,

522
00:20:17,319 --> 00:20:18,199
it's a little subtle,

523
00:20:18,280 --> 00:20:20,739
but if this is like the very first time through the file,

524
00:20:20,920 --> 00:20:22,790
there is no key Python.

525
00:20:22,839 --> 00:20:27,319
There is no key C or scratch because no one has put them there and yet recall

526
00:20:27,319 --> 00:20:29,949
that plus equal means you're going to that location

527
00:20:29,949 --> 00:20:32,439
in the dictionary and just blindly incrementing it.

528
00:20:32,479 --> 00:20:33,099
But what is it?

529
00:20:33,239 --> 00:20:33,280
Well,

530
00:20:33,400 --> 00:20:34,920
it's effectively a garbage value,

531
00:20:34,959 --> 00:20:37,849
but it's not even that because there's no actual key there.

532
00:20:37,959 --> 00:20:41,310
So we need to do a little bit of logic here and we can solve this in a couple of ways.

533
00:20:41,670 --> 00:20:41,910
Well,

534
00:20:42,030 --> 00:20:45,069
I could say something very pedantically like this.

535
00:20:45,109 --> 00:20:45,780
I could just say,

536
00:20:45,790 --> 00:20:46,060
well,

537
00:20:46,069 --> 00:20:50,750
if this favorite is in the counts dictionary,

538
00:20:50,869 --> 00:20:55,459
this is the Pythonic way to ask that question is this key in this dictionary?

539
00:20:55,670 --> 00:20:56,229
If so,

540
00:20:56,270 --> 00:20:59,140
well then it's safe to go ahead and increment it just as I've done before.

541
00:20:59,310 --> 00:21:00,150
But if it's not,

542
00:21:00,310 --> 00:21:05,869
what I think I want to do is set counts favorites equal to.

543
00:21:08,939 --> 00:21:09,569
One

544
00:21:10,219 --> 00:21:10,689
instead

545
00:21:11,140 --> 00:21:16,060
because either I want to increment the current count by 1 or

546
00:21:16,060 --> 00:21:18,780
this is the first time logic like I've seen this favorite,

547
00:21:18,939 --> 00:21:21,729
so I want to set it equal to 1 instead.

548
00:21:21,939 --> 00:21:23,849
We could do this a different way logically just

549
00:21:23,849 --> 00:21:26,010
like we could in C solve problems differently.

550
00:21:26,020 --> 00:21:28,130
I could instead say something like this.

551
00:21:28,579 --> 00:21:32,209
I could get rid of all this code and just say if.

552
00:21:32,500 --> 00:21:33,839
Favorite not

553
00:21:34,010 --> 00:21:35,000
in counts,

554
00:21:35,209 --> 00:21:38,449
then I could say counts bracket favorite equals 0.

555
00:21:38,530 --> 00:21:41,079
So just always initialize it to 0 if it's not there.

556
00:21:41,369 --> 00:21:43,359
Now I can safely blindly

557
00:21:43,890 --> 00:21:45,410
update the count

558
00:21:45,689 --> 00:21:48,119
by 1 because now I know no matter what,

559
00:21:48,170 --> 00:21:49,680
once I get to line 13,

560
00:21:49,890 --> 00:21:52,280
that count is actually there.

561
00:21:52,849 --> 00:21:53,150
All right,

562
00:21:53,369 --> 00:21:55,199
so let's see with this version of the code,

563
00:21:55,770 --> 00:21:58,000
let's go ahead and clear my terminal window,

564
00:21:58,290 --> 00:21:58,599
uh,

565
00:21:58,609 --> 00:22:00,410
rerun Pythonofavos.ie,

566
00:22:00,609 --> 00:22:01,280
cross my fingers,

567
00:22:01,290 --> 00:22:01,750
and

568
00:22:01,949 --> 00:22:02,650
There we go,

569
00:22:02,699 --> 00:22:05,010
Python and Scratch and see.

570
00:22:05,219 --> 00:22:05,739
Interestingly,

571
00:22:05,819 --> 00:22:09,900
the order switched around this time based on the order

572
00:22:09,900 --> 00:22:11,780
in which I was inserting things into the dictionary,

573
00:22:11,859 --> 00:22:14,609
but we'll see how we can exercise a bit more control over that.

574
00:22:14,780 --> 00:22:18,540
But let me propose that that key error recall we discussed briefly last week that

575
00:22:18,540 --> 00:22:23,339
whenever you have these kinds of trace backs that refer to certain exceptions like.

576
00:22:23,485 --> 00:22:25,666
Exceptionally bad situations that can happen,

577
00:22:25,755 --> 00:22:28,345
you can also change your code to just try to do something

578
00:22:28,556 --> 00:22:31,026
and then try to catch the exception instead.

579
00:22:31,196 --> 00:22:34,926
So an alternative way to do what we initially did would be this

580
00:22:35,436 --> 00:22:38,385
instead of just blindly saying go into the counts dictionary,

581
00:22:38,515 --> 00:22:40,145
index into it at the favorite

582
00:22:40,635 --> 00:22:41,066
key,

583
00:22:41,255 --> 00:22:43,145
and increment it by one,

584
00:22:43,316 --> 00:22:44,875
what we could do is.

585
00:22:45,021 --> 00:22:46,501
Try to do that please,

586
00:22:46,812 --> 00:22:49,602
except if there is a key error,

587
00:22:49,891 --> 00:22:50,661
in which case,

588
00:22:50,692 --> 00:22:51,131
you know what,

589
00:22:51,212 --> 00:22:53,161
go ahead and just initialize that

590
00:22:53,452 --> 00:22:53,962
value

591
00:22:54,131 --> 00:22:55,281
to one instead.

592
00:22:55,411 --> 00:22:57,572
So in short there's like 4 different ways already to solve

593
00:22:57,572 --> 00:23:00,562
the same problem whichever way you prefer is quite reasonable.

594
00:23:00,771 --> 00:23:03,932
This is just another way and arguably another pythonic way

595
00:23:03,932 --> 00:23:06,491
to do things by trying to do something but anticipating

596
00:23:06,812 --> 00:23:08,891
that something in fact can go wrong.

597
00:23:11,920 --> 00:23:12,969
A while ago what?

598
00:23:15,790 --> 00:23:16,069
Correct.

599
00:23:16,109 --> 00:23:20,420
A while ago I removed next reader because that was only necessary for CSV.reader

600
00:23:20,869 --> 00:23:23,699
because that was just reading every row again and again,

601
00:23:23,910 --> 00:23:26,260
but when you use a CSV dictionary reader,

602
00:23:26,390 --> 00:23:29,030
that automatically consumes the first row because

603
00:23:29,030 --> 00:23:31,349
that's how the dictionary reader knows what the

604
00:23:31,349 --> 00:23:34,270
columns will be called and so you don't have to skip over it instead,

605
00:23:34,369 --> 00:23:35,489
a nice enhancement.

606
00:23:35,750 --> 00:23:36,619
Other questions.

607
00:23:37,550 --> 00:23:38,349
On what

608
00:23:38,750 --> 00:23:39,619
we've just done.

609
00:23:40,270 --> 00:23:40,290
Here

610
00:23:42,839 --> 00:23:43,319
All right,

611
00:23:43,630 --> 00:23:48,800
so let me propose that like writing this amount of code is kind of annoying just

612
00:23:48,800 --> 00:23:50,719
to ask a relatively simple question like what's

613
00:23:50,719 --> 00:23:52,439
the most popular language in this file,

614
00:23:52,479 --> 00:23:52,599
right?

615
00:23:52,829 --> 00:23:53,560
It's nice.

616
00:23:53,640 --> 00:23:54,719
It's sort of a step backwards from

617
00:23:54,719 --> 00:23:58,199
Google spreadsheets and Apple Numbers and Microsoft

618
00:23:58,199 --> 00:24:01,520
Excel where you could really just like highlight the column and it would just

619
00:24:01,520 --> 00:24:04,000
tell you the answer usually in the bottom right hand corner or you could

620
00:24:04,000 --> 00:24:07,829
use a function in one of those spreadsheet tools to ask the same question.

621
00:24:07,959 --> 00:24:11,800
So it's starting to feel like with almost 20 lines of code like maybe.

622
00:24:11,916 --> 00:24:12,616
There's a better way,

623
00:24:12,626 --> 00:24:16,597
and I dare say there is rather than use a flat file database,

624
00:24:16,786 --> 00:24:20,227
let's graduate already to what the world calls a relational database,

625
00:24:20,237 --> 00:24:21,677
and a relational database

626
00:24:21,906 --> 00:24:24,136
is simply data in which

627
00:24:24,526 --> 00:24:26,347
you define relations among your data,

628
00:24:26,427 --> 00:24:28,776
which isn't so much relevant now except that

629
00:24:28,786 --> 00:24:31,296
that time stamp is associated with that language

630
00:24:31,406 --> 00:24:32,937
is associated with that

631
00:24:33,506 --> 00:24:34,776
prefer favorite

632
00:24:35,307 --> 00:24:36,477
problem as well.

633
00:24:36,666 --> 00:24:38,536
But we'll see that data sets can be much more,

634
00:24:38,827 --> 00:24:41,227
much larger and more complicated and it might be valuable.

635
00:24:41,343 --> 00:24:44,963
We can actually express relationships across multiple pieces of data.

636
00:24:45,093 --> 00:24:45,644
In particular,

637
00:24:45,813 --> 00:24:48,453
let's introduce already a programming language called

638
00:24:48,453 --> 00:24:51,014
Structured Query Language or SQL for short,

639
00:24:51,173 --> 00:24:55,413
AKA SQL and SQL essentially only has 4 fundamental operations.

640
00:24:55,453 --> 00:24:56,683
So even though we're transitioning

641
00:24:56,854 --> 00:24:57,774
into a new language,

642
00:24:57,854 --> 00:24:59,614
by the end of today we're gonna transition out of the

643
00:24:59,614 --> 00:25:01,293
new language because there's only so much you can do.

644
00:25:01,323 --> 00:25:01,604
Now,

645
00:25:01,693 --> 00:25:02,404
as with any language,

646
00:25:02,453 --> 00:25:06,264
it's going to take time and practice or to sort of get a hold the hang of it,

647
00:25:06,654 --> 00:25:07,093
but

648
00:25:07,413 --> 00:25:10,614
take comfort in knowing that SQL really just supports four fundamental.

649
00:25:11,480 --> 00:25:14,681
operations and the acronym that the world uses is indeed CRD,

650
00:25:14,791 --> 00:25:16,081
which stands for Create,

651
00:25:16,520 --> 00:25:16,990
read,

652
00:25:17,321 --> 00:25:17,651
update,

653
00:25:18,000 --> 00:25:18,630
and delete.

654
00:25:18,770 --> 00:25:19,500
That is to say,

655
00:25:19,510 --> 00:25:20,990
when using a relational database,

656
00:25:21,000 --> 00:25:22,031
you can create data,

657
00:25:22,360 --> 00:25:23,071
read data,

658
00:25:23,510 --> 00:25:24,161
update the data,

659
00:25:24,281 --> 00:25:25,031
or delete data,

660
00:25:25,041 --> 00:25:27,831
and that's pretty comprehensive as to what's possible.

661
00:25:27,961 --> 00:25:29,281
Now what is an actual database?

662
00:25:29,321 --> 00:25:29,441
Well,

663
00:25:29,520 --> 00:25:30,071
generally speaking,

664
00:25:30,120 --> 00:25:34,230
a database is just a piece of software that's running on a computer somewhere

665
00:25:34,720 --> 00:25:37,191
inside of which is stored a whole lot of data and

666
00:25:37,191 --> 00:25:40,041
that database therefore provides you with access to that data.

667
00:25:40,449 --> 00:25:41,040
At any time,

668
00:25:41,089 --> 00:25:43,130
whether it's on your local Mac or PC somewhere in

669
00:25:43,130 --> 00:25:45,770
the cloud or to a whole cluster of web servers

670
00:25:45,770 --> 00:25:47,290
which we'll talk about in the weeks to come as

671
00:25:47,290 --> 00:25:50,280
we transition from command line tools to the web.

672
00:25:50,449 --> 00:25:51,660
Now technically in SQL,

673
00:25:51,849 --> 00:25:55,290
the commands you actually use to implement this idea of creating data,

674
00:25:55,329 --> 00:25:55,800
reading data,

675
00:25:55,849 --> 00:25:56,250
updating,

676
00:25:56,260 --> 00:25:58,280
and deleting data is almost the same,

677
00:25:58,489 --> 00:25:59,800
but for whatever reason,

678
00:25:59,979 --> 00:26:00,060
uh,

679
00:26:00,170 --> 00:26:02,180
the world chose the command select,

680
00:26:02,369 --> 00:26:03,449
which is equivalent to reading.

681
00:26:03,525 --> 00:26:06,234
Data so we'll soon see that there's a command in SQL that lets

682
00:26:06,234 --> 00:26:09,584
us select data which is equivalent to this idea of reading it,

683
00:26:09,594 --> 00:26:11,505
whereas the other three options refer of course

684
00:26:11,505 --> 00:26:14,104
to writing data that is changing data.

685
00:26:14,494 --> 00:26:14,564
Um,

686
00:26:14,574 --> 00:26:15,625
technically speaking,

687
00:26:15,954 --> 00:26:18,675
we'll be able to insert data into a database as we'll soon see,

688
00:26:18,685 --> 00:26:21,155
and we'll also be able to drop data altogether,

689
00:26:21,194 --> 00:26:23,915
not just delete individual rows but whole tables,

690
00:26:23,994 --> 00:26:24,564
so to speak,

691
00:26:24,734 --> 00:26:26,594
of rows instead.

692
00:26:27,290 --> 00:26:29,180
So what does this all mean?

693
00:26:29,229 --> 00:26:29,300
Well,

694
00:26:29,369 --> 00:26:30,880
let's go ahead and do,

695
00:26:31,290 --> 00:26:31,760
say,

696
00:26:31,810 --> 00:26:34,369
an example of using SQL to solve,

697
00:26:34,449 --> 00:26:36,930
to ask some relatively simple questions and begin to

698
00:26:36,930 --> 00:26:39,119
develop some muscle memory for using this new language.

699
00:26:39,329 --> 00:26:40,900
If I were to manually

700
00:26:41,130 --> 00:26:45,369
load a bunch of data into a proper database for SQL,

701
00:26:45,569 --> 00:26:46,780
I would actually use code like this.

702
00:26:46,849 --> 00:26:48,420
I would literally type Create table.

703
00:26:48,619 --> 00:26:50,219
I'd come up with the name of the table,

704
00:26:50,510 --> 00:26:51,239
aka sheet,

705
00:26:51,449 --> 00:26:55,760
and then I would specify every column that I want to put in that table.

706
00:26:55,930 --> 00:26:57,329
And here's where the vernacular changes.

707
00:26:57,410 --> 00:26:59,969
So whereas in the world of spreadsheets you have sheets,

708
00:27:00,130 --> 00:27:02,329
tabs that contain rows and columns,

709
00:27:02,339 --> 00:27:06,609
in the world of databases you have tables which are just rows and columns.

710
00:27:06,650 --> 00:27:07,530
It's different terminology,

711
00:27:07,579 --> 00:27:09,810
but it refers to conceptually the same thing.

712
00:27:10,109 --> 00:27:13,660
In CS 50 we're going to use a specific version of SQL known as SQL Light,

713
00:27:13,739 --> 00:27:15,630
which is like a lightweight version of SQL

714
00:27:15,630 --> 00:27:18,540
that's actually very commonly used in web applications,

715
00:27:18,619 --> 00:27:19,810
in mobile applications,

716
00:27:19,819 --> 00:27:23,599
but it doesn't have all of the bells and whistles or all of the scalability

717
00:27:24,010 --> 00:27:25,140
uh that your Oracle,

718
00:27:25,339 --> 00:27:26,060
SQL servers,

719
00:27:26,180 --> 00:27:27,380
Microsoft Access,

720
00:27:27,579 --> 00:27:28,180
Postgress,

721
00:27:28,219 --> 00:27:29,050
MySQL,

722
00:27:29,219 --> 00:27:29,979
those are just product.

723
00:27:30,119 --> 00:27:31,609
Names open source and commercial alike,

724
00:27:31,670 --> 00:27:34,979
which if you've ever heard of just represent bigger,

725
00:27:35,109 --> 00:27:35,780
faster

726
00:27:36,060 --> 00:27:38,349
versions of SQL databases,

727
00:27:38,430 --> 00:27:41,670
but we'll indeed use the lightweight version of it known as SQL Light,

728
00:27:41,709 --> 00:27:44,260
and the command we're going to start to run is quite literally

729
00:27:44,520 --> 00:27:45,390
SQL Light 3,

730
00:27:45,469 --> 00:27:47,189
which is version 3 of the same command which

731
00:27:47,189 --> 00:27:50,020
we've pre-installed into your code spaces for you.

732
00:27:50,400 --> 00:27:51,550
So let's go ahead and do this.

733
00:27:51,750 --> 00:27:54,390
Let me go ahead and run a command called SQL Light 3 which

734
00:27:54,390 --> 00:27:58,780
is going to let me create my very first SQL Light database,

735
00:27:58,949 --> 00:28:01,060
and I'm going to import into that database

736
00:28:01,229 --> 00:28:02,619
the CSV file

737
00:28:02,869 --> 00:28:05,180
that we downloaded from Google Forms.

738
00:28:05,250 --> 00:28:05,790
In other words,

739
00:28:05,900 --> 00:28:09,589
I'm going to load that same data set into a different program,

740
00:28:09,630 --> 00:28:10,939
an actual database,

741
00:28:11,189 --> 00:28:13,390
so that I can use a completely different programming

742
00:28:13,390 --> 00:28:15,800
language to ask questions about it instead of writing,

743
00:28:15,869 --> 00:28:17,910
as we just did some Python code.

744
00:28:18,349 --> 00:28:20,369
So let me go back into VS code here.

745
00:28:20,579 --> 00:28:23,569
Let me close my CSV file and my Python file.

746
00:28:23,780 --> 00:28:27,170
Let me reopen my terminal window and let me go ahead and run

747
00:28:27,459 --> 00:28:29,319
SQLite 3 space,

748
00:28:29,459 --> 00:28:31,339
and then the name I want to give to this database,

749
00:28:31,380 --> 00:28:35,890
which for instance will be favorites.db for database by convention.

750
00:28:36,099 --> 00:28:36,609
Enter.

751
00:28:36,790 --> 00:28:39,599
I'm going to be prompted to make sure I want to create this new file.

752
00:28:39,699 --> 00:28:40,510
Y for yes,

753
00:28:40,540 --> 00:28:40,989
enter,

754
00:28:41,219 --> 00:28:42,819
and now I'm inside of the data.

755
00:28:43,062 --> 00:28:47,593
Base running a command at a prompt that now says SQL light and then an angle bracket.

756
00:28:47,833 --> 00:28:50,853
I'm not going to be using any.SQL files for now,

757
00:28:50,942 --> 00:28:54,262
although you can actually write SQL code in separate text files.

758
00:28:54,432 --> 00:28:58,792
I'm actually going to use the database's interactive interpreter to just run

759
00:28:58,792 --> 00:29:01,392
all of the commands I want interactively by just typing them out.

760
00:29:01,512 --> 00:29:02,292
Semicolon enter.

761
00:29:02,392 --> 00:29:02,942
Type it out,

762
00:29:03,072 --> 00:29:03,782
semicolon,

763
00:29:03,792 --> 00:29:04,292
enter

764
00:29:04,552 --> 00:29:05,152
back and forth,

765
00:29:05,192 --> 00:29:07,392
but you can save all of these commands as you'll see in problems.

766
00:29:07,536 --> 00:29:09,235
7 in files as well.

767
00:29:09,446 --> 00:29:12,235
Now how do I go about actually importing

768
00:29:12,406 --> 00:29:15,426
that CSV file into this lightweight database?

769
00:29:15,526 --> 00:29:15,586
Well,

770
00:29:15,645 --> 00:29:15,916
for this,

771
00:29:15,926 --> 00:29:17,566
I'm going to execute 3 commands,

772
00:29:17,595 --> 00:29:22,625
and any command in SQL Light that starts with a dot is specific to SQL Light.

773
00:29:22,725 --> 00:29:24,286
This lightweight version of SQL,

774
00:29:24,765 --> 00:29:27,566
anything that doesn't start with a dot is generalizable and will

775
00:29:27,566 --> 00:29:30,206
work on most any SQL database anywhere in the world,

776
00:29:30,245 --> 00:29:31,885
no matter the product you're using.

777
00:29:32,400 --> 00:29:37,189
So I'm going to go ahead and in my SQLite terminal I'm going to change my mode

778
00:29:37,189 --> 00:29:40,979
to CSV mode just to tell the database that I want to load some CSV data.

779
00:29:41,229 --> 00:29:43,699
I'm going to then literally import that data

780
00:29:43,949 --> 00:29:46,189
from a file called favorites.csv,

781
00:29:46,349 --> 00:29:50,380
which is the file we downloaded earlier and then uploaded to my code space.

782
00:29:50,589 --> 00:29:52,819
And now I have to specify the name of a table,

783
00:29:52,949 --> 00:29:54,339
so I'm going to call this table,

784
00:29:54,349 --> 00:29:57,390
aka sheet favorites just to keep everything consistent.

785
00:29:57,880 --> 00:29:58,579
And that's it.

786
00:29:58,750 --> 00:29:59,959
In the absence of an error message,

787
00:30:00,349 --> 00:30:01,270
everything probably worked fine.

788
00:30:01,390 --> 00:30:02,859
I'm going to do quit.

789
00:30:02,949 --> 00:30:04,349
That quits out of SQL light,

790
00:30:04,589 --> 00:30:08,829
but what you'll now see if I type LS is that not only do I have favorites.

791
00:30:08,989 --> 00:30:09,430
CSV,

792
00:30:09,510 --> 00:30:10,349
which I uploaded,

793
00:30:10,550 --> 00:30:11,349
favorites.ie,

794
00:30:11,430 --> 00:30:12,660
which we wrote a few minutes ago,

795
00:30:12,829 --> 00:30:15,020
but I also now have favorites.db,

796
00:30:15,150 --> 00:30:18,699
which is a database version of that same file.

797
00:30:18,910 --> 00:30:23,199
Now I can't actually see what's inside of it because if I go ahead and run

798
00:30:23,630 --> 00:30:25,550
a code of favorites.db.

799
00:30:26,060 --> 00:30:27,969
I'm going to see this file is not displayed in the text

800
00:30:27,969 --> 00:30:31,369
editor because it is either binary or uses an unsupported text encoding.

801
00:30:31,530 --> 00:30:32,680
This is to be expected

802
00:30:32,969 --> 00:30:36,770
because this database is stored essentially in the form of zeros

803
00:30:36,770 --> 00:30:39,839
and ones that the SQLite 3 program knows how to read,

804
00:30:39,920 --> 00:30:42,920
but it's not something that VS Code can just show me everything they're in.

805
00:30:42,930 --> 00:30:45,449
And generally storing data in binary is going

806
00:30:45,449 --> 00:30:48,800
to be more efficient than storing things purely textually

807
00:30:49,369 --> 00:30:51,890
because we're going to be able to use various

808
00:30:51,890 --> 00:30:53,849
data structures and algorithms that we've been talking about.

809
00:30:53,942 --> 00:30:58,003
For weeks more easily on that binary data.

810
00:30:58,412 --> 00:30:58,753
All right,

811
00:30:59,052 --> 00:31:01,973
so let's go ahead now and see what this import command did.

812
00:31:02,052 --> 00:31:02,883
I'm going to again

813
00:31:03,453 --> 00:31:04,762
maximize my terminal window.

814
00:31:04,942 --> 00:31:07,603
I'm going to go ahead and run SQLite 3 again,

815
00:31:07,812 --> 00:31:09,272
passing in favorites.db.

816
00:31:09,522 --> 00:31:11,133
Enter this time it already exists,

817
00:31:11,213 --> 00:31:13,083
so it just opened it without prompting me.

818
00:31:13,292 --> 00:31:14,253
And now I'm going to go ahead and

819
00:31:14,253 --> 00:31:18,253
type another SQL Light specific command called schema.

820
00:31:18,532 --> 00:31:21,572
The schema of a database is just the design of the database.

821
00:31:21,826 --> 00:31:22,365
It look like?

822
00:31:22,375 --> 00:31:24,615
What are the rows and columns and tables therein?

823
00:31:24,895 --> 00:31:25,765
So if I type

824
00:31:26,156 --> 00:31:26,776
dot schema,

825
00:31:27,015 --> 00:31:28,206
what I'm going to see

826
00:31:28,456 --> 00:31:31,125
is this SQL command Create table,

827
00:31:31,336 --> 00:31:32,245
if not exists,

828
00:31:32,536 --> 00:31:33,456
quote unquote favorites,

829
00:31:33,536 --> 00:31:34,725
which is the name of the table.

830
00:31:34,936 --> 00:31:38,076
Then in parentheses there are going to be apparently 3 columns,

831
00:31:38,125 --> 00:31:39,416
one of which is called Timestamp,

832
00:31:39,605 --> 00:31:41,036
the next of which is called Language,

833
00:31:41,125 --> 00:31:42,576
the third of which is called Problem,

834
00:31:42,615 --> 00:31:44,946
and each of those columns is going to be raw text.

835
00:31:45,135 --> 00:31:46,995
Now we'll soon see that it doesn't have to just be text,

836
00:31:47,015 --> 00:31:47,446
but

837
00:31:47,855 --> 00:31:49,615
when I use the dot import command.

838
00:31:49,989 --> 00:31:55,079
This is the default table that SQLite created for me.

839
00:31:55,250 --> 00:31:57,359
Soon we'll see that I can exercise more control,

840
00:31:57,609 --> 00:32:00,410
especially over the types of data that I'm putting in this database.

841
00:32:00,650 --> 00:32:04,849
But what's really nice about the import command is it could not be easier to convert

842
00:32:04,849 --> 00:32:08,780
a CSV file to a SQLite database so that now as we're about to see,

843
00:32:08,969 --> 00:32:13,040
we can use SQL on it instead of Python or any other language

844
00:32:13,489 --> 00:32:13,770
instead.

845
00:32:14,689 --> 00:32:15,410
OK,

846
00:32:15,729 --> 00:32:19,000
so how do we go about getting data from

847
00:32:19,250 --> 00:32:19,680
this

848
00:32:19,849 --> 00:32:20,449
database?

849
00:32:20,530 --> 00:32:20,739
Well,

850
00:32:21,050 --> 00:32:24,369
the first of our commands that we'll explore is that one called Select.

851
00:32:24,410 --> 00:32:26,880
So select data means to read data from the database,

852
00:32:27,050 --> 00:32:30,290
and in this sense it's going to be a declarative language because I'm

853
00:32:30,290 --> 00:32:33,449
just going to declare what data I want to select from the database,

854
00:32:33,459 --> 00:32:36,890
and I'm not going to worry about opening the file anymore or iterating.

855
00:32:37,064 --> 00:32:40,444
It with a 4 loop or a while loop or defining variables of the like,

856
00:32:40,614 --> 00:32:42,204
I'm just going to select

857
00:32:42,775 --> 00:32:44,734
syntactically what I want.

858
00:32:44,895 --> 00:32:46,974
So let me go back to SQLite here.

859
00:32:47,055 --> 00:32:49,175
Let me clear my terminal just to get rid of

860
00:32:49,175 --> 00:32:51,484
the past commands and let's do the first of these.

861
00:32:51,734 --> 00:32:54,334
Select star from favorites,

862
00:32:54,405 --> 00:32:58,454
and I regret to say the semicolon is back for the SQL code we're now writing.

863
00:32:58,859 --> 00:32:59,469
Enter

864
00:32:59,780 --> 00:33:03,819
and we will see a sort of Asky art version now so even

865
00:33:03,819 --> 00:33:07,569
better than the raw CSV file of all of the data that was inputted

866
00:33:07,900 --> 00:33:09,089
into this table.

867
00:33:09,380 --> 00:33:13,420
So select star from favorites is apparently selecting everything so the

868
00:33:13,420 --> 00:33:15,420
star in this context is a wild card of sorts.

869
00:33:15,500 --> 00:33:18,079
That represents all of the columns in the table.

870
00:33:18,329 --> 00:33:19,810
The table itself is called favorites,

871
00:33:19,859 --> 00:33:23,250
so I'm selecting all of the columns from the table called favorites,

872
00:33:23,329 --> 00:33:26,000
and here you have it with sort of simple Asy art first column,

873
00:33:26,050 --> 00:33:26,630
second column,

874
00:33:26,689 --> 00:33:27,430
3rd column,

875
00:33:27,689 --> 00:33:29,800
chronologically listed because that's exactly how

876
00:33:29,800 --> 00:33:32,010
it was loaded into the database.

877
00:33:32,609 --> 00:33:32,890
All right,

878
00:33:33,050 --> 00:33:34,650
so if star is wildcard,

879
00:33:34,750 --> 00:33:35,890
what more can we do?

880
00:33:35,930 --> 00:33:36,010
Well,

881
00:33:36,089 --> 00:33:38,089
if you don't care about all of the columns,

882
00:33:38,170 --> 00:33:39,880
you can actually be a little more specific.

883
00:33:40,050 --> 00:33:43,439
So I could say instead select just the language column from

884
00:33:43,810 --> 00:33:45,239
the favorites table,

885
00:33:45,369 --> 00:33:46,229
semicolon,

886
00:33:46,250 --> 00:33:46,709
enter,

887
00:33:46,930 --> 00:33:49,359
and now I have just a single column of data

888
00:33:49,569 --> 00:33:53,050
that shows me one cell for every submission but not the

889
00:33:53,050 --> 00:33:56,150
time stamp or the favorite problem that that person put in.

890
00:33:56,449 --> 00:33:58,359
Or if I want to declare that I want a couple

891
00:33:58,359 --> 00:34:00,689
of columns so I can say select language and problem.

892
00:34:01,040 --> 00:34:02,270
but I don't care about

893
00:34:02,599 --> 00:34:05,430
the time stamp from favorites as such,

894
00:34:05,469 --> 00:34:07,270
and now you get two columns instead.

895
00:34:07,479 --> 00:34:08,120
So in short,

896
00:34:08,239 --> 00:34:12,270
rather than write the dozen or so lines of code that we earlier did

897
00:34:12,270 --> 00:34:15,708
with Python to open the file and then iterate over it with a reader,

898
00:34:15,918 --> 00:34:19,270
we just select what data we want from this here database.

899
00:34:19,438 --> 00:34:20,478
But even more powerfully,

900
00:34:20,600 --> 00:34:22,280
SQL comes with a whole bunch of functions

901
00:34:22,280 --> 00:34:24,679
built in quite like the spreadsheet software that you

902
00:34:24,679 --> 00:34:26,159
and I are already familiar with in the real

903
00:34:26,159 --> 00:34:29,040
world like Excel and Numbers and Google Sheets.

904
00:34:29,708 --> 00:34:31,590
SQLite comes with an average function,

905
00:34:31,790 --> 00:34:32,270
account function,

906
00:34:32,350 --> 00:34:33,600
distinct lower min,

907
00:34:33,949 --> 00:34:34,139
uh,

908
00:34:34,149 --> 00:34:34,708
max min,

909
00:34:34,790 --> 00:34:35,530
upper case,

910
00:34:35,830 --> 00:34:36,550
and so forth.

911
00:34:36,590 --> 00:34:37,699
There's a whole list of them.

912
00:34:37,870 --> 00:34:39,629
We'll play around with just a couple of these

913
00:34:39,629 --> 00:34:41,179
if we want to transform some of this data.

914
00:34:41,270 --> 00:34:42,550
Let me go back into VS code,

915
00:34:42,668 --> 00:34:44,340
clear my SQLite terminal,

916
00:34:44,510 --> 00:34:48,668
and suppose I just want to get the total number of rows in the favorites table,

917
00:34:48,719 --> 00:34:51,830
like how many people at the moment in time I downloaded the file,

918
00:34:51,909 --> 00:34:53,830
even if not everyone had quite buzzed in yet.

919
00:34:54,339 --> 00:34:55,989
Did I end up with in that file?

920
00:34:56,099 --> 00:34:56,217
Well,

921
00:34:56,299 --> 00:35:02,059
I could say select the count of all of the rows from the favorites table,

922
00:35:02,099 --> 00:35:02,819
semicolon,

923
00:35:02,858 --> 00:35:04,569
and now I'll get back a single cell,

924
00:35:04,779 --> 00:35:09,928
which gives me 272 submissions had come in the moment I downloaded that file.

925
00:35:10,259 --> 00:35:11,448
Suppose I want to see

926
00:35:11,698 --> 00:35:14,878
just to confirm that no one submitted bogus data

927
00:35:14,878 --> 00:35:17,908
which languages were actually among those typed in.

928
00:35:18,099 --> 00:35:20,138
Well I can select only the distinct.

929
00:35:20,245 --> 00:35:24,114
Languages that were typed in from the favorites table and now I get a

930
00:35:24,114 --> 00:35:27,354
unique list of languages that everyone buzzed

931
00:35:27,354 --> 00:35:29,784
in with irrespective of how many times.

932
00:35:30,034 --> 00:35:31,364
If I want to maybe get

933
00:35:31,764 --> 00:35:33,614
um how many distinct languages there are,

934
00:35:33,675 --> 00:35:35,824
if it's not as obvious as 3 here,

935
00:35:35,995 --> 00:35:40,304
I could select the count of distinct languages from

936
00:35:40,544 --> 00:35:41,564
the favorites table,

937
00:35:41,574 --> 00:35:42,864
and that would just tell me the answer.

938
00:35:42,985 --> 00:35:46,235
3 is the total number of languages that are distinct.

939
00:35:46,699 --> 00:35:47,889
In that submission,

940
00:35:48,060 --> 00:35:49,949
so again it's easy to just eyeball this,

941
00:35:50,060 --> 00:35:54,530
but very quickly with single statements that are sort of English like left to right

942
00:35:54,860 --> 00:35:58,810
is enabling me to just select the answers I want to some of these problems.

943
00:35:58,899 --> 00:35:58,949
Well,

944
00:35:59,020 --> 00:36:00,250
what more can SQL do?

945
00:36:00,419 --> 00:36:00,649
Well,

946
00:36:00,780 --> 00:36:02,620
here is a bunch of other.

947
00:36:03,199 --> 00:36:07,030
A keywords that we can add to our SQL commands that allow us

948
00:36:07,030 --> 00:36:09,649
to control further what kind of data we're going to get back.

949
00:36:09,790 --> 00:36:12,310
We're going to be able to group data by similar values.

950
00:36:12,429 --> 00:36:15,219
We're going to check for not not just string equality but for

951
00:36:15,629 --> 00:36:16,419
fuzzy matching,

952
00:36:16,550 --> 00:36:19,199
checking if something is close to a string that we're looking for.

953
00:36:19,270 --> 00:36:21,070
We can limit the total number of rows coming back.

954
00:36:21,270 --> 00:36:23,820
We can order or sort the data by a certain column,

955
00:36:23,889 --> 00:36:25,550
and we can actually have predicates,

956
00:36:25,590 --> 00:36:26,020
so to speak,

957
00:36:26,030 --> 00:36:27,750
using a where which is similar in.

958
00:36:27,992 --> 00:36:29,732
It to an if condition,

959
00:36:29,883 --> 00:36:31,782
but a little more succinctly written instead.

960
00:36:31,943 --> 00:36:32,502
So for instance,

961
00:36:32,623 --> 00:36:34,052
let me go back to VS code here.

962
00:36:34,343 --> 00:36:35,732
Let me clear my terminal again

963
00:36:35,863 --> 00:36:39,653
and let me go ahead and select how many of you answered

964
00:36:39,653 --> 00:36:43,693
C is your favorite language without selecting all of the counts again.

965
00:36:43,853 --> 00:36:45,812
Let's just hit the nail on the head.

966
00:36:46,022 --> 00:36:48,653
So let's select the count of rows

967
00:36:49,103 --> 00:36:49,653
from

968
00:36:49,863 --> 00:36:51,093
the favorites table

969
00:36:51,462 --> 00:36:52,702
where the language.

970
00:36:52,815 --> 00:36:54,625
Selected equals quote unquote

971
00:36:55,575 --> 00:36:56,355
semicolon,

972
00:36:56,436 --> 00:37:00,575
and I get back a simple answer 58 of you buzzed in with the answer C.

973
00:37:00,895 --> 00:37:03,696
How many of you liked both C and very

974
00:37:03,696 --> 00:37:06,605
specifically the problem called hello world if you sort of

975
00:37:06,855 --> 00:37:09,855
that was the extent of your sort of um the passion for for code,

976
00:37:09,936 --> 00:37:13,895
let's go ahead and select the count of star from favorites

977
00:37:13,895 --> 00:37:17,416
where the language you typed in equals quote unquote C.

978
00:37:17,830 --> 00:37:18,139
Uh,

979
00:37:18,270 --> 00:37:24,379
and the problem you typed in equals quote unquote hello world semicolon,

980
00:37:24,510 --> 00:37:26,310
and it looks like 5 of you said your

981
00:37:26,310 --> 00:37:28,669
favorite language was C and your favorite program was

982
00:37:28,989 --> 00:37:29,739
hello world.

983
00:37:29,870 --> 00:37:30,179
Great.

984
00:37:30,649 --> 00:37:30,899
All right,

985
00:37:31,110 --> 00:37:32,600
so it's getting a little more interesting.

986
00:37:32,669 --> 00:37:37,100
What about the other version of Hello World where we called it hello it's me?

987
00:37:37,270 --> 00:37:37,350
Well,

988
00:37:37,389 --> 00:37:39,330
that one's interesting because I think it's gonna

989
00:37:39,330 --> 00:37:41,510
break my convention of using single quotes,

990
00:37:41,590 --> 00:37:42,989
which would be convention here in SQL.

991
00:37:43,070 --> 00:37:44,520
Whenever you're using a raw string,

992
00:37:44,750 --> 00:37:46,379
single quotes here would be the norm,

993
00:37:46,429 --> 00:37:46,989
but let's type this.

994
00:37:47,136 --> 00:37:50,267
Out so select count of star

995
00:37:51,126 --> 00:37:55,656
from favorites where language equals quote unquote C

996
00:37:56,007 --> 00:37:59,666
and the problem this time equals quote unquote hello

997
00:38:00,126 --> 00:38:00,596
it's

998
00:38:00,846 --> 00:38:01,316
me.

999
00:38:01,566 --> 00:38:06,037
So at a glance this is probably going to confuse SQLite 3 because does that

1000
00:38:06,336 --> 00:38:09,556
middle apostrophe belong to the first one or the second one.

1001
00:38:09,773 --> 00:38:11,313
is ambiguous and this is weird.

1002
00:38:11,404 --> 00:38:13,674
In C we would solve this problem by putting

1003
00:38:13,884 --> 00:38:16,354
a backslash in front of it and a so-called escape character.

1004
00:38:16,434 --> 00:38:18,033
Different languages have different conventions.

1005
00:38:18,204 --> 00:38:19,083
This one's a little weird,

1006
00:38:19,164 --> 00:38:23,434
but in SQL light what you instead do is doubly single quote it.

1007
00:38:23,604 --> 00:38:27,533
So putting two single quotes is the convention for escaping

1008
00:38:27,763 --> 00:38:30,474
a single quote just because you got to remember

1009
00:38:30,474 --> 00:38:32,283
or Google these kinds of things in the real.

1010
00:38:32,561 --> 00:38:33,190
If you forget.

1011
00:38:33,400 --> 00:38:34,871
Enter now I get back that.

1012
00:38:35,000 --> 00:38:39,710
So it was not the case that any of you liked both C and that problem

1013
00:38:40,121 --> 00:38:40,670
specifically.

1014
00:38:40,841 --> 00:38:40,960
Well,

1015
00:38:41,000 --> 00:38:44,000
what if we want to be a little more inclusive of either hello problem?

1016
00:38:44,081 --> 00:38:44,121
Well,

1017
00:38:44,200 --> 00:38:45,510
I could do this in this way,

1018
00:38:46,081 --> 00:38:47,230
just like in my

1019
00:38:48,041 --> 00:38:49,081
code spaces terminal.

1020
00:38:49,121 --> 00:38:51,351
I can go up and down to go back through my history.

1021
00:38:51,561 --> 00:38:52,470
Same thing in SQLite,

1022
00:38:52,520 --> 00:38:54,881
so I can go back to commands to get up here.

1023
00:38:55,199 --> 00:38:57,300
And let me go ahead and write something longer

1024
00:38:57,669 --> 00:38:59,100
where the problem is

1025
00:38:59,350 --> 00:39:04,020
hello world or the problem equals quote unquote hello,

1026
00:39:04,270 --> 00:39:04,780
it's

1027
00:39:05,030 --> 00:39:06,989
double apostrophe me

1028
00:39:07,669 --> 00:39:11,350
single apostrophe semicolon and parenthesis so it's wrapped onto

1029
00:39:11,350 --> 00:39:12,919
two lines here so it's a little messy,

1030
00:39:12,989 --> 00:39:18,340
but I'm just logically saying where you buzzed in with C as your language and

1031
00:39:18,590 --> 00:39:19,350
a problem of.

1032
00:39:19,465 --> 00:39:21,735
A world or a problem of hello it's me E.

1033
00:39:22,334 --> 00:39:25,995
It should be the same answer as before because none of you liked hello it's me,

1034
00:39:26,014 --> 00:39:30,364
but I chose this syntax because I can actually make this a little cleaner.

1035
00:39:30,574 --> 00:39:33,294
I can go and delete this whole parenthetical

1036
00:39:33,574 --> 00:39:36,844
and just say we're language equals C and the problem

1037
00:39:37,215 --> 00:39:39,885
is like quote unquote hello

1038
00:39:41,054 --> 00:39:43,655
percent sign single semicolon.

1039
00:39:43,909 --> 00:39:45,179
So this is a little weird too.

1040
00:39:45,219 --> 00:39:47,449
It's just how SQL does this instead,

1041
00:39:47,659 --> 00:39:49,830
but whereas previously I was using an equal

1042
00:39:49,830 --> 00:39:52,000
sign to check for literal string equality,

1043
00:39:52,060 --> 00:39:56,050
like literally those problem names like allows me to use wildcards,

1044
00:39:56,060 --> 00:40:00,090
and it's not a wildcard quite like the previous use of the asterisk that we saw

1045
00:40:00,419 --> 00:40:03,510
when you are using a Wildcard in a string

1046
00:40:03,800 --> 00:40:08,800
in sequel you say percent sign to represent zero or more characters

1047
00:40:08,800 --> 00:40:14,379
there so hello comma space percent is going to hopefully match this or

1048
00:40:14,719 --> 00:40:17,040
the other problem that started with hello comma.

1049
00:40:17,280 --> 00:40:18,590
So let me go ahead now

1050
00:40:19,080 --> 00:40:19,790
and hit enter.

1051
00:40:19,840 --> 00:40:21,270
The answer is still gonna be the same,

1052
00:40:21,639 --> 00:40:24,479
but indeed it's demonstrative that that is how you could express yourself

1053
00:40:24,479 --> 00:40:27,399
a little more generally if you wanted a pattern match like that.

1054
00:40:28,399 --> 00:40:29,419
Questions now

1055
00:40:29,560 --> 00:40:30,520
on any of these techniques,

1056
00:40:30,600 --> 00:40:30,919
yeah.

1057
00:40:32,389 --> 00:40:32,879
they have

1058
00:40:34,060 --> 00:40:34,350
Uh,

1059
00:40:34,479 --> 00:40:34,870
good question.

1060
00:40:34,909 --> 00:40:37,409
Does it have to be capitalized when doing string equality,

1061
00:40:37,469 --> 00:40:37,899
yes,

1062
00:40:38,070 --> 00:40:39,610
but not with like.

1063
00:40:39,620 --> 00:40:41,939
Like will tolerate case insensitivity,

1064
00:40:42,189 --> 00:40:43,659
so upper case or lower case.

1065
00:40:45,909 --> 00:40:46,500
00,

1066
00:40:46,540 --> 00:40:46,820
I see.

1067
00:40:46,909 --> 00:40:47,300
Good question.

1068
00:40:47,419 --> 00:40:48,459
So the capitalization,

1069
00:40:48,540 --> 00:40:50,659
so stylistically in SQL,

1070
00:40:50,739 --> 00:40:51,689
I would argue,

1071
00:40:51,739 --> 00:40:53,580
and this is a stylistic convention in SQL,

1072
00:40:53,659 --> 00:40:55,179
certainly for CS 50 and also for a lot of

1073
00:40:55,179 --> 00:41:00,209
companies and communities in the world to uppercase your SQL keywords

1074
00:41:00,580 --> 00:41:03,340
just to make them stand out from words that you and I.

1075
00:41:03,429 --> 00:41:06,659
Chose is like the name of the table or the name of the columns they're in.

1076
00:41:06,870 --> 00:41:07,790
This is just a convention.

1077
00:41:07,870 --> 00:41:09,739
I would propose like always to be consistent,

1078
00:41:09,750 --> 00:41:11,820
but for CS 50 and for Style 50's sake,

1079
00:41:12,070 --> 00:41:14,439
I would propose that you indeed capitalize like this and

1080
00:41:14,439 --> 00:41:16,520
frankly it just makes it easier to read to my

1081
00:41:16,520 --> 00:41:18,870
eye because the SQL stuff jumps out and then the

1082
00:41:18,870 --> 00:41:20,929
lower case stuff is specific to your data set.

1083
00:41:21,389 --> 00:41:22,030
A good question.

1084
00:41:23,649 --> 00:41:24,120
All right.

1085
00:41:24,290 --> 00:41:25,419
How about

1086
00:41:25,939 --> 00:41:26,739
another

1087
00:41:27,169 --> 00:41:29,889
uh set of keywords that we saw on the screen earlier,

1088
00:41:30,010 --> 00:41:31,889
namely grouping by.

1089
00:41:31,969 --> 00:41:32,090
Well,

1090
00:41:32,399 --> 00:41:34,639
suppose we have a data set like this,

1091
00:41:34,899 --> 00:41:35,379
whereby,

1092
00:41:35,540 --> 00:41:36,080
oops,

1093
00:41:36,530 --> 00:41:38,120
we suppose we have a data set like this,

1094
00:41:38,209 --> 00:41:39,360
whereby

1095
00:41:40,340 --> 00:41:41,250
How does this go?

1096
00:41:41,939 --> 00:41:42,750
Happy Halloween.

1097
00:41:43,459 --> 00:41:45,449
Whereby here's just an excerpt from that table.

1098
00:41:45,580 --> 00:41:47,050
So for as languages go,

1099
00:41:47,169 --> 00:41:47,260
uh,

1100
00:41:47,379 --> 00:41:49,129
say one of you liked C,

1101
00:41:49,459 --> 00:41:51,989
2 of you like 3 of you liked Python,

1102
00:41:52,020 --> 00:41:53,459
and then now that we're introducing SQL,

1103
00:41:53,500 --> 00:41:56,409
let's imagine that 2 of you now like SQL even better.

1104
00:41:56,580 --> 00:41:57,899
So that's the extent of the data set.

1105
00:41:58,139 --> 00:42:03,340
Wouldn't it be nice to be able to figure out how many of you like C or Python or SQL?

1106
00:42:03,459 --> 00:42:03,580
Well,

1107
00:42:03,699 --> 00:42:05,560
I could write some Python code,

1108
00:42:05,629 --> 00:42:06,260
open the file,

1109
00:42:06,300 --> 00:42:07,699
iterate over it using variables,

1110
00:42:07,780 --> 00:42:08,459
using a dictionary,

1111
00:42:08,469 --> 00:42:10,060
and those what 20 or.

1112
00:42:10,172 --> 00:42:12,392
Lines of code we wrote earlier to answer this question.

1113
00:42:12,681 --> 00:42:15,832
Wouldn't it be nice to just ask the SQL language

1114
00:42:16,041 --> 00:42:17,721
to figure out how many of you like C,

1115
00:42:17,882 --> 00:42:18,822
how many of you like Python,

1116
00:42:18,882 --> 00:42:19,802
how many of you like SQL?

1117
00:42:19,822 --> 00:42:21,912
We can do this by grouping

1118
00:42:22,122 --> 00:42:24,352
these cells by common values.

1119
00:42:24,362 --> 00:42:26,511
Let's group all of the Python rows together

1120
00:42:26,681 --> 00:42:28,471
and all of the SQL rows together,

1121
00:42:28,511 --> 00:42:29,602
and even though there's just one,

1122
00:42:29,642 --> 00:42:31,112
all of the Crows as well.

1123
00:42:31,322 --> 00:42:32,122
So how can we do this?

1124
00:42:32,281 --> 00:42:32,332
Well,

1125
00:42:32,402 --> 00:42:33,112
let me go

1126
00:42:33,711 --> 00:42:35,832
back to VS code here and clear my terminal,

1127
00:42:36,082 --> 00:42:36,961
and let's do this.

1128
00:42:37,083 --> 00:42:37,983
Let's select

1129
00:42:38,233 --> 00:42:39,343
every language,

1130
00:42:39,793 --> 00:42:40,303
but

1131
00:42:40,593 --> 00:42:42,823
it's respective count as well

1132
00:42:43,313 --> 00:42:44,714
from the favorites table,

1133
00:42:44,724 --> 00:42:45,144
but

1134
00:42:45,474 --> 00:42:48,624
before you do any of that group everything by

1135
00:42:48,954 --> 00:42:49,704
language.

1136
00:42:49,993 --> 00:42:52,343
So this one takes a little more practice and getting used to,

1137
00:42:52,434 --> 00:42:57,543
but this is simply saying select all of the uh it's saying look at the languages,

1138
00:42:57,864 --> 00:43:02,023
essentially group all of the common languages together and then figure out

1139
00:43:02,313 --> 00:43:03,874
what count that gives you for all.

1140
00:43:03,996 --> 00:43:05,305
Of the grouped rows.

1141
00:43:05,426 --> 00:43:06,496
If I hit enter here,

1142
00:43:06,666 --> 00:43:09,105
we'll get an answer just like the Python code that

1143
00:43:09,105 --> 00:43:11,575
took me 20 lines of code to write earlier.

1144
00:43:11,766 --> 00:43:14,976
What's really happening though in the database is something a little bit like this.

1145
00:43:15,266 --> 00:43:15,575
Notice,

1146
00:43:15,585 --> 00:43:16,095
of course,

1147
00:43:16,135 --> 00:43:17,656
that there's only one version of C.

1148
00:43:17,946 --> 00:43:21,275
There's then 3 versions of Python and there's 2 examples of SQL,

1149
00:43:21,506 --> 00:43:24,226
and the table I'm essentially building is to group all of those

1150
00:43:24,226 --> 00:43:28,226
by identical values and then spit out the total counts here.

1151
00:43:28,305 --> 00:43:29,575
Now on the screen it's just 13,

1152
00:43:29,585 --> 00:43:30,785
and 2 in the data set.

1153
00:43:30,907 --> 00:43:34,077
With some 200+ responses we have much larger answers,

1154
00:43:34,177 --> 00:43:36,728
including Scratch instead of SQL right here.

1155
00:43:36,978 --> 00:43:40,288
But this now sort of speaks to just how much more convenient it is to,

1156
00:43:40,458 --> 00:43:41,818
if you want to ask a question like that,

1157
00:43:41,937 --> 00:43:44,208
especially if the data set is more than a couple 100 rows,

1158
00:43:44,298 --> 00:43:44,857
if your boss,

1159
00:43:44,867 --> 00:43:45,177
for instance,

1160
00:43:45,187 --> 00:43:48,407
in the real world has a CSV data set and wants you to analyze the data,

1161
00:43:48,617 --> 00:43:48,657
well,

1162
00:43:48,697 --> 00:43:49,697
you can literally download it,

1163
00:43:49,738 --> 00:43:50,897
import it into SQLite,

1164
00:43:50,937 --> 00:43:51,657
run one command,

1165
00:43:51,667 --> 00:43:52,177
and boom,

1166
00:43:52,298 --> 00:43:55,177
like you've got this analysis done if the extent of

1167
00:43:55,177 --> 00:43:57,697
it is just to group the data and figure out.

1168
00:43:58,070 --> 00:43:58,570
Uh,

1169
00:43:58,649 --> 00:43:59,719
what kinds of,

1170
00:43:59,939 --> 00:44:00,189
uh,

1171
00:44:00,209 --> 00:44:02,120
accounts you have in the data set.

1172
00:44:02,370 --> 00:44:02,489
All right,

1173
00:44:02,570 --> 00:44:03,250
what else can we do?

1174
00:44:03,350 --> 00:44:03,449
Well,

1175
00:44:03,530 --> 00:44:05,010
we can play around with this a bit more.

1176
00:44:05,169 --> 00:44:06,919
Let me go back here into VS code

1177
00:44:07,290 --> 00:44:09,209
and propose that we could.

1178
00:44:09,610 --> 00:44:09,850
Uh,

1179
00:44:09,929 --> 00:44:13,330
order those results more than just the uh the default way.

1180
00:44:13,449 --> 00:44:15,040
So let's go ahead and select the language

1181
00:44:15,489 --> 00:44:17,040
and the count from

1182
00:44:17,250 --> 00:44:19,000
the favorites table yet again.

1183
00:44:19,209 --> 00:44:21,879
Let's group by language yet again,

1184
00:44:22,010 --> 00:44:24,270
but this time let's order by

1185
00:44:24,530 --> 00:44:27,719
the counts column in descending order.

1186
00:44:27,969 --> 00:44:29,290
So it's a bit more of a mouthful and it

1187
00:44:29,290 --> 00:44:31,239
takes some practice to memorize all of the syntax,

1188
00:44:31,290 --> 00:44:32,629
but when I hit enter now,

1189
00:44:32,689 --> 00:44:33,889
I get back the same answers,

1190
00:44:33,929 --> 00:44:34,300
but Python.

1191
00:44:34,491 --> 00:44:36,241
is at the very top of the list.

1192
00:44:36,451 --> 00:44:40,771
Now Countar isn't necessarily all that self explanatory

1193
00:44:40,771 --> 00:44:42,531
and indeed it's a little annoying that I

1194
00:44:42,531 --> 00:44:45,521
have to write out Countar here at top right as well as in the beginning.

1195
00:44:45,691 --> 00:44:47,922
So it turns out SQL also supports aliases.

1196
00:44:48,172 --> 00:44:50,652
So if you want to change the temporary name of

1197
00:44:50,652 --> 00:44:53,761
the column to be something else like N for number,

1198
00:44:53,931 --> 00:44:57,441
well then I can actually define an alias with the keyword as

1199
00:44:57,691 --> 00:44:59,211
order by N at the end.

1200
00:44:59,343 --> 00:45:02,763
Of this statement and then hit enter and get back the same results too.

1201
00:45:02,974 --> 00:45:04,083
And so if it's not

1202
00:45:04,333 --> 00:45:06,404
sort of implicitly clear already,

1203
00:45:06,813 --> 00:45:11,724
each of these SQL select commands is essentially giving me back a temporary table.

1204
00:45:11,854 --> 00:45:14,093
This is not being saved anywhere like now it's gone

1205
00:45:14,093 --> 00:45:16,604
from the computer's memory once I've actually gotten my answer,

1206
00:45:16,854 --> 00:45:19,053
but it's essentially returning a subset

1207
00:45:19,293 --> 00:45:21,813
of the tables that do exist in the computer's

1208
00:45:21,813 --> 00:45:24,174
memory because that's what the import command did for.

1209
00:45:24,266 --> 00:45:24,525
Me,

1210
00:45:24,696 --> 00:45:26,966
it loaded the whole data set into memory,

1211
00:45:27,176 --> 00:45:29,486
and now I have these temporary tables

1212
00:45:29,815 --> 00:45:32,565
that are just containing the answers to questions I care about.

1213
00:45:32,736 --> 00:45:34,605
And if you only care about the top one language,

1214
00:45:34,696 --> 00:45:34,966
well,

1215
00:45:35,135 --> 00:45:36,486
there's a limit keyword too.

1216
00:45:36,555 --> 00:45:41,045
I can literally just say limit one at the end of that exact same statement enter,

1217
00:45:41,256 --> 00:45:43,855
and now I've got the single answer to my question,

1218
00:45:43,936 --> 00:45:49,055
a single row saying Python was the most popular with 190 people selecting that.

1219
00:45:50,560 --> 00:45:50,679
All right,

1220
00:45:50,760 --> 00:45:51,040
for now,

1221
00:45:51,080 --> 00:45:52,800
I think that's enough on select.

1222
00:45:53,000 --> 00:45:53,959
There's a few more keywords,

1223
00:45:54,000 --> 00:45:56,870
but it really is just a matter of composing these building blocks,

1224
00:45:57,270 --> 00:45:59,310
questions though on these capabilities.

1225
00:46:00,510 --> 00:46:01,580
Fundamentally.

1226
00:46:04,100 --> 00:46:04,439
No.

1227
00:46:04,629 --> 00:46:04,719
All right,

1228
00:46:04,770 --> 00:46:04,919
well,

1229
00:46:04,929 --> 00:46:07,500
how about maybe inserting data instead?

1230
00:46:07,570 --> 00:46:11,939
So here might be the canonical way to insert a row into a table in SQL.

1231
00:46:11,969 --> 00:46:14,800
You literally say insert into then the name of the table,

1232
00:46:15,010 --> 00:46:18,280
then in parentheses the one or more columns for which you have data,

1233
00:46:18,489 --> 00:46:20,419
and then literally the word values,

1234
00:46:20,429 --> 00:46:23,239
and then in another set of parentheses a comma separated list

1235
00:46:23,239 --> 00:46:25,689
of the one or more values that you want to insert

1236
00:46:26,010 --> 00:46:26,810
into those that.

1237
00:46:27,175 --> 00:46:27,725
columns.

1238
00:46:27,814 --> 00:46:28,824
So for instance,

1239
00:46:28,975 --> 00:46:31,165
let me go back into VS code here and of course

1240
00:46:31,165 --> 00:46:34,445
at the time we circulated this form a few minutes ago,

1241
00:46:34,534 --> 00:46:36,375
we had not yet assigned problem set 7.

1242
00:46:36,455 --> 00:46:40,014
But in problem set 7 is a problem called 50ville which

1243
00:46:40,014 --> 00:46:42,764
let's propose might very well be someone's favorite in a week.

1244
00:46:42,975 --> 00:46:46,725
So let's go ahead and insert that row now preemptively.

1245
00:46:46,895 --> 00:46:49,564
Let's insert into the favorites table.

1246
00:46:50,139 --> 00:46:52,770
Two columns language and problem.

1247
00:46:52,979 --> 00:46:53,370
Why?

1248
00:46:53,540 --> 00:46:53,639
Well,

1249
00:46:53,739 --> 00:46:56,820
I don't really care to figure out what the time stamp is and the format thereof,

1250
00:46:56,879 --> 00:46:59,050
so I'm just going to omit the time stamp altogether,

1251
00:46:59,179 --> 00:47:02,419
but the values I'm going to insert for this new row are

1252
00:47:02,419 --> 00:47:04,709
going to be are going to be quote unquote SQL 50 ville

1253
00:47:08,860 --> 00:47:08,989
close

1254
00:47:09,129 --> 00:47:10,969
close parenthesis semicolon.

1255
00:47:11,139 --> 00:47:11,310
E.

1256
00:47:12,189 --> 00:47:13,580
Nothing bad seems to have happened.

1257
00:47:13,750 --> 00:47:16,149
Let me go ahead and select star from favorites just

1258
00:47:16,149 --> 00:47:17,699
to see what my data set looks like now.

1259
00:47:17,909 --> 00:47:20,979
And indeed at the bottom of the file or the bottom of the table,

1260
00:47:21,030 --> 00:47:22,739
indeed there is that new row.

1261
00:47:22,949 --> 00:47:25,899
But what's sort of noteworthy is that this isn't just blank.

1262
00:47:26,149 --> 00:47:27,429
There's our old friend null,

1263
00:47:27,469 --> 00:47:28,979
which is not a null pointer,

1264
00:47:28,989 --> 00:47:29,820
it's the same word,

1265
00:47:29,989 --> 00:47:31,780
literally NULL,

1266
00:47:31,790 --> 00:47:34,100
and it refers explicitly to the absence of data.

1267
00:47:34,229 --> 00:47:36,949
And this is actually a nice feature because if any of you have ever used like Google.

1268
00:47:37,070 --> 00:47:37,419
Spreadsheets,

1269
00:47:37,459 --> 00:47:37,949
Apple numbers,

1270
00:47:38,060 --> 00:47:39,070
Microsoft Excel

1271
00:47:39,379 --> 00:47:40,409
and thought about

1272
00:47:40,739 --> 00:47:42,469
uh or looked at cells that are blank.

1273
00:47:42,620 --> 00:47:44,760
Like what does it mean if a spreadsheet cell is blank?

1274
00:47:44,939 --> 00:47:47,209
Does it mean like there's literally no data there?

1275
00:47:47,379 --> 00:47:51,770
Does it mean that you just don't have the data there or it's missing in some form?

1276
00:47:51,939 --> 00:47:51,979
Well,

1277
00:47:52,060 --> 00:47:52,860
how do you address that?

1278
00:47:52,979 --> 00:47:53,020
Well,

1279
00:47:53,100 --> 00:47:57,300
maybe you put like Nlash A in English for like not available or something like that,

1280
00:47:57,409 --> 00:47:59,449
but that's kind of hackish and if you use NA,

1281
00:47:59,620 --> 00:48:01,939
that might mean that no one can actually type NA at the.

1282
00:48:02,060 --> 00:48:02,520
Answer.

1283
00:48:02,530 --> 00:48:05,770
And so what's nice about SQL and data and database languages

1284
00:48:05,770 --> 00:48:10,600
more generally is that null signifies the conscious omission of data.

1285
00:48:10,770 --> 00:48:12,120
It's not just a missing value,

1286
00:48:12,129 --> 00:48:14,120
it's consciously not there.

1287
00:48:14,290 --> 00:48:15,610
It's not just the empty string,

1288
00:48:15,709 --> 00:48:16,419
quote unquote,

1289
00:48:16,489 --> 00:48:17,280
for instance.

1290
00:48:17,530 --> 00:48:19,040
So we might see different examples of that,

1291
00:48:19,090 --> 00:48:19,550
but

1292
00:48:19,770 --> 00:48:23,370
what's nice now is that I can distinguish null from other values and in fact

1293
00:48:23,370 --> 00:48:26,889
if that is not a good idea to have any data in my data set.

1294
00:48:27,389 --> 00:48:30,090
That is null for whatever reason like it just looks like bogus data.

1295
00:48:30,129 --> 00:48:32,239
It would be nice to know who inserted that when,

1296
00:48:32,570 --> 00:48:33,280
no problem.

1297
00:48:33,409 --> 00:48:35,409
We can also delete data from a table in SQL,

1298
00:48:35,419 --> 00:48:39,479
and I can delete from the name of the table where some condition is true.

1299
00:48:39,610 --> 00:48:40,520
So for instance,

1300
00:48:40,770 --> 00:48:42,080
if I want to delete that,

1301
00:48:42,290 --> 00:48:43,649
I can do this in a couple of ways,

1302
00:48:43,689 --> 00:48:46,889
but perhaps the simplest is to delete from.

1303
00:48:48,479 --> 00:48:49,459
Favorites,

1304
00:48:49,840 --> 00:48:50,550
where,

1305
00:48:50,879 --> 00:48:51,310
uh,

1306
00:48:51,320 --> 00:48:52,310
time stamp

1307
00:48:52,879 --> 00:48:53,510
is

1308
00:48:53,679 --> 00:48:54,350
null,

1309
00:48:54,520 --> 00:48:55,469
semicolon.

1310
00:48:55,679 --> 00:48:57,830
So is 2 is another SQL keyword here,

1311
00:48:57,860 --> 00:48:59,300
and that will go ahead and delete

1312
00:48:59,639 --> 00:49:02,389
only those rows where the time stamp is null.

1313
00:49:02,870 --> 00:49:03,500
Enter.

1314
00:49:03,830 --> 00:49:05,820
Let's do the same select command as before.

1315
00:49:06,020 --> 00:49:07,469
Enter and voila,

1316
00:49:07,590 --> 00:49:08,979
that row is now gone.

1317
00:49:09,229 --> 00:49:09,820
Be very,

1318
00:49:09,909 --> 00:49:09,979
very,

1319
00:49:10,149 --> 00:49:12,419
very careful with delete

1320
00:49:12,679 --> 00:49:13,340
statements.

1321
00:49:13,550 --> 00:49:15,040
If I had foolishly

1322
00:49:15,310 --> 00:49:16,270
done this,

1323
00:49:16,629 --> 00:49:18,459
wanna guess what the results would be.

1324
00:49:21,399 --> 00:49:24,530
It would delete everything and like you can Google around and see

1325
00:49:24,530 --> 00:49:27,669
actual articles of like interns at companies who had way too much

1326
00:49:27,669 --> 00:49:29,520
access to a company database executing

1327
00:49:29,520 --> 00:49:30,870
something like delete from favorites because

1328
00:49:30,870 --> 00:49:34,219
they forgot the predicate they hit enter too soon and boom,

1329
00:49:34,550 --> 00:49:36,219
all of the data is now gone.

1330
00:49:36,350 --> 00:49:38,709
So these are very destructive commands and just like in the real

1331
00:49:38,709 --> 00:49:42,899
world if you don't have backups or versions of these same tables,

1332
00:49:42,949 --> 00:49:44,750
the data can indeed be lost.

1333
00:49:45,145 --> 00:49:46,574
So don't do that.

1334
00:49:46,784 --> 00:49:48,735
Always have your wear and make sure

1335
00:49:48,985 --> 00:49:50,685
your wear is correct.

1336
00:49:51,215 --> 00:49:51,344
All right,

1337
00:49:51,504 --> 00:49:51,614
well,

1338
00:49:51,625 --> 00:49:53,754
let's go ahead maybe and um

1339
00:49:54,344 --> 00:49:56,705
suppose let's claim that maybe 50ville is going

1340
00:49:56,705 --> 00:49:58,824
to be a really popular problem among students,

1341
00:49:58,905 --> 00:50:01,304
so much so that it becomes overnight everyone's favorite problem.

1342
00:50:01,425 --> 00:50:01,504
Well,

1343
00:50:01,544 --> 00:50:03,215
we can update the table as is.

1344
00:50:03,504 --> 00:50:06,054
Here is the general syntax for updating rows in a table.

1345
00:50:06,104 --> 00:50:08,294
You literally say update the name of the table.

1346
00:50:08,570 --> 00:50:12,229
The word set and then a bunch of key value pairs.

1347
00:50:12,239 --> 00:50:14,429
The column that you want to update

1348
00:50:14,870 --> 00:50:17,959
setting it equal to the value that you want to update it to

1349
00:50:18,439 --> 00:50:19,800
where some condition is true.

1350
00:50:19,879 --> 00:50:21,280
So what does this mean concretely?

1351
00:50:21,399 --> 00:50:21,479
Well,

1352
00:50:21,560 --> 00:50:26,189
let's say that we want to change everyone's favorite to SQL and 50ville.

1353
00:50:26,310 --> 00:50:27,189
I could do this

1354
00:50:27,679 --> 00:50:28,870
update favorites,

1355
00:50:29,229 --> 00:50:32,030
set language equal to SQL,

1356
00:50:33,600 --> 00:50:36,179
problem equal to 50 ville.

1357
00:50:37,020 --> 00:50:38,050
Close quote

1358
00:50:38,419 --> 00:50:39,389
semicolon,

1359
00:50:39,580 --> 00:50:41,219
and this is where again it can be dangerous,

1360
00:50:41,300 --> 00:50:42,820
but in this case I'm gonna go ahead and

1361
00:50:42,820 --> 00:50:45,100
hit enter without any predicate to filter this.

1362
00:50:45,659 --> 00:50:46,929
Nothing bad seems to happen,

1363
00:50:46,989 --> 00:50:50,290
but if I now do select star from favorite semicolon,

1364
00:50:50,300 --> 00:50:50,889
all of you

1365
00:50:51,100 --> 00:50:52,780
would seem to like 50ville,

1366
00:50:52,820 --> 00:50:56,340
and there is no going back to the previous version of the table unless I quit

1367
00:50:56,340 --> 00:51:01,290
out of this and I import the whole CSV again maybe after deleting the data entirely.

1368
00:51:01,500 --> 00:51:01,659
All right,

1369
00:51:01,739 --> 00:51:03,050
so how do I get rid of all of the data?

1370
00:51:03,179 --> 00:51:03,300
Well,

1371
00:51:03,389 --> 00:51:06,090
if you want to delete from favorites for real now,

1372
00:51:06,280 --> 00:51:08,540
enter select star from.

1373
00:51:09,209 --> 00:51:09,969
Favorites,

1374
00:51:10,050 --> 00:51:11,929
we can confirm that that was a bad idea.

1375
00:51:12,010 --> 00:51:15,330
There's literally no data in the database anymore,

1376
00:51:15,649 --> 00:51:18,379
but we can certainly restore from our actual CSV.

1377
00:51:18,729 --> 00:51:19,169
So in short,

1378
00:51:19,250 --> 00:51:20,020
we've got select,

1379
00:51:20,090 --> 00:51:21,080
we've got insert,

1380
00:51:21,209 --> 00:51:22,250
we've got update,

1381
00:51:22,370 --> 00:51:23,639
we've got delete,

1382
00:51:23,889 --> 00:51:24,409
we've seen.

1383
00:51:24,709 --> 00:51:28,080
8 albeit automatically generated by SQL Light 3,

1384
00:51:28,250 --> 00:51:30,709
maybe we'll see Drop and actually we can see Drop now.

1385
00:51:30,729 --> 00:51:32,250
So recall that if I do.

1386
00:51:32,370 --> 00:51:33,040
schema,

1387
00:51:33,169 --> 00:51:35,840
I can see all of the tables in this database.

1388
00:51:36,050 --> 00:51:38,399
If I do drop table

1389
00:51:38,810 --> 00:51:39,379
favorites,

1390
00:51:39,409 --> 00:51:40,320
semicolon,

1391
00:51:40,570 --> 00:51:42,199
and now again do do schema,

1392
00:51:42,370 --> 00:51:44,530
now there is nothing in this database at all.

1393
00:51:44,649 --> 00:51:46,300
So that's an even worse command to run

1394
00:51:46,530 --> 00:51:48,689
unless you know and intend what you're doing.

1395
00:51:49,500 --> 00:51:52,370
Questions then on these crud operations creating,

1396
00:51:52,379 --> 00:51:52,590
reading,

1397
00:51:52,659 --> 00:51:52,939
updating,

1398
00:51:53,000 --> 00:51:54,469
deleting yeah here first.

1399
00:51:59,010 --> 00:52:01,239
Why do you not do quotation marks around null?

1400
00:52:01,449 --> 00:52:03,370
So null is a special symbol,

1401
00:52:03,409 --> 00:52:05,070
and if you put quotation marks around it,

1402
00:52:05,090 --> 00:52:09,110
you would literally be looking for the value NULL that maybe was the name of

1403
00:52:09,110 --> 00:52:12,280
a language or the name of a problem or something literally in the CSV.

1404
00:52:12,530 --> 00:52:15,120
We are looking for the absence of that data altogether,

1405
00:52:15,449 --> 00:52:15,790
yeah.

1406
00:52:22,709 --> 00:52:23,500
Really good question,

1407
00:52:23,510 --> 00:52:25,590
because it's so easy to destroy data like this,

1408
00:52:25,629 --> 00:52:27,100
are people actively backing up their data?

1409
00:52:27,209 --> 00:52:28,139
Short answer yes,

1410
00:52:28,270 --> 00:52:28,780
absolutely.

1411
00:52:28,949 --> 00:52:30,550
Like all of CS 50's web apps and the

1412
00:52:30,550 --> 00:52:32,580
like are automatically backed up on some schedule.

1413
00:52:32,790 --> 00:52:34,540
Even then we have to decide what that schedule is,

1414
00:52:34,570 --> 00:52:35,550
and if it's daily,

1415
00:52:35,709 --> 00:52:36,070
for instance,

1416
00:52:36,189 --> 00:52:36,699
nightly,

1417
00:52:36,830 --> 00:52:38,820
we could lose up to like 23 hours,

1418
00:52:38,899 --> 00:52:41,189
59 minutes of data in some case,

1419
00:52:41,350 --> 00:52:43,590
maybe companies would therefore version their data more tightly,

1420
00:52:43,669 --> 00:52:45,070
like every 5 minutes,

1421
00:52:45,110 --> 00:52:45,629
every minute,

1422
00:52:45,709 --> 00:52:47,300
although that's going to consume a lot more space,

1423
00:52:47,389 --> 00:52:49,830
but there already is this theme of trade off certainly in computer.

1424
00:52:50,485 --> 00:52:52,985
You can also implement forms of access control.

1425
00:52:53,074 --> 00:52:54,354
So SQL Light is lightweight.

1426
00:52:54,375 --> 00:52:56,185
It has no notion of usernames or passwords.

1427
00:52:56,264 --> 00:52:57,215
If you have access to the data,

1428
00:52:57,264 --> 00:52:58,254
you can touch everything,

1429
00:52:58,445 --> 00:53:01,064
but in the real world with commercial and open source

1430
00:53:01,064 --> 00:53:05,455
software like Oracle and SQL Server and Postgrass and MySQL,

1431
00:53:05,665 --> 00:53:08,745
you actually have usernames and passwords and specific permissions,

1432
00:53:08,824 --> 00:53:12,014
so you can give users interns the ability to select data

1433
00:53:12,014 --> 00:53:15,475
but not update or delete or insert data or any combination

1434
00:53:15,665 --> 00:53:16,185
thereof.

1435
00:53:16,344 --> 00:53:17,344
So there are defenses.

1436
00:53:17,810 --> 00:53:18,760
Other questions

1437
00:53:19,050 --> 00:53:20,330
on these here crud.

1438
00:53:21,250 --> 00:53:22,000
Commands

1439
00:53:24,629 --> 00:53:24,979
OK,

1440
00:53:25,179 --> 00:53:27,100
let's go ahead and play with some real world data.

1441
00:53:27,189 --> 00:53:29,100
So many of you might be familiar with IMDB,

1442
00:53:29,139 --> 00:53:30,540
the Internet Movie Database,

1443
00:53:30,550 --> 00:53:32,699
which is a great repository of data for movies

1444
00:53:32,699 --> 00:53:35,209
and also TV shows and actors and the like.

1445
00:53:35,370 --> 00:53:38,330
And within IMDB's website you can actually download

1446
00:53:38,699 --> 00:53:39,939
uh TSV files,

1447
00:53:39,979 --> 00:53:44,500
tab separated values of files that contain a lot of the data from that website.

1448
00:53:44,540 --> 00:53:45,770
So we went ahead and did this.

1449
00:53:45,939 --> 00:53:47,620
We then converted that TSV.

1450
00:53:47,771 --> 00:53:52,392
Data into a whole bunch of SQL tables so that we can begin to play with it

1451
00:53:52,802 --> 00:53:54,471
in the context of TV shows.

1452
00:53:54,541 --> 00:53:54,802
However,

1453
00:53:54,882 --> 00:53:56,922
let's start first with a question about how you

1454
00:53:56,922 --> 00:54:00,681
could go about modeling data for TV shows themselves.

1455
00:54:00,842 --> 00:54:01,552
So for instance,

1456
00:54:01,562 --> 00:54:02,231
in advance,

1457
00:54:02,441 --> 00:54:05,481
I also created a few different spreadsheets that just allowed

1458
00:54:05,481 --> 00:54:08,001
me to play with how I might model data,

1459
00:54:08,162 --> 00:54:09,231
real world data at that.

1460
00:54:09,281 --> 00:54:10,721
So the Office is very popular.

1461
00:54:10,983 --> 00:54:11,174
Uh,

1462
00:54:11,184 --> 00:54:11,733
TV show,

1463
00:54:11,783 --> 00:54:16,093
the US version here is uh the US version here starred Steve Carell and others.

1464
00:54:16,184 --> 00:54:20,894
So if I think about how IMDB or maybe just even little old me with a spreadsheet,

1465
00:54:21,063 --> 00:54:24,174
might keep track of who starred in what TV show,

1466
00:54:24,384 --> 00:54:24,464
well,

1467
00:54:24,503 --> 00:54:26,013
I might just use a Google sheet like this,

1468
00:54:26,063 --> 00:54:28,144
and in the first column have a title column where

1469
00:54:28,144 --> 00:54:30,214
this is the title of the show like The Office,

1470
00:54:30,424 --> 00:54:31,694
and then if it stars one person,

1471
00:54:31,704 --> 00:54:33,614
I would put Steve Carell in the next column,

1472
00:54:33,654 --> 00:54:33,944
but if.

1473
00:54:34,055 --> 00:54:36,605
As a second star I might put Rainn Wilson or John

1474
00:54:36,605 --> 00:54:40,875
or Jenna or BJ Novak here column by column by column,

1475
00:54:40,916 --> 00:54:45,016
and I could just keep adding show after show after show after show one

1476
00:54:45,325 --> 00:54:46,916
row per show

1477
00:54:47,196 --> 00:54:49,996
and then however many stars that are in there.

1478
00:54:50,446 --> 00:54:52,845
What might you not like about the design of this

1479
00:54:52,845 --> 00:54:55,426
data though or what might start to look odd?

1480
00:54:57,439 --> 00:54:57,659
Yeah,

1481
00:54:57,780 --> 00:55:00,770
it's a little weird that we have star star star star star.

1482
00:55:00,820 --> 00:55:02,979
Just this repetition has tended to be bad any time

1483
00:55:02,979 --> 00:55:05,770
we're copying and pasting should rub you the wrong way.

1484
00:55:05,899 --> 00:55:07,260
Other observations about it too?

1485
00:55:08,149 --> 00:55:08,879
Yeah.

1486
00:55:10,020 --> 00:55:10,250
Yeah,

1487
00:55:10,330 --> 00:55:13,120
at the moment I've got 12345 stars,

1488
00:55:13,129 --> 00:55:16,760
and there's certainly TV shows with fewer TV stars and more,

1489
00:55:16,830 --> 00:55:17,159
and so,

1490
00:55:17,169 --> 00:55:17,370
OK,

1491
00:55:17,409 --> 00:55:18,929
I can add more columns.

1492
00:55:18,969 --> 00:55:19,969
I can just keep saying star,

1493
00:55:20,000 --> 00:55:20,570
star,

1494
00:55:20,580 --> 00:55:20,600
star,

1495
00:55:20,649 --> 00:55:23,330
but then it's going to be a very ragged data set,

1496
00:55:23,409 --> 00:55:25,090
very sparse data set where there's gonna be a lot

1497
00:55:25,090 --> 00:55:27,639
of blank cells for shows that have small casts,

1498
00:55:27,649 --> 00:55:30,129
but then a lot of columns for shows that have large casts,

1499
00:55:30,209 --> 00:55:31,739
so it just feels like mm,

1500
00:55:31,770 --> 00:55:33,129
this should be rubbing you the wrong way.

1501
00:55:33,169 --> 00:55:34,729
It just feels like it's gonna get messy,

1502
00:55:35,050 --> 00:55:36,570
especially as the number of stars,

1503
00:55:36,649 --> 00:55:37,729
let alone shows,

1504
00:55:37,850 --> 00:55:38,129
gets.

1505
00:55:38,250 --> 00:55:38,699
Larger.

1506
00:55:38,840 --> 00:55:39,070
All right,

1507
00:55:39,350 --> 00:55:39,429
well,

1508
00:55:39,590 --> 00:55:40,739
another version of this,

1509
00:55:40,870 --> 00:55:41,649
uh,

1510
00:55:41,669 --> 00:55:42,280
data set

1511
00:55:42,419 --> 00:55:44,419
that I put together is this instead.

1512
00:55:44,629 --> 00:55:46,070
So I didn't like the fact that I was going to have

1513
00:55:46,070 --> 00:55:50,860
an arbitrary number of columns based on the specific show in question.

1514
00:55:51,110 --> 00:55:54,939
So here I scaled back and I just have a single column for title as before,

1515
00:55:55,070 --> 00:55:57,260
but now a single column for star,

1516
00:55:57,429 --> 00:56:00,379
and I decided that if a TV show has multiple stars,

1517
00:56:00,469 --> 00:56:03,590
well I just put each of the stars' names and then

1518
00:56:03,590 --> 00:56:06,350
to the left of them specify the show that they're in.

1519
00:56:07,100 --> 00:56:10,060
Seems to be a little better and that I've solved some of the redundancy problem,

1520
00:56:10,139 --> 00:56:11,860
but I've kind of just

1521
00:56:12,139 --> 00:56:15,830
kind of like covered up the hole in a leaky hose and now another leak sprung up here,

1522
00:56:15,899 --> 00:56:17,719
which is to say there's still a bad design.

1523
00:56:18,060 --> 00:56:19,020
What's bad here?

1524
00:56:19,969 --> 00:56:20,360
Yeah.

1525
00:56:22,199 --> 00:56:22,389
Yeah,

1526
00:56:22,510 --> 00:56:23,189
now I've got the office,

1527
00:56:23,229 --> 00:56:23,550
the office,

1528
00:56:23,560 --> 00:56:23,909
the office,

1529
00:56:23,919 --> 00:56:24,320
the office,

1530
00:56:24,389 --> 00:56:25,139
the office,

1531
00:56:25,189 --> 00:56:27,469
and that too feels like I'm wasting space.

1532
00:56:27,500 --> 00:56:28,739
If I manually type this in,

1533
00:56:28,830 --> 00:56:31,699
odds are eventually going to screw up and one of these is going to be misspelled,

1534
00:56:31,709 --> 00:56:33,300
which is going to break something somehow.

1535
00:56:33,469 --> 00:56:35,379
So this too doesn't feel quite ideal.

1536
00:56:35,629 --> 00:56:39,270
So the third and final version I whipped up to model this data,

1537
00:56:39,310 --> 00:56:43,419
which is going to lead us to a similar design in an actual database

1538
00:56:43,870 --> 00:56:46,979
looks a little more arcane but is the right way,

1539
00:56:47,070 --> 00:56:48,110
at least academically,

1540
00:56:48,149 --> 00:56:48,709
to do things,

1541
00:56:48,770 --> 00:56:51,350
and we'll see technologically too this is going to be a big game.

1542
00:56:51,610 --> 00:56:55,439
So here I now have a spreadsheet with 3 separate sheets.

1543
00:56:55,679 --> 00:56:57,080
One is called shows,

1544
00:56:57,120 --> 00:56:58,469
which is selected at the moment.

1545
00:56:58,639 --> 00:56:59,879
Another is called People,

1546
00:57:00,199 --> 00:57:01,229
which is not selected yet,

1547
00:57:01,300 --> 00:57:03,350
and the third of which is called Stars.

1548
00:57:03,760 --> 00:57:04,649
What am I doing here?

1549
00:57:04,800 --> 00:57:04,879
Well,

1550
00:57:05,000 --> 00:57:08,370
notice that in the show sheet I've still got the title column,

1551
00:57:08,439 --> 00:57:10,649
but I've decided to give the office a unique ID,

1552
00:57:10,719 --> 00:57:12,600
much like a Harvard student has a unique ID number,

1553
00:57:12,620 --> 00:57:13,909
much like an employee in a company,

1554
00:57:13,919 --> 00:57:14,239
probably.

1555
00:57:14,344 --> 00:57:15,804
A unique employee ID.

1556
00:57:16,054 --> 00:57:16,685
Similarly,

1557
00:57:16,774 --> 00:57:19,935
have I given the office a unique identifier that happens

1558
00:57:19,935 --> 00:57:22,364
to be the same as it is in IMDB.

1559
00:57:22,655 --> 00:57:23,165
Meanwhile,

1560
00:57:23,254 --> 00:57:26,014
for all of the people that exist in the world of TV shows,

1561
00:57:26,175 --> 00:57:26,604
for instance,

1562
00:57:26,655 --> 00:57:27,635
these 5 folks,

1563
00:57:27,774 --> 00:57:30,844
I have their names as well as unique IDs for them,

1564
00:57:30,854 --> 00:57:33,544
and those integers are unique to the people and no

1565
00:57:33,544 --> 00:57:36,965
connection per se to the show IDs just yet.

1566
00:57:37,360 --> 00:57:40,219
But the third and final sheet I've whipped up is going to be a

1567
00:57:40,219 --> 00:57:44,850
sort of cross referencing sheet that allows me to associate shows with people,

1568
00:57:44,989 --> 00:57:49,530
and at a glance this looks the most arcane of the three because it's just

1569
00:57:49,820 --> 00:57:50,370
numbers,

1570
00:57:50,379 --> 00:57:51,729
it's just integers,

1571
00:57:51,739 --> 00:57:52,169
but

1572
00:57:52,419 --> 00:57:57,250
if you recall from a moment ago that the office's unique ID was 386-676,

1573
00:57:57,419 --> 00:57:57,600
well,

1574
00:57:57,620 --> 00:58:00,209
that's how we associated that show with this person,

1575
00:58:00,219 --> 00:58:01,810
which happens to be Steve Carell,

1576
00:58:02,219 --> 00:58:03,129
and so forth.

1577
00:58:03,300 --> 00:58:04,290
Now at a glance,

1578
00:58:04,540 --> 00:58:05,100
not very useful.

1579
00:58:05,222 --> 00:58:05,613
To me,

1580
00:58:05,772 --> 00:58:06,282
the human,

1581
00:58:06,363 --> 00:58:09,603
unless I do some fancy spreadsheet stuff like the lookups if familiar or the like,

1582
00:58:09,972 --> 00:58:10,403
but

1583
00:58:10,532 --> 00:58:14,762
this is a stepping stone to how proper databases do actually store data.

1584
00:58:14,853 --> 00:58:17,052
What I have done here is normalize the

1585
00:58:17,052 --> 00:58:21,663
data by eliminating all redundancies except for maximally

1586
00:58:22,012 --> 00:58:23,333
some redundant integers.

1587
00:58:23,373 --> 00:58:24,173
And why is that?

1588
00:58:24,292 --> 00:58:24,333
Well,

1589
00:58:24,413 --> 00:58:24,853
integers,

1590
00:58:24,863 --> 00:58:26,093
at least we know from our days in C,

1591
00:58:26,103 --> 00:58:27,173
are going to be a finite length.

1592
00:58:27,212 --> 00:58:28,212
It's going to be 32 bits,

1593
00:58:28,252 --> 00:58:29,232
maybe 64 bits,

1594
00:58:29,363 --> 00:58:31,373
but it's always going to be the same number of bits,

1595
00:58:31,383 --> 00:58:34,516
and that's nice because any time you have Fixed number of bits,

1596
00:58:34,525 --> 00:58:36,845
it lends itself to storing things nicely in an array

1597
00:58:36,845 --> 00:58:40,236
or doing binary search because everything is a predictable distance apart

1598
00:58:40,446 --> 00:58:43,006
as opposed to strings like Steve Carell or John

1599
00:58:43,006 --> 00:58:45,156
Krasinski or the names might vary in length.

1600
00:58:45,486 --> 00:58:49,045
These IDs for the title of the show and these IDs for the

1601
00:58:49,045 --> 00:58:52,805
persons are not going to vary in length because they're all just integers.

1602
00:58:52,926 --> 00:58:55,766
But of course this spreadsheet now much less useful because if

1603
00:58:55,766 --> 00:58:57,406
I want to figure out who is in the office,

1604
00:58:57,486 --> 00:58:59,476
well first I have to figure out what show this is,

1605
00:58:59,645 --> 00:59:00,926
then I have to figure out what.

1606
00:59:01,399 --> 00:59:01,590
Uh,

1607
00:59:01,669 --> 00:59:02,189
person

1608
00:59:02,300 --> 00:59:03,989
this is and this is and this is,

1609
00:59:04,159 --> 00:59:06,870
but that's where SQL is again going to swoop in

1610
00:59:07,080 --> 00:59:08,639
and allow us to solve this problem.

1611
00:59:08,669 --> 00:59:13,399
And indeed SQL is one of the most common ways that web applications today,

1612
00:59:13,560 --> 00:59:16,830
mobile applications today store any amount of data at scale.

1613
00:59:16,840 --> 00:59:19,320
They are most likely not using simple CSV files.

1614
00:59:19,479 --> 00:59:22,360
They are using SQL L Lite or MySQL or Postgress

1615
00:59:22,360 --> 00:59:25,669
or Oracle or other commercial and open source incarnations of

1616
00:59:26,040 --> 00:59:27,479
SQL databases,

1617
00:59:27,560 --> 00:59:29,679
and odds are IMDb might be using.

1618
00:59:30,149 --> 00:59:31,290
The same as well.

1619
00:59:31,820 --> 00:59:31,989
All right,

1620
00:59:32,189 --> 00:59:33,699
so let's go ahead and do this.

1621
00:59:33,790 --> 00:59:37,449
I have created in advance a file called shows.db

1622
00:59:37,790 --> 00:59:41,229
that contains hundreds of thousands of rows from

1623
00:59:41,229 --> 00:59:44,179
TV shows and TV stars and other data from

1624
00:59:44,429 --> 00:59:45,580
IMDB itself,

1625
00:59:45,739 --> 00:59:47,060
and in a moment we'll see

1626
00:59:47,350 --> 00:59:51,219
a database that if drone as a picture looks a little something like this.

1627
00:59:51,310 --> 00:59:52,899
There is going to be a people table,

1628
00:59:53,110 --> 00:59:54,850
there's going to be a shows table.

1629
00:59:55,199 --> 00:59:57,790
Going to be a star's table that somehow links the two.

1630
00:59:57,989 --> 01:00:02,139
There's also going to be a writer's table and a ratings table and a genres table.

1631
01:00:02,149 --> 01:00:04,870
So overnight this sort of escalated quickly from just favorites,

1632
01:00:04,949 --> 01:00:05,979
which was a single table,

1633
01:00:06,110 --> 01:00:08,820
to now a real world data set that has 6 tables.

1634
01:00:08,909 --> 01:00:12,149
But here is the relational in relational databases as

1635
01:00:12,149 --> 01:00:14,780
these arrows are meant to imply right now,

1636
01:00:14,949 --> 01:00:18,429
there are relationships across these several tables.

1637
01:00:18,629 --> 01:00:19,379
Case in point,

1638
01:00:19,669 --> 01:00:20,270
here's people.

1639
01:00:20,360 --> 01:00:24,659
Here and we'll see in a moment that a person in the IMDb world has an ID number,

1640
01:00:24,830 --> 01:00:25,260
a name,

1641
01:00:25,350 --> 01:00:26,500
and a year of birth.

1642
01:00:26,830 --> 01:00:29,590
A show in the IMDB world has a unique ID,

1643
01:00:29,669 --> 01:00:30,189
a title,

1644
01:00:30,300 --> 01:00:31,270
the year it debuted,

1645
01:00:31,280 --> 01:00:32,699
and a total number of episodes.

1646
01:00:32,790 --> 01:00:34,750
But there's no mention of people in shows.

1647
01:00:34,909 --> 01:00:36,820
There's no mention of shows and people.

1648
01:00:36,949 --> 01:00:38,379
But for the arrows,

1649
01:00:38,550 --> 01:00:40,629
there's going to be this third table here,

1650
01:00:40,709 --> 01:00:45,110
stars that somehow links show IDs with person IDs,

1651
01:00:45,120 --> 01:00:45,429
and this is.

1652
01:00:45,520 --> 01:00:49,489
Where relational databases get really powerful because you can solve all of those

1653
01:00:50,030 --> 01:00:51,699
redundancy concerns

1654
01:00:52,070 --> 01:00:56,620
and actually enable yourself to select data much more quickly instead.

1655
01:00:56,750 --> 01:00:58,340
But let's focus on something simple first.

1656
01:00:58,469 --> 01:01:00,699
Let's focus just on the show's table,

1657
01:01:00,989 --> 01:01:03,699
which pictorial might look a little something like this.

1658
01:01:03,870 --> 01:01:06,500
So in just a moment I'm going to go ahead and reopen VS code,

1659
01:01:06,550 --> 01:01:08,949
and I'm going to open up instead of favorites.db.

1660
01:01:09,030 --> 01:01:10,459
I'm going to go ahead and open up.

1661
01:01:11,040 --> 01:01:11,189
Uh,

1662
01:01:11,199 --> 01:01:16,370
a file called shows.db which again I arrived with in advance.

1663
01:01:16,800 --> 01:01:20,520
So if I open up with SQLite 3 shows.db and hit enter,

1664
01:01:20,800 --> 01:01:22,590
I'm back at a SQL prompt.

1665
01:01:22,840 --> 01:01:27,409
Let me go ahead and type schema shows just to show you what

1666
01:01:27,560 --> 01:01:29,600
command created this here table,

1667
01:01:29,610 --> 01:01:31,790
and it got a little more interesting already.

1668
01:01:32,040 --> 01:01:35,479
Notice that the table is called shows and it's got 123.

1669
01:01:35,540 --> 01:01:38,159
Four columns the ID for each show,

1670
01:01:38,370 --> 01:01:39,500
a title for each show,

1671
01:01:39,570 --> 01:01:41,120
the year it debuted for each show,

1672
01:01:41,370 --> 01:01:42,770
and the number of episodes.

1673
01:01:42,929 --> 01:01:44,929
There's also clearly some mention of types and some

1674
01:01:44,929 --> 01:01:46,639
other keywords that we haven't yet talked about,

1675
01:01:46,689 --> 01:01:49,840
but let's focus now first on just what the data is.

1676
01:01:49,969 --> 01:01:52,689
The best way to wrap your mind around a new data set if someone hands you a

1677
01:01:52,689 --> 01:01:57,350
SQL database or you've imported a CSV into a SQL database is just select some data.

1678
01:01:57,409 --> 01:01:59,169
So select star from shows,

1679
01:01:59,250 --> 01:02:00,050
semicolon.

1680
01:02:00,770 --> 01:02:03,229
That's a lot of data flying across the screen.

1681
01:02:03,280 --> 01:02:05,080
It's not very easy to see because some of the

1682
01:02:05,080 --> 01:02:07,429
show names are apparently crazy long and so it's wrapping,

1683
01:02:07,439 --> 01:02:09,000
but it's still going and going and going.

1684
01:02:09,040 --> 01:02:10,879
I'm gonna hit control C to interrupt it.

1685
01:02:11,000 --> 01:02:11,699
Control C,

1686
01:02:11,919 --> 01:02:14,129
as with our terminals in general as your friend,

1687
01:02:14,280 --> 01:02:17,199
let's run that same command but just limit it to the 1st 10 shows.

1688
01:02:17,239 --> 01:02:22,209
So there are the 1st 10 shows in the IMDB database of TV shows.

1689
01:02:22,219 --> 01:02:22,989
So we've got

1690
01:02:23,360 --> 01:02:27,280
10 rows in this data set going back to it looks like the 1970s is roughly.

1691
01:02:27,387 --> 01:02:29,177
Where their data set starts.

1692
01:02:29,357 --> 01:02:29,927
All right,

1693
01:02:30,218 --> 01:02:33,327
so here's the data we have in here.

1694
01:02:33,558 --> 01:02:33,697
Well,

1695
01:02:33,818 --> 01:02:34,617
how much is there?

1696
01:02:34,697 --> 01:02:34,778
Well,

1697
01:02:34,857 --> 01:02:35,857
let's go ahead and check.

1698
01:02:35,937 --> 01:02:40,167
So select count star from shows semicolon,

1699
01:02:40,288 --> 01:02:41,018
and now we're talking.

1700
01:02:41,097 --> 01:02:44,978
There's 250,000 87 shows in this database.

1701
01:02:45,018 --> 01:02:46,327
And if I do the same for people,

1702
01:02:46,538 --> 01:02:53,897
select count star from people semicolon looks like there are 704,315 TV.

1703
01:02:54,006 --> 01:02:56,135
Stars associated with this year data sets.

1704
01:02:56,196 --> 01:02:56,875
So here too,

1705
01:02:56,916 --> 01:03:01,206
the data is much more interesting and much more representative of real world data.

1706
01:03:01,795 --> 01:03:02,956
How about the ratings?

1707
01:03:03,075 --> 01:03:03,635
IMDb,

1708
01:03:03,676 --> 01:03:04,275
if unfamiliar,

1709
01:03:04,335 --> 01:03:05,746
is also a place where you can go to check

1710
01:03:05,746 --> 01:03:09,055
the ratings from users as to whether something is good,

1711
01:03:09,196 --> 01:03:09,635
a good show,

1712
01:03:09,645 --> 01:03:10,315
a bad show,

1713
01:03:10,436 --> 01:03:11,506
or anything in between.

1714
01:03:11,716 --> 01:03:13,825
So let's dotschema ratings

1715
01:03:14,156 --> 01:03:14,946
and I'll see that,

1716
01:03:14,956 --> 01:03:15,216
yeah,

1717
01:03:15,436 --> 01:03:19,025
there's this table called ratings that as we saw briefly on the screen,

1718
01:03:19,315 --> 01:03:20,545
there's a show ID.

1719
01:03:20,624 --> 01:03:24,404
And then a rating and then the total number of votes that contributed there too

1720
01:03:24,404 --> 01:03:27,644
and again some data types and other syntax that we'll get to before long.

1721
01:03:27,813 --> 01:03:31,053
But let me go ahead and just do select star from ratings

1722
01:03:31,053 --> 01:03:34,003
limit 10 just to get a sense of what the data is.

1723
01:03:34,374 --> 01:03:36,483
That's now what the data looks like in that table.

1724
01:03:36,573 --> 01:03:37,894
So to a human at a glance,

1725
01:03:38,053 --> 01:03:41,083
not that useful because you don't know what those show IDs are,

1726
01:03:41,293 --> 01:03:42,894
but in a moment we're going to see how we

1727
01:03:42,894 --> 01:03:47,134
can reconstitute this data by linking these tables together.

1728
01:03:47,241 --> 01:03:50,822
By way of those IDs and actually get answers to questions.

1729
01:03:51,072 --> 01:03:51,941
So among other things,

1730
01:03:52,031 --> 01:03:53,951
a SQL database or a relational database

1731
01:03:53,951 --> 01:03:57,302
more generally supports 1 to 1 relationships whereby

1732
01:03:57,471 --> 01:04:01,501
a row in one table can map to a one row in another table.

1733
01:04:01,711 --> 01:04:03,991
So it's this is in contrast to one to many,

1734
01:04:04,072 --> 01:04:04,541
for instance.

1735
01:04:04,592 --> 01:04:09,142
So 1 to 1 means one row over here somehow relates to one row over here.

1736
01:04:09,152 --> 01:04:09,352
Again,

1737
01:04:09,392 --> 01:04:11,681
the relational in relational database.

1738
01:04:11,951 --> 01:04:12,162
Uh,

1739
01:04:12,231 --> 01:04:13,711
how might we go about.

1740
01:04:14,270 --> 01:04:14,760
Uh,

1741
01:04:15,149 --> 01:04:15,780
seeing this,

1742
01:04:15,790 --> 01:04:15,909
well,

1743
01:04:16,030 --> 01:04:16,419
first,

1744
01:04:16,590 --> 01:04:19,669
here's a tour of the data types that SQL Light supports,

1745
01:04:20,110 --> 01:04:24,830
whereas in C we had a somewhat similar list and in Python that list went away,

1746
01:04:24,870 --> 01:04:27,149
at least with regard to explicit types.

1747
01:04:27,350 --> 01:04:29,550
In SQL we're back to when creating our

1748
01:04:29,550 --> 01:04:32,219
tables explicitly stating what the types of those

1749
01:04:32,989 --> 01:04:33,739
columns are.

1750
01:04:33,909 --> 01:04:35,020
So you have integers,

1751
01:04:35,149 --> 01:04:35,870
you have numeric,

1752
01:04:35,909 --> 01:04:37,590
which is more of a catch all for things like

1753
01:04:37,590 --> 01:04:40,060
times and dates and other useful real world data.

1754
01:04:40,189 --> 01:04:42,310
You have real numbers which are like floats with.

1755
01:04:42,465 --> 01:04:43,564
points you have text,

1756
01:04:43,655 --> 01:04:44,604
which we've seen already,

1757
01:04:44,735 --> 01:04:45,614
and then you have blobs,

1758
01:04:45,655 --> 01:04:48,094
which is a great name which stands for binary large objects.

1759
01:04:48,135 --> 01:04:50,534
You can actually store raw zeros and ones like files

1760
01:04:50,534 --> 01:04:53,254
in the database generally that's frowned upon to store files,

1761
01:04:53,294 --> 01:04:57,215
but there's certain times where you do want to store binary data and not pure text.

1762
01:04:57,375 --> 01:04:58,524
That's it for SQLite.

1763
01:04:58,574 --> 01:05:03,205
There are only these 5 types in other commercial and open source

1764
01:05:03,735 --> 01:05:06,495
SQL databases like Oracle and MySQL and Postress

1765
01:05:06,495 --> 01:05:08,044
and the same names I keep rattling off,

1766
01:05:08,254 --> 01:05:10,215
you have even more data types than these.

1767
01:05:10,304 --> 01:05:14,399
So that's a the additional features you get by using other databases as well.

1768
01:05:14,800 --> 01:05:17,209
There's a few keywords though that are worth noting in SQL.

1769
01:05:17,520 --> 01:05:20,100
You can specifically say when creating a table

1770
01:05:20,280 --> 01:05:22,590
that this column cannot be null.

1771
01:05:22,760 --> 01:05:24,199
If you don't want time stamp,

1772
01:05:24,239 --> 01:05:24,600
for instance,

1773
01:05:24,679 --> 01:05:26,679
to ever allow for null values,

1774
01:05:26,760 --> 01:05:30,600
you can literally specify when creating that table this column cannot be null.

1775
01:05:30,639 --> 01:05:33,909
And if I try to insert data into that table

1776
01:05:34,239 --> 01:05:36,919
with a null value as by not providing a time stamp,

1777
01:05:37,110 --> 01:05:38,590
the insertion will fail.

1778
01:05:38,760 --> 01:05:41,304
And so Here's where things are different from just writing

1779
01:05:41,304 --> 01:05:43,905
Python code or certainly using a spreadsheet you can actually

1780
01:05:43,905 --> 01:05:46,534
have built-in defenses so that you and no one else

1781
01:05:46,534 --> 01:05:50,175
messes up your data by inserting bogus or blank data

1782
01:05:50,465 --> 01:05:51,284
accidentally.

1783
01:05:51,465 --> 01:05:53,774
You can further say that things must be unique,

1784
01:05:53,864 --> 01:05:54,614
so every

1785
01:05:55,185 --> 01:05:55,415
element,

1786
01:05:55,584 --> 01:05:58,465
every cell in a column must be unique to ensure that you

1787
01:05:58,465 --> 01:06:01,804
can't accidentally put two things with the same ID to Harvard IDs,

1788
01:06:01,864 --> 01:06:03,584
to employee IDs that are duplicates.

1789
01:06:03,705 --> 01:06:05,445
You can avoid that altogether.

1790
01:06:05,745 --> 01:06:07,225
But more importantly.

1791
01:06:08,010 --> 01:06:12,709
Relational databases support these two concepts primary keys and foreign keys,

1792
01:06:12,770 --> 01:06:14,879
and this is where the magic really starts to happen.

1793
01:06:15,090 --> 01:06:16,280
A primary key

1794
01:06:16,570 --> 01:06:20,040
is the unique identifier for a table.

1795
01:06:20,290 --> 01:06:23,929
It is the column of values that uniquely identify every row,

1796
01:06:24,050 --> 01:06:25,620
so it's probably going to be the show ID,

1797
01:06:25,760 --> 01:06:26,800
the person ID,

1798
01:06:26,969 --> 01:06:27,929
the Harvard ID,

1799
01:06:27,969 --> 01:06:29,080
the employee ID,

1800
01:06:29,100 --> 01:06:30,760
any time you have a value,

1801
01:06:31,050 --> 01:06:31,919
often numeric,

1802
01:06:32,250 --> 01:06:32,709
often integral.

1803
01:06:32,879 --> 01:06:34,939
All that uniquely identifies rows,

1804
01:06:34,949 --> 01:06:37,419
you simply call that a primary key.

1805
01:06:37,909 --> 01:06:42,780
When that same ID appears in another table for cross referencing purposes,

1806
01:06:42,790 --> 01:06:45,270
you refer to it instead as a foreign key because

1807
01:06:45,270 --> 01:06:47,540
that same key is over there in another table,

1808
01:06:47,709 --> 01:06:50,340
thus foreign but they refer to one and the same things

1809
01:06:50,340 --> 01:06:53,300
in the context of the table in which it's defined,

1810
01:06:53,350 --> 01:06:55,899
it's primary if it appears in some other table,

1811
01:06:56,110 --> 01:06:57,870
it is now considered foreign.

1812
01:06:58,399 --> 01:06:58,679
All right,

1813
01:06:58,800 --> 01:06:59,790
so how can we

1814
01:07:00,000 --> 01:07:01,360
make use of this?

1815
01:07:01,439 --> 01:07:01,770
Well,

1816
01:07:01,959 --> 01:07:03,830
let me go ahead and propose that

1817
01:07:04,080 --> 01:07:07,010
we execute a few SQL commands as follows.

1818
01:07:07,159 --> 01:07:10,000
If I wanted to start asking questions about ratings,

1819
01:07:10,120 --> 01:07:13,550
I could do something like this select star from ratings,

1820
01:07:13,679 --> 01:07:15,840
where the rating is maybe a good show,

1821
01:07:15,879 --> 01:07:17,989
so let's call it 6.0 or higher,

1822
01:07:18,159 --> 01:07:21,469
but let's just limit this to the top 10 shows that meet that threshold.

1823
01:07:21,600 --> 01:07:22,000
Enter.

1824
01:07:22,370 --> 01:07:25,280
So here I now have a temporary table that gives

1825
01:07:25,280 --> 01:07:28,949
me 3 columns from the ratings table show ID,

1826
01:07:29,000 --> 01:07:31,719
which is a for the moment useless identifier because

1827
01:07:31,719 --> 01:07:33,310
I don't know what show it corresponds to,

1828
01:07:33,560 --> 01:07:36,629
but the rating value and the number of votes that contributed there too.

1829
01:07:37,000 --> 01:07:37,159
Well,

1830
01:07:37,320 --> 01:07:42,590
how might I actually get to the shows that are actually highly rated at 6.0 or higher?

1831
01:07:42,760 --> 01:07:42,800
Well,

1832
01:07:42,850 --> 01:07:44,040
I don't need to select star.

1833
01:07:44,120 --> 01:07:45,949
If all I care about is these top 10,

1834
01:07:46,120 --> 01:07:49,520
I can whittle this same command down to just selecting the ratings.

1835
01:07:49,639 --> 01:07:49,959
And now,

1836
01:07:50,320 --> 01:07:50,629
sorry,

1837
01:07:51,330 --> 01:07:51,760
sorry.

1838
01:07:52,209 --> 01:07:52,929
Not the ratings.

1839
01:07:52,969 --> 01:07:55,199
I can whittle this uh this table down

1840
01:07:55,449 --> 01:07:57,489
to just selecting the show IDs.

1841
01:07:57,659 --> 01:07:59,939
So this is the answer to the question What are the

1842
01:07:59,939 --> 01:08:03,679
top 10 TV shows whose ratings are 6.0 or higher?

1843
01:08:03,929 --> 01:08:04,179
Well,

1844
01:08:04,449 --> 01:08:05,010
from the table,

1845
01:08:05,090 --> 01:08:06,679
these are the 1st 10 that come back,

1846
01:08:06,969 --> 01:08:08,570
how do I now select.

1847
01:08:09,320 --> 01:08:11,750
The shows that correspond to these values.

1848
01:08:11,949 --> 01:08:14,189
Here's where things can be done a few different ways.

1849
01:08:14,350 --> 01:08:15,139
I could

1850
01:08:15,429 --> 01:08:18,819
select everything I know from the show's table

1851
01:08:19,310 --> 01:08:22,180
where the idea of the show is in

1852
01:08:22,379 --> 01:08:23,620
the following

1853
01:08:23,950 --> 01:08:24,350
set.

1854
01:08:24,459 --> 01:08:27,600
I'm going to do a parenthesis and then just for readability I'm going to hit enter.

1855
01:08:28,620 --> 01:08:29,669
The and angle bracket just means.

1856
01:08:29,729 --> 01:08:30,560
Continuing my thought,

1857
01:08:30,640 --> 01:08:32,310
it's not executing the command yet.

1858
01:08:32,520 --> 01:08:34,069
What is the query I now want to run?

1859
01:08:34,140 --> 01:08:34,200
Well,

1860
01:08:34,240 --> 01:08:35,549
it's going to be a nested query.

1861
01:08:35,680 --> 01:08:38,319
I can now do the same thing as before select the show

1862
01:08:38,319 --> 01:08:42,529
ID from the ratings table where the rating is really good,

1863
01:08:42,759 --> 01:08:44,430
greater than or equal to 6.0,

1864
01:08:44,720 --> 01:08:47,870
but let's then limit the total number of queries

1865
01:08:48,240 --> 01:08:49,189
to just

1866
01:08:49,520 --> 01:08:50,000
10.

1867
01:08:50,419 --> 01:08:51,060
So here,

1868
01:08:51,069 --> 01:08:52,819
just like in sort of grade school math,

1869
01:08:53,069 --> 01:08:54,069
we have parentheses.

1870
01:08:54,109 --> 01:08:56,950
So the first thing that's going to be executed is the thing inside parentheses.

1871
01:08:57,029 --> 01:08:58,870
So this is going to get me every show ID from the

1872
01:08:58,870 --> 01:09:01,950
ratings table that has a really good rating of 6.0 or higher.

1873
01:09:02,109 --> 01:09:05,350
That's going to return to me a column of values.

1874
01:09:05,390 --> 01:09:05,589
I'm.

1875
01:09:05,734 --> 01:09:08,515
Then gonna say select star from the show's table

1876
01:09:08,935 --> 01:09:14,035
where the ID of the show is in that list of values but only show me 10 of those

1877
01:09:14,285 --> 01:09:15,435
is what I'm asking here.

1878
01:09:15,645 --> 01:09:17,964
So what I should now see is much more useful data,

1879
01:09:18,084 --> 01:09:20,805
namely the 10 shows that are highly rated enter.

1880
01:09:21,240 --> 01:09:24,020
And indeed I get back these 10 shows,

1881
01:09:24,040 --> 01:09:27,140
all of whose ratings are indeed quite a bit higher.

1882
01:09:27,390 --> 01:09:29,220
If I want to only care about the title,

1883
01:09:29,310 --> 01:09:30,220
that too I can do.

1884
01:09:30,390 --> 01:09:31,419
So let's do this again.

1885
01:09:31,509 --> 01:09:32,779
Instead of selecting star,

1886
01:09:32,990 --> 01:09:36,549
let's select title from shows where the ID

1887
01:09:36,549 --> 01:09:39,060
of the show is in the following parenthetical

1888
01:09:39,060 --> 01:09:45,180
select show ID from ratings where the rating is greater than or equal to 6.0.

1889
01:09:45,470 --> 01:09:46,430
Close my parenthesis,

1890
01:09:46,669 --> 01:09:47,549
limit to 10.

1891
01:09:47,589 --> 01:09:47,750
E.

1892
01:09:48,649 --> 01:09:50,069
And I see the exact same thing,

1893
01:09:50,120 --> 01:09:50,990
but just

1894
01:09:51,120 --> 01:09:52,439
the nail being hit on the head.

1895
01:09:52,520 --> 01:09:55,870
Just give me the titles of those top several shows.

1896
01:09:56,189 --> 01:09:56,830
Of course

1897
01:09:57,200 --> 01:09:57,859
I might

1898
01:09:58,080 --> 01:09:58,669
want to,

1899
01:09:58,779 --> 01:10:00,120
might be able to do this differently.

1900
01:10:00,220 --> 01:10:00,950
In other words,

1901
01:10:01,120 --> 01:10:02,509
here's the top 10 titles.

1902
01:10:02,560 --> 01:10:02,640
Well,

1903
01:10:02,720 --> 01:10:03,520
what are the ratings?

1904
01:10:03,629 --> 01:10:06,279
Like that's why you go to IMDB or Rotten Tomatoes or the like.

1905
01:10:06,290 --> 01:10:07,399
You want to see the actual ratings,

1906
01:10:07,479 --> 01:10:09,279
not the titles or the ratings.

1907
01:10:09,479 --> 01:10:09,520
Well,

1908
01:10:09,560 --> 01:10:11,750
it turns out we're gonna need another technique to do that,

1909
01:10:11,919 --> 01:10:15,959
namely an ability to join two tables and in fact just as a teaser for this.

1910
01:10:16,200 --> 01:10:18,379
If we want to start playing around with some real data,

1911
01:10:18,640 --> 01:10:19,240
here might be,

1912
01:10:19,250 --> 01:10:20,009
for instance,

1913
01:10:20,160 --> 01:10:21,299
excerpts from

1914
01:10:21,799 --> 01:10:22,560
two tables.

1915
01:10:22,680 --> 01:10:24,549
Here's the show's table at left.

1916
01:10:24,759 --> 01:10:26,600
Here's the ratings table at right,

1917
01:10:26,799 --> 01:10:27,990
or a subset thereof.

1918
01:10:28,319 --> 01:10:31,509
If I want to figure out what the rating is for a given show,

1919
01:10:31,680 --> 01:10:34,240
wouldn't it be nice if I could somehow like line these two

1920
01:10:34,240 --> 01:10:36,950
tables up together such that just like the tips of my finger,

1921
01:10:37,120 --> 01:10:40,709
I line up this value with its corresponding value over here,

1922
01:10:40,759 --> 01:10:42,160
a cross reference of sorts?

1923
01:10:42,279 --> 01:10:42,359
Well,

1924
01:10:42,479 --> 01:10:43,359
just for the sake of.

1925
01:10:43,450 --> 01:10:45,350
And let me just kind of visually flip this around,

1926
01:10:45,399 --> 01:10:47,310
though that does nothing technically underneath the hood.

1927
01:10:47,560 --> 01:10:50,759
Let me just scooch them together now after highlighting the common values,

1928
01:10:50,919 --> 01:10:51,669
demonstrate that,

1929
01:10:51,799 --> 01:10:51,959
well,

1930
01:10:52,080 --> 01:10:53,910
wouldn't it be nice to take the show's table

1931
01:10:53,910 --> 01:10:56,520
and join it with the ratings table in such a

1932
01:10:56,520 --> 01:11:01,439
way that those IDs all line up and we're going to have the ability to do just this.

1933
01:11:01,680 --> 01:11:03,479
This is a lot already and this isn't the sort of

1934
01:11:03,479 --> 01:11:06,000
cliffhanger I'd wanted to end on because who cares about joints,

1935
01:11:06,009 --> 01:11:06,830
but it's going to be cool.

1936
01:11:06,919 --> 01:11:10,729
But let's take our 10 minute Halloween candy break and come back in 10 for the next.

1937
01:11:11,750 --> 01:11:11,759
All

1938
01:11:12,700 --> 01:11:13,140
right,

1939
01:11:13,299 --> 01:11:14,089
we're back.

1940
01:11:14,919 --> 01:11:18,229
So recall where we left off was essentially here.

1941
01:11:18,279 --> 01:11:19,350
We had these two tables,

1942
01:11:19,390 --> 01:11:21,720
the show's table at left and the ratings table at right,

1943
01:11:21,799 --> 01:11:26,319
and the motivation here was like how do we actually associate shows with their

1944
01:11:26,319 --> 01:11:29,839
respective ratings because the ratings of course are not in the show's table.

1945
01:11:29,890 --> 01:11:30,399
As an aside,

1946
01:11:30,410 --> 01:11:31,109
they could be.

1947
01:11:31,240 --> 01:11:31,950
And in fact,

1948
01:11:32,040 --> 01:11:33,680
because this is meant to demonstrate a 1 to

1949
01:11:33,680 --> 01:11:36,529
1 relationship whereby every show has one rating,

1950
01:11:36,720 --> 01:11:40,709
we could have just put the rating and the number of votes into the show's table,

1951
01:11:40,740 --> 01:11:43,439
but we chose not to because uh you know I am.

1952
01:11:44,089 --> 01:11:46,720
actually stores their ratings as a separate TSV file,

1953
01:11:46,729 --> 01:11:49,770
and so what we tried to do for parity with that is only import

1954
01:11:49,770 --> 01:11:53,370
into a ratings table the very TSV file that we had downloaded from them.

1955
01:11:53,410 --> 01:11:55,200
But that too would be a solution there too.

1956
01:11:55,410 --> 01:11:57,799
So at this point in the story we've got the shows table here.

1957
01:11:57,970 --> 01:12:00,220
We've got the ratings table over here.

1958
01:12:00,410 --> 01:12:02,359
We've noticed that there are commonalities.

1959
01:12:02,450 --> 01:12:06,160
There are show IDs that appear in both tables and in fact,

1960
01:12:06,209 --> 01:12:06,560
to

1961
01:12:06,850 --> 01:12:08,089
use some of the new vernacular,

1962
01:12:08,209 --> 01:12:10,049
this is the primary key,

1963
01:12:10,169 --> 01:12:11,319
the ID column here.

1964
01:12:11,529 --> 01:12:12,490
This is that same value.

1965
01:12:12,629 --> 01:12:15,939
But in this context it's known as a foreign key because it's in some other table,

1966
01:12:15,950 --> 01:12:18,450
but that's gonna be how we link these two things together.

1967
01:12:18,700 --> 01:12:22,580
So how do we select for not just the Office but maybe every TV show,

1968
01:12:22,620 --> 01:12:23,890
its respective rating?

1969
01:12:24,060 --> 01:12:24,140
Well,

1970
01:12:24,220 --> 01:12:27,000
let's go back to VS Code and at my SQL light prompt,

1971
01:12:27,100 --> 01:12:29,430
let me go ahead and do this select star

1972
01:12:29,819 --> 01:12:31,290
from the show's table,

1973
01:12:31,540 --> 01:12:32,060
but

1974
01:12:32,379 --> 01:12:33,930
let's go ahead and

1975
01:12:34,060 --> 01:12:34,680
join

1976
01:12:34,850 --> 01:12:35,890
the show's table

1977
01:12:36,140 --> 01:12:37,729
with the ratings table.

1978
01:12:37,899 --> 01:12:40,020
How do I want to join these two tables together?

1979
01:12:40,200 --> 01:12:41,589
We'll do so on.

1980
01:12:41,790 --> 01:12:44,069
The shows tables ID column

1981
01:12:44,439 --> 01:12:49,069
being equal to the ratings tables show ID column

1982
01:12:49,319 --> 01:12:53,040
and then go ahead and filter the results in the following way where the

1983
01:12:53,040 --> 01:12:56,640
rating we care about should still be greater than or equal to 6.0,

1984
01:12:56,700 --> 01:12:59,799
and let's only limit this to the top 10 results.

1985
01:12:59,919 --> 01:13:01,430
So it's a bit more of a mouthful,

1986
01:13:01,560 --> 01:13:04,279
but what I'm doing is selecting everything from

1987
01:13:04,279 --> 01:13:08,080
the result of joining shows and ratings on.

1988
01:13:08,452 --> 01:13:13,242
This column with this column and the rest of the predicate is as before.

1989
01:13:13,412 --> 01:13:15,341
So join is going to do literally that.

1990
01:13:15,492 --> 01:13:17,722
Join these two tables as I have prescribed.

1991
01:13:17,892 --> 01:13:20,401
When I go ahead here and hit enter now that I have my semicolon,

1992
01:13:20,611 --> 01:13:24,801
I get back a complete table containing everything from the show's table,

1993
01:13:25,332 --> 01:13:29,231
everything from the ratings table with those unique identifiers lined up.

1994
01:13:29,332 --> 01:13:29,662
Indeed,

1995
01:13:29,731 --> 01:13:31,602
if you look at the primary key over here,

1996
01:13:31,662 --> 01:13:34,162
the ID column 62614.

1997
01:13:34,983 --> 01:13:39,784
Over here you have show ID which came from the ratings table 62614.

1998
01:13:40,423 --> 01:13:44,054
So we've taken two tables and really joined them together,

1999
01:13:44,104 --> 01:13:47,724
but we're only seeing a subset because I limited it to 10 such rows.

2000
01:13:47,824 --> 01:13:50,313
Now of course most of this data doesn't seem very interesting if my whole

2001
01:13:50,313 --> 01:13:54,474
goal is just to tell me what the ratings are for these shows.

2002
01:13:54,503 --> 01:13:54,664
Well,

2003
01:13:54,943 --> 01:13:57,903
let's go ahead and in code achieve this sort of result.

2004
01:13:57,983 --> 01:13:59,773
Let's literally join these tables together.

2005
01:13:59,983 --> 01:14:00,874
Let's get rid of the redundant.

2006
01:14:01,005 --> 01:14:03,155
See altogether and then really let's whittle it down

2007
01:14:03,155 --> 01:14:05,395
to just a title column and a rating column.

2008
01:14:05,476 --> 01:14:06,395
So how do we do that?

2009
01:14:06,516 --> 01:14:06,616
Well,

2010
01:14:06,715 --> 01:14:10,496
in code I'm going to go ahead and select more specifically the title

2011
01:14:10,496 --> 01:14:13,945
of every show and the rating of every show from the show's table,

2012
01:14:14,116 --> 01:14:18,556
but I'm going to join it with the ratings table on shows.

2013
01:14:18,706 --> 01:14:23,346
ID equaling ratings.show ID and as before,

2014
01:14:23,416 --> 01:14:27,155
I'm going to limit it to where rating is greater than or equal to 6.0.

2015
01:14:27,629 --> 01:14:29,299
And 10 such results.

2016
01:14:29,379 --> 01:14:33,979
Enter and now I have a nice simple temporary table that in one column has the

2017
01:14:33,979 --> 01:14:37,959
titles of these shows and in the right hand side has the ratings of the shows,

2018
01:14:38,020 --> 01:14:42,049
even though those two data sets were completely separate in two

2019
01:14:42,310 --> 01:14:43,319
separate tables.

2020
01:14:43,379 --> 01:14:43,700
Indeed,

2021
01:14:43,740 --> 01:14:46,169
if we think back to where this data came from,

2022
01:14:46,339 --> 01:14:48,490
what we've been focusing on is the show's table,

2023
01:14:48,660 --> 01:14:50,569
and we've joined it with the ratings table.

2024
01:14:50,740 --> 01:14:52,290
Here's the primary key for shows.

2025
01:14:52,299 --> 01:14:54,209
Here's the foreign key for ratings,

2026
01:14:54,299 --> 01:14:55,870
and by convention notice

2027
01:14:56,339 --> 01:14:57,459
that we've adopted a certain.

2028
01:14:57,750 --> 01:14:58,120
Uh,

2029
01:14:58,129 --> 01:14:59,000
a certain approach.

2030
01:14:59,319 --> 01:15:03,419
Anything that's called ID here implies that it's a primary key.

2031
01:15:03,689 --> 01:15:07,979
Anything that's something underscore ID implies that it's a foreign key,

2032
01:15:08,169 --> 01:15:09,410
and the convention we adopted,

2033
01:15:09,419 --> 01:15:10,569
which is actually quite common,

2034
01:15:10,609 --> 01:15:13,129
is if the table is called shows plural,

2035
01:15:13,490 --> 01:15:16,879
we call the foreign key show singularco ID.

2036
01:15:17,089 --> 01:15:17,850
Different companies,

2037
01:15:17,970 --> 01:15:19,609
different communities will have different practices,

2038
01:15:19,660 --> 01:15:21,490
but we've been consistent across all of these

2039
01:15:21,490 --> 01:15:23,959
tables with our underscore and lower case conventions.

2040
01:15:26,160 --> 01:15:26,169
Yeah.

2041
01:15:26,910 --> 01:15:29,649
Is all generate and relate to each other.

2042
01:15:30,439 --> 01:15:31,120
Really good question.

2043
01:15:31,279 --> 01:15:33,799
How do all these IDs generate and relate to each other properly?

2044
01:15:33,899 --> 01:15:33,970
Well,

2045
01:15:34,040 --> 01:15:34,750
in our case,

2046
01:15:35,000 --> 01:15:35,879
I have no idea.

2047
01:15:35,959 --> 01:15:39,669
The Internet Movie Database people came up with these unique identifiers somehow,

2048
01:15:39,839 --> 01:15:42,430
and we simply incorporating them into our data set.

2049
01:15:42,640 --> 01:15:43,399
In practice,

2050
01:15:43,479 --> 01:15:45,470
what they probably did and what you will do,

2051
01:15:45,479 --> 01:15:45,830
for instance,

2052
01:15:45,839 --> 01:15:48,720
in future problem sets when generating data is you

2053
01:15:48,720 --> 01:15:51,040
just assign an arbitrary integer starting at 1,

2054
01:15:51,200 --> 01:15:51,770
then 2,

2055
01:15:51,799 --> 01:15:52,370
then 3,

2056
01:15:52,379 --> 01:15:52,879
then 4,

2057
01:15:52,959 --> 01:15:53,509
then 5,

2058
01:15:53,520 --> 01:15:55,520
and you just let it auto increment all the way up and

2059
01:15:55,520 --> 01:15:58,430
you let the database ensure that you never have duplicate values,

2060
01:15:58,839 --> 01:15:59,089
yeah.

2061
01:15:59,919 --> 01:16:02,859
Just to clarify for the dot dot dot and er symbols,

2062
01:16:02,879 --> 01:16:05,209
that's only to like make it look better,

2063
01:16:05,299 --> 01:16:05,419
right?

2064
01:16:05,470 --> 01:16:06,299
Like there's no like.

2065
01:16:08,729 --> 01:16:09,049
Correct.

2066
01:16:09,089 --> 01:16:14,270
The angled bracket that you keep seeing is just the continuation prompt,

2067
01:16:14,330 --> 01:16:16,319
which means I have prematurely hit enter

2068
01:16:16,319 --> 01:16:18,129
deliberately because I want to move everything

2069
01:16:18,129 --> 01:16:21,729
onto the next line so it doesn't wrap ugly on to multiple lines.

2070
01:16:21,890 --> 01:16:23,560
It is not SQL syntax.

2071
01:16:23,569 --> 01:16:24,879
It's specific to SQL Light 3,

2072
01:16:24,890 --> 01:16:26,879
and it's just a continuation of the thought.

2073
01:16:27,250 --> 01:16:27,839
That's all.

2074
01:16:28,089 --> 01:16:28,209
Good,

2075
01:16:28,299 --> 01:16:29,049
good observation.

2076
01:16:29,870 --> 01:16:30,430
Yeah.

2077
01:16:30,770 --> 01:16:31,089
Um,

2078
01:16:31,180 --> 01:16:32,770
when you limit it to 10,

2079
01:16:32,899 --> 01:16:33,990
is it showing

2080
01:16:34,299 --> 01:16:34,810
how does it

2081
01:16:38,810 --> 01:16:39,569
earliest ones.

2082
01:16:41,520 --> 01:16:41,879
Good question.

2083
01:16:41,919 --> 01:16:43,129
When you limit something to 10,

2084
01:16:43,200 --> 01:16:43,479
for instance,

2085
01:16:43,560 --> 01:16:44,240
which ones do you get,

2086
01:16:44,319 --> 01:16:47,350
you just get literally the 1st 10 rows from the table.

2087
01:16:47,600 --> 01:16:52,520
And so it will typically be ordered if you don't use the order by uh keywords,

2088
01:16:52,839 --> 01:16:53,189
uh,

2089
01:16:53,200 --> 01:16:56,189
in the same order from which it came from those tables.

2090
01:16:56,444 --> 01:16:59,984
And so you're just seeing arbitrarily the 1st 10 that match that predicate,

2091
01:16:59,995 --> 01:17:02,665
which is rating greater than or equal to 6.

2092
01:17:02,955 --> 01:17:04,274
We have not ordered it by rating,

2093
01:17:04,314 --> 01:17:06,555
so I'm not getting like the 10 shows necessarily.

2094
01:17:06,595 --> 01:17:09,115
I'm just getting the 1st 10 shows that are greater than 6,

2095
01:17:09,134 --> 01:17:11,464
and the point for that is just I want it to fit on the screen

2096
01:17:12,075 --> 01:17:13,955
rather than see hundreds of thousands of answers.

2097
01:17:14,750 --> 01:17:15,160
OK,

2098
01:17:15,450 --> 01:17:19,169
so you might recall now that there were certainly other tables besides these.

2099
01:17:19,259 --> 01:17:21,410
So let's see in the broader scheme,

2100
01:17:21,529 --> 01:17:22,689
not just shows and ratings,

2101
01:17:22,729 --> 01:17:23,910
but let's focus on genres,

2102
01:17:23,930 --> 01:17:28,080
if only because genres is interesting because it's no longer a 1 to 1 relationship

2103
01:17:28,290 --> 01:17:29,750
because of course why would a show have multiple

2104
01:17:29,750 --> 01:17:31,520
ratings that sort of has its own rating,

2105
01:17:31,729 --> 01:17:33,930
but a show could certainly belong to multiple genres.

2106
01:17:33,970 --> 01:17:35,290
You could imagine a show being a.

2107
01:17:35,404 --> 01:17:41,075
and a drama or a musical and a comedy or any other number of combinations of one or more

2108
01:17:41,075 --> 01:17:44,035
genres and so the way we've chosen to implement that

2109
01:17:44,035 --> 01:17:46,555
here too is with a separate table called genres,

2110
01:17:46,634 --> 01:17:47,424
which is not perfect.

2111
01:17:47,595 --> 01:17:50,674
There's going to be some redundancies here that we have not yet eliminated,

2112
01:17:50,754 --> 01:17:56,035
but it does indicate that we can go ahead and have multiple such values.

2113
01:17:56,689 --> 01:17:57,879
Associated with

2114
01:17:58,129 --> 01:17:59,450
each and every show.

2115
01:17:59,529 --> 01:18:00,529
So how do we get there?

2116
01:18:00,580 --> 01:18:01,879
Let's focus just on this.

2117
01:18:02,049 --> 01:18:04,129
Let's go back in just a moment to VS code and

2118
01:18:04,129 --> 01:18:07,410
let's take a look at the schema for now genres.

2119
01:18:07,450 --> 01:18:10,319
In genres we have the following a table called genres,

2120
01:18:10,330 --> 01:18:12,240
which has two columns a show ID,

2121
01:18:12,250 --> 01:18:13,859
which is an integer that cannot be null,

2122
01:18:14,049 --> 01:18:15,250
and a genre which is text,

2123
01:18:15,290 --> 01:18:16,580
which is also not be null.

2124
01:18:16,770 --> 01:18:17,680
And now for the first time,

2125
01:18:17,689 --> 01:18:20,160
let's actually use some of the vernacular we've introduced.

2126
01:18:20,569 --> 01:18:24,930
Here we have an example explicitly in SQL that specifies when creating this table

2127
01:18:25,250 --> 01:18:26,089
that it shall.

2128
01:18:26,189 --> 01:18:29,529
The show ID column shall be a foreign key

2129
01:18:29,830 --> 01:18:33,209
that references the show's tables ID column,

2130
01:18:33,290 --> 01:18:36,779
and admittedly I think the syntax for creating tables is a bit of a mouthful.

2131
01:18:36,819 --> 01:18:40,490
Even I often have to read to look it up to remember the order of everything,

2132
01:18:40,620 --> 01:18:41,000
but

2133
01:18:41,299 --> 01:18:45,850
here we have the columns listed first and then these key constraints,

2134
01:18:45,859 --> 01:18:49,089
foreign key referencing this primary key over here.

2135
01:18:49,180 --> 01:18:49,540
And in fact,

2136
01:18:49,580 --> 01:18:51,970
let's rewind to look at the show's table now to see

2137
01:18:52,299 --> 01:18:53,729
from which from whence we came.

2138
01:18:53,939 --> 01:18:55,589
So if I do dot schema.

2139
01:18:56,180 --> 01:18:57,319
Of

2140
01:18:57,450 --> 01:18:58,069
shows,

2141
01:18:58,080 --> 01:19:00,479
which we've done before but waved our hand at it then,

2142
01:19:00,689 --> 01:19:04,370
we'll indeed see that shows has a primary key called ID,

2143
01:19:04,410 --> 01:19:05,129
which is an integer.

2144
01:19:05,169 --> 01:19:05,930
How do I know that?

2145
01:19:06,049 --> 01:19:08,250
Because the very last thing in the parenthesis says that

2146
01:19:08,250 --> 01:19:11,120
the ID column in this table is a primary key.

2147
01:19:11,290 --> 01:19:14,029
Then we see that the title is text can't be null.

2148
01:19:14,290 --> 01:19:15,330
The year is numeric,

2149
01:19:15,410 --> 01:19:17,250
which again I described as sort of a catch all

2150
01:19:17,250 --> 01:19:20,930
for other real world numeric types that aren't purely integers or

2151
01:19:21,410 --> 01:19:22,680
real numbers per se.

2152
01:19:23,100 --> 01:19:24,020
Episodes is an integer.

2153
01:19:24,049 --> 01:19:24,490
Both of those are.

2154
01:19:24,634 --> 01:19:26,884
Apparently can be null because maybe IMDB just

2155
01:19:26,884 --> 01:19:29,424
doesn't have that data for some older shows,

2156
01:19:29,504 --> 01:19:31,455
but primary key is indeed specified here.

2157
01:19:31,584 --> 01:19:32,464
And just for thoroughness,

2158
01:19:32,544 --> 01:19:35,665
let me distinguish now genres from ratings.

2159
01:19:35,705 --> 01:19:37,924
If I do do schema ratings again,

2160
01:19:38,185 --> 01:19:39,814
which we waved our hand at earlier,

2161
01:19:40,185 --> 01:19:43,384
very similar in spirit to genres in that there's

2162
01:19:43,384 --> 01:19:46,814
an ID column that somehow references the show's table,

2163
01:19:46,984 --> 01:19:48,814
and then some other column here genre.

2164
01:19:48,984 --> 01:19:52,984
In this case we had ratings and votes which were reels and integers respectively.

2165
01:19:53,229 --> 01:19:56,009
But notice this one additional constraint here.

2166
01:19:56,339 --> 01:20:00,330
I deliberately specified that show ID in the ratings table

2167
01:20:00,620 --> 01:20:01,529
must be unique.

2168
01:20:01,620 --> 01:20:02,209
That is to say,

2169
01:20:02,220 --> 01:20:05,740
you cannot have the same show ID more than once in the ratings table.

2170
01:20:05,819 --> 01:20:06,209
Why?

2171
01:20:06,419 --> 01:20:09,330
Because I indeed wanted a 1 to 1 relationship,

2172
01:20:09,339 --> 01:20:10,419
and it would not be 1 to 1.

2173
01:20:10,774 --> 01:20:14,794
If there were multiple show IDs that correspond to one ID

2174
01:20:15,165 --> 01:20:17,285
in the show's table itself,

2175
01:20:17,564 --> 01:20:21,185
but genres we're going to allow that it can be

2176
01:20:21,185 --> 01:20:24,634
duplicates and so we don't have mention of unique there.

2177
01:20:24,944 --> 01:20:25,084
All right,

2178
01:20:25,165 --> 01:20:25,964
so where does this get us?

2179
01:20:26,044 --> 01:20:26,125
Well,

2180
01:20:26,205 --> 01:20:27,674
let me go back into

2181
01:20:28,365 --> 01:20:30,694
my terminal here after clearing all of that,

2182
01:20:30,765 --> 01:20:34,165
and let's go ahead and just see the data to wrap our mind around it a little more.

2183
01:20:34,500 --> 01:20:34,879
Uh,

2184
01:20:34,979 --> 01:20:35,370
real.

2185
01:20:35,479 --> 01:20:37,990
So select star from genres,

2186
01:20:38,080 --> 01:20:40,209
limit 10 just to see the the 1st 10.

2187
01:20:40,479 --> 01:20:40,680
All right,

2188
01:20:40,759 --> 01:20:42,120
so it looks like there's some comedies,

2189
01:20:42,200 --> 01:20:42,680
avengers,

2190
01:20:42,779 --> 01:20:43,120
comedies,

2191
01:20:43,240 --> 01:20:43,799
family action,

2192
01:20:43,830 --> 01:20:44,279
sci-fi,

2193
01:20:44,319 --> 01:20:45,069
and so forth.

2194
01:20:45,279 --> 01:20:45,319
Well,

2195
01:20:45,399 --> 01:20:49,069
let's go ahead and look up just one show's information.

2196
01:20:49,109 --> 01:20:49,399
In fact,

2197
01:20:49,439 --> 01:20:51,149
I saw this number this ID before.

2198
01:20:51,399 --> 01:20:53,160
How about let's just look up this show?

2199
01:20:53,200 --> 01:20:54,729
What is this adventure show?

2200
01:20:54,879 --> 01:20:56,279
63881.

2201
01:20:56,330 --> 01:20:59,359
So select star from shows where ID equals.

2202
01:20:59,560 --> 01:21:01,459
63881 semicolon.

2203
01:21:01,620 --> 01:21:01,899
OK,

2204
01:21:02,020 --> 01:21:04,850
so this is the show called Cat Weasel from 1970,

2205
01:21:04,910 --> 01:21:06,930
which had 26 episodes in total,

2206
01:21:07,100 --> 01:21:09,100
and that was indeed its unique identifier.

2207
01:21:09,180 --> 01:21:10,370
So that's all fine and good

2208
01:21:10,580 --> 01:21:13,060
if I want to see something about that specific show.

2209
01:21:13,100 --> 01:21:14,020
But as before,

2210
01:21:14,100 --> 01:21:17,779
how do I associate Cat Weasel in this case with all of its genres?

2211
01:21:17,859 --> 01:21:17,939
Well,

2212
01:21:18,180 --> 01:21:20,339
instead of it being a 1 to 1 relationship necessarily,

2213
01:21:20,459 --> 01:21:22,609
maybe Cat Weasel is not just an adventure,

2214
01:21:22,779 --> 01:21:24,459
maybe it's also a comedy and a family.

2215
01:21:24,759 --> 01:21:27,209
Show and indeed if I go back to the results just now,

2216
01:21:27,240 --> 01:21:30,959
you'll see that 68111 indeed lines up with adventure,

2217
01:21:31,160 --> 01:21:31,520
comedy,

2218
01:21:31,600 --> 01:21:34,910
and family and then the ID changes to be about some other show.

2219
01:21:35,200 --> 01:21:40,680
So how do I select these three answers to the question What genre is cat weasel?

2220
01:21:40,799 --> 01:21:40,879
Well,

2221
01:21:40,959 --> 01:21:44,870
for this we need to talk about one to many relationships and how we can get those back.

2222
01:21:45,120 --> 01:21:45,169
Well,

2223
01:21:45,200 --> 01:21:48,029
let's go ahead and do this now in my terminal.

2224
01:21:48,259 --> 01:21:49,589
Let me go ahead and say,

2225
01:21:50,250 --> 01:21:50,970
Uh,

2226
01:21:51,169 --> 01:21:55,609
the following select genre from the genres table

2227
01:21:55,609 --> 01:21:59,609
where the show ID equals just that 63881,

2228
01:21:59,649 --> 01:22:01,810
which I'm now starting to memorize adventure,

2229
01:22:02,009 --> 01:22:02,250
comedy,

2230
01:22:02,259 --> 01:22:02,649
and family.

2231
01:22:02,689 --> 01:22:04,160
So that's the answer to the question,

2232
01:22:04,290 --> 01:22:06,770
but this certainly isn't the best way to do this where you have

2233
01:22:06,770 --> 01:22:09,520
to like look up the unique ID for the show you care about,

2234
01:22:09,770 --> 01:22:11,200
then copy paste it or.

2235
01:22:11,553 --> 01:22:14,263
and type it out into this query just to get the genres.

2236
01:22:14,303 --> 01:22:17,062
It would be nice to just ask all of this in one breath.

2237
01:22:17,342 --> 01:22:17,422
Well,

2238
01:22:17,462 --> 01:22:19,583
we can do this even though it's a bit more verbose.

2239
01:22:19,703 --> 01:22:22,973
I'm going to instead this time say select genre from genres

2240
01:22:23,303 --> 01:22:26,223
where the show ID I care about equals,

2241
01:22:26,422 --> 01:22:28,223
and now I'm just going to hit enter so

2242
01:22:28,223 --> 01:22:32,013
as to move this nested query inside of parentheses,

2243
01:22:32,022 --> 01:22:32,462
and I'm going to.

2244
01:22:32,565 --> 01:22:32,675
Well,

2245
01:22:33,076 --> 01:22:36,585
I don't know off the top of my head what the unique ID is for cat weasel,

2246
01:22:36,835 --> 01:22:39,715
but I can ask the database select the ID from

2247
01:22:39,715 --> 01:22:43,786
the show's table where the title of the show equals

2248
01:22:44,125 --> 01:22:44,666
cat weasel,

2249
01:22:44,755 --> 01:22:48,786
and this now obviates the need for me to memorize or copy paste that unique ID.

2250
01:22:48,945 --> 01:22:50,806
I'll hit enter and close my parenthesis.

2251
01:22:51,076 --> 01:22:51,145
Uh,

2252
01:22:51,235 --> 01:22:53,596
I'm gonna go ahead then and say.

2253
01:22:53,919 --> 01:22:54,220
Uh,

2254
01:22:54,259 --> 01:22:55,129
semicolon,

2255
01:22:55,359 --> 01:22:55,879
enter,

2256
01:22:56,180 --> 01:22:59,580
and now I get back the exact same answers but without having to know

2257
01:22:59,580 --> 01:23:02,890
or care about these numeric values and that's kind of the point here,

2258
01:23:03,020 --> 01:23:04,259
even though the database itself,

2259
01:23:04,299 --> 01:23:06,049
the actual IMDB website,

2260
01:23:06,220 --> 01:23:10,660
needs to use these unique identifiers to store everything in the database we.

2261
01:23:10,770 --> 01:23:14,810
Humans generally speaking should not know or care what these identifiers are.

2262
01:23:15,000 --> 01:23:17,839
They're just meant to implement this notion of relationships,

2263
01:23:17,959 --> 01:23:19,200
these cross references,

2264
01:23:19,359 --> 01:23:22,720
and so here we see an example where you can ask the question you care about

2265
01:23:22,720 --> 01:23:25,200
without worrying about any of the underlying numbers

2266
01:23:25,200 --> 01:23:27,470
or even seeing them as a result.

2267
01:23:27,890 --> 01:23:27,910
All right,

2268
01:23:28,720 --> 01:23:28,990
well,

2269
01:23:29,049 --> 01:23:30,229
what's really,

2270
01:23:30,399 --> 01:23:32,669
how else might we go about doing this?

2271
01:23:32,839 --> 01:23:32,879
Well,

2272
01:23:32,930 --> 01:23:34,839
let me propose that we join these two tables

2273
01:23:34,839 --> 01:23:36,549
and ask the question in a slightly different way.

2274
01:23:36,680 --> 01:23:38,350
So here's an excerpt from the show's table.

2275
01:23:38,520 --> 01:23:40,350
Here's an excerpt from the genre's table,

2276
01:23:40,520 --> 01:23:44,000
and clearly we could do something like we did before for ratings where we could line

2277
01:23:44,000 --> 01:23:48,580
these two up and kind of join them together just for the sake of discussion,

2278
01:23:48,640 --> 01:23:51,350
let me flip these columns around though that has no technical significance,

2279
01:23:51,359 --> 01:23:53,439
and now we can clearly see 63881.

2280
01:23:53,602 --> 01:23:55,062
There and here.

2281
01:23:55,191 --> 01:23:55,952
The difference though,

2282
01:23:56,182 --> 01:23:58,262
because now this is a one to many relationship,

2283
01:23:58,472 --> 01:24:01,662
is that it's not quite as simple as just joining the rows together.

2284
01:24:01,912 --> 01:24:05,062
I need to kind of join it here and here and here,

2285
01:24:05,182 --> 01:24:06,782
and the database can do this for you,

2286
01:24:06,872 --> 01:24:09,111
albeit at some cost in redundancy.

2287
01:24:09,191 --> 01:24:11,432
So what I'm going to observe is that these IDs

2288
01:24:11,432 --> 01:24:14,262
are all the same primary key in this context,

2289
01:24:14,512 --> 01:24:16,071
foreign key in this context.

2290
01:24:16,352 --> 01:24:16,512
Well,

2291
01:24:16,602 --> 01:24:17,262
I'm going to

2292
01:24:17,751 --> 01:24:19,151
start to join them together here.

2293
01:24:19,313 --> 01:24:21,534
But it's not possible to return

2294
01:24:21,744 --> 01:24:24,534
a temporary table that's just outright missing data.

2295
01:24:24,704 --> 01:24:28,133
You have to get the same number of rows and columns everywhere in a grid.

2296
01:24:28,423 --> 01:24:31,063
So what the database is going to do if I do join these two tables

2297
01:24:31,063 --> 01:24:35,213
together and they are participating in a one to many relationship with each other,

2298
01:24:35,423 --> 01:24:37,943
it's going to duplicate the data that's necessary to

2299
01:24:37,943 --> 01:24:39,733
sort of make every row look the same.

2300
01:24:39,903 --> 01:24:42,423
Downside is it might indeed be taking up some additional space

2301
01:24:42,423 --> 01:24:44,903
unless the database is smart and somehow using pointers or something.

2302
01:24:45,025 --> 01:24:47,605
That underneath the hood to avoid the redundancy,

2303
01:24:47,815 --> 01:24:50,775
but for my purposes this is actually quite nice because if

2304
01:24:50,775 --> 01:24:53,976
I iterate over these rows as I could in Python,

2305
01:24:53,985 --> 01:24:55,125
as we'll eventually see,

2306
01:24:55,335 --> 01:24:57,375
it's just nice to have all the data you care about

2307
01:24:57,375 --> 01:25:00,686
in each and every row even though it's clearly redundant,

2308
01:25:00,895 --> 01:25:03,366
but the data is not being stored redundantly in the data,

2309
01:25:03,576 --> 01:25:06,445
it's just temporarily being presented to me

2310
01:25:06,655 --> 01:25:08,405
with this here redundancy.

2311
01:25:08,616 --> 01:25:10,266
So what do I really want to have happen?

2312
01:25:10,295 --> 01:25:10,576
Well,

2313
01:25:11,160 --> 01:25:14,680
I really care about actually joining these two tables together and

2314
01:25:14,680 --> 01:25:17,990
ultimately just getting back the title and the genre respectively,

2315
01:25:18,200 --> 01:25:20,629
so let me go ahead and my VS code here

2316
01:25:20,879 --> 01:25:22,669
and do select title.

2317
01:25:23,229 --> 01:25:24,560
And genre

2318
01:25:24,970 --> 01:25:26,200
from the show's table,

2319
01:25:26,370 --> 01:25:29,770
but let's join it this time on the genres table on shows.

2320
01:25:29,919 --> 01:25:32,770
ID equaling genres.ho ID.

2321
01:25:32,890 --> 01:25:34,720
So that's quite the same as with ratings

2322
01:25:35,169 --> 01:25:35,720
where

2323
01:25:35,990 --> 01:25:38,850
uh the ID equals just for time's sake,

2324
01:25:38,939 --> 01:25:40,419
63881,

2325
01:25:40,450 --> 01:25:41,529
which I know is cat weasel,

2326
01:25:41,569 --> 01:25:45,479
but I could certainly use a nested query if I wanted to do this as before.

2327
01:25:45,720 --> 01:25:46,089
Enter.

2328
01:25:46,520 --> 01:25:49,779
And I get back cat weasel's 3 genres,

2329
01:25:49,790 --> 01:25:51,540
and if I were to loop over this data

2330
01:25:51,790 --> 01:25:53,229
in some kind of like Python code,

2331
01:25:53,310 --> 01:25:56,549
I would have access to the title and genre with each iteration,

2332
01:25:56,589 --> 01:25:57,720
which I claim is.

2333
01:25:58,180 --> 01:25:58,770
Useful,

2334
01:25:58,859 --> 01:26:01,899
but if I don't care about that and I just really want to select the genres,

2335
01:26:02,020 --> 01:26:03,649
I can do this with joins too.

2336
01:26:03,859 --> 01:26:10,299
Let me just select the genre from shows joining it on genres on shows.

2337
01:26:10,419 --> 01:26:13,649
ID equaling genres.ho ID

2338
01:26:14,020 --> 01:26:17,259
where the ID is cat weasel 63881.

2339
01:26:17,529 --> 01:26:19,490
And now I get back just that answer.

2340
01:26:19,879 --> 01:26:20,399
So in short,

2341
01:26:20,479 --> 01:26:21,509
what have we just seen?

2342
01:26:21,919 --> 01:26:22,229
One,

2343
01:26:22,399 --> 01:26:24,919
you can join two tables together and whittle down the

2344
01:26:24,919 --> 01:26:26,910
temporary table to just the data you care about.

2345
01:26:27,240 --> 01:26:28,520
Or if you prefer,

2346
01:26:28,629 --> 01:26:30,990
and if I scroll back up in my history here,

2347
01:26:31,279 --> 01:26:35,109
you could take a fundamentally different approach but still get the same answer

2348
01:26:35,439 --> 01:26:37,120
of simply using a nested query.

2349
01:26:37,160 --> 01:26:39,149
I would say as you learn SQL for the first time,

2350
01:26:39,240 --> 01:26:42,399
I think it's quite often easier to just do multiple.

2351
01:26:42,830 --> 01:26:45,439
Nested queries because you sort of work your way

2352
01:26:45,919 --> 01:26:48,580
from the inside out taking sort of baby steps to the problem.

2353
01:26:48,609 --> 01:26:52,759
If the problem in question is give me all of the genres for a specific TV show.

2354
01:26:53,089 --> 01:26:53,419
Well,

2355
01:26:53,689 --> 01:26:57,919
first I need to know because I know how the data is laid out in the database.

2356
01:26:58,129 --> 01:27:00,600
I need to know the unique ID of the show I care about.

2357
01:27:00,770 --> 01:27:00,970
fine,

2358
01:27:01,009 --> 01:27:03,399
that's pretty straightforward and hence this inner query.

2359
01:27:03,549 --> 01:27:07,279
Once you have that you can parenthesize it and on the outside now you can select.

2360
01:27:07,470 --> 01:27:09,669
The question to which you really want the answer,

2361
01:27:09,700 --> 01:27:12,129
which is what is the genre that lines up with

2362
01:27:12,330 --> 01:27:15,169
that show ID one or more times.

2363
01:27:15,339 --> 01:27:15,790
So in short,

2364
01:27:15,899 --> 01:27:19,970
nested queries probably easier and certainly when learning for the first time,

2365
01:27:20,220 --> 01:27:22,750
but quite powerful are these joined queries

2366
01:27:22,750 --> 01:27:24,970
where this achieves the exact same result,

2367
01:27:25,259 --> 01:27:29,169
especially if I were to generalize away the 63881 and do a nested query here.

2368
01:27:29,740 --> 01:27:30,500
Sometimes you want joins,

2369
01:27:30,819 --> 01:27:32,299
sometimes nested queries suffice.

2370
01:27:35,149 --> 01:27:35,569
What

2371
01:27:36,850 --> 01:27:37,410
Oh my goodness,

2372
01:27:37,529 --> 01:27:39,250
how does SQL do all of these searches?

2373
01:27:39,330 --> 01:27:40,569
What's its time complexity?

2374
01:27:40,609 --> 01:27:42,319
We'll talk about that to the end of today.

2375
01:27:42,609 --> 01:27:44,319
In the most naive implementation,

2376
01:27:44,450 --> 01:27:48,200
SQL is essentially just doing linear search from the top of the table

2377
01:27:48,450 --> 01:27:49,500
all the way to the bottom.

2378
01:27:49,609 --> 01:27:49,959
However,

2379
01:27:50,169 --> 01:27:53,160
we as the programmers are going to have the ability

2380
01:27:53,160 --> 01:27:55,689
to optimize those queries so that the database can actually

2381
01:27:55,689 --> 01:27:58,689
do something closer to binary search and in general we'll

2382
01:27:58,689 --> 01:28:01,439
be able to achieve much better performance as a result.

2383
01:28:01,729 --> 01:28:02,759
A really good question.

2384
01:28:03,120 --> 01:28:03,209
All right,

2385
01:28:03,250 --> 01:28:04,410
let's go back to the big.

2386
01:28:05,140 --> 01:28:05,339
Uh,

2387
01:28:05,370 --> 01:28:08,799
flow chart of this data set we've looked now at shows and ratings.

2388
01:28:08,859 --> 01:28:10,379
We've looked at shows and genres.

2389
01:28:10,500 --> 01:28:12,339
Let's now focus on the juiciest part,

2390
01:28:12,419 --> 01:28:14,979
like the part that associates shows with people,

2391
01:28:15,020 --> 01:28:16,490
that is who stars in what,

2392
01:28:16,660 --> 01:28:20,169
thinking back now to what I was mocking up in the Google sheet at the very start,

2393
01:28:20,419 --> 01:28:22,939
whereby I wanted to somehow be able to associate the Office with

2394
01:28:22,939 --> 01:28:25,850
Steve Carell and John Krasinski and Jenna Fischer and so forth,

2395
01:28:26,220 --> 01:28:27,020
the right way.

2396
01:28:27,116 --> 01:28:29,255
And the right way I claim is going to be like this.

2397
01:28:29,346 --> 01:28:30,456
Here's my people table,

2398
01:28:30,625 --> 01:28:32,746
which has a primary key of ID and then the

2399
01:28:32,746 --> 01:28:35,215
name of each person and their birth year if known.

2400
01:28:35,425 --> 01:28:36,576
Then we have the show's table,

2401
01:28:36,585 --> 01:28:37,505
which we keep talking about,

2402
01:28:37,585 --> 01:28:39,056
which again has a primary key,

2403
01:28:39,266 --> 01:28:41,616
a title and year and episodes thereof.

2404
01:28:41,786 --> 01:28:44,625
And then the stars table is somewhat new now because

2405
01:28:44,625 --> 01:28:47,186
now when it comes to people starring in TV shows,

2406
01:28:47,266 --> 01:28:49,145
we have a third and final type of relationship.

2407
01:28:49,671 --> 01:28:51,642
A many to many relationship.

2408
01:28:51,711 --> 01:28:52,091
Why?

2409
01:28:52,271 --> 01:28:56,102
Because it's certainly the case that one person can be in multiple shows,

2410
01:28:56,432 --> 01:28:59,541
and it's certainly the case that some shows have multiple people,

2411
01:28:59,671 --> 01:29:01,001
hence many to many.

2412
01:29:01,071 --> 01:29:04,312
So this is the 3rd and final relationship where just to recap,

2413
01:29:04,631 --> 01:29:06,162
ratings was 1 to 1,

2414
01:29:06,392 --> 01:29:07,921
genres was one to many,

2415
01:29:08,032 --> 01:29:09,312
and now stars

2416
01:29:09,671 --> 01:29:11,312
is going to be many to many.

2417
01:29:11,870 --> 01:29:12,109
All right,

2418
01:29:12,189 --> 01:29:12,939
let's dive in.

2419
01:29:13,149 --> 01:29:15,830
So these queries will be a bit more

2420
01:29:16,229 --> 01:29:16,870
verbose,

2421
01:29:16,910 --> 01:29:19,189
but again they're gonna follow this principle of sort of

2422
01:29:19,189 --> 01:29:21,029
taking baby steps to the answer we care about.

2423
01:29:21,089 --> 01:29:22,660
Let me go back into VS code here

2424
01:29:22,870 --> 01:29:24,700
and suppose I want to find out

2425
01:29:25,229 --> 01:29:26,759
everything about the office that we know.

2426
01:29:26,870 --> 01:29:32,569
So select star from shows where title equals quote unquote the office semicolon.

2427
01:29:32,790 --> 01:29:32,830
Well,

2428
01:29:32,870 --> 01:29:33,419
that's interesting.

2429
01:29:33,549 --> 01:29:34,669
There's a whole bunch of offices.

2430
01:29:34,709 --> 01:29:35,669
There was the UK versions.

2431
01:29:35,950 --> 01:29:36,779
A few other variants,

2432
01:29:36,819 --> 01:29:39,500
but the one we're probably talking about with these stars

2433
01:29:39,500 --> 01:29:43,459
is the one that started in 2005 with 188 episodes.

2434
01:29:43,540 --> 01:29:44,609
That's the US version,

2435
01:29:44,620 --> 01:29:45,049
in fact.

2436
01:29:45,299 --> 01:29:46,609
So let me be a little more precise.

2437
01:29:46,779 --> 01:29:49,060
Let me select everything I know from the stars from the

2438
01:29:49,060 --> 01:29:52,810
show's table where the title equals office and year equals 2005,

2439
01:29:53,020 --> 01:29:56,330
so we don't confuse our answers with the other versions of The Office.

2440
01:29:56,620 --> 01:30:00,220
Now how do I go about selecting all of the people who starred in that.

2441
01:30:00,770 --> 01:30:02,560
version of the office.

2442
01:30:02,850 --> 01:30:02,890
Well,

2443
01:30:02,970 --> 01:30:06,450
I already have an answer to the question of what is the ID of

2444
01:30:06,450 --> 01:30:08,979
that version of the office because it's right there in front of me.

2445
01:30:09,040 --> 01:30:09,410
And in fact,

2446
01:30:09,490 --> 01:30:11,720
I can narrow my query more precisely.

2447
01:30:11,890 --> 01:30:13,520
Let's just select the ID

2448
01:30:13,879 --> 01:30:19,799
from the show's table where the title is The Office and the year is 2005 386676.

2449
01:30:19,970 --> 01:30:22,410
Now I could lazily just copy paste that or memorize it,

2450
01:30:22,569 --> 01:30:24,640
but we're going to do this query more dynamically.

2451
01:30:25,089 --> 01:30:28,410
I want to next though figure out who is in.

2452
01:30:28,959 --> 01:30:30,270
That show.

2453
01:30:30,479 --> 01:30:32,109
So if I have a show ID,

2454
01:30:32,240 --> 01:30:34,120
I want to figure out who's in it,

2455
01:30:34,160 --> 01:30:37,270
but how do I get to the people and the names of those people?

2456
01:30:37,560 --> 01:30:41,589
I have to logically go through this cross referencing of the star's table.

2457
01:30:41,810 --> 01:30:44,680
So here's where this query is going to be a bit meatier than the

2458
01:30:44,680 --> 01:30:47,709
past ones and that we need to do a bit more work than before.

2459
01:30:48,029 --> 01:30:48,120
All right,

2460
01:30:48,200 --> 01:30:48,319
well,

2461
01:30:48,359 --> 01:30:49,680
what's the work I need to do?

2462
01:30:49,939 --> 01:30:51,310
Let me go ahead now.

2463
01:30:51,700 --> 01:30:53,759
And do the following select

2464
01:30:54,089 --> 01:30:57,959
all of the person IDs that are associated with this

2465
01:30:58,529 --> 01:30:59,109
show ID.

2466
01:30:59,209 --> 01:31:00,209
So how do I do that?

2467
01:31:00,410 --> 01:31:03,560
Select person ID from the stars table

2468
01:31:04,009 --> 01:31:05,919
where the show ID

2469
01:31:06,129 --> 01:31:06,810
equals,

2470
01:31:06,839 --> 01:31:09,330
and I could lazily copy paste this,

2471
01:31:09,370 --> 01:31:10,370
but let's avoid that,

2472
01:31:10,529 --> 01:31:12,879
where the show ID equals,

2473
01:31:13,049 --> 01:31:14,919
let me now in parentheses do this,

2474
01:31:15,250 --> 01:31:20,000
select ID from shows where title equals quote unquote the office

2475
01:31:20,649 --> 01:31:20,850
and.

2476
01:31:20,959 --> 01:31:23,379
And year equals 2005

2477
01:31:23,669 --> 01:31:25,839
and then close my parenthesis semicolon.

2478
01:31:25,950 --> 01:31:26,549
So what am I doing?

2479
01:31:26,629 --> 01:31:28,149
I'm taking a second baby step,

2480
01:31:28,160 --> 01:31:28,620
if you will.

2481
01:31:28,879 --> 01:31:33,310
The innermost query inside the parentheses is just again dynamically figuring

2482
01:31:33,310 --> 01:31:35,740
out the unique ID of the office I care about.

2483
01:31:35,910 --> 01:31:39,109
The outer query is now figuring out all of the person

2484
01:31:39,109 --> 01:31:43,029
IDs associated with that show as per the stars table,

2485
01:31:43,069 --> 01:31:44,979
and the stars table has only two columns

2486
01:31:45,100 --> 01:31:45,859
show ID

2487
01:31:46,109 --> 01:31:47,029
and person ID.

2488
01:31:47,149 --> 01:31:49,589
That's how the linkage is done just with those integers.

2489
01:31:49,669 --> 01:31:50,069
Enter.

2490
01:31:50,649 --> 01:31:56,640
I now have a column of person IDs that are starring in that version of The Office,

2491
01:31:56,850 --> 01:31:58,930
so how do I take this one final step if I really

2492
01:31:58,930 --> 01:32:02,450
want to care about their names and not their random person IDs?

2493
01:32:02,609 --> 01:32:02,810
Well,

2494
01:32:02,970 --> 01:32:04,680
I could go ahead and select the name

2495
01:32:05,169 --> 01:32:06,009
from the people.

2496
01:32:06,319 --> 01:32:06,870
table

2497
01:32:07,279 --> 01:32:09,589
where that person's ID

2498
01:32:09,890 --> 01:32:11,950
is in the following set.

2499
01:32:12,040 --> 01:32:13,500
So when I'm dealing with a single value,

2500
01:32:13,560 --> 01:32:15,029
I just use equals for equality,

2501
01:32:15,160 --> 01:32:17,359
but when I'm dealing with a whole result set,

2502
01:32:17,399 --> 01:32:18,839
a whole column of answers,

2503
01:32:18,910 --> 01:32:20,390
I use the preposition in

2504
01:32:20,520 --> 01:32:21,560
in SQL instead.

2505
01:32:21,919 --> 01:32:26,430
So where the person's ID is in the following data set.

2506
01:32:26,500 --> 01:32:26,620
Well,

2507
01:32:26,779 --> 01:32:28,339
let's do the same queries as before.

2508
01:32:28,419 --> 01:32:34,649
Select all the person IDs from the stars table where the show ID I care about

2509
01:32:34,779 --> 01:32:35,330
equals,

2510
01:32:35,339 --> 01:32:36,959
because there's only one show I care about.

2511
01:32:37,060 --> 01:32:38,850
I'm going to further parenthesize this

2512
01:32:39,299 --> 01:32:42,859
select ID from shows where title equals quote

2513
01:32:42,859 --> 01:32:46,660
unquote the Office and year equals 2005.

2514
01:32:47,200 --> 01:32:47,609
Uh,

2515
01:32:48,259 --> 01:32:49,350
I'll close my parenthesis.

2516
01:32:49,509 --> 01:32:49,779
Enter.

2517
01:32:49,899 --> 01:32:51,729
I'll close my parenthesis semicolon,

2518
01:32:51,859 --> 01:32:55,089
and now from the outside in I've taken three baby steps.

2519
01:32:55,100 --> 01:32:57,729
The innermost one just gets me the show ID.

2520
01:32:57,890 --> 01:33:01,140
The second one in the middle gets me all of the related person IDs,

2521
01:33:01,149 --> 01:33:03,089
and the last one is really the final flourish.

2522
01:33:03,299 --> 01:33:06,970
Get me all of the names of these people based on those IDs.

2523
01:33:07,299 --> 01:33:07,879
Enter

2524
01:33:08,439 --> 01:33:10,939
and now we see all of the stars in this

2525
01:33:10,939 --> 01:33:14,310
show beyond even the subset that we've been playing with visually

2526
01:33:14,700 --> 01:33:15,430
on the screen.

2527
01:33:16,729 --> 01:33:17,180
OK,

2528
01:33:17,290 --> 01:33:17,930
that's a lot.

2529
01:33:18,129 --> 01:33:19,879
Let me pause here and see if there's any

2530
01:33:20,529 --> 01:33:21,160
questions.

2531
01:33:21,330 --> 01:33:21,649
Yeah.

2532
01:33:25,180 --> 01:33:27,890
This outermost query is what gives me the names,

2533
01:33:28,299 --> 01:33:32,890
but that query needs to know the ID of the person who whose name you want.

2534
01:33:33,180 --> 01:33:36,580
So the middle query actually gets all of those person IDs,

2535
01:33:36,700 --> 01:33:37,939
but to get those person IDs,

2536
01:33:37,950 --> 01:33:39,259
I need to know the show ID.

2537
01:33:39,299 --> 01:33:40,660
So the innermost query,

2538
01:33:40,700 --> 01:33:41,330
this one,

2539
01:33:41,580 --> 01:33:44,729
gets me the show ID of the office itself.

2540
01:33:46,770 --> 01:33:47,339
All right,

2541
01:33:47,810 --> 01:33:49,560
so at the risk of overwhelming,

2542
01:33:49,689 --> 01:33:52,009
here are other ways you can solve the same problem,

2543
01:33:52,049 --> 01:33:54,890
but I do claim that the nested selects

2544
01:33:54,890 --> 01:33:58,479
is probably conceptually and pragmatically the easiest way.

2545
01:33:58,649 --> 01:34:02,160
But let's also solve this problem by doing a few joins just so you've seen it.

2546
01:34:02,410 --> 01:34:02,569
Actually,

2547
01:34:02,810 --> 01:34:03,919
before we do a joint,

2548
01:34:04,009 --> 01:34:05,799
let's let's flip the question around first.

2549
01:34:05,930 --> 01:34:09,209
How about all of the shows that Steve Carell has starred in besides The Office?

2550
01:34:09,250 --> 01:34:13,129
So let me select everything I know from the people table where the name of the person.

2551
01:34:13,402 --> 01:34:14,493
Equals quote unquote

2552
01:34:14,842 --> 01:34:16,603
Steve Carell semicolon.

2553
01:34:16,723 --> 01:34:16,842
All right,

2554
01:34:16,922 --> 01:34:20,393
there seems to be only one Steve Carell in IMDB born in 1962.

2555
01:34:20,643 --> 01:34:21,442
That's all nice and good.

2556
01:34:21,562 --> 01:34:23,192
What I really care about is his ID,

2557
01:34:23,362 --> 01:34:24,013
so I'm going to

2558
01:34:24,522 --> 01:34:27,243
narrow this down to selecting just his ID.

2559
01:34:27,502 --> 01:34:30,433
Now I could memorize or copy paste 136797,

2560
01:34:30,442 --> 01:34:30,792
but

2561
01:34:31,002 --> 01:34:31,712
don't need to do that.

2562
01:34:31,743 --> 01:34:33,752
Let's just use this as part of a nested query.

2563
01:34:33,962 --> 01:34:39,723
Let's now select all of the show IDs from the stars table that are somehow related.

2564
01:34:39,835 --> 01:34:42,485
Need to Steve Carell's person ID.

2565
01:34:42,655 --> 01:34:44,565
So where person ID

2566
01:34:44,956 --> 01:34:45,636
equals,

2567
01:34:45,715 --> 01:34:47,786
and I could copy paste this,

2568
01:34:48,076 --> 01:34:49,476
but that's generally frowned upon.

2569
01:34:49,556 --> 01:34:50,315
So let's not do that.

2570
01:34:50,395 --> 01:34:53,746
Let's just set it equal to a nested query where I do the same thing as before.

2571
01:34:53,916 --> 01:34:57,465
Select ID from people where name equals

2572
01:34:57,755 --> 01:34:59,186
Steve Carell,

2573
01:34:59,596 --> 01:35:01,715
then close my parenthesis semicolon.

2574
01:35:01,925 --> 01:35:02,155
All right,

2575
01:35:02,266 --> 01:35:03,706
he's been in a lot of TV shows,

2576
01:35:03,715 --> 01:35:06,275
but this is not useful because I have no idea what all of these integers are.

2577
01:35:06,539 --> 01:35:07,659
So the final flourish,

2578
01:35:07,809 --> 01:35:09,059
select the title

2579
01:35:09,668 --> 01:35:15,298
from the show's table where the ID of the shows I care about is somehow in

2580
01:35:15,588 --> 01:35:17,108
this parenthetical list.

2581
01:35:17,148 --> 01:35:17,238
Well,

2582
01:35:17,309 --> 01:35:18,309
what's that parenthetical list?

2583
01:35:18,449 --> 01:35:18,519
Well,

2584
01:35:18,668 --> 01:35:20,008
select the show ID

2585
01:35:20,349 --> 01:35:24,168
from stars where the person ID equals Steve Carell's.

2586
01:35:24,269 --> 01:35:25,119
What is his ID?

2587
01:35:25,229 --> 01:35:25,539
Well,

2588
01:35:25,628 --> 01:35:26,469
I didn't memorize it,

2589
01:35:26,508 --> 01:35:29,418
so I'm gonna select ID from people where

2590
01:35:29,789 --> 01:35:32,889
the name of the person I care about is Steve Carell.

2591
01:35:33,742 --> 01:35:36,432
I quote unquote close these this parenthesis,

2592
01:35:36,541 --> 01:35:37,301
close this parenthesis,

2593
01:35:37,341 --> 01:35:38,012
semicolon,

2594
01:35:38,021 --> 01:35:38,452
enter,

2595
01:35:38,662 --> 01:35:41,301
and now I see all of Steve Carell's shows.

2596
01:35:41,421 --> 01:35:44,332
And even though we're doing this in a black and white command line environment,

2597
01:35:44,742 --> 01:35:47,622
think about what the actual IMDB is doing with both of these queries.

2598
01:35:47,662 --> 01:35:50,222
If you go to IMDb.com and search for Steve Carell,

2599
01:35:50,301 --> 01:35:52,892
even though there's going to be a lot of colors and pretty pictures and whatnot,

2600
01:35:53,062 --> 01:35:56,852
you'll probably get in some form a list of all of Steve Carell's shows.

2601
01:35:56,861 --> 01:35:58,301
Or if you search for the Office,

2602
01:35:58,352 --> 01:35:59,461
you'll get a list in some.

2603
01:35:59,584 --> 01:36:01,314
Of all of the stars they're in,

2604
01:36:01,654 --> 01:36:03,245
I could claim then that if

2605
01:36:03,615 --> 01:36:05,254
IMDb.com is using SQL,

2606
01:36:05,305 --> 01:36:06,535
which it very likely is,

2607
01:36:06,615 --> 01:36:07,685
but not necessarily,

2608
01:36:08,055 --> 01:36:11,095
they are executing queries just like we did.

2609
01:36:11,115 --> 01:36:15,444
And when you type into the search box something like The Office or Steve Carell,

2610
01:36:15,654 --> 01:36:17,035
they're essentially just

2611
01:36:17,375 --> 01:36:22,685
copy pasting your user input into a prefabbed SQL query that they wrote in advance

2612
01:36:23,134 --> 01:36:26,015
so as to get you the answers that you actually care about.

2613
01:36:26,410 --> 01:36:30,430
So this is how a lot of today's websites and mobile apps are actually working.

2614
01:36:30,680 --> 01:36:34,629
The programmer comes up with sort of the template for the queries you might ask,

2615
01:36:34,720 --> 01:36:36,589
and then you supply the actual data

2616
01:36:36,799 --> 01:36:37,910
you're searching for.

2617
01:36:38,640 --> 01:36:38,839
All right,

2618
01:36:38,919 --> 01:36:39,750
how about now,

2619
01:36:39,799 --> 01:36:40,399
as promised,

2620
01:36:40,439 --> 01:36:44,520
a couple of other ways to implement these many to many relationships,

2621
01:36:44,600 --> 01:36:45,310
uh,

2622
01:36:45,640 --> 01:36:46,589
based queries,

2623
01:36:47,279 --> 01:36:48,549
but by using joints.

2624
01:36:48,600 --> 01:36:51,109
If I know I need to involve the show's table,

2625
01:36:51,200 --> 01:36:51,910
the people table,

2626
01:36:51,919 --> 01:36:52,689
and the stars table,

2627
01:36:52,720 --> 01:36:53,799
I can actually do this all in.

2628
01:36:53,895 --> 01:36:55,875
One breath without any nested queries.

2629
01:36:56,205 --> 01:36:59,754
Select for me the title from the show's table,

2630
01:37:00,165 --> 01:37:05,044
but let's join that on the stars table on shows.

2631
01:37:05,245 --> 01:37:09,205
ID equaling stars.sh show ID.

2632
01:37:09,930 --> 01:37:09,939
Uh,

2633
01:37:11,729 --> 01:37:15,509
But let's additionally join the show's table on the following.

2634
01:37:15,589 --> 01:37:20,899
Let's join it on people on stars.person ID equaling people.

2635
01:37:21,229 --> 01:37:21,649
ID.

2636
01:37:21,669 --> 01:37:22,359
In other words,

2637
01:37:22,589 --> 01:37:25,140
if you know conceptually that you've got these 3 tables,

2638
01:37:25,149 --> 01:37:28,629
you want to somehow combine them without using nested selects,

2639
01:37:28,790 --> 01:37:30,720
just figure out how to line them all up.

2640
01:37:30,990 --> 01:37:31,350
So again,

2641
01:37:31,430 --> 01:37:32,939
I'm selecting from the show's table,

2642
01:37:32,990 --> 01:37:35,149
but I'm joining it with the stars table.

2643
01:37:35,444 --> 01:37:37,515
By lining up the shows,

2644
01:37:37,524 --> 01:37:38,075
tables,

2645
01:37:38,084 --> 01:37:41,395
primary key with the stars tables foreign key,

2646
01:37:41,404 --> 01:37:41,904
and

2647
01:37:42,205 --> 01:37:45,444
I'm lining it up with the people table by lining up

2648
01:37:45,444 --> 01:37:50,234
the stars tables foreign key with the people table's primary key.

2649
01:37:50,325 --> 01:37:53,834
I'm just kind of logically connecting all of the things I know to be related

2650
01:37:54,044 --> 01:37:54,774
and lastly,

2651
01:37:54,865 --> 01:37:58,615
let's just say where the name I care about equals quote unquote Steve

2652
01:37:59,595 --> 01:38:00,245
Carell

2653
01:38:00,564 --> 01:38:01,365
semicolon.

2654
01:38:01,899 --> 01:38:04,850
It's a little slower for now and this speaks to the question that was asked earlier,

2655
01:38:04,890 --> 01:38:06,009
how is the database doing this?

2656
01:38:06,109 --> 01:38:06,229
Well,

2657
01:38:06,290 --> 01:38:06,689
slowly,

2658
01:38:06,770 --> 01:38:08,720
apparently by default unless we optimize it,

2659
01:38:08,930 --> 01:38:12,359
I got back essentially the same results although

2660
01:38:12,359 --> 01:38:14,200
there is some duplication as a result,

2661
01:38:14,410 --> 01:38:14,799
uh,

2662
01:38:14,810 --> 01:38:15,930
which alludes to the.

2663
01:38:16,270 --> 01:38:16,759
Um,

2664
01:38:16,890 --> 01:38:19,479
filling in blank of blanks that I alluded to earlier.

2665
01:38:19,729 --> 01:38:21,560
But let me show you one other technique too.

2666
01:38:21,810 --> 01:38:22,129
But again,

2667
01:38:22,209 --> 01:38:24,649
I would encourage you certainly for problems at 7 to focus on

2668
01:38:24,649 --> 01:38:27,359
nested queries when you can because they're a little conceptually simpler.

2669
01:38:27,569 --> 01:38:29,529
If I care about the titles of those shows,

2670
01:38:29,649 --> 01:38:33,450
I could select title from the show's table and the stars

2671
01:38:33,450 --> 01:38:36,560
table and the people table all at once in one breath.

2672
01:38:36,970 --> 01:38:39,930
But I want to do so where the show's

2673
01:38:39,930 --> 01:38:44,649
table's primary key equals the stars tables foreign key.

2674
01:38:45,129 --> 01:38:45,490
Uh,

2675
01:38:45,569 --> 01:38:50,580
and the people table's primary key equals the stars tables

2676
01:38:51,049 --> 01:38:51,879
foreign key,

2677
01:38:52,200 --> 01:38:54,970
and the name I care about is Steve Carell.

2678
01:38:55,089 --> 01:38:55,569
In other words,

2679
01:38:55,609 --> 01:38:58,839
this is just a third way to express the exact same idea

2680
01:38:59,129 --> 01:39:00,009
by doing implicit.

2681
01:39:00,270 --> 01:39:03,990
Joins by selecting data clearly from all three tables as per this comma

2682
01:39:03,990 --> 01:39:08,149
separated list of table names but telling the database with your predicate,

2683
01:39:08,160 --> 01:39:09,180
the where clause,

2684
01:39:09,410 --> 01:39:11,859
how you want to line all of those tables up.

2685
01:39:12,029 --> 01:39:13,180
If I hit enter here,

2686
01:39:13,430 --> 01:39:14,109
cross my fingers,

2687
01:39:14,200 --> 01:39:15,259
I should get back

2688
01:39:15,870 --> 01:39:16,500
the same

2689
01:39:16,859 --> 01:39:18,140
results as well,

2690
01:39:18,350 --> 01:39:19,529
albeit with duplication,

2691
01:39:19,549 --> 01:39:21,609
which I didn't see in the nested queries.

2692
01:39:21,990 --> 01:39:22,149
OK,

2693
01:39:22,189 --> 01:39:23,069
that too was a mouthful.

2694
01:39:23,109 --> 01:39:24,220
Let me pause here

2695
01:39:24,790 --> 01:39:25,669
for questions.

2696
01:39:27,250 --> 01:39:27,560
Yeah.

2697
01:39:28,910 --> 01:39:29,500
do that

2698
01:39:30,430 --> 01:39:32,430
No the internal structure.

2699
01:39:34,629 --> 01:39:34,950
Correct.

2700
01:39:34,990 --> 01:39:35,669
In order to do this,

2701
01:39:35,709 --> 01:39:36,020
you,

2702
01:39:36,029 --> 01:39:38,770
as the programmer must know the internal structure of the database,

2703
01:39:39,029 --> 01:39:41,790
which is quite often the case whether you created the database yourself or

2704
01:39:41,790 --> 01:39:44,939
you work with a colleague who designed the schema for the database.

2705
01:39:45,310 --> 01:39:45,709
That said,

2706
01:39:45,790 --> 01:39:47,669
I think your question's hinting at sort of the

2707
01:39:47,669 --> 01:39:50,589
challenge like I really need to know the underlying implementation

2708
01:39:50,589 --> 01:39:52,549
details when really all I care about is the

2709
01:39:52,549 --> 01:39:56,669
answers to my questions in code quite oftenly nowadays,

2710
01:39:56,859 --> 01:39:57,009
um,

2711
01:39:57,149 --> 01:39:58,350
there are object relations.

2712
01:39:58,669 --> 01:40:01,479
Mappings whereby you can use ORMs for sure,

2713
01:40:01,729 --> 01:40:03,680
whereby you can use libraries

2714
01:40:03,970 --> 01:40:06,850
that they understand the underlying database schema

2715
01:40:06,850 --> 01:40:08,600
you as the programmer do not need

2716
01:40:08,600 --> 01:40:12,209
to because it figures out how to do all of the joints for you.

2717
01:40:12,450 --> 01:40:14,529
So for CS 50 we're introducing everyone to the

2718
01:40:14,529 --> 01:40:16,600
bottom up understanding of how these joints work,

2719
01:40:16,750 --> 01:40:19,040
but that too can be easily automated

2720
01:40:19,370 --> 01:40:20,330
because of those schemas.

2721
01:40:20,410 --> 01:40:20,819
Yeah.

2722
01:40:23,839 --> 01:40:24,459
That is

2723
01:40:26,359 --> 01:40:26,850
Good question.

2724
01:40:26,870 --> 01:40:28,939
Is indentation in SQL important?

2725
01:40:29,270 --> 01:40:29,990
Technically no,

2726
01:40:30,069 --> 01:40:32,430
but like with any of the languages we've talked about thus far,

2727
01:40:32,439 --> 01:40:36,339
it is good for the humans and certainly good for the students in a context like this.

2728
01:40:36,589 --> 01:40:39,029
Python of the languages we looked at is the most rigorous,

2729
01:40:39,069 --> 01:40:43,229
whereby indentation very much matters and the consistency thereof SQL,

2730
01:40:43,270 --> 01:40:46,430
I'm just trying to pretty print things to make it easy to grok visually.

2731
01:40:47,279 --> 01:40:47,479
All right,

2732
01:40:47,600 --> 01:40:49,919
so those last two queries were arguably kind of slow,

2733
01:40:49,959 --> 01:40:51,189
whereas with my nested queries,

2734
01:40:51,200 --> 01:40:52,459
I actually got lucky and just boom,

2735
01:40:52,520 --> 01:40:53,830
I got the answer quite quickly.

2736
01:40:54,040 --> 01:40:56,629
Those joins seemed to be a step backwards and that it was taking

2737
01:40:56,629 --> 01:41:00,089
more time to get back the same data that I actually cared about,

2738
01:41:00,279 --> 01:41:02,189
but that's something we can actually chip away at.

2739
01:41:02,279 --> 01:41:04,990
It turns out that one of the other values of

2740
01:41:05,200 --> 01:41:08,520
a relational database vis a vis something like a spreadsheet is that you

2741
01:41:08,520 --> 01:41:12,490
can actually tell the database in advance how to optimize for certain queries.

2742
01:41:12,640 --> 01:41:14,390
This is not the case for spreadsheets if you.

2743
01:41:14,450 --> 01:41:18,640
Have a lot of data in Google spreadsheets or Microsoft Excel or Apple Numbers,

2744
01:41:18,660 --> 01:41:20,040
tens of thousands of rows,

2745
01:41:20,120 --> 01:41:21,319
hundreds of thousands of rows,

2746
01:41:21,410 --> 01:41:22,339
millions of rows.

2747
01:41:22,399 --> 01:41:24,160
Your computer's going to slow to a crawl,

2748
01:41:24,169 --> 01:41:27,950
and at some point those software packages are just going to say sorry file is too big,

2749
01:41:28,080 --> 01:41:30,750
and they're certainly not going to be terribly fast at searching the data.

2750
01:41:30,959 --> 01:41:34,229
But with a SQL database and relational databases more generally,

2751
01:41:34,450 --> 01:41:38,830
you are as much the architect of it as you are the user of it in this case.

2752
01:41:38,959 --> 01:41:41,830
And so you can tell the database in advance if you want to.

2753
01:41:42,540 --> 01:41:45,479
Optimize for certain queries like select statements.

2754
01:41:45,560 --> 01:41:46,200
So for instance,

2755
01:41:46,319 --> 01:41:49,310
let me go back to VS code here and just for the sake of discussion,

2756
01:41:49,399 --> 01:41:54,709
let's time how long it takes to find all of the shows whose name is the Office.

2757
01:41:54,879 --> 01:41:58,310
I'm gonna use a SQL like command called Timer and I'm gonna set it to on,

2758
01:41:58,439 --> 01:42:02,740
and this is just now going to tell me for every command I run how long it took.

2759
01:42:03,000 --> 01:42:06,240
I'm gonna now select everything from the show's table where

2760
01:42:06,240 --> 01:42:09,000
the title of the show equals quote unquote the office.

2761
01:42:09,479 --> 01:42:10,839
Semicolon Enter

2762
01:42:11,120 --> 01:42:12,339
and that query took,

2763
01:42:12,479 --> 01:42:16,430
let's say in real terms 0.042 seconds.

2764
01:42:16,600 --> 01:42:17,520
That's crazy fast.

2765
01:42:17,640 --> 01:42:18,680
Like it's less than a second.

2766
01:42:18,759 --> 01:42:20,189
I mean it's truly a split second,

2767
01:42:20,200 --> 01:42:21,069
so no big deal,

2768
01:42:21,279 --> 01:42:22,750
but it's a fairly simple query.

2769
01:42:22,959 --> 01:42:25,169
But I bet we could optimize even this.

2770
01:42:25,279 --> 01:42:28,390
Now why would you want to optimize even queries that are already pretty fast?

2771
01:42:28,520 --> 01:42:28,620
Well,

2772
01:42:28,680 --> 01:42:30,520
if they're very commonly being executed,

2773
01:42:30,600 --> 01:42:34,470
and I dare say someone going to IMDb.com and searching for The Office or any TV show,

2774
01:42:34,600 --> 01:42:35,680
like that's the common case.

2775
01:42:35,759 --> 01:42:36,640
People are looking for TV.

2776
01:42:36,779 --> 01:42:37,040
Shows,

2777
01:42:37,080 --> 01:42:37,439
movies,

2778
01:42:37,520 --> 01:42:37,919
actors,

2779
01:42:37,959 --> 01:42:38,629
and so forth,

2780
01:42:38,759 --> 01:42:42,410
it'd be nice to use as little amount of time to answer those questions as possible.

2781
01:42:42,439 --> 01:42:42,830
Why?

2782
01:42:43,080 --> 01:42:43,279
One,

2783
01:42:43,290 --> 01:42:45,279
it makes for happier customers and users

2784
01:42:45,279 --> 01:42:46,830
because you're getting them the answer faster.

2785
01:42:47,040 --> 01:42:47,200
Two,

2786
01:42:47,209 --> 01:42:48,189
it saves you money

2787
01:42:48,640 --> 01:42:52,439
because presumably if you've spent $1000 for a server

2788
01:42:52,439 --> 01:42:54,640
and that server has a certain amount of RAM,

2789
01:42:54,879 --> 01:42:56,560
a certain speed CPU or brain,

2790
01:42:56,680 --> 01:43:00,040
it can only do so many searches per unit of time per second,

2791
01:43:00,120 --> 01:43:01,069
per minute or the like.

2792
01:43:01,240 --> 01:43:04,040
So wouldn't it be nice if all of those searches is faster.

2793
01:43:04,209 --> 01:43:07,169
Using less time so you can handle not 1000 users at once

2794
01:43:07,169 --> 01:43:10,799
but 2000 users or 5000 users all with the same hardware.

2795
01:43:10,839 --> 01:43:13,069
So there's certainly upsides there.

2796
01:43:13,319 --> 01:43:13,399
Well,

2797
01:43:13,479 --> 01:43:15,529
how can I go about optimizing a query?

2798
01:43:15,680 --> 01:43:15,720
Well,

2799
01:43:15,759 --> 01:43:17,160
I can create my own index,

2800
01:43:17,279 --> 01:43:19,229
another use of the create keyword in SQL,

2801
01:43:19,240 --> 01:43:20,660
where I can tell the database

2802
01:43:21,200 --> 01:43:23,950
to optimize for searches on

2803
01:43:24,200 --> 01:43:26,839
a specific table and specific columns therein.

2804
01:43:27,020 --> 01:43:28,319
I say create index,

2805
01:43:28,379 --> 01:43:30,270
and then I come up with a name for the index,

2806
01:43:30,279 --> 01:43:31,109
whatever I want.

2807
01:43:31,799 --> 01:43:34,000
the name of the table that I want to index,

2808
01:43:34,160 --> 01:43:37,350
and then in parentheses the columns that I want to optimize for.

2809
01:43:37,600 --> 01:43:38,919
So what does this mean in real terms?

2810
01:43:38,970 --> 01:43:39,049
Well,

2811
01:43:39,080 --> 01:43:42,549
let's go back to BS code here and let me create an index called,

2812
01:43:42,560 --> 01:43:43,149
for instance,

2813
01:43:43,160 --> 01:43:43,919
title index,

2814
01:43:43,959 --> 01:43:45,109
though the name doesn't matter,

2815
01:43:45,479 --> 01:43:49,350
on the shows table using the title column.

2816
01:43:49,399 --> 01:43:49,959
In other words,

2817
01:43:50,160 --> 01:43:51,109
tell the database,

2818
01:43:51,439 --> 01:43:56,629
please expedite searches on the shows tables title column.

2819
01:43:56,799 --> 01:43:57,200
After all,

2820
01:43:57,279 --> 01:43:58,430
that's what I just searched on.

2821
01:43:58,520 --> 01:43:58,959
Enter.

2822
01:43:59,680 --> 01:44:00,479
Now that took a moment,

2823
01:44:00,669 --> 01:44:01,569
almost half a second,

2824
01:44:01,799 --> 01:44:04,509
but that's a tab that's an index that only has to be created once.

2825
01:44:04,680 --> 01:44:06,160
If I do a lot of updates and deletes,

2826
01:44:06,240 --> 01:44:09,430
it might actually take a little bit of time over over

2827
01:44:09,430 --> 01:44:12,000
the course of using the database to maintain that index,

2828
01:44:12,040 --> 01:44:15,129
but for now that's a one-time operation creating the index.

2829
01:44:15,319 --> 01:44:16,790
But watch what happens now.

2830
01:44:17,000 --> 01:44:20,509
If I scroll up in my history and go to the exact same query as before,

2831
01:44:20,720 --> 01:44:24,680
which previously took 0.042 seconds,

2832
01:44:24,720 --> 01:44:24,919
which,

2833
01:44:24,959 --> 01:44:25,169
yes,

2834
01:44:25,180 --> 01:44:28,439
is fast but not nearly as fast as the new version.

2835
01:44:29,129 --> 01:44:32,799
Which is 0.001 seconds instead.

2836
01:44:32,890 --> 01:44:37,330
orders of magnitude faster so I can handle 42

2837
01:44:37,330 --> 01:44:39,799
times as many users on the same database,

2838
01:44:40,009 --> 01:44:40,580
so to speak,

2839
01:44:40,770 --> 01:44:44,160
than I could have previously just by building this index.

2840
01:44:44,410 --> 01:44:45,850
So what actually is an index?

2841
01:44:45,890 --> 01:44:46,009
Well,

2842
01:44:46,089 --> 01:44:49,660
we come full circle to discussions in like week 5 of the class.

2843
01:44:49,729 --> 01:44:53,799
So an index in a database is very often created using what's called a Bree.

2844
01:44:53,810 --> 01:44:55,200
This is not a binary tree.

2845
01:44:55,290 --> 01:44:55,490
B.

2846
01:44:55,603 --> 01:44:59,143
The tree is its own distinct structure that's very similar in spirit

2847
01:44:59,143 --> 01:45:02,583
in that it's fairly shallow because most of the nodes have children,

2848
01:45:02,723 --> 01:45:03,942
but it doesn't necessarily have

2849
01:45:04,192 --> 01:45:04,712
two children.

2850
01:45:04,792 --> 01:45:06,152
It might have more children and in fact,

2851
01:45:06,163 --> 01:45:07,542
the more children the nodes have,

2852
01:45:07,632 --> 01:45:09,993
the sort of higher up you can pull all of the leaf

2853
01:45:09,993 --> 01:45:13,022
nodes and the shorter you can make the height of the tree.

2854
01:45:13,192 --> 01:45:15,542
So this is just a generic representation of a bee tree,

2855
01:45:15,553 --> 01:45:17,022
but what this implies is that

2856
01:45:17,312 --> 01:45:20,502
when I am now searching for titles like The Office,

2857
01:45:20,663 --> 01:45:22,033
the database doesn't have to do the.

2858
01:45:22,186 --> 01:45:23,895
Fault behavior which is start at the top and

2859
01:45:23,895 --> 01:45:25,985
use linear search all the way to the bottom.

2860
01:45:26,215 --> 01:45:30,085
If it has proactively built up an index in memory thanks to my command,

2861
01:45:30,295 --> 01:45:33,855
it now has a tree-like structure storing those titles

2862
01:45:33,855 --> 01:45:36,585
that allows it to find in some logarithmic time,

2863
01:45:36,735 --> 01:45:38,925
whether it's logbase 2 or some other base,

2864
01:45:39,166 --> 01:45:40,085
the same data

2865
01:45:40,255 --> 01:45:41,186
much more quickly,

2866
01:45:41,215 --> 01:45:46,456
and that's how we went from 0042 to 0.001 2nd

2867
01:45:47,056 --> 01:45:47,445
instead

2868
01:45:47,666 --> 01:45:48,616
in this case here.

2869
01:45:50,089 --> 01:45:51,149
Questions then

2870
01:45:51,370 --> 01:45:53,169
on these here indexes.

2871
01:45:55,759 --> 01:45:55,770
No.

2872
01:45:56,910 --> 01:45:57,109
All right,

2873
01:45:57,259 --> 01:45:57,390
well,

2874
01:45:57,430 --> 01:45:58,729
let's propose that

2875
01:45:58,950 --> 01:46:00,990
we can combine some of today's ideas.

2876
01:46:01,029 --> 01:46:01,819
It turns out

2877
01:46:02,149 --> 01:46:04,509
that now we're getting to the point in the course

2878
01:46:04,509 --> 01:46:06,709
where you're not just choosing between this language and another,

2879
01:46:06,830 --> 01:46:09,189
you're generally using a suite of languages to solve problems.

2880
01:46:09,229 --> 01:46:10,549
And indeed in the coming weeks of the

2881
01:46:10,549 --> 01:46:13,100
class when we transition to web-based applications,

2882
01:46:13,109 --> 01:46:14,629
you're going to use a bit of Python.

2883
01:46:14,669 --> 01:46:15,790
You're going to use a bit of SQL,

2884
01:46:15,830 --> 01:46:19,189
you're going to use a bit of JavaScript and two other languages called HTML and CS.

2885
01:46:19,481 --> 01:46:21,841
You might be using like 5 different languages

2886
01:46:21,841 --> 01:46:23,532
at a time just to build one application.

2887
01:46:23,642 --> 01:46:23,992
Why?

2888
01:46:24,282 --> 01:46:26,452
Because some of them are better for the job than others,

2889
01:46:26,461 --> 01:46:29,952
and indeed that's the ecosystem in which real world software development is done.

2890
01:46:30,162 --> 01:46:30,222
Well,

2891
01:46:30,282 --> 01:46:31,401
to make this bridge,

2892
01:46:31,441 --> 01:46:33,521
we have a version of the CS 50 library we're

2893
01:46:33,521 --> 01:46:36,082
called for Python which has functions like Get string,

2894
01:46:36,091 --> 01:46:38,521
even though it's not that useful because it's just like the input function,

2895
01:46:38,722 --> 01:46:40,892
but get in and get float,

2896
01:46:41,122 --> 01:46:42,722
but also in the CS 50 library.

2897
01:46:42,824 --> 01:46:43,804
For Python,

2898
01:46:44,014 --> 01:46:45,474
we have a

2899
01:46:45,773 --> 01:46:51,184
module that specifically makes it easier to use SQL from Python code.

2900
01:46:51,374 --> 01:46:51,773
After all,

2901
01:46:51,894 --> 01:46:54,934
wouldn't it be nice if I could get the best of both worlds and implement

2902
01:46:54,934 --> 01:46:59,403
like an interactive program in Python but that uses SQL to actually get back data?

2903
01:46:59,653 --> 01:47:02,514
Or I can build a website that allows people to search for

2904
01:47:02,514 --> 01:47:06,213
TV shows or TV stars and actually get that data from.

2905
01:47:06,355 --> 01:47:09,936
A database but use Python to generate the web pages themselves.

2906
01:47:10,105 --> 01:47:10,155
Well,

2907
01:47:10,186 --> 01:47:11,905
we have some documentation for this library here,

2908
01:47:12,016 --> 01:47:15,695
but I'm going to go ahead and use it in real time to show you how much

2909
01:47:16,105 --> 01:47:20,806
more easily you can solve certain problems by using each tool for what it's good at.

2910
01:47:20,985 --> 01:47:22,735
So let's go back to VS code here.

2911
01:47:22,985 --> 01:47:26,295
Let me exit out of SQL light and get back to my normal terminal,

2912
01:47:26,386 --> 01:47:28,815
and let me go ahead and let's say,

2913
01:47:28,826 --> 01:47:29,706
minimize.

2914
01:47:30,839 --> 01:47:32,020
My terminal here.

2915
01:47:33,310 --> 01:47:33,790
Uh,

2916
01:47:33,830 --> 01:47:34,040
actually,

2917
01:47:34,109 --> 01:47:36,810
let's go ahead and open up favorites.ie,

2918
01:47:36,910 --> 01:47:38,259
which is where we left off before,

2919
01:47:38,350 --> 01:47:39,950
and recall that in the last version of

2920
01:47:39,950 --> 01:47:42,629
favorites.ie we had simply used a dictionary to

2921
01:47:42,629 --> 01:47:46,419
go about keeping track of how many of you said Python or C or scratch.

2922
01:47:46,589 --> 01:47:49,660
And when I last ran this program with Pythonofavos.ie,

2923
01:47:49,910 --> 01:47:51,620
the answer looked like this.

2924
01:47:51,830 --> 01:47:54,430
Now notice that it's not sorted alphabetically,

2925
01:47:54,549 --> 01:47:55,859
otherwise C would be first,

2926
01:47:55,950 --> 01:47:56,470
and it's also.

2927
01:47:56,604 --> 01:47:58,225
Sorted numerically,

2928
01:47:58,435 --> 01:48:00,665
otherwise C would be second.

2929
01:48:00,915 --> 01:48:04,194
So it would be nice in Python to maybe exercise some control over this,

2930
01:48:04,234 --> 01:48:07,424
but I stopped short of doing that before because it gets very annoying quickly.

2931
01:48:07,595 --> 01:48:08,995
And by this I mean the following.

2932
01:48:09,075 --> 01:48:11,185
Let me go back into VS code here

2933
01:48:11,634 --> 01:48:13,185
and into favorites.ie.

2934
01:48:13,515 --> 01:48:15,424
And if I wanted to sort by

2935
01:48:15,955 --> 01:48:16,875
the counts here,

2936
01:48:16,955 --> 01:48:18,024
I could do this.

2937
01:48:18,634 --> 01:48:19,884
I could change my

2938
01:48:20,000 --> 01:48:24,430
Loop from iterating for favorite in counts to favorite in sorted counts.

2939
01:48:24,479 --> 01:48:26,549
So this is actually not too bad thus far.

2940
01:48:26,640 --> 01:48:28,759
I can actually sort dictionaries pretty readily.

2941
01:48:28,839 --> 01:48:29,990
So now if I run this,

2942
01:48:30,080 --> 01:48:33,669
and let me make my terminal a little bit taller so we can see both the results,

2943
01:48:33,830 --> 01:48:35,189
if I run the program now,

2944
01:48:35,399 --> 01:48:38,640
you'll see that it's sorted alphabetically by key.

2945
01:48:38,839 --> 01:48:42,990
So apparently when you use the sorted function in Python and pass it a dictionary.

2946
01:48:43,254 --> 01:48:46,095
Can still iterate over all of the key value pairs in that dictionary,

2947
01:48:46,165 --> 01:48:47,875
but it's been sorted now by key.

2948
01:48:48,285 --> 01:48:50,154
So that's nice if that's to be my goal,

2949
01:48:50,245 --> 01:48:51,805
but maybe that's not really my goal.

2950
01:48:51,884 --> 01:48:55,765
And here's how alternatively I could sort by value the 190,

2951
01:48:55,845 --> 01:48:56,365
the 58,

2952
01:48:56,404 --> 01:48:57,314
and the 24.

2953
01:48:57,444 --> 01:48:59,174
I can still use the sorted function,

2954
01:48:59,245 --> 01:48:59,595
but

2955
01:48:59,765 --> 01:49:01,884
I need to tell Python to use a key,

2956
01:49:01,924 --> 01:49:06,595
a sorting key of the counts dictionary's gets function,

2957
01:49:07,125 --> 01:49:08,975
and then if I run it again.

2958
01:49:09,490 --> 01:49:10,930
I now see it's sorted by value,

2959
01:49:10,970 --> 01:49:11,419
but darn it,

2960
01:49:11,430 --> 01:49:12,970
it's now sorted in the opposite order.

2961
01:49:13,049 --> 01:49:14,250
I see scratch at 24,

2962
01:49:14,330 --> 01:49:14,890
then 58,

2963
01:49:14,970 --> 01:49:15,529
then 190.

2964
01:49:15,589 --> 01:49:16,660
If I want to reverse it,

2965
01:49:16,890 --> 01:49:18,720
well then I have to go up here and add another

2966
01:49:19,060 --> 01:49:20,040
named parameter.

2967
01:49:20,250 --> 01:49:21,680
Reverse equals true.

2968
01:49:21,890 --> 01:49:24,850
I can run it another time and now I get the result.

2969
01:49:24,890 --> 01:49:25,089
I.

2970
01:49:25,839 --> 01:49:26,520
Long story short,

2971
01:49:26,600 --> 01:49:30,839
this is just very annoying to have to use that amount of code to actually

2972
01:49:30,839 --> 01:49:32,839
answer relatively simple questions and this is

2973
01:49:32,839 --> 01:49:34,750
why we did transition for much of today

2974
01:49:34,959 --> 01:49:37,439
to a declarative language like SQL that just let

2975
01:49:37,439 --> 01:49:40,129
me select what I care about in that data.

2976
01:49:40,240 --> 01:49:41,290
So if I again

2977
01:49:41,600 --> 01:49:45,220
I go back into my database version with SQLite 3 of favorites.

2978
01:49:45,399 --> 01:49:45,750
DB,

2979
01:49:45,839 --> 01:49:47,390
I'll maximize my terminal window.

2980
01:49:47,600 --> 01:49:48,709
What did we do before?

2981
01:49:48,970 --> 01:49:49,080
Well,

2982
01:49:49,160 --> 01:49:52,350
we can select uh from the database,

2983
01:49:53,000 --> 01:49:53,419
uh,

2984
01:49:53,430 --> 01:49:53,919
select.

2985
01:49:54,430 --> 01:49:55,339
Uh,

2986
01:49:55,790 --> 01:49:56,149
let's see,

2987
01:49:56,310 --> 01:49:56,939
favorite

2988
01:49:58,169 --> 01:50:01,140
com count star from favorites

2989
01:50:01,350 --> 01:50:02,649
group by,

2990
01:50:02,990 --> 01:50:03,490
uh,

2991
01:50:03,520 --> 01:50:04,700
favorite semicolon,

2992
01:50:04,709 --> 01:50:05,459
whoops

2993
01:50:07,390 --> 01:50:07,680
oh

2994
01:50:10,600 --> 01:50:10,640
it's fine.

2995
01:50:12,569 --> 01:50:12,979
Oh,

2996
01:50:13,020 --> 01:50:13,290
sorry.

2997
01:50:14,339 --> 01:50:14,970
What do we do?

2998
01:50:15,060 --> 01:50:19,700
We do select language com count star from favorites group by favorite.

2999
01:50:19,720 --> 01:50:20,649
Oh damn it,

3000
01:50:20,939 --> 01:50:21,569
what happened?

3001
01:50:21,859 --> 01:50:22,189
Oh,

3002
01:50:22,339 --> 01:50:23,299
we deleted it.

3003
01:50:24,160 --> 01:50:26,439
See this is why you don't use the delete or drop commands.

3004
01:50:26,520 --> 01:50:28,049
So I'm not going to demonstrate this again,

3005
01:50:28,120 --> 01:50:31,910
but recall before break that when we last selected this information,

3006
01:50:32,080 --> 01:50:35,859
we used the group by command to actually group by the language in question,

3007
01:50:35,879 --> 01:50:37,000
and we got back all the counts,

3008
01:50:37,040 --> 01:50:41,040
but then we were very easily able to reorder things by actually just using

3009
01:50:41,040 --> 01:50:42,660
order by and then doing something in

3010
01:50:42,660 --> 01:50:45,439
ascending order or for instance descending order.

3011
01:50:45,803 --> 01:50:45,812
Well,

3012
01:50:46,312 --> 01:50:48,982
now let's actually combine these worlds of Python

3013
01:50:48,982 --> 01:50:52,062
and SQL together to write first a program

3014
01:50:52,232 --> 01:50:52,942
that does

3015
01:50:53,152 --> 01:50:53,942
just that.

3016
01:50:53,993 --> 01:50:54,823
But to do this,

3017
01:50:54,902 --> 01:50:56,553
we're going to need to restore that database.

3018
01:50:56,632 --> 01:50:57,513
So let's go ahead and do this.

3019
01:50:57,672 --> 01:50:59,902
Let's remove favorites.db,

3020
01:50:59,993 --> 01:51:02,062
which is just a file in my account.

3021
01:51:02,232 --> 01:51:05,353
Let's go ahead and run SQLite 3

3022
01:51:05,723 --> 01:51:07,002
of favorites.db.

3023
01:51:07,275 --> 01:51:09,076
Create a new version thereof.

3024
01:51:09,505 --> 01:51:13,655
Let's now go ahead and change my mode as we did earlier in class to CSV.

3025
01:51:13,826 --> 01:51:19,335
Let's now do import of favorites.csv into a table called favorites,

3026
01:51:19,346 --> 01:51:20,895
and now let's do do quit.

3027
01:51:21,025 --> 01:51:22,215
And when I do LS,

3028
01:51:22,386 --> 01:51:22,585
OK,

3029
01:51:22,686 --> 01:51:23,255
now it's back,

3030
01:51:23,386 --> 01:51:25,976
favorites.db in addition to today's other files.

3031
01:51:26,226 --> 01:51:28,855
Now let me go ahead and run SQLite 3.

3032
01:51:29,459 --> 01:51:34,540
Of favorites.db and just as a sanity check select star from favorites semicolon,

3033
01:51:34,700 --> 01:51:36,700
there's all of the data back minus the

3034
01:51:36,700 --> 01:51:39,740
addition and subtraction that we ourselves made earlier manually

3035
01:51:40,060 --> 01:51:44,569
and let's go ahead and in SQL go ahead and do select language

3036
01:51:45,660 --> 01:51:46,649
count star

3037
01:51:47,189 --> 01:51:48,779
from favorites.

3038
01:51:49,589 --> 01:51:51,390
And group by

3039
01:51:51,720 --> 01:51:52,589
language,

3040
01:51:53,279 --> 01:51:55,069
but let's order by

3041
01:51:55,640 --> 01:51:57,950
count in descending order,

3042
01:51:57,990 --> 01:51:59,919
and that's one of the last commands we ran with this

3043
01:51:59,919 --> 01:52:02,509
file and there's the answer in a single line of code

3044
01:52:02,979 --> 01:52:07,290
instead of some 17 lines of code plus or minus some white space here.

3045
01:52:07,520 --> 01:52:09,149
Can we merge now these two ideas?

3046
01:52:09,200 --> 01:52:09,279
Well,

3047
01:52:09,359 --> 01:52:10,470
let's see how to do this.

3048
01:52:10,680 --> 01:52:12,640
Let's go back into favorites.

3049
01:52:13,174 --> 01:52:15,084
here and make a new and improved version of

3050
01:52:15,084 --> 01:52:17,645
it that actually uses SQL and no dictionary,

3051
01:52:17,734 --> 01:52:18,415
no for loop,

3052
01:52:18,535 --> 01:52:20,165
no try accept or any of this.

3053
01:52:20,274 --> 01:52:20,884
Instead,

3054
01:52:21,134 --> 01:52:23,524
let's go ahead and from CS 50's own library,

3055
01:52:23,774 --> 01:52:27,685
import a SQL function which will give me access to this functionality.

3056
01:52:27,935 --> 01:52:30,174
Let's create a variable called DB by convention,

3057
01:52:30,214 --> 01:52:32,104
but I could call it anything I want and set it

3058
01:52:32,104 --> 01:52:36,455
equal to CS50 SQL function and pass to CS50 SQL function.

3059
01:52:36,669 --> 01:52:39,450
The path to the database file I want to open.

3060
01:52:39,569 --> 01:52:40,319
This is a little weird,

3061
01:52:40,410 --> 01:52:43,759
but the syntax here is SQL Light without the 3,

3062
01:52:44,129 --> 01:52:46,600
colon slash slash slash

3063
01:52:47,209 --> 01:52:47,810
favorites.

3064
01:52:50,569 --> 01:52:51,450
This syntax,

3065
01:52:51,569 --> 01:52:52,919
otherwise known as URI,

3066
01:52:52,930 --> 01:53:01,129
is going to allow us to use the SQL light uh protocol in order to open up favorites.db,

3067
01:53:01,209 --> 01:53:04,799
which is the very file I was just experimenting with manually in my terminal.

3068
01:53:05,109 --> 01:53:10,290
Here now is how I can execute a SQL query in Python using CS 50's library.

3069
01:53:10,330 --> 01:53:10,439
Now,

3070
01:53:10,450 --> 01:53:10,910
as an aside,

3071
01:53:11,009 --> 01:53:13,359
even though this is indeed meant to be a training wheel,

3072
01:53:13,770 --> 01:53:16,649
CS 50's library is just easier to use than a lot of the.

3073
01:53:16,774 --> 01:53:18,515
World libraries that makes this possible.

3074
01:53:18,604 --> 01:53:20,915
So because we spend so relatively little time on this,

3075
01:53:21,084 --> 01:53:23,245
we're still using this training wheel for this.

3076
01:53:23,564 --> 01:53:26,325
Give me a variable called rows because I want to get back all

3077
01:53:26,325 --> 01:53:31,214
of the rows from this table that contain those languages and db.

3078
01:53:31,604 --> 01:53:32,274
execute.

3079
01:53:32,524 --> 01:53:36,125
The only function that's useful in the CS 50 library for SQL is this execute

3080
01:53:36,125 --> 01:53:41,384
function which allows me to write literally a line of SQL like select language,

3081
01:53:41,725 --> 01:53:42,154
count,

3082
01:53:42,444 --> 01:53:42,955
star.

3083
01:53:43,529 --> 01:53:43,879
Uh,

3084
01:53:43,970 --> 01:53:45,370
from favorites,

3085
01:53:45,529 --> 01:53:47,339
group by language,

3086
01:53:47,450 --> 01:53:49,069
order by count,

3087
01:53:49,370 --> 01:53:49,950
star.

3088
01:53:50,410 --> 01:53:50,640
Uh,

3089
01:53:50,850 --> 01:53:51,879
descending order

3090
01:53:52,209 --> 01:53:53,450
just to make my life easier,

3091
01:53:53,529 --> 01:53:55,919
I'm going to add that alias trick that we saw before.

3092
01:53:55,970 --> 01:53:59,240
So as N to change the count to the variable n,

3093
01:53:59,290 --> 01:54:02,020
and then here I can just do order by N instead.

3094
01:54:02,149 --> 01:54:03,080
It's a little long,

3095
01:54:03,169 --> 01:54:07,120
but notice that now I'm using SQL as a string

3096
01:54:07,410 --> 01:54:11,240
that I'm passing as an argument to this DB execute

3097
01:54:11,529 --> 01:54:12,120
function.

3098
01:54:12,330 --> 01:54:15,680
So at the very end of this I've got to close my quote,

3099
01:54:15,970 --> 01:54:17,279
close my parenthesis

3100
01:54:17,609 --> 01:54:18,549
so as to use.

3101
01:54:18,604 --> 01:54:21,305
One language in effect inside of another.

3102
01:54:21,595 --> 01:54:24,134
Now assuming I do get back at temporary tables,

3103
01:54:24,145 --> 01:54:26,395
rows with that line of code on line 5,

3104
01:54:26,444 --> 01:54:29,674
let's do this for each row in rows,

3105
01:54:29,754 --> 01:54:32,785
go ahead and do the following create a variable

3106
01:54:33,194 --> 01:54:35,225
called language and set it equal to row,

3107
01:54:35,475 --> 01:54:36,984
quote unquote language.

3108
01:54:37,274 --> 01:54:41,064
Then create another variable called N for instance and set it equal to row,

3109
01:54:41,475 --> 01:54:42,245
unquote N.

3110
01:54:42,555 --> 01:54:46,754
and then let's just go ahead and print out language and N respectively.

3111
01:54:47,040 --> 01:54:49,109
So what does CS 50's library do?

3112
01:54:49,270 --> 01:54:53,310
It returns by design a list of rows.

3113
01:54:53,509 --> 01:54:57,870
Each of those rows is a dictionary of key value pairs.

3114
01:54:57,990 --> 01:54:59,589
So when I do 4 row and rows,

3115
01:54:59,669 --> 01:55:02,209
this is just iterating over a list of values,

3116
01:55:02,220 --> 01:55:04,580
and we've done that over the past couple of weeks.

3117
01:55:04,910 --> 01:55:06,029
Inside of this loop,

3118
01:55:06,109 --> 01:55:08,189
I'm just creating temporarily two variables,

3119
01:55:08,709 --> 01:55:09,580
language and N,

3120
01:55:09,870 --> 01:55:10,629
to show you that.

3121
01:55:10,750 --> 01:55:12,290
Each row is indeed a dictionary,

3122
01:55:12,379 --> 01:55:16,370
which means I can index into it using strings like quote unquote language

3123
01:55:16,580 --> 01:55:17,839
and quote unquote n

3124
01:55:18,299 --> 01:55:18,689
because

3125
01:55:19,020 --> 01:55:23,009
those are the columns that I selected using this query up above.

3126
01:55:23,259 --> 01:55:23,890
Strictly speaking,

3127
01:55:23,939 --> 01:55:25,180
I don't even need these variables.

3128
01:55:25,259 --> 01:55:26,490
I can just get rid of that

3129
01:55:26,700 --> 01:55:30,490
and a little more succinctly just pass in row bracket language

3130
01:55:30,740 --> 01:55:34,339
and then row bracket N instead.

3131
01:55:34,689 --> 01:55:36,729
So let me go down to my terminal window here,

3132
01:55:36,939 --> 01:55:38,330
exit out of SQL light,

3133
01:55:38,660 --> 01:55:41,580
run Python of favorites.pi in this form,

3134
01:55:41,640 --> 01:55:42,209
enter,

3135
01:55:42,500 --> 01:55:43,370
and I get back,

3136
01:55:43,439 --> 01:55:44,220
it would seem.

3137
01:55:46,879 --> 01:55:48,470
The same exact answer,

3138
01:55:48,479 --> 01:55:49,200
190,

3139
01:55:49,310 --> 01:55:52,589
58 and 24 in this case.

3140
01:55:53,040 --> 01:55:55,200
Questions now on this co mingling.

3141
01:55:56,339 --> 01:55:57,549
Of languages

3142
01:55:59,330 --> 01:55:59,470
All right,

3143
01:56:00,060 --> 01:56:01,479
how about one final thing.

3144
01:56:01,609 --> 01:56:03,240
Once we have the ability to like use Python,

3145
01:56:03,290 --> 01:56:05,009
now we can in fact make things interactive.

3146
01:56:05,049 --> 01:56:05,529
So for instance,

3147
01:56:05,609 --> 01:56:07,319
let me close my terminal temporarily.

3148
01:56:07,649 --> 01:56:09,979
Let me go ahead and now ask for some user input.

3149
01:56:10,049 --> 01:56:11,209
So after opening the database,

3150
01:56:11,250 --> 01:56:11,839
let's do this.

3151
01:56:12,009 --> 01:56:14,359
Let's ask the human using Python's input function,

3152
01:56:14,410 --> 01:56:17,569
or equivalently CS 50s get string function for their favorite TV.

3153
01:56:17,850 --> 01:56:19,810
Show and store it in that same variable.

3154
01:56:20,069 --> 01:56:24,350
Then let's do a SQL query that selects that data rows equals db.

3155
01:56:24,589 --> 01:56:25,310
execute.

3156
01:56:25,709 --> 01:56:29,390
Select and let's see how many people selected

3157
01:56:29,390 --> 01:56:31,459
this favorite problem rather not TV show.

3158
01:56:31,629 --> 01:56:33,859
How about favorite problem from our favorites data set.

3159
01:56:34,069 --> 01:56:39,910
So select count star as N from the favorites database

3160
01:56:40,270 --> 01:56:43,069
where the problem in question equals.

3161
01:56:43,390 --> 01:56:43,609
Well,

3162
01:56:43,649 --> 01:56:46,290
now I need to put the user's inputs.

3163
01:56:46,410 --> 01:56:48,689
I don't know what that is yet because they haven't typed it in yet,

3164
01:56:48,770 --> 01:56:50,919
so what I'm going to go ahead and do is

3165
01:56:51,169 --> 01:56:52,359
a placeholder

3166
01:56:52,649 --> 01:56:54,120
and say favorite,

3167
01:56:54,370 --> 01:56:55,000
close quote,

3168
01:56:55,009 --> 01:56:57,279
and make this whole thing an F string.

3169
01:56:57,609 --> 01:56:59,490
Then I'm going to go down here and I don't need

3170
01:56:59,490 --> 01:57:01,950
to iterate because ideally I'm just getting back a single answer.

3171
01:57:02,049 --> 01:57:04,879
How many people chose this problem as their favorite?

3172
01:57:05,049 --> 01:57:06,100
So I'm going to say.

3173
01:57:06,629 --> 01:57:08,859
That the row I care about

3174
01:57:09,029 --> 01:57:10,419
is simply the first row.

3175
01:57:10,669 --> 01:57:12,180
So rows is a list,

3176
01:57:12,370 --> 01:57:15,779
so rows 0 is the first and only row in that list,

3177
01:57:15,959 --> 01:57:18,390
and then let's go ahead and print out row N.

3178
01:57:20,350 --> 01:57:22,740
Let's see the results here and then

3179
01:57:23,390 --> 01:57:25,140
see what happens.

3180
01:57:25,229 --> 01:57:26,819
Let me put some single quotes here

3181
01:57:27,189 --> 01:57:28,620
and single quotes here.

3182
01:57:28,830 --> 01:57:30,220
Let me open my terminal.

3183
01:57:30,549 --> 01:57:32,750
Let me do Python of favorites.ie.

3184
01:57:33,379 --> 01:57:35,189
And I'll say hello

3185
01:57:35,720 --> 01:57:37,120
world enter

3186
01:57:37,509 --> 01:57:39,149
and as before at the start of class,

3187
01:57:39,270 --> 01:57:41,100
42 of you like that.

3188
01:57:41,390 --> 01:57:41,790
However,

3189
01:57:41,950 --> 01:57:42,899
this is not,

3190
01:57:42,910 --> 01:57:43,359
not,

3191
01:57:43,370 --> 01:57:46,879
not how you should ever write SQL code in Python.

3192
01:57:47,310 --> 01:57:49,620
What could go wrong with this code?

3193
01:57:51,319 --> 01:57:52,720
Nothing went wrong a moment ago,

3194
01:57:52,799 --> 01:57:53,910
but what could go wrong?

3195
01:57:55,560 --> 01:57:55,950
Yeah.

3196
01:57:56,959 --> 01:57:57,770
The user input,

3197
01:57:57,850 --> 01:57:58,439
how so?

3198
01:58:00,029 --> 01:58:00,649
Injection

3199
01:58:02,649 --> 01:58:02,890
True,

3200
01:58:02,930 --> 01:58:03,879
I don't know what those are yet,

3201
01:58:03,890 --> 01:58:05,040
but we're about to go there.

3202
01:58:05,609 --> 01:58:07,839
What even more simplistically could go wrong

3203
01:58:08,290 --> 01:58:09,200
by plugging in

3204
01:58:09,410 --> 01:58:10,729
the user's input here?

3205
01:58:11,629 --> 01:58:12,299
Yeah.

3206
01:58:16,129 --> 01:58:16,509
Exactly.

3207
01:58:16,560 --> 01:58:18,609
If I inputted the other problem we played with hello,

3208
01:58:19,149 --> 01:58:19,870
it's me,

3209
01:58:19,950 --> 01:58:21,930
where it was IT apostrophe S,

3210
01:58:22,270 --> 01:58:26,430
that if interpolated right here is clearly going to confuse the

3211
01:58:26,430 --> 01:58:29,379
single quotes such that who knows what's going to come back.

3212
01:58:29,430 --> 01:58:31,140
Now in the best case,

3213
01:58:31,229 --> 01:58:34,180
the code might just not work and I'll get some kind of error on the screen,

3214
01:58:34,229 --> 01:58:36,750
which is not great for the user because the program's not going to be useful.

3215
01:58:36,790 --> 01:58:38,220
There's no user friendly error message,

3216
01:58:38,430 --> 01:58:39,810
but in the worst case,

3217
01:58:39,990 --> 01:58:43,520
the user could do something incredibly malicious if

3218
01:58:43,790 --> 01:58:44,950
you are simply blind.

3219
01:58:45,290 --> 01:58:48,899
Blindly trusting user input and plugging their input

3220
01:58:48,899 --> 01:58:51,299
into a SQL query that you yourself constructed.

3221
01:58:51,390 --> 01:58:51,819
Why?

3222
01:58:52,109 --> 01:58:58,910
What if the user types something crazy like the word delete or drop or update or any of

3223
01:58:58,910 --> 01:59:01,759
those destructive commands that we saw earlier and somehow

3224
01:59:01,759 --> 01:59:05,459
tricks your code into executing maybe the select,

3225
01:59:05,470 --> 01:59:06,459
but then eventually

3226
01:59:06,709 --> 01:59:09,140
an additional query like a delete.

3227
01:59:09,290 --> 01:59:11,430
Maybe they type in a semicolon and then delete or

3228
01:59:11,430 --> 01:59:13,620
a semicolon and then drop or something like that.

3229
01:59:13,830 --> 01:59:14,029
This is.

3230
01:59:14,120 --> 01:59:20,310
The biggest threat to taking user input and trusting it in the context of databases,

3231
01:59:20,350 --> 01:59:21,700
and it's called,

3232
01:59:22,029 --> 01:59:24,140
as one of your classmates knows already,

3233
01:59:24,430 --> 01:59:27,660
what's known as a SQL injection attack.

3234
01:59:27,910 --> 01:59:29,669
A SQL injection attack

3235
01:59:30,029 --> 01:59:33,209
is the ability for an adversary or an unknowing

3236
01:59:33,209 --> 01:59:36,819
user to somehow inject code into your database.

3237
01:59:37,149 --> 01:59:40,709
A SQL injection attack then might look something like this in the real world.

3238
01:59:40,790 --> 01:59:41,680
Here for instance

3239
01:59:42,109 --> 01:59:43,109
is like the login screen.

3240
01:59:43,200 --> 01:59:44,379
To GitHub.com,

3241
01:59:44,790 --> 01:59:47,390
they do actually use SQL among other languages underneath the hood,

3242
01:59:47,430 --> 01:59:47,979
I believe,

3243
01:59:48,109 --> 01:59:49,100
not necessarily for this,

3244
01:59:49,109 --> 01:59:50,100
but suppose they did.

3245
01:59:50,350 --> 01:59:52,479
And when logging into GitHub.com,

3246
01:59:52,509 --> 01:59:54,229
you're prompted for your username or email address,

3247
01:59:54,240 --> 01:59:55,580
and then of course your password.

3248
01:59:55,790 --> 01:59:55,910
Well,

3249
01:59:56,009 --> 01:59:58,609
what if I know a little something about SQL and suppose

3250
01:59:58,609 --> 02:00:00,790
for the sake of discussion GitHub is using SQL L Lite,

3251
02:00:00,830 --> 02:00:03,779
which they're not using because it's not meant for massive,

3252
02:00:03,990 --> 02:00:05,979
large massive data sets like this,

3253
02:00:06,310 --> 02:00:07,339
but suppose they are,

3254
02:00:07,549 --> 02:00:09,419
and just to be malicious,

3255
02:00:09,629 --> 02:00:12,029
I type in my username maillin at harbor.edu.

3256
02:00:12,580 --> 02:00:15,399
But then I use a single quote and then da da.

3257
02:00:15,879 --> 02:00:15,959
Well,

3258
02:00:16,009 --> 02:00:17,149
the single quote is there,

3259
02:00:17,240 --> 02:00:18,720
me being an adversary in the story,

3260
02:00:18,839 --> 02:00:21,229
because maybe I can confuse their code by

3261
02:00:21,229 --> 02:00:24,029
closing their quotes sooner than they intended,

3262
02:00:24,120 --> 02:00:25,240
and we haven't talked about this yet,

3263
02:00:25,479 --> 02:00:28,390
but it turns out that in SQL is the comment character.

3264
02:00:28,470 --> 02:00:31,979
So it's like hash in Python or slash slash C.

3265
02:00:32,240 --> 02:00:34,720
This in SQL means ignore everything to the right.

3266
02:00:35,189 --> 02:00:38,790
That alone can be used fairly maliciously as follows.

3267
02:00:38,990 --> 02:00:39,220
Here,

3268
02:00:39,270 --> 02:00:39,919
for instance,

3269
02:00:39,990 --> 02:00:43,020
could be the code that GitHub is using underneath the hood,

3270
02:00:43,270 --> 02:00:43,939
whereby

3271
02:00:44,390 --> 02:00:45,540
they might have some Python code,

3272
02:00:45,549 --> 02:00:45,830
and heck,

3273
02:00:45,870 --> 02:00:47,459
maybe they're using the CS 50 library

3274
02:00:47,629 --> 02:00:49,740
that executes this pre-made query.

3275
02:00:49,950 --> 02:00:53,509
Select star from the user's table where the username equals

3276
02:00:53,509 --> 02:00:56,660
this question mark and the password equals this question mark,

3277
02:00:56,870 --> 02:00:58,560
passing in username and password,

3278
02:00:58,629 --> 02:00:59,310
for instance.

3279
02:00:59,819 --> 02:01:00,109
Uh,

3280
02:01:00,259 --> 02:01:00,759
but

3281
02:01:01,020 --> 02:01:03,540
if they are trusting the username and password I

3282
02:01:03,540 --> 02:01:05,810
typed in and just plugging it right there,

3283
02:01:06,220 --> 02:01:08,819
they could be vulnerable to indeed a SQL injection attack.

3284
02:01:08,899 --> 02:01:09,419
For instance,

3285
02:01:09,540 --> 02:01:12,169
this code we'll soon see is actually the right way to do it.

3286
02:01:12,379 --> 02:01:13,750
But suppose they were doing it

3287
02:01:14,060 --> 02:01:17,799
with F strings like I started to in my version of favorites.ie.

3288
02:01:18,060 --> 02:01:18,379
Same thing,

3289
02:01:18,459 --> 02:01:20,500
select start from users where username equals

3290
02:01:20,500 --> 02:01:23,529
this username and password equals this password,

3291
02:01:23,660 --> 02:01:26,149
and the little F here means here's a format string.

3292
02:01:26,379 --> 02:01:27,129
What could go wrong?

3293
02:01:27,220 --> 02:01:27,310
Well,

3294
02:01:27,339 --> 02:01:27,970
let me actually.

3295
02:01:28,174 --> 02:01:33,495
Paste in the mail at harvard.edu single text here.

3296
02:01:33,745 --> 02:01:36,024
Notice that this single quote and this single quote are meant

3297
02:01:36,024 --> 02:01:39,095
to surround the username and same thing for the password there.

3298
02:01:39,265 --> 02:01:43,785
But watch what happens when I type in my data maillin at harvard.edu single quote.

3299
02:01:43,984 --> 02:01:46,975
So this would seem to finish the thought prematurely,

3300
02:01:47,245 --> 02:01:48,095
and then it says,

3301
02:01:49,064 --> 02:01:51,294
and so that just means ignore everything else.

3302
02:01:51,464 --> 02:01:53,944
And so the effect here is essentially to gray out

3303
02:01:53,944 --> 02:01:56,504
all of that stuff because it's effectively been commented out.

3304
02:01:56,680 --> 02:02:00,270
So what GitHub ends up doing accidentally in this case is selecting star

3305
02:02:00,270 --> 02:02:03,470
from users where username is mailen@harvard.edu irrespective

3306
02:02:03,470 --> 02:02:05,540
of what his password actually is.

3307
02:02:05,709 --> 02:02:09,029
And if you assume that down here they've got some conditional logic like,

3308
02:02:09,109 --> 02:02:09,189
well,

3309
02:02:09,270 --> 02:02:10,470
if we get back some rows,

3310
02:02:10,509 --> 02:02:13,379
that means that Malin is in fact a registered user,

3311
02:02:13,709 --> 02:02:15,040
go ahead and log him in.

3312
02:02:15,390 --> 02:02:16,470
We don't know what the code looks like,

3313
02:02:16,509 --> 02:02:20,430
so it's you've just enabled anyone on the internet to log in as

3314
02:02:20,430 --> 02:02:25,109
me or anyone else just by suffixing their input with a single quote.

3315
02:02:25,205 --> 02:02:28,234
And and that's the least of our concerns.

3316
02:02:28,314 --> 02:02:29,995
If we additionally went in there and maybe

3317
02:02:29,995 --> 02:02:32,944
instead of we put a semicolon and then delete

3318
02:02:33,194 --> 02:02:34,944
from users or drop users,

3319
02:02:34,995 --> 02:02:37,225
we could cause massive havoc on their database.

3320
02:02:37,395 --> 02:02:38,785
This happens all the time,

3321
02:02:38,834 --> 02:02:40,774
even now in the current year,

3322
02:02:40,915 --> 02:02:43,395
you can Google around and see examples of companies

3323
02:02:43,395 --> 02:02:47,104
that have not used proper sanitization of user input,

3324
02:02:47,154 --> 02:02:48,165
and it's not just the intern,

3325
02:02:48,194 --> 02:02:50,064
it's like random people on the internet

3326
02:02:50,064 --> 02:02:53,555
are accessing or destroying their data maliciously.

3327
02:02:53,910 --> 02:02:56,500
So what is the solution to a problem like this?

3328
02:02:56,540 --> 02:02:56,890
Well,

3329
02:02:57,240 --> 02:02:57,580
one,

3330
02:02:57,819 --> 02:03:01,470
do not use format strings in Python to simply plug in user input.

3331
02:03:01,500 --> 02:03:03,290
But the more important lesson is

3332
02:03:03,700 --> 02:03:05,830
never trust users' input.

3333
02:03:05,979 --> 02:03:07,890
Either they're going to do something accidentally

3334
02:03:07,890 --> 02:03:09,660
or they're going to do something maliciously,

3335
02:03:09,700 --> 02:03:11,129
and you do not want that to happen.

3336
02:03:11,259 --> 02:03:13,770
So the solution then is to use a library,

3337
02:03:14,189 --> 02:03:15,259
almost always use a library.

3338
02:03:15,299 --> 02:03:17,209
This is not a wheel you should reinvent yourself,

3339
02:03:17,259 --> 02:03:19,370
and by library I mean something like this.

3340
02:03:19,660 --> 02:03:20,549
If you instead.

3341
02:03:20,879 --> 02:03:24,609
Use a library like CS 50s and you don't just use F strings,

3342
02:03:24,680 --> 02:03:26,729
you'll see in a moment you use question marks.

3343
02:03:26,839 --> 02:03:28,120
What will happen is this

3344
02:03:28,479 --> 02:03:32,790
when the user goes and types in mail in at Harvard.edu single quote that's fine.

3345
02:03:32,959 --> 02:03:36,160
Let them put weird scary characters like single quotes in their input.

3346
02:03:36,589 --> 02:03:40,540
The library will take charge of escaping user input,

3347
02:03:40,669 --> 02:03:43,830
so anything dangerous in their input will be changed from

3348
02:03:43,830 --> 02:03:46,399
one single quote to two because we saw earlier today that

3349
02:03:46,509 --> 02:03:48,180
that's how you escape a character,

3350
02:03:48,350 --> 02:03:50,910
and that means that now what you have is

3351
02:03:50,910 --> 02:03:55,500
an effect my username is apparently Malin@harvard.edu apostrophe,

3352
02:03:56,259 --> 02:03:57,379
and that's my username.

3353
02:03:57,589 --> 02:03:57,629
Well,

3354
02:03:57,709 --> 02:03:59,299
that's obviously not a real email address.

3355
02:03:59,350 --> 02:04:00,350
It's not a real username.

3356
02:04:00,475 --> 02:04:02,294
This is just going to return false.

3357
02:04:02,384 --> 02:04:04,375
No rows are actually going to come back.

3358
02:04:04,584 --> 02:04:09,734
And the way to do this now in our favorites example analogously is in VS code here

3359
02:04:10,145 --> 02:04:13,865
to actually go up into this execute line,

3360
02:04:14,104 --> 02:04:15,415
don't use an F string,

3361
02:04:15,825 --> 02:04:19,654
change the value of problem to be a placeholder instead,

3362
02:04:19,915 --> 02:04:22,015
and then pass into

3363
02:04:22,384 --> 02:04:22,964
this

3364
02:04:23,265 --> 02:04:24,305
execute function.

3365
02:04:24,870 --> 02:04:28,470
One or more arguments that will be substituted in for that

3366
02:04:28,470 --> 02:04:30,189
question mark and this is not a CS 50 thing,

3367
02:04:30,200 --> 02:04:32,790
this is a uh industry convention whereby

3368
02:04:32,790 --> 02:04:35,220
you quite often use literally a question mark

3369
02:04:35,540 --> 02:04:39,390
and that means that whatever this variable's value is will get plugged.

3370
02:04:39,524 --> 02:04:41,185
Into that question mark for you,

3371
02:04:41,194 --> 02:04:42,794
but the single quotes will be added.

3372
02:04:42,854 --> 02:04:45,185
Any dangerous characters will be escaped for you,

3373
02:04:45,395 --> 02:04:48,544
and at that point you can trust that the user can type in anything they want.

3374
02:04:48,555 --> 02:04:51,024
Your code is not going to break.

3375
02:04:51,154 --> 02:04:54,395
You can see hints of this actually in the real world if you've ever gone to a website.

3376
02:04:54,689 --> 02:04:58,109
And they tell you like oh you can't like for passwords for instance,

3377
02:04:58,189 --> 02:05:01,020
like all of us probably intuitively know that you should have pretty long

3378
02:05:01,310 --> 02:05:05,830
uh hard to guess passwords with letters and numbers and punctuation symbols

3379
02:05:05,830 --> 02:05:08,830
sometimes websites very stupidly prohibit you

3380
02:05:08,830 --> 02:05:11,149
from using certain punctuation symbols,

3381
02:05:11,229 --> 02:05:14,149
which should drive you nuts because there's no computational reason that you have

3382
02:05:14,149 --> 02:05:16,979
to put the onus on the user to sanitize their own input,

3383
02:05:17,060 --> 02:05:19,229
but quite likely those websites have kind of learned.

3384
02:05:19,314 --> 02:05:20,424
Part of this lesson,

3385
02:05:20,435 --> 02:05:22,705
and they know some characters can be dangerous in

3386
02:05:22,705 --> 02:05:25,814
sequel like semicolons or single quotes or the like,

3387
02:05:26,145 --> 02:05:28,024
and they just don't want you to ever type those

3388
02:05:28,024 --> 02:05:30,495
in even though there are solutions to this problem.

3389
02:05:30,705 --> 02:05:35,185
Use a library that someone else smarter than you with more

3390
02:05:35,185 --> 02:05:37,825
history of writing code than you has used that's open source so

3391
02:05:37,825 --> 02:05:39,865
that many people have seen it and banged on it over the

3392
02:05:39,865 --> 02:05:43,935
years so that this problem is not something you're vulnerable to.

3393
02:05:45,694 --> 02:05:48,904
Questions then on what these here SQL injection attacks.

3394
02:05:50,500 --> 02:05:51,410
Are all about,

3395
02:05:53,959 --> 02:05:53,970
yeah.

3396
02:05:55,189 --> 02:05:58,589
also telling them what you're using and so maybe that.

3397
02:05:59,689 --> 02:06:00,240
Good point.

3398
02:06:00,370 --> 02:06:03,759
So if by also telling people what characters they shouldn't use,

3399
02:06:03,770 --> 02:06:06,490
you're leaking information because a smart adversary might know,

3400
02:06:06,609 --> 02:06:06,879
oh well,

3401
02:06:06,899 --> 02:06:08,049
if they don't want me using that symbol,

3402
02:06:08,089 --> 02:06:09,930
they're probably using this language or this technology.

3403
02:06:10,089 --> 02:06:10,240
Yes,

3404
02:06:10,370 --> 02:06:13,720
no good comes from telling the world more information than they need to know.

3405
02:06:13,850 --> 02:06:15,720
So that's another good paranoia to have.

3406
02:06:16,189 --> 02:06:20,229
How about one other issue before we come full circle to the SQL injection attacks.

3407
02:06:20,390 --> 02:06:24,220
There's another challenge with relational databases and with SQL uh itself,

3408
02:06:24,430 --> 02:06:25,629
namely race conditions.

3409
02:06:25,750 --> 02:06:27,620
This isn't so much a problem when I'm writing a,

3410
02:06:27,629 --> 02:06:29,819
a little program here on my own computer.

3411
02:06:30,299 --> 02:06:30,310
Uh,

3412
02:06:31,129 --> 02:06:35,180
but when you're running SQL code on a database in the real world in the

3413
02:06:35,180 --> 02:06:37,810
cloud where you have many different servers talking

3414
02:06:37,810 --> 02:06:39,759
to that database and many different users,

3415
02:06:40,089 --> 02:06:40,500
uh,

3416
02:06:40,529 --> 02:06:41,810
talking to those web servers,

3417
02:06:41,850 --> 02:06:43,330
as is going to be the case at Meta and

3418
02:06:43,330 --> 02:06:46,850
Google and Microsoft and any number of popular companies nowadays,

3419
02:06:46,859 --> 02:06:50,439
and even some of CS 50 zone apps uses centralized SQL databases

3420
02:06:50,689 --> 02:06:53,970
where if multiple people are trying to do the same thing on them at the same time,

3421
02:06:54,089 --> 02:06:54,770
submit their homework,

3422
02:06:54,850 --> 02:06:55,569
run Check 50,

3423
02:06:55,850 --> 02:06:57,490
we too are vulnerable to what are called.

3424
02:06:57,790 --> 02:06:58,560
Race conditions.

3425
02:06:58,680 --> 02:06:59,640
So what is a race condition?

3426
02:06:59,680 --> 02:06:59,770
Well,

3427
02:06:59,799 --> 02:07:01,160
the way I learned this back in the day when

3428
02:07:01,160 --> 02:07:04,830
taking a course on databases and operating systems more generally

3429
02:07:05,120 --> 02:07:06,870
was to think of a scenario like this.

3430
02:07:06,959 --> 02:07:09,479
Maybe in your dorm you and your roommates have a little dorm fridge

3431
02:07:09,479 --> 02:07:11,830
and you're both in the habit of really liking to drink milk,

3432
02:07:11,879 --> 02:07:13,149
as the story was told to us.

3433
02:07:13,279 --> 02:07:17,029
And so maybe one of you comes home from class one day and you get to your room,

3434
02:07:17,200 --> 02:07:17,799
look in the fridge,

3435
02:07:17,879 --> 02:07:18,790
there's no milk in there,

3436
02:07:18,839 --> 02:07:22,430
and so you decide to walk across the street to CVS or some other store to get milk.

3437
02:07:22,720 --> 02:07:23,160
Meanwhile,

3438
02:07:23,279 --> 02:07:24,879
your roommate comes home from there.

3439
02:07:25,000 --> 02:07:26,589
Class and opens the fridge and it's like,

3440
02:07:26,600 --> 02:07:26,939
oh,

3441
02:07:27,109 --> 02:07:27,720
we're out of milk.

3442
02:07:27,790 --> 02:07:29,060
Let me go to the store too.

3443
02:07:29,069 --> 02:07:31,990
And for the sake of the story they go to a different store altogether

3444
02:07:31,990 --> 02:07:34,459
so that you don't run into each other and the problem solves itself.

3445
02:07:34,669 --> 02:07:37,060
So now both of you are on your way to a store to get milk.

3446
02:07:37,310 --> 02:07:37,870
Time passes,

3447
02:07:37,910 --> 02:07:38,790
you both come home,

3448
02:07:38,870 --> 02:07:40,580
one of you puts a jug of milk in the fridge,

3449
02:07:40,620 --> 02:07:41,709
the other one gets home and it's like,

3450
02:07:41,939 --> 02:07:42,350
Oh damn it,

3451
02:07:42,390 --> 02:07:43,819
like we already got milk.

3452
02:07:44,250 --> 02:07:45,819
I can't fit this milk in the fridge,

3453
02:07:45,870 --> 02:07:46,750
or now it's too much milk.

3454
02:07:46,790 --> 02:07:47,790
We don't really like milk this much.

3455
02:07:47,870 --> 02:07:48,660
It's gonna go bad.

3456
02:07:48,870 --> 02:07:50,069
Like a very bad outcome here,

3457
02:07:50,109 --> 02:07:52,220
having too much milk is the moral of the story.

3458
02:07:52,700 --> 02:07:54,310
But what's the

3459
02:07:55,479 --> 02:07:56,229
stupid story.

3460
02:07:56,419 --> 02:07:57,310
What's the,

3461
02:07:57,959 --> 02:07:59,240
what's the real takeaway?

3462
02:07:59,399 --> 02:08:03,189
Why did we find ourselves in a situation where we ended up with too milk,

3463
02:08:03,439 --> 02:08:04,200
too much milk?

3464
02:08:05,240 --> 02:08:05,850
You know what the other

3465
02:08:06,620 --> 02:08:08,500
We didn't know what the other person was doing,

3466
02:08:08,540 --> 02:08:09,970
and to really geek out on this,

3467
02:08:10,140 --> 02:08:12,770
we inspected the state of a variable that was

3468
02:08:12,770 --> 02:08:16,129
in the process of being updated by someone else.

3469
02:08:16,259 --> 02:08:18,459
And this is a thing in computing as far back as scratch.

3470
02:08:18,500 --> 02:08:19,220
Recall with scratch,

3471
02:08:19,259 --> 02:08:21,459
you could have multiple scripts running at the same time

3472
02:08:21,459 --> 02:08:24,600
for a single sprite because Scratch in effect is multi-threaded.

3473
02:08:24,660 --> 02:08:27,540
You can have a single sprite doing multiple.

3474
02:08:27,660 --> 02:08:30,089
Things in parallel by having those multiple scripts.

3475
02:08:30,290 --> 02:08:31,000
Similarly here,

3476
02:08:31,060 --> 02:08:34,609
your room is sort of multi-threaded because you have two independent beings who

3477
02:08:34,609 --> 02:08:37,299
can both go to the store to solve the same problem in parallel.

3478
02:08:37,490 --> 02:08:39,270
The problem though is that if one is not

3479
02:08:39,270 --> 02:08:41,319
aware that the other is doing that work already,

3480
02:08:41,490 --> 02:08:42,620
you might make poor decisions.

3481
02:08:42,729 --> 02:08:43,410
So in the real world,

3482
02:08:43,490 --> 02:08:45,490
what should the first roommate have done after

3483
02:08:45,490 --> 02:08:47,560
inspecting the state of the refrigerator and realizing,

3484
02:08:47,669 --> 02:08:47,759
oh,

3485
02:08:47,810 --> 02:08:48,689
we're out of milk.

3486
02:08:49,560 --> 02:08:49,879
OK,

3487
02:08:50,029 --> 02:08:52,549
call the other roommate or maybe more simply like put

3488
02:08:52,549 --> 02:08:55,859
a note on the door or like maybe dramatically lock

3489
02:08:55,859 --> 02:08:58,350
the refrigerator somehow and in fact that's a term of

3490
02:08:58,350 --> 02:09:01,319
art in databases is to actually use a database lock

3491
02:09:01,669 --> 02:09:02,339
so that

3492
02:09:02,509 --> 02:09:05,200
if you are in the process of updating the value in the database,

3493
02:09:05,350 --> 02:09:07,839
lock it so that no one else can inspect

3494
02:09:08,020 --> 02:09:10,700
the value of that database and potentially make a poor

3495
02:09:11,229 --> 02:09:11,589
decision.

3496
02:09:12,120 --> 02:09:14,129
So when might this actually happen in the

3497
02:09:14,129 --> 02:09:16,370
real world rather than the contrived milk example.

3498
02:09:16,450 --> 02:09:20,370
So there are a lot of social media posts nowadays that are quite popular to this day,

3499
02:09:20,450 --> 02:09:20,890
as of today,

3500
02:09:20,970 --> 02:09:22,970
this is still the most popular Instagram post,

3501
02:09:23,049 --> 02:09:23,490
for instance.

3502
02:09:23,569 --> 02:09:25,970
And imagine when this was first posted hundreds,

3503
02:09:26,120 --> 02:09:26,770
thousands,

3504
02:09:26,959 --> 02:09:28,049
hundreds of thousands of.

3505
02:09:28,140 --> 02:09:31,799
People might have all been clicking the heart icon essentially at the same time.

3506
02:09:32,009 --> 02:09:32,799
Now Mehta,

3507
02:09:33,129 --> 02:09:34,490
the company behind Instagram,

3508
02:09:34,529 --> 02:09:36,759
presumably has lots and lots of different servers,

3509
02:09:37,009 --> 02:09:39,649
but let's suppose for the sake of discussion they have a single database,

3510
02:09:39,660 --> 02:09:40,370
which is not true,

3511
02:09:40,450 --> 02:09:40,839
but

3512
02:09:41,169 --> 02:09:44,049
the danger is still there even with multiple databases.

3513
02:09:44,660 --> 02:09:47,399
All of these different web servers are talking to the same database,

3514
02:09:47,580 --> 02:09:51,350
and suppose those those servers are using Python code and hey,

3515
02:09:51,419 --> 02:09:52,609
the CS 50 library

3516
02:09:52,819 --> 02:09:55,140
that might look a little something like this in order to decide

3517
02:09:55,140 --> 02:09:58,850
how to update the total number of likes for an Instagram post.

3518
02:09:58,979 --> 02:10:01,549
The first line of code running on meta servers.

3519
02:10:01,604 --> 02:10:04,475
Might say this get these rows as follows.

3520
02:10:04,484 --> 02:10:08,595
Execute a query like select the current number of likes from the posts

3521
02:10:08,595 --> 02:10:13,064
table where the ID of the post is whatever it is 123456,

3522
02:10:13,234 --> 02:10:13,625
whatever.

3523
02:10:13,754 --> 02:10:17,754
Notice no SQL injection attacks possible here because I'm using the placeholder,

3524
02:10:17,875 --> 02:10:18,754
not an F string.

3525
02:10:19,490 --> 02:10:22,129
Then the next line of code running on MetaServer maybe just

3526
02:10:22,129 --> 02:10:24,479
stores in a variable just to make the code more readable.

3527
02:10:25,020 --> 02:10:27,569
The first rows likes column.

3528
02:10:27,689 --> 02:10:29,720
So it's again it's the CS 50 library in the story.

3529
02:10:29,890 --> 02:10:32,040
Rose is a list of dictionaries,

3530
02:10:32,250 --> 02:10:34,560
so this is the first such element in the list,

3531
02:10:34,750 --> 02:10:38,069
and this is the likes column in

3532
02:10:38,410 --> 02:10:38,919
the

3533
02:10:39,290 --> 02:10:40,399
column we just selected,

3534
02:10:40,410 --> 02:10:40,859
the temporary.

3535
02:10:41,580 --> 02:10:41,939
Lastly,

3536
02:10:42,020 --> 02:10:42,620
what do we want to do?

3537
02:10:42,720 --> 02:10:42,779
Well,

3538
02:10:42,819 --> 02:10:45,049
we want a plus plus essentially that total,

3539
02:10:45,259 --> 02:10:49,180
so we update the post table setting the number of likes equal to this question

3540
02:10:49,180 --> 02:10:53,339
mark where the ID equals this question mark and we didn't see this already,

3541
02:10:53,379 --> 02:10:57,729
but the CS 50 library supports indeed multiple arguments after the SQL string.

3542
02:10:57,930 --> 02:11:00,209
I'm going to update the number of likes to be likes plus one,

3543
02:11:00,580 --> 02:11:02,729
plugging in the same ID of that post.

3544
02:11:03,169 --> 02:11:04,009
So in short,

3545
02:11:04,240 --> 02:11:06,240
take on faith that it's quite common that in

3546
02:11:06,240 --> 02:11:08,640
order to achieve one small goal like updating the number

3547
02:11:08,640 --> 02:11:13,700
of likes stands to reason you might need to do 2 database queries or 3 lines of code.

3548
02:11:13,879 --> 02:11:17,200
Now if these lines of code are executing on multiple web servers,

3549
02:11:17,319 --> 02:11:19,600
you could certainly imagine that if people are hitting

3550
02:11:19,600 --> 02:11:22,669
the like button pretty much at the same time,

3551
02:11:22,919 --> 02:11:25,479
maybe one server is going to execute this first line

3552
02:11:25,479 --> 02:11:27,560
of code and it's going to get its answer.

3553
02:11:27,600 --> 02:11:29,830
Maybe there's 100 likes at this point in the story.

3554
02:11:30,040 --> 02:11:31,240
And then just by chance.

3555
02:11:31,330 --> 02:11:32,160
Another server,

3556
02:11:32,399 --> 02:11:34,430
this line of code is also executed,

3557
02:11:34,540 --> 02:11:36,319
but it too gets the same answer.

3558
02:11:36,359 --> 02:11:37,959
There's currently 100 likes.

3559
02:11:38,200 --> 02:11:38,720
Meanwhile,

3560
02:11:38,799 --> 02:11:43,319
the first server in the story continues to do its execution of code

3561
02:11:43,319 --> 02:11:46,509
such that it updates the number of likes from 100 to 101.

3562
02:11:46,720 --> 02:11:50,080
But because the other server was essentially running the same code in parallel,

3563
02:11:50,359 --> 02:11:53,439
it's going to make the same mathematical decision and update the number of posts,

3564
02:11:53,490 --> 02:11:56,009
the number of likes from 100 to 1001.

3565
02:11:56,359 --> 02:11:57,200
But at this point in the story,

3566
02:11:57,229 --> 02:11:59,359
the number of likes should obviously be 10.

3567
02:12:00,390 --> 02:12:00,810
2,

3568
02:12:00,919 --> 02:12:02,430
so we've lost data,

3569
02:12:02,600 --> 02:12:05,319
and that's one of the dangers of a race condition is that you'll

3570
02:12:05,319 --> 02:12:08,720
end up with an inaccurate result and for a company like Meta they

3571
02:12:08,720 --> 02:12:11,720
don't want to go losing data like likes like this like that actually

3572
02:12:11,720 --> 02:12:15,000
drives engagement and so forth and so like that's genuinely a technical,

3573
02:12:15,040 --> 02:12:16,790
if not a business problem as well.

3574
02:12:17,160 --> 02:12:20,399
So it's analogous to sort of the milk problem but actually at scale.

3575
02:12:20,439 --> 02:12:21,569
So what's the solution?

3576
02:12:21,890 --> 02:12:22,770
There's a bunch of different ways,

3577
02:12:22,799 --> 02:12:25,160
but conceptually we just want to lock the

3578
02:12:25,160 --> 02:12:27,040
database when this logic is being executed.

3579
02:12:27,495 --> 02:12:29,895
such that when one server is updating the number of likes,

3580
02:12:30,095 --> 02:12:33,765
no one else should be allowed to update the like count at the same time.

3581
02:12:33,975 --> 02:12:36,734
Now that's a little crazy for someone as big as meta because

3582
02:12:36,734 --> 02:12:39,964
you're really just serializing all of these likes and slowing things down.

3583
02:12:40,174 --> 02:12:42,095
So there's more fine grain control nowadays,

3584
02:12:42,214 --> 02:12:45,615
namely called transactions where you can essentially lock not the

3585
02:12:45,615 --> 02:12:47,725
whole table and then certainly not the whole database,

3586
02:12:47,895 --> 02:12:49,615
but just the row in question,

3587
02:12:49,654 --> 02:12:50,325
for instance.

3588
02:12:50,575 --> 02:12:54,325
And so you would use commands in SQL like begin transaction.

3589
02:12:54,549 --> 02:12:56,779
And then execute the lines of code that you want,

3590
02:12:56,819 --> 02:12:58,279
and then when you're ready to commit it,

3591
02:12:58,350 --> 02:12:59,220
that is save it,

3592
02:12:59,390 --> 02:13:00,540
you use a commit command,

3593
02:13:00,549 --> 02:13:02,660
but if something goes wrong or you get interrupted,

3594
02:13:02,790 --> 02:13:04,830
you can actually roll back the whole thing.

3595
02:13:05,279 --> 02:13:08,259
And what this kind of code does in effect by using

3596
02:13:08,629 --> 02:13:13,549
more verbose CS 50 and Python code like this is you can ensure that

3597
02:13:13,549 --> 02:13:16,950
those three lines of code inside or technically the two database queries inside,

3598
02:13:16,990 --> 02:13:18,729
will either both be executed

3599
02:13:19,069 --> 02:13:19,950
or not at all.

3600
02:13:20,029 --> 02:13:22,140
They will not be interrupted,

3601
02:13:22,259 --> 02:13:25,620
and that's the fundamental solution to this problem analogous to putting a lock

3602
02:13:25,620 --> 02:13:29,709
on the fridge or by leaving a note or calling your roommate,

3603
02:13:29,839 --> 02:13:31,740
preventing them from making the same

3604
02:13:32,129 --> 02:13:32,660
decision

3605
02:13:33,149 --> 02:13:33,629
themselves.

3606
02:13:34,689 --> 02:13:35,520
Questions

3607
02:13:35,729 --> 02:13:36,240
then

3608
02:13:36,450 --> 02:13:37,680
on these race conditions,

3609
02:13:37,689 --> 02:13:38,450
the solutions again,

3610
02:13:38,569 --> 02:13:40,439
even though this won't be germane for CS 50,

3611
02:13:40,709 --> 02:13:43,229
simply using techniques like locks and

3612
02:13:43,490 --> 02:13:45,129
what we called transactions.

3613
02:13:47,379 --> 02:13:47,629
No.

3614
02:13:47,729 --> 02:13:47,979
All right,

3615
02:13:48,040 --> 02:13:49,890
then a final moment to end on.

3616
02:13:50,100 --> 02:13:50,149
Uh,

3617
02:13:50,299 --> 02:13:51,979
we would not be a computer science course if we

3618
02:13:51,979 --> 02:13:54,810
didn't introduce you to a few pieces of CS Canon.

3619
02:13:55,180 --> 02:13:55,200
Uh,

3620
02:13:55,299 --> 02:13:57,540
here is a sort of meme that's circulated for

3621
02:13:57,540 --> 02:14:00,459
years when it comes to like optical character recognition,

3622
02:14:00,470 --> 02:14:04,560
OCR of like toll booths trying to detect your license plate automatically.

3623
02:14:04,819 --> 02:14:06,850
This is someone trying to have a funny old time

3624
02:14:07,089 --> 02:14:10,180
tricking the city into deleting their database altogether

3625
02:14:10,180 --> 02:14:12,069
because if you're just scanning this off of someone's

3626
02:14:12,069 --> 02:14:13,500
license plate in front of the car and just

3627
02:14:13,500 --> 02:14:16,270
blindly plugging it in without sanitizing their input.

3628
02:14:16,515 --> 02:14:18,995
Escaping their input with something like a good library,

3629
02:14:19,245 --> 02:14:21,604
you might very well still drop the entire database.

3630
02:14:21,805 --> 02:14:22,305
As an aside,

3631
02:14:22,404 --> 02:14:24,044
something one did something similar to where I

3632
02:14:24,044 --> 02:14:25,765
think they made their license plate null,

3633
02:14:25,924 --> 02:14:26,714
NULL,

3634
02:14:26,805 --> 02:14:28,084
which just confused the heck out of

3635
02:14:28,084 --> 02:14:30,484
the system too because the programmers didn't understand

3636
02:14:30,484 --> 02:14:33,555
why null was all over the place when lights were being run and whatnot.

3637
02:14:33,725 --> 02:14:34,705
And lastly,

3638
02:14:34,924 --> 02:14:39,955
a very famed character in the world of XKCD as computer science circles goes is this,

3639
02:14:39,964 --> 02:14:42,044
so we'll end as we've done before on an awkward

3640
02:14:42,044 --> 02:14:45,564
silence as you process this here canonical CS joke.

3641
02:14:50,560 --> 02:14:50,910
Oh

3642
02:14:53,279 --> 02:14:55,810
Now you two know who little Bobby Tables is.

3643
02:14:55,970 --> 02:14:56,049
All right,

3644
02:14:56,169 --> 02:14:57,089
that's it for week 7.

3645
02:14:57,169 --> 02:14:58,169
We'll see you next time.