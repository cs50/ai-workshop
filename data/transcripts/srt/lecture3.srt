0
00:01:53,160 --> 00:01:53,169
Why

1
00:02:11,990 --> 00:02:12,000
All

2
00:02:14,070 --> 00:02:14,300
right,

3
00:02:14,619 --> 00:02:16,059
this is CS 50.

4
00:02:16,139 --> 00:02:17,490
This is week 3,

5
00:02:17,619 --> 00:02:19,899
and this was an artist's rendition of what

6
00:02:19,899 --> 00:02:22,740
various sorting algorithms look and sound like.

7
00:02:22,839 --> 00:02:25,100
Recall from week 0 that an algorithm is just step

8
00:02:25,100 --> 00:02:28,179
by step instructions for solving some problem to sort information,

9
00:02:28,250 --> 00:02:30,110
as in the real world just means to order it

10
00:02:30,419 --> 00:02:33,850
from like smallest to largest or alphabetically or some other heuristic.

11
00:02:33,979 --> 00:02:35,300
And it's among the algorithms that we're going

12
00:02:35,300 --> 00:02:36,970
to focus on today in addition to searching,

13
00:02:37,020 --> 00:02:38,339
which of course is looking for.

14
00:02:38,479 --> 00:02:40,419
Information as we did in week 02.

15
00:02:40,750 --> 00:02:42,460
Among the goals for today are to give you

16
00:02:42,460 --> 00:02:44,869
a sense of certain computer science building blocks like

17
00:02:44,869 --> 00:02:47,669
there's a lot of canonical algorithms out there that

18
00:02:47,669 --> 00:02:50,169
most anyone who studied computer science would know,

19
00:02:50,410 --> 00:02:52,699
anyone who leads a tech interview would ask.

20
00:02:52,869 --> 00:02:53,910
But more importantly,

21
00:02:53,949 --> 00:02:57,669
the goal is to give you different mental models for and methodologies

22
00:02:57,669 --> 00:03:00,740
for actually solving problems by giving you a sense of how these,

23
00:03:00,869 --> 00:03:01,100
uh,

24
00:03:01,110 --> 00:03:03,990
real world algorithms can be translated to actual computers.

25
00:03:04,160 --> 00:03:05,259
You and I can control.

26
00:03:05,429 --> 00:03:08,380
We thought we'd begin today with an actual algorithm

27
00:03:08,750 --> 00:03:10,029
for sort of taking attendance.

28
00:03:10,070 --> 00:03:11,630
We of course do this with scanners outside,

29
00:03:11,710 --> 00:03:13,270
but we can do it old school whereby I just

30
00:03:13,270 --> 00:03:17,830
use my hand or my mind and start doing 123456789,

31
00:03:17,910 --> 00:03:18,509
1011,

32
00:03:18,520 --> 00:03:19,059
12,

33
00:03:19,350 --> 00:03:20,100
and so forth.

34
00:03:20,229 --> 00:03:21,630
That's going to take quite a few steps because

35
00:03:21,630 --> 00:03:24,110
I've got to point at and recite a number for

36
00:03:24,110 --> 00:03:25,710
everyone in the room so I could kind of

37
00:03:25,710 --> 00:03:27,380
do what my like grade school teachers taught me,

38
00:03:27,389 --> 00:03:28,710
which is count by 2s,

39
00:03:28,789 --> 00:03:29,710
which would seem to be faster.

40
00:03:29,839 --> 00:03:31,550
So like 2468,

41
00:03:31,559 --> 00:03:32,229
1012,

42
00:03:32,320 --> 00:03:33,070
1416,

43
00:03:33,139 --> 00:03:33,979
1820,

44
00:03:34,110 --> 00:03:36,940
and clearly that sounds and is actually faster,

45
00:03:37,110 --> 00:03:38,619
but I think with a little more

46
00:03:38,830 --> 00:03:42,309
intuition and a little more thought back to week zero,

47
00:03:42,509 --> 00:03:45,020
I dare say we could actually do much better than that.

48
00:03:45,149 --> 00:03:46,699
So if you won't mind,

49
00:03:46,949 --> 00:03:49,899
I'd like you to humor us by all standing up

50
00:03:50,149 --> 00:03:50,899
in place

51
00:03:51,130 --> 00:03:52,460
and think of the number one,

52
00:03:52,589 --> 00:03:53,179
if you could,

53
00:03:53,270 --> 00:03:55,350
and join us in this here algorithm.

54
00:03:56,160 --> 00:03:57,229
So stand up

55
00:03:57,720 --> 00:03:58,710
in place

56
00:03:58,960 --> 00:04:01,039
and think of the number 1.

57
00:04:01,119 --> 00:04:02,149
So at this point in the story,

58
00:04:02,330 --> 00:04:04,770
everyone should be thinking of the number 1.

59
00:04:05,080 --> 00:04:09,869
Step 2 of this algorithm for you is going to be this pair off with someone standing,

60
00:04:10,199 --> 00:04:11,759
add their number to yours,

61
00:04:11,839 --> 00:04:13,089
and remember the sum.

62
00:04:14,539 --> 00:04:15,020
Go

63
00:04:20,350 --> 00:04:21,519
OK.

64
00:04:21,910 --> 00:04:23,220
At this point in the story,

65
00:04:23,829 --> 00:04:24,260
everyone,

66
00:04:24,470 --> 00:04:27,750
except maybe one lone person if we've got an odd number of people in the room,

67
00:04:27,829 --> 00:04:28,959
is thinking of what number?

68
00:04:29,510 --> 00:04:30,260
2,

69
00:04:30,589 --> 00:04:30,899
OK,

70
00:04:31,070 --> 00:04:32,350
so next step,

71
00:04:32,940 --> 00:04:33,700
one of you

72
00:04:33,950 --> 00:04:34,700
in each pair

73
00:04:34,910 --> 00:04:35,630
should sit down.

74
00:04:40,790 --> 00:04:41,649
OK.

75
00:04:42,279 --> 00:04:42,470
Good.

76
00:04:42,600 --> 00:04:44,480
Never seen some people sit down so fast.

77
00:04:44,600 --> 00:04:44,829
So,

78
00:04:44,920 --> 00:04:46,399
those of you who are still standing,

79
00:04:46,440 --> 00:04:47,750
the algorithm's still going.

80
00:04:47,959 --> 00:04:50,750
So the next step for those of you still standing is this,

81
00:04:51,040 --> 00:04:52,230
if still standing,

82
00:04:52,640 --> 00:04:54,029
go back to step

83
00:04:54,239 --> 00:04:54,869
2.

84
00:04:56,299 --> 00:04:59,089
Ergo repeat or loop if you could.

85
00:05:05,790 --> 00:05:06,040
Um

86
00:05:10,890 --> 00:05:12,579
And notice if you've gone back to step 2,

87
00:05:12,739 --> 00:05:13,779
that leads you to step 3,

88
00:05:13,899 --> 00:05:15,750
that leads some of you to step 4,

89
00:05:15,940 --> 00:05:17,709
which leads you back to step 2.

90
00:05:18,579 --> 00:05:19,510
So this is a loop.

91
00:05:27,649 --> 00:05:28,079
Keep going.

92
00:05:28,130 --> 00:05:29,239
If still standing,

93
00:05:29,410 --> 00:05:30,690
pair off with someone else,

94
00:05:30,730 --> 00:05:31,480
still standing,

95
00:05:31,690 --> 00:05:32,399
add together,

96
00:05:32,429 --> 00:05:33,920
and then one of you sit down.

97
00:05:34,369 --> 00:05:35,559
So with each passing second,

98
00:05:35,690 --> 00:05:38,160
more and more people should be sitting down.

99
00:05:39,869 --> 00:05:41,529
And fewer and fewer are standing.

100
00:05:41,820 --> 00:05:42,480
OK.

101
00:05:42,820 --> 00:05:44,019
Almost everyone is sitting down.

102
00:05:44,119 --> 00:05:45,899
You're getting farther and farther away from each other.

103
00:05:45,980 --> 00:05:46,549
That's OK.

104
00:05:47,510 --> 00:05:50,040
I can help with some of the math at the end here.

105
00:05:52,559 --> 00:05:52,799
All right.

106
00:05:52,880 --> 00:05:54,279
I see a few of you still standing,

107
00:05:54,320 --> 00:05:56,559
so I'll help out and I'll I'll join you together.

108
00:05:56,679 --> 00:05:58,230
So I see you in the middle here.

109
00:05:58,279 --> 00:05:59,109
What's your number?

110
00:06:00,649 --> 00:06:01,570
32.

111
00:06:01,890 --> 00:06:02,049
OK,

112
00:06:02,130 --> 00:06:04,760
go ahead and sit down and I'll pair you off with what's your number?

113
00:06:05,450 --> 00:06:05,899
20.

114
00:06:05,929 --> 00:06:06,130
OK,

115
00:06:06,170 --> 00:06:07,359
you can go ahead and sit down.

116
00:06:07,649 --> 00:06:07,769
Uh,

117
00:06:07,850 --> 00:06:09,019
who's still

118
00:06:10,109 --> 00:06:11,149
Then you're still standing.

119
00:06:12,640 --> 00:06:13,359
27?

120
00:06:13,380 --> 00:06:13,600
OK,

121
00:06:13,640 --> 00:06:14,630
you can sit down.

122
00:06:15,649 --> 00:06:16,950
You guys are still adding together,

123
00:06:17,049 --> 00:06:17,880
who's gonna stay standing?

124
00:06:17,959 --> 00:06:18,079
OK,

125
00:06:18,130 --> 00:06:18,829
what's your number?

126
00:06:19,940 --> 00:06:22,429
The worst part is doing like arithmetic across a crowded room,

127
00:06:22,470 --> 00:06:22,859
but

128
00:06:23,470 --> 00:06:24,579
27 also?

129
00:06:24,950 --> 00:06:25,549
47.

130
00:06:25,589 --> 00:06:25,750
OK,

131
00:06:25,790 --> 00:06:26,350
you can sit down.

132
00:06:26,429 --> 00:06:27,429
Is anyone still standing?

133
00:06:27,470 --> 00:06:27,670
Yeah.

134
00:06:28,839 --> 00:06:29,170
Nice,

135
00:06:29,239 --> 00:06:29,720
15.

136
00:06:29,799 --> 00:06:29,959
OK,

137
00:06:30,000 --> 00:06:30,630
you can sit down.

138
00:06:30,880 --> 00:06:31,869
Anyone still standing?

139
00:06:33,380 --> 00:06:33,750
OK,

140
00:06:34,019 --> 00:06:38,250
so all I've done is sort of automate the process of pairing people up at the end here.

141
00:06:38,380 --> 00:06:39,450
When I hit enter,

142
00:06:39,660 --> 00:06:41,279
we should hopefully see,

143
00:06:41,540 --> 00:06:41,649
oh,

144
00:06:41,660 --> 00:06:42,489
the numbers are a little,

145
00:06:42,619 --> 00:06:43,260
what's going on there?

146
00:06:43,380 --> 00:06:44,010
There we go.

147
00:06:44,540 --> 00:06:45,899
When I hit enter,

148
00:06:46,179 --> 00:06:49,170
we'll add together all of the numbers that were left.

149
00:06:49,220 --> 00:06:51,459
And if you think about the algorithm that we just executed,

150
00:06:51,540 --> 00:06:54,690
each of you started with the number 1 and then half of you handed off your number.

151
00:06:54,804 --> 00:06:56,244
Then half of you handed off your number,

152
00:06:56,274 --> 00:06:57,665
then half of you handed off your number.

153
00:06:57,834 --> 00:06:59,994
So theoretically all of these ones with which we

154
00:06:59,994 --> 00:07:02,765
started should be aggregated into the final count,

155
00:07:02,954 --> 00:07:04,075
which if this room weren't so big,

156
00:07:04,195 --> 00:07:05,945
would just be in one person's mind,

157
00:07:05,954 --> 00:07:08,704
and they would have declared what the total number of people in the room is.

158
00:07:08,774 --> 00:07:10,945
I'm going to speed that up by hitting enter on the keyboard,

159
00:07:11,154 --> 00:07:14,744
and if your execution of this algorithm is correct,

160
00:07:14,954 --> 00:07:16,195
there should be.

161
00:07:16,739 --> 00:07:18,970
141 people in the room.

162
00:07:19,489 --> 00:07:21,299
According to our old school human though,

163
00:07:21,540 --> 00:07:21,899
Kelly,

164
00:07:21,980 --> 00:07:24,529
who did this manually one at a time,

165
00:07:24,739 --> 00:07:26,890
the total number of people

166
00:07:27,179 --> 00:07:27,920
in the room,

167
00:07:28,109 --> 00:07:28,940
according to Kelly,

168
00:07:28,980 --> 00:07:30,179
if you want to come on up and

169
00:07:30,739 --> 00:07:32,989
shouted into the microphone is of course going to be,

170
00:07:33,040 --> 00:07:33,299
I don't know,

171
00:07:33,459 --> 00:07:34,890
something around 160,

172
00:07:34,940 --> 00:07:36,220
I think 160,

173
00:07:36,299 --> 00:07:37,380
so not quite the same.

174
00:07:37,459 --> 00:07:37,619
OK,

175
00:07:37,670 --> 00:07:38,339
but that's pretty good.

176
00:07:38,420 --> 00:07:38,540
OK,

177
00:07:38,619 --> 00:07:39,910
round of applause for your,

178
00:07:40,059 --> 00:07:41,720
your accuracy.

179
00:07:45,070 --> 00:07:45,290
OK,

180
00:07:45,329 --> 00:07:48,209
so ideally counting one at a time would have been perfectly correct.

181
00:07:48,329 --> 00:07:49,920
So we're only off by a little bit.

182
00:07:50,010 --> 00:07:50,239
Now,

183
00:07:50,489 --> 00:07:53,850
presumably that's just because of some bugs in execution of the algorithm,

184
00:07:53,929 --> 00:07:56,549
maybe some mental math didn't quite go according to plan,

185
00:07:56,690 --> 00:08:00,279
but theoretically your third and final algorithm wherein you all participated,

186
00:08:00,450 --> 00:08:03,329
should have been much faster than my algorithm or Kelly's algorithm,

187
00:08:03,369 --> 00:08:06,089
whether or not we were counting one at a time or two at a time.

188
00:08:06,130 --> 00:08:06,519
Why?

189
00:08:06,640 --> 00:08:09,279
We'll think back to week zero when we did the whole phone book example,

190
00:08:09,489 --> 00:08:11,010
which was especially fast in it.

191
00:08:11,127 --> 00:08:13,596
Final form because we were dividing and conquering,

192
00:08:13,677 --> 00:08:14,957
tearing half of the problem away,

193
00:08:15,076 --> 00:08:16,226
half of the problem away.

194
00:08:16,397 --> 00:08:18,467
And even though it's hard to see in a room like this,

195
00:08:18,717 --> 00:08:21,986
it stands to reason that when all of you were standing up,

196
00:08:22,117 --> 00:08:24,717
we took a big bite out of the first problem and half of you sat down,

197
00:08:24,837 --> 00:08:25,557
half of you sat down,

198
00:08:25,636 --> 00:08:26,546
half of you sat down,

199
00:08:26,557 --> 00:08:29,766
and theoretically there would have been if you were closer in

200
00:08:30,117 --> 00:08:30,506
space,

201
00:08:30,777 --> 00:08:33,145
one single person with the final count.

202
00:08:33,317 --> 00:08:35,486
So let's see if we can analyze this

203
00:08:35,996 --> 00:08:37,812
just a little bit by considering We did.

204
00:08:37,942 --> 00:08:39,413
So here's that same algorithm.

205
00:08:39,663 --> 00:08:42,703
He recall is how we motivated Week zero's

206
00:08:42,703 --> 00:08:44,822
demonstration of the phonebook in either digital form,

207
00:08:44,833 --> 00:08:46,893
as you might see in an iPhone or Android device,

208
00:08:47,103 --> 00:08:47,742
looking for someone,

209
00:08:47,783 --> 00:08:48,143
for instance,

210
00:08:48,223 --> 00:08:49,853
like John Harvard who might be at the beginning,

211
00:08:49,942 --> 00:08:50,223
middle,

212
00:08:50,232 --> 00:08:51,783
or end of said phonebook,

213
00:08:51,822 --> 00:08:54,732
but we analyzed that algorithm just as we can now this one.

214
00:08:54,942 --> 00:08:57,263
So in my very first verbalized algorithm,

215
00:08:57,302 --> 00:08:59,093
1234,

216
00:08:59,263 --> 00:09:02,302
you could draw that as a straight line because the relationship between the number

217
00:09:02,302 --> 00:09:05,630
of people in the room and the of time it takes is linear.

218
00:09:05,690 --> 00:09:08,481
It's a straight line with each additional person in the room.

219
00:09:08,611 --> 00:09:10,120
It takes me one more step.

220
00:09:10,250 --> 00:09:11,841
So if you think to sort of high school math,

221
00:09:11,901 --> 00:09:13,450
there's sort of a slope of one there.

222
00:09:13,531 --> 00:09:18,440
And so this N number denoting number of people in the room is indeed a straight line.

223
00:09:18,531 --> 00:09:19,651
And on the x axis,

224
00:09:19,731 --> 00:09:20,380
as in week 0,

225
00:09:20,411 --> 00:09:23,130
we have the size of the problem in people and the time to

226
00:09:23,130 --> 00:09:26,281
solve in steps or seconds or whatever your unit of measure is.

227
00:09:26,481 --> 00:09:28,270
If and when I started counting 2 at a time,

228
00:09:28,281 --> 00:09:29,411
2468,

229
00:09:29,440 --> 00:09:29,851
10.

230
00:09:30,099 --> 00:09:30,960
And so forth.

231
00:09:31,169 --> 00:09:34,630
That still is a straight line because I'm taking two bytes consistently out of

232
00:09:34,630 --> 00:09:37,799
the problem until maybe the very end where there's just 1 person left,

233
00:09:38,010 --> 00:09:38,929
but it's still a straight line,

234
00:09:38,969 --> 00:09:40,239
but it's strictly faster.

235
00:09:40,409 --> 00:09:41,729
No matter the size of the problem,

236
00:09:41,770 --> 00:09:43,500
if you sort of draw a line vertically,

237
00:09:43,630 --> 00:09:45,969
you'll see that you hit the yellow line well before you

238
00:09:45,969 --> 00:09:48,960
hit the red line because it's moving essentially twice as fast.

239
00:09:49,090 --> 00:09:50,650
But that third and final algorithm,

240
00:09:50,729 --> 00:09:53,809
even though in reality it felt like it took a while and I had to

241
00:09:53,809 --> 00:09:56,890
kind of bring us to the exciting conclusion by doing some of the math.

242
00:09:57,153 --> 00:10:00,033
That looked much more like our 3rd and final phone book

243
00:10:00,033 --> 00:10:03,294
example because if you think about it from an opposite perspective,

244
00:10:03,624 --> 00:10:05,843
suppose there were twice as many people in the room.

245
00:10:06,064 --> 00:10:06,184
Well,

246
00:10:06,263 --> 00:10:09,403
it would have taken you all theoretically just one more step.

247
00:10:09,523 --> 00:10:09,583
You know,

248
00:10:09,614 --> 00:10:12,424
granted one more loop and there might be some substeps in there if you will,

249
00:10:12,583 --> 00:10:14,693
but it's really just fundamentally one more step.

250
00:10:14,864 --> 00:10:16,893
If the number of people in the room quadrupled,

251
00:10:16,903 --> 00:10:18,294
4 times as many people,

252
00:10:18,504 --> 00:10:18,573
well,

253
00:10:18,583 --> 00:10:20,414
that's 2 more steps.

254
00:10:20,544 --> 00:10:21,653
equivalently,

255
00:10:21,703 --> 00:10:26,908
the amount of time it takes to solve the Attendance problem using that 3rd and final

256
00:10:26,908 --> 00:10:33,028
algorithm grows very slowly because it takes a huge number of more people in the room

257
00:10:33,427 --> 00:10:36,627
before you even begin to feel the impacts of that

258
00:10:37,317 --> 00:10:37,687
growth.

259
00:10:37,797 --> 00:10:38,877
And so today indeed,

260
00:10:38,888 --> 00:10:40,918
as we talk about not only the correctness of algorithms,

261
00:10:41,098 --> 00:10:43,388
we're going to talk about the design of algorithms as well,

262
00:10:43,398 --> 00:10:47,348
just as we have code because the smarter you are with your design,

263
00:10:47,547 --> 00:10:51,158
the more efficient your algorithms ultimately are going to be and the slow.

264
00:10:51,262 --> 00:10:56,882
Where their cost is going to grow and by cost I mean time like here maybe it's money,

265
00:10:57,072 --> 00:10:58,841
maybe it's the amount of storage space that you need.

266
00:10:58,851 --> 00:11:01,961
Any limited resource is something that we can ultimately measure,

267
00:11:02,052 --> 00:11:03,492
and we're not going to do it very precisely.

268
00:11:03,531 --> 00:11:03,802
Indeed,

269
00:11:03,812 --> 00:11:05,892
we're going to use some broad strokes and some

270
00:11:05,892 --> 00:11:09,812
standard mechanisms for describing ultimately the running time,

271
00:11:09,892 --> 00:11:15,161
the amount of time it takes for an algorithm or in turn code to actually run.

272
00:11:15,372 --> 00:11:16,331
So how can we do this?

273
00:11:16,562 --> 00:11:16,572
Well,

274
00:11:16,692 --> 00:11:17,442
last week we're called,

275
00:11:17,452 --> 00:11:18,171
we set the stage.

276
00:11:18,945 --> 00:11:21,825
for talking about something called arrays which were the simplest

277
00:11:21,825 --> 00:11:24,306
of data structures inside of a computer where you just take

278
00:11:24,306 --> 00:11:26,265
the memory in your computer and you break it up

279
00:11:26,265 --> 00:11:28,306
into chunks and you can store a bunch of integers,

280
00:11:28,315 --> 00:11:28,945
a bunch of strings,

281
00:11:29,026 --> 00:11:29,495
whatever,

282
00:11:29,786 --> 00:11:31,065
back to back to back to back,

283
00:11:31,106 --> 00:11:33,255
and that's the key characteristic for an array.

284
00:11:33,426 --> 00:11:38,445
It is a chunk of memory wherein all of the values they're in are back to back to back,

285
00:11:38,666 --> 00:11:40,385
so right next to each other in memory.

286
00:11:40,546 --> 00:11:43,486
So we drew this fairly abstractly by drawing a grid like this and I said,

287
00:11:43,625 --> 00:11:43,666
Well,

288
00:11:43,716 --> 00:11:45,265
maybe this is byte 0 and this is by.

289
00:11:45,440 --> 00:11:46,270
1 billion,

290
00:11:46,479 --> 00:11:49,030
whatever the total amount of memory is that you have,

291
00:11:49,200 --> 00:11:52,590
we zoomed in and looked at a little something like this a canvas of memory.

292
00:11:52,799 --> 00:11:55,070
We talked about what and where you can put things,

293
00:11:55,130 --> 00:12:01,070
but today let's just assume that we want 1234567 chunks of memory for the moment,

294
00:12:01,080 --> 00:12:04,630
and inside of them we might put something like these numbers here.

295
00:12:04,919 --> 00:12:05,039
Well,

296
00:12:05,049 --> 00:12:07,640
the interesting thing about computers is that even though if I were

297
00:12:07,640 --> 00:12:10,880
to ask you all find the number 50 in this array,

298
00:12:11,000 --> 00:12:11,200
I mean,

299
00:12:11,239 --> 00:12:12,359
our eyes quickly.

300
00:12:12,424 --> 00:12:14,664
See where it is because we sort of have this bird's eye

301
00:12:14,664 --> 00:12:17,124
view of the whole screen and it's obvious where 50 is,

302
00:12:17,333 --> 00:12:20,903
but the catch with computers and with code that we write

303
00:12:21,174 --> 00:12:22,973
is that really these arrays,

304
00:12:23,054 --> 00:12:24,124
these chunks of memory,

305
00:12:24,294 --> 00:12:27,804
are equivalent to a whole bunch of closed doors and the computer

306
00:12:28,013 --> 00:12:30,203
can't just have this bird's eye view of everything.

307
00:12:30,273 --> 00:12:31,843
If the computer wants to see

308
00:12:32,213 --> 00:12:32,604
what

309
00:12:32,934 --> 00:12:34,883
value is at a certain location,

310
00:12:34,953 --> 00:12:37,814
it has to do the metaphorical equivalent of going to that location,

311
00:12:37,934 --> 00:12:38,643
opening the door,

312
00:12:38,653 --> 00:12:39,414
and looking.

313
00:12:39,640 --> 00:12:41,429
Then closing it and moving on to the next.

314
00:12:41,510 --> 00:12:41,940
That is to say,

315
00:12:41,950 --> 00:12:45,940
a computer can only look at or access one value at a time.

316
00:12:46,109 --> 00:12:47,109
Now that's in the simplest form.

317
00:12:47,150 --> 00:12:49,659
You can build fancier computers that theoretically can do more than that,

318
00:12:49,669 --> 00:12:52,419
but all of the code we write generally is going to assume that model.

319
00:12:52,510 --> 00:12:53,979
You can't just see everything at once.

320
00:12:54,109 --> 00:12:57,229
You have to go to each location in these here lockers,

321
00:12:57,270 --> 00:12:57,900
if you will.

322
00:12:58,070 --> 00:12:58,830
Starting today too,

323
00:12:58,909 --> 00:13:01,130
when we talk about the locations in memory,

324
00:13:01,349 --> 00:13:05,719
we're going to use our old zero indexing vernacular.

325
00:13:05,815 --> 00:13:08,455
That is to say we start counting from 0 instead of 1.

326
00:13:08,645 --> 00:13:09,434
So this will be

327
00:13:09,554 --> 00:13:10,395
locker 0,

328
00:13:10,525 --> 00:13:11,085
locker 1,

329
00:13:11,125 --> 00:13:11,594
locker 2,

330
00:13:12,244 --> 00:13:13,674
all the way up to locker 6.

331
00:13:13,844 --> 00:13:17,234
So just ingrained in your mind that if you hear something like location 6,

332
00:13:17,484 --> 00:13:19,604
that's actually implying that there's at least 7

333
00:13:19,604 --> 00:13:22,405
total locations because we started counting at 0.

334
00:13:22,484 --> 00:13:23,484
So that's intentional.

335
00:13:23,965 --> 00:13:25,844
We don't have in the real world yellow lockers,

336
00:13:25,885 --> 00:13:27,765
so we're going to make this metaphor red instead.

337
00:13:27,844 --> 00:13:31,844
We do have these lockers here and suppose that within these 7 lockers physically.

338
00:13:31,989 --> 00:13:32,770
On stage

339
00:13:33,049 --> 00:13:34,809
we've put a whole bunch of money,

340
00:13:35,140 --> 00:13:35,859
monopoly money,

341
00:13:35,940 --> 00:13:36,380
if you will,

342
00:13:36,539 --> 00:13:39,059
but the goal initially here is going to be to search for

343
00:13:39,059 --> 00:13:40,900
some specific denomination of interest and

344
00:13:40,900 --> 00:13:42,849
use these physical lockers as a metaphor

345
00:13:43,099 --> 00:13:44,849
for what your computer is going to do and what

346
00:13:44,849 --> 00:13:48,090
your code ultimately is going to do if we're searching for

347
00:13:48,419 --> 00:13:49,940
the solution to a problem like this.

348
00:13:50,099 --> 00:13:52,500
The input to the problem at hand is 7 lockers,

349
00:13:52,580 --> 00:13:54,929
all of whose doors are metaphorically closed,

350
00:13:55,099 --> 00:13:56,940
the output of which we want to be a bull,

351
00:13:57,239 --> 00:13:58,020
true or false answer.

352
00:13:58,164 --> 00:13:59,044
Yes or no,

353
00:13:59,434 --> 00:14:00,875
that number is there or no,

354
00:14:00,885 --> 00:14:01,625
it is not.

355
00:14:01,835 --> 00:14:05,474
So inside of this black box today is going to be the first of our algorithms,

356
00:14:05,594 --> 00:14:08,155
step by step instructions for solving some problem where the

357
00:14:08,155 --> 00:14:10,914
problem here is defined among all of these dollar bills,

358
00:14:11,195 --> 00:14:12,994
specifically the $50 bill.

359
00:14:13,155 --> 00:14:17,544
If we could get two volunteers to come on up who are ideally really good at monopoly.

360
00:14:17,794 --> 00:14:17,955
OK,

361
00:14:18,005 --> 00:14:21,835
how about over here in front and uh how about let me look a little farther and back.

362
00:14:21,914 --> 00:14:22,075
OK,

363
00:14:22,155 --> 00:14:22,645
over here,

364
00:14:22,755 --> 00:14:23,364
there and back.

365
00:14:23,525 --> 00:14:24,195
Come on down.

366
00:14:24,770 --> 00:14:25,010
All right,

367
00:14:25,169 --> 00:14:28,200
as these volunteers kindly come down to the stage,

368
00:14:28,409 --> 00:14:31,130
we're going to ask them in turn to search for

369
00:14:31,130 --> 00:14:33,690
specifically the $50 bill that we've hit in in advance.

370
00:14:33,729 --> 00:14:37,719
And if my colleague Kelly could come on up too because we're going to do this twice,

371
00:14:38,039 --> 00:14:39,359
once searching

372
00:14:39,849 --> 00:14:42,440
in one with one algorithm and a second time with another.

373
00:14:42,700 --> 00:14:44,219
Let me go ahead and say hello

374
00:14:44,690 --> 00:14:46,559
if you'd like to introduce yourselves to the group.

375
00:14:46,770 --> 00:14:46,869
Hey,

376
00:14:46,909 --> 00:14:47,929
I'm Jose Garcia.

377
00:14:49,489 --> 00:14:49,770
Hi,

378
00:14:49,849 --> 00:14:51,260
I'm Caitlin Cow.

379
00:14:51,450 --> 00:14:51,650
All right,

380
00:14:51,770 --> 00:14:52,369
Jose and Caitlin,

381
00:14:52,450 --> 00:14:53,090
nice to meet you both.

382
00:14:53,190 --> 00:14:56,719
Come on over and let me go ahead and propose that Jose,

383
00:14:56,969 --> 00:14:57,090
um,

384
00:14:57,130 --> 00:14:58,890
the first algorithm that I'd like you to do is

385
00:14:58,890 --> 00:15:01,059
to find the number 50 and let's keep it simple.

386
00:15:01,140 --> 00:15:03,059
Just start from the left and work your way to the right.

387
00:15:03,330 --> 00:15:05,039
And with each time you open the door,

388
00:15:05,159 --> 00:15:07,130
stand over to the side so people can see what's inside and

389
00:15:07,130 --> 00:15:09,559
just hold the dollar amount up for the world to see.

390
00:15:09,729 --> 00:15:10,200
All right?

391
00:15:10,809 --> 00:15:11,530
The floor is yours.

392
00:15:11,609 --> 00:15:13,200
Find us the $50 bill.

393
00:15:15,700 --> 00:15:16,150
20

394
00:15:17,710 --> 00:15:17,909
No,

395
00:15:17,989 --> 00:15:18,289
that's good.

396
00:15:18,349 --> 00:15:19,070
That's good acting too.

397
00:15:19,190 --> 00:15:19,400
Thank you.

398
00:15:19,590 --> 00:15:19,669
No,

399
00:15:19,750 --> 00:15:20,460
you can shut it

400
00:15:20,590 --> 00:15:21,229
just like the computer,

401
00:15:21,380 --> 00:15:21,780
all right.

402
00:15:24,979 --> 00:15:25,500
No,

403
00:15:25,979 --> 00:15:26,419
very clear,

404
00:15:26,570 --> 00:15:27,119
thank you.

405
00:15:30,010 --> 00:15:30,440
Mm,

406
00:15:30,630 --> 00:15:32,070
still no $10 bill.

407
00:15:34,260 --> 00:15:35,250
Next locker.

408
00:15:36,580 --> 00:15:37,340
$5 bill,

409
00:15:37,460 --> 00:15:38,289
not going well.

410
00:15:41,479 --> 00:15:42,609
$100 bill,

411
00:15:42,880 --> 00:15:44,080
but not the one we want.

412
00:15:45,320 --> 00:15:46,150
This 1

413
00:15:46,710 --> 00:15:47,440
$1 bill,

414
00:15:47,719 --> 00:15:48,669
still no $50.

415
00:15:48,919 --> 00:15:49,200
Of course,

416
00:15:49,280 --> 00:15:50,599
you've been sort of set up to fail,

417
00:15:50,799 --> 00:15:51,590
but here,

418
00:15:52,059 --> 00:15:52,309
amazing,

419
00:15:52,460 --> 00:15:53,229
a round of applause,

420
00:15:53,359 --> 00:15:55,030
Jose found the $50 bill.

421
00:15:56,890 --> 00:15:57,450
All right,

422
00:15:58,000 --> 00:15:58,570
so let me ask you,

423
00:15:58,659 --> 00:15:59,010
Jose,

424
00:15:59,049 --> 00:16:00,239
you found the $50 bill.

425
00:16:00,409 --> 00:16:00,570
Um,

426
00:16:00,650 --> 00:16:02,280
it clearly took you a long time.

427
00:16:02,489 --> 00:16:04,719
Just describe in your own words what was your algorithm,

428
00:16:04,809 --> 00:16:06,010
even though I nudged you.

429
00:16:06,250 --> 00:16:06,330
Yeah,

430
00:16:06,450 --> 00:16:10,039
so my algorithm was basically walk up to the first door available,

431
00:16:10,250 --> 00:16:10,960
open it,

432
00:16:11,450 --> 00:16:14,289
check if the dollar bill was the dollar bill that I was looking for,

433
00:16:14,299 --> 00:16:15,409
and then put it back and then go.

434
00:16:15,484 --> 00:16:16,094
The next one.

435
00:16:16,195 --> 00:16:16,434
OK,

436
00:16:16,515 --> 00:16:19,864
so it's very reasonable because if the $50 bill were there,

437
00:16:19,994 --> 00:16:22,465
Jose was absolutely going to find it eventually,

438
00:16:22,674 --> 00:16:23,434
if slowly.

439
00:16:23,474 --> 00:16:23,875
In the meantime,

440
00:16:24,034 --> 00:16:26,784
Kelly's going to kindly reshuffle the numbers behind these doors here.

441
00:16:26,955 --> 00:16:29,304
And even though Jose took a long time here,

442
00:16:29,515 --> 00:16:29,635
I mean,

443
00:16:29,775 --> 00:16:33,505
what if Jose like wouldn't have been smart to start from the other end instead,

444
00:16:33,554 --> 00:16:34,054
do you think?

445
00:16:34,700 --> 00:16:35,169
Um,

446
00:16:35,429 --> 00:16:38,950
not necessarily because we don't know if the 50 is going to be at that end.

447
00:16:39,260 --> 00:16:39,409
Exactly.

448
00:16:39,700 --> 00:16:41,239
So he could have gotten lucky if he sort of

449
00:16:41,239 --> 00:16:43,650
flaunted my advice and didn't start on the left,

450
00:16:43,700 --> 00:16:44,700
but instead started on the right,

451
00:16:44,780 --> 00:16:45,020
boom,

452
00:16:45,179 --> 00:16:46,380
he would have solved this in one step.

453
00:16:46,460 --> 00:16:46,950
But in general,

454
00:16:47,020 --> 00:16:48,219
that's not really going to work out.

455
00:16:48,340 --> 00:16:49,260
Maybe half the time it will,

456
00:16:49,299 --> 00:16:49,809
you'll get lucky,

457
00:16:49,900 --> 00:16:50,809
half the time it won't,

458
00:16:50,890 --> 00:16:51,099
but that.

459
00:16:51,244 --> 00:16:53,994
Not really a fundamental change in the algorithm whether you go left to right,

460
00:16:54,234 --> 00:16:54,815
right to left,

461
00:16:54,914 --> 00:16:55,825
to Jose's point,

462
00:16:55,955 --> 00:16:58,945
if you don't know anything a priori about the numbers,

463
00:16:58,955 --> 00:17:00,945
the best you can probably do

464
00:17:01,195 --> 00:17:04,515
is just go through linearly left to right or right to left,

465
00:17:04,594 --> 00:17:05,704
so long as you're consistent.

466
00:17:05,875 --> 00:17:06,064
Now,

467
00:17:06,074 --> 00:17:07,834
could you have jumped around randomly?

468
00:17:08,938 --> 00:17:09,138
Uh,

469
00:17:09,178 --> 00:17:09,868
I guess I could have,

470
00:17:09,979 --> 00:17:10,779
but if again,

471
00:17:10,858 --> 00:17:12,979
if they weren't in any like specified order,

472
00:17:13,038 --> 00:17:14,328
I don't think it would have helped either.

473
00:17:14,538 --> 00:17:14,848
Yeah,

474
00:17:15,058 --> 00:17:15,739
so and additionally,

475
00:17:15,779 --> 00:17:18,328
if he just jumped around to random order,

476
00:17:18,618 --> 00:17:20,659
then you might get lucky and it might be in the very first one,

477
00:17:20,749 --> 00:17:22,568
might have taken fewer steps ultimately,

478
00:17:22,659 --> 00:17:22,968
but

479
00:17:23,178 --> 00:17:25,009
presumably you're going to have to then keep track

480
00:17:25,009 --> 00:17:27,298
of like which locker doors have you opened.

481
00:17:27,338 --> 00:17:29,458
So that's going to take some memory or space.

482
00:17:29,659 --> 00:17:30,979
Not a big deal with 7 lockers,

483
00:17:31,019 --> 00:17:32,130
but if 70 lockers,

484
00:17:32,170 --> 00:17:33,170
700 lockers,

485
00:17:33,319 --> 00:17:35,560
even random probably isn't going to be the best job.

486
00:17:35,689 --> 00:17:38,589
So let me go ahead and take the mic away and hand it over to Caitlin.

487
00:17:38,650 --> 00:17:39,609
You can stay on the stage with us.

488
00:17:39,729 --> 00:17:40,069
Caitlin,

489
00:17:40,369 --> 00:17:42,250
what I'd like you to do is approach this a

490
00:17:42,250 --> 00:17:45,930
little more intelligently by dividing and conquering the problem,

491
00:17:46,010 --> 00:17:47,839
but we're going to give you an advantage over Jose.

492
00:17:48,020 --> 00:17:49,800
Kelly has kindly sorted

493
00:17:50,000 --> 00:17:53,839
the numbers from smallest to largest from left to right.

494
00:17:54,329 --> 00:17:54,849
So accordingly,

495
00:17:54,890 --> 00:17:56,119
what's your strategy going to be?

496
00:17:56,530 --> 00:17:57,719
Start in the middle,

497
00:17:57,810 --> 00:17:58,010
OK,

498
00:17:58,130 --> 00:17:58,530
please.

499
00:18:00,569 --> 00:18:03,349
And go ahead as before and reveal to the audience what you found,

500
00:18:03,920 --> 00:18:04,400
not the 50,

501
00:18:04,479 --> 00:18:04,760
the 20,

502
00:18:04,800 --> 00:18:05,319
but what do you know,

503
00:18:05,400 --> 00:18:05,680
Caitlin,

504
00:18:05,719 --> 00:18:06,170
at this point?

505
00:18:06,229 --> 00:18:06,260
Correct.

506
00:18:09,530 --> 00:18:10,680
So the 20 is going to be to the left.

507
00:18:10,760 --> 00:18:13,989
So where might you go next with this 3 locker problem?

508
00:18:14,079 --> 00:18:15,199
Let me propose that

509
00:18:15,439 --> 00:18:17,660
you maybe go to the middle of

510
00:18:18,160 --> 00:18:18,719
the 3.

511
00:18:19,280 --> 00:18:19,689
There we go,

512
00:18:19,719 --> 00:18:20,650
the middle of the middle.

513
00:18:20,800 --> 00:18:21,989
Like that would have been good,

514
00:18:22,079 --> 00:18:22,709
but let's.

515
00:18:22,800 --> 00:18:23,250
Oh no,

516
00:18:23,560 --> 00:18:23,959
oh no,

517
00:18:24,099 --> 00:18:25,270
it's up 100 instead.

518
00:18:25,359 --> 00:18:25,920
You failed,

519
00:18:26,040 --> 00:18:27,030
but what do you know?

520
00:18:27,199 --> 00:18:29,869
It's in the middle that I should have just let you,

521
00:18:29,880 --> 00:18:30,390
but.

522
00:18:31,140 --> 00:18:33,900
Now we have a big round of applause for Kaitlin for having found

523
00:18:34,150 --> 00:18:35,819
the 50 as well.

524
00:18:36,469 --> 00:18:36,949
OK.

525
00:18:38,599 --> 00:18:40,880
So the one catch with this particular demo is that

526
00:18:40,880 --> 00:18:44,170
because they know presumably what monopoly money denominations are,

527
00:18:44,300 --> 00:18:46,890
because we just did this exercise and we had the whole cheat sheet on the board,

528
00:18:46,959 --> 00:18:49,650
you probably had some intuition as to where the 50 was going to be,

529
00:18:49,660 --> 00:18:51,410
even though I was trying to get you to play along.

530
00:18:51,540 --> 00:18:52,339
But in the general case,

531
00:18:52,380 --> 00:18:55,500
if you don't know what the numbers are and that they are the specific denominations,

532
00:18:55,619 --> 00:18:58,530
but you do know that they're going from smallest to largest,

533
00:18:58,739 --> 00:18:59,540
going to the middle,

534
00:18:59,660 --> 00:19:00,339
then the middle of the.

535
00:19:00,439 --> 00:19:00,709
Middle,

536
00:19:00,750 --> 00:19:03,030
then the middle of the middle again and again would have

537
00:19:03,030 --> 00:19:05,270
the effect of starting with a big problem and having it,

538
00:19:05,349 --> 00:19:05,709
having it,

539
00:19:05,750 --> 00:19:08,380
having it just like the phone book as well.

540
00:19:08,630 --> 00:19:10,020
So thanks to you both,

541
00:19:10,069 --> 00:19:12,780
we have these wonderful parting gifts that we found in Harvard Square.

542
00:19:13,079 --> 00:19:13,859
If you like Monopoly,

543
00:19:13,869 --> 00:19:17,780
you'll love the Cambridge edition filled with Harvard Square

544
00:19:18,069 --> 00:19:18,750
name spots.

545
00:19:18,829 --> 00:19:20,150
So thank you to you both,

546
00:19:20,189 --> 00:19:22,180
and a round of applause for our volunteers here.

547
00:19:26,880 --> 00:19:26,900
All right,

548
00:19:27,829 --> 00:19:32,510
so let's see if we can't formalize a little bit these two algorithms known as

549
00:19:32,510 --> 00:19:36,540
linear search insofar as Jose was searching essentially along a line left to right,

550
00:19:36,790 --> 00:19:40,310
and binary search by implying 2 because we were having

551
00:19:40,310 --> 00:19:43,020
that problem in 2 again and again and again.

552
00:19:43,189 --> 00:19:44,030
So for instance.

553
00:19:44,170 --> 00:19:47,260
Linar search from left to right or equivalently right to left,

554
00:19:47,430 --> 00:19:50,430
we could document our pseudo code as follows.

555
00:19:50,510 --> 00:19:52,619
For each door from left to right,

556
00:19:52,949 --> 00:19:55,260
if the 50 is behind the door,

557
00:19:55,469 --> 00:19:56,069
well then we're done.

558
00:19:56,170 --> 00:19:57,150
Just return true.

559
00:19:57,229 --> 00:20:00,260
That's the boolean value which was the goal of this exercise to say yes,

560
00:20:00,430 --> 00:20:01,229
here is the 50.

561
00:20:01,880 --> 00:20:02,770
Otherwise,

562
00:20:02,849 --> 00:20:04,599
at the very bottom of this pseudo code,

563
00:20:04,609 --> 00:20:08,160
we could just say return false because if you get all the way through

564
00:20:08,160 --> 00:20:12,119
the lockers and you have never once declared true by finding the 50,

565
00:20:12,160 --> 00:20:14,719
you might as well default at the very end to saying false,

566
00:20:14,800 --> 00:20:15,869
I did not find it.

567
00:20:16,040 --> 00:20:16,630
But notice here,

568
00:20:16,640 --> 00:20:18,800
just like in week zero when we talked about pseudo code for.

569
00:20:18,890 --> 00:20:19,609
Searching the phone book,

570
00:20:19,800 --> 00:20:23,150
my indentation of all things is actually very intentional.

571
00:20:23,520 --> 00:20:24,869
This version of this code

572
00:20:25,239 --> 00:20:26,430
would be wrong

573
00:20:26,719 --> 00:20:31,790
if I instead used our old friend if else and made this conditional decision.

574
00:20:31,920 --> 00:20:34,469
Why is this code now in red wrong

575
00:20:34,959 --> 00:20:35,739
in terms of correctness?

576
00:20:35,800 --> 00:20:36,150
Yeah.

577
00:20:38,989 --> 00:20:39,400
Exactly,

578
00:20:39,640 --> 00:20:42,550
because if the number 50 is not behind the first door,

579
00:20:42,709 --> 00:20:45,400
the E is telling you right then and there return false.

580
00:20:45,439 --> 00:20:46,790
But as we've seen in C code,

581
00:20:46,920 --> 00:20:49,709
whenever you return a value like that's it for the function,

582
00:20:49,719 --> 00:20:51,189
it is done doing its work.

583
00:20:51,359 --> 00:20:53,069
And so if you return false right away,

584
00:20:53,250 --> 00:20:55,109
not having looked at the other six lockers,

585
00:20:55,239 --> 00:20:56,910
you may very well get the answer wrong.

586
00:20:56,959 --> 00:20:58,640
So the first version of the code where there

587
00:20:58,640 --> 00:21:01,719
wasn't an L but rather this implicit line of

588
00:21:01,719 --> 00:21:04,829
code at the or this explicit line of code at the very end that just says if you.

589
00:21:04,891 --> 00:21:07,131
Reach this line of code returned false,

590
00:21:07,322 --> 00:21:08,562
that addresses that problem.

591
00:21:08,602 --> 00:21:09,241
And to be clear,

592
00:21:09,482 --> 00:21:14,791
even though it's right after an indented return true when you return a value as in C,

593
00:21:15,082 --> 00:21:17,871
that's it like execution stops at that point,

594
00:21:17,921 --> 00:21:21,151
at least for the function or in this case the pseudo code in question.

595
00:21:21,482 --> 00:21:21,641
All right,

596
00:21:21,722 --> 00:21:25,322
so here's a more computer sciencey way of describing the same algorithm

597
00:21:25,322 --> 00:21:27,281
and even though it starts to look a little more arcane,

598
00:21:27,362 --> 00:21:29,362
the reality is when you start using variables

599
00:21:29,362 --> 00:21:30,881
and sort of standard notation you can actually.

600
00:21:30,973 --> 00:21:33,313
Express yourself much more clearly and precisely,

601
00:21:33,364 --> 00:21:35,913
even though it might take a little bit of practice to get used to.

602
00:21:36,163 --> 00:21:37,693
Here is how a computer scientist would

603
00:21:37,693 --> 00:21:40,524
express that exact same ideas instead of saying

604
00:21:40,524 --> 00:21:44,083
for each door from left to right we might throw some numbers on the table.

605
00:21:44,203 --> 00:21:45,014
So for I,

606
00:21:45,163 --> 00:21:49,323
a variable apparently from the value zero on up through the

607
00:21:49,323 --> 00:21:52,683
value and minus 1 is what this shorthand notation means.

608
00:21:52,843 --> 00:21:55,693
If 50 is behind doors bracket I,

609
00:21:55,823 --> 00:21:56,514
so to speak,

610
00:21:56,644 --> 00:21:56,963
so now.

611
00:21:57,056 --> 00:22:02,436
Sort of treating the notion of doors as an array using our notation from last week.

612
00:22:02,765 --> 00:22:05,436
If 50 is behind doors bracket I return true.

613
00:22:05,725 --> 00:22:06,225
Otherwise,

614
00:22:06,286 --> 00:22:10,145
if you get through the entirety of that array of doors,

615
00:22:10,156 --> 00:22:11,995
you can still return false.

616
00:22:12,166 --> 00:22:16,485
Now notice here N minus 1 seems a little weird because aren't there end doors?

617
00:22:16,686 --> 00:22:20,416
Why do I want to go from 0 to N minus 1 instead of 0 to end?

618
00:22:20,485 --> 00:22:20,906
Yeah.

619
00:22:21,446 --> 00:22:22,965
Because um 0 is the first.

620
00:22:23,599 --> 00:22:23,920
Exactly,

621
00:22:24,000 --> 00:22:26,719
if you start counting at 0 and you have n elements,

622
00:22:26,800 --> 00:22:29,560
the last one is going to be addressed as n minus 1,

623
00:22:29,599 --> 00:22:30,219
not N,

624
00:22:30,520 --> 00:22:31,199
because if it were N,

625
00:22:31,280 --> 00:22:33,680
then you actually have N + 1 elements,

626
00:22:33,719 --> 00:22:34,890
which is not what we're talking about.

627
00:22:35,000 --> 00:22:35,479
So again,

628
00:22:35,520 --> 00:22:38,280
just a standard notation and it's a little terser this way.

629
00:22:38,319 --> 00:22:41,869
It's a little more succinct and frankly it's a little more adaptable to code.

630
00:22:42,000 --> 00:22:43,119
And so what you're going to find is

631
00:22:43,119 --> 00:22:46,540
that as our problem sets and programming challenges.

632
00:22:46,597 --> 00:22:48,376
We assign sort of get a little more involved.

633
00:22:48,427 --> 00:22:53,337
It's often helpful to write out pseudo code like this using an amalgam of English,

634
00:22:53,467 --> 00:22:53,996
and C,

635
00:22:54,116 --> 00:22:55,526
and eventually Python code,

636
00:22:55,587 --> 00:22:58,866
because then it's way easier after to just translate your pseudo code

637
00:22:58,866 --> 00:23:02,366
into actual code if you're operating at this level of detail.

638
00:23:02,666 --> 00:23:02,937
All right,

639
00:23:02,987 --> 00:23:06,516
so in the second algorithm where Caitlin kindly searched for 50 again,

640
00:23:06,666 --> 00:23:09,666
but Kelly gave her the advantage of sorting the numbers.

641
00:23:09,744 --> 00:23:12,933
Advance now she doesn't have to just resort to brute force,

642
00:23:12,973 --> 00:23:13,484
so to speak,

643
00:23:13,614 --> 00:23:15,734
trying all possible doors from left to right.

644
00:23:16,014 --> 00:23:17,604
She can be a little more intelligent about it

645
00:23:17,604 --> 00:23:19,833
and pick and choose the locker she opens.

646
00:23:19,894 --> 00:23:21,793
And so with binary search as we call that,

647
00:23:21,854 --> 00:23:24,254
we could implement the same pseudo code or we

648
00:23:24,254 --> 00:23:26,973
could implement pseudo code for it as follows.

649
00:23:27,053 --> 00:23:30,244
We might say if 50 is behind the middle door,

650
00:23:30,534 --> 00:23:31,004
then

651
00:23:31,254 --> 00:23:32,563
go ahead and return true.

652
00:23:32,890 --> 00:23:34,561
Else if it's not behind the middle door,

653
00:23:34,640 --> 00:23:36,911
but 50 is less than that number

654
00:23:37,230 --> 00:23:38,151
behind the middle door,

655
00:23:38,321 --> 00:23:41,360
we want to go and search the left half so that

656
00:23:41,360 --> 00:23:44,321
didn't happen in Caitlin's sense because we ended up going right,

657
00:23:44,360 --> 00:23:45,750
so that's just another branch here.

658
00:23:45,961 --> 00:23:48,791
LA 50 is greater than what was at the middle door.

659
00:23:49,000 --> 00:23:51,470
We want to search the right half,

660
00:23:51,921 --> 00:23:55,130
but there's going to be one other condition here that we should probably consider,

661
00:23:55,161 --> 00:23:55,880
which is what?

662
00:23:56,949 --> 00:23:57,660
Is it here,

663
00:23:57,739 --> 00:23:58,609
is it to the left,

664
00:23:58,780 --> 00:23:59,729
or is it to the right?

665
00:24:00,410 --> 00:24:03,199
But there's another a corner case that we'd better.

666
00:24:04,219 --> 00:24:05,250
Keep track of

667
00:24:05,540 --> 00:24:06,650
what else could happen

668
00:24:08,020 --> 00:24:09,969
if it's not in the ray or really like we're out

669
00:24:09,969 --> 00:24:12,290
of doors so we can implement this in a different way.

670
00:24:12,380 --> 00:24:14,530
I left myself some space at the top because

671
00:24:14,739 --> 00:24:18,250
I shouldn't do any of this if there are no doors to search for,

672
00:24:18,260 --> 00:24:20,339
so I should have this sort of sanity check whereby if

673
00:24:20,339 --> 00:24:22,969
there's no doors left or no doors to begin with,

674
00:24:23,140 --> 00:24:24,939
let's just immediately return false.

675
00:24:25,020 --> 00:24:25,859
And why is that?

676
00:24:25,979 --> 00:24:26,099
Well,

677
00:24:26,180 --> 00:24:29,430
notice that when I say search left half and search right half,

678
00:24:29,660 --> 00:24:31,619
this is implicitly telling me just do.

679
00:24:31,739 --> 00:24:32,380
This again,

680
00:24:32,530 --> 00:24:33,280
just do this again,

681
00:24:33,349 --> 00:24:35,239
but with fewer and fewer doors,

682
00:24:35,250 --> 00:24:37,329
and this is a technique for solving

683
00:24:37,329 --> 00:24:38,930
problems and implementing algorithms that we're going

684
00:24:38,930 --> 00:24:41,290
to end today's discussion on because what

685
00:24:41,290 --> 00:24:43,489
seems very colloquial and very straightforward,

686
00:24:43,569 --> 00:24:43,689
OK,

687
00:24:43,849 --> 00:24:44,530
search the left half,

688
00:24:44,650 --> 00:24:45,290
search the right half,

689
00:24:45,449 --> 00:24:47,890
is actually a very powerful programming technique that's going

690
00:24:47,890 --> 00:24:49,369
to enable us to write more elegant code,

691
00:24:49,609 --> 00:24:50,479
sometimes less code,

692
00:24:50,650 --> 00:24:53,319
to solve problems such as this and more on that

693
00:24:53,530 --> 00:24:54,839
in just a little bit.

694
00:24:55,040 --> 00:24:58,369
But how can we Now formalize this using some of our array notation.

695
00:24:58,410 --> 00:24:58,489
Well,

696
00:24:58,530 --> 00:24:59,930
it looks a little more complicated,

697
00:25:00,010 --> 00:25:01,119
but it isn't really.

698
00:25:01,329 --> 00:25:03,650
Instead of asking questions in English alone,

699
00:25:03,739 --> 00:25:06,959
I might say if 50 is behind doors bracket middle.

700
00:25:07,209 --> 00:25:09,489
This soda code presupposes that I did some

701
00:25:09,489 --> 00:25:12,439
math and figured out what the numeric address,

702
00:25:12,510 --> 00:25:15,770
the numeric index is of the middle element and how can I do that?

703
00:25:15,930 --> 00:25:15,969
Well,

704
00:25:16,010 --> 00:25:18,689
if I've got 7 doors and I divide by 2,

705
00:25:18,770 --> 00:25:19,449
what's that?

706
00:25:19,459 --> 00:25:20,849
7 divide by 2.

707
00:25:22,109 --> 00:25:23,219
3.5,

708
00:25:23,280 --> 00:25:26,319
3.5 makes no sense if I'm using integers to address this,

709
00:25:26,400 --> 00:25:27,920
so maybe we just round down,

710
00:25:27,959 --> 00:25:28,709
so 3,

711
00:25:28,880 --> 00:25:32,790
so that would be locker number 0123,

712
00:25:33,160 --> 00:25:36,040
which indeed if you look at the seven lockers is in fact the middle.

713
00:25:36,119 --> 00:25:39,280
So this is to say using some relatively simple arithmetic,

714
00:25:39,319 --> 00:25:41,469
I can figure out what the address is,

715
00:25:41,500 --> 00:25:43,319
the index is of the middle door.

716
00:25:43,599 --> 00:25:46,180
How many there are and I divide by 2 and round down.

717
00:25:46,390 --> 00:25:46,959
Meanwhile,

718
00:25:47,229 --> 00:25:49,300
if I don't find 50 behind the middle door,

719
00:25:49,430 --> 00:25:50,189
let's ask the question.

720
00:25:50,229 --> 00:25:53,739
If 50 is less than the value at the middle door,

721
00:25:53,989 --> 00:25:55,459
then let's search,

722
00:25:55,959 --> 00:25:58,859
not the left half per se in the general sense,

723
00:25:58,949 --> 00:26:03,800
more specifically search doors 0 through doors bracket

724
00:26:04,189 --> 00:26:04,989
middle minus 1.

725
00:26:05,750 --> 00:26:06,540
Otherwise,

726
00:26:06,670 --> 00:26:09,300
if 50 is greater than the value at the middle door,

727
00:26:09,469 --> 00:26:15,560
go ahead and search doors bracket middle plus 1 through doors bracket and minus 1.

728
00:26:15,869 --> 00:26:17,170
Now let's consider these in turn.

729
00:26:17,270 --> 00:26:18,800
So searching the left half,

730
00:26:18,869 --> 00:26:20,260
as we described this earlier,

731
00:26:20,630 --> 00:26:23,829
seems to line up with this idea like start start searching from doors

732
00:26:24,089 --> 00:26:24,430
0,

733
00:26:24,469 --> 00:26:25,619
the very first one,

734
00:26:25,910 --> 00:26:27,140
but why are we searching

735
00:26:27,469 --> 00:26:28,369
doors

736
00:26:28,869 --> 00:26:32,619
bracket middle minus 1 instead of doors bracket middle?

737
00:26:33,849 --> 00:26:34,689
Yeah.

738
00:26:35,920 --> 00:26:36,079
Yeah,

739
00:26:36,500 --> 00:26:36,680
exactly.

740
00:26:36,719 --> 00:26:39,349
We already checked the middle door by asking this previous question,

741
00:26:39,439 --> 00:26:42,160
so you're just wasting everyone's time if you divide the

742
00:26:42,160 --> 00:26:45,910
half and still consider that door as checkable again.

743
00:26:46,040 --> 00:26:46,750
And same thing here.

744
00:26:46,810 --> 00:26:48,260
We check middle + 1

745
00:26:48,640 --> 00:26:50,579
through the end of the locker's array

746
00:26:50,930 --> 00:26:52,280
because we already checked the middle one.

747
00:26:52,319 --> 00:26:53,030
So same reason,

748
00:26:53,040 --> 00:26:55,709
even though it just kind of complicates the look of the math,

749
00:26:55,839 --> 00:26:58,079
but it's really just using variables and arithmetic

750
00:26:58,079 --> 00:27:01,349
to describe the locations of these same lockers.

751
00:27:01,560 --> 00:27:02,160
But let's consider.

752
00:27:02,248 --> 00:27:04,157
Now what we mean by running time,

753
00:27:04,238 --> 00:27:06,468
the amount of time it takes for an algorithm to run,

754
00:27:06,637 --> 00:27:08,708
and consider which and why

755
00:27:09,078 --> 00:27:11,667
one of these algorithms is better than the other.

756
00:27:11,878 --> 00:27:12,868
So in general,

757
00:27:13,037 --> 00:27:14,008
when talking about running time,

758
00:27:14,037 --> 00:27:15,427
we can actually use pictures like this.

759
00:27:15,437 --> 00:27:17,157
This is not going to be some like very low

760
00:27:17,157 --> 00:27:19,598
level mathematical analysis where we count up lots of values.

761
00:27:19,637 --> 00:27:22,838
It's going to be broad strokes so that we can communicate to colleagues,

762
00:27:23,277 --> 00:27:24,297
to other humans,

763
00:27:24,397 --> 00:27:24,947
generally,

764
00:27:24,998 --> 00:27:28,557
whether an algorithm is better than another and how you might compare the two.

765
00:27:29,036 --> 00:27:33,475
So here for instance is a pictorial analysis of two different algorithms the

766
00:27:33,475 --> 00:27:37,546
phone book from week zero and then the attendance taking from today itself.

767
00:27:37,956 --> 00:27:38,985
And let's generally,

768
00:27:38,995 --> 00:27:39,715
as we've done before,

769
00:27:39,796 --> 00:27:40,676
sort of label these things.

770
00:27:40,755 --> 00:27:44,595
So the very first algorithm took end steps in the very worst case if I had

771
00:27:44,595 --> 00:27:47,345
to search the whole phone book or if I had to count everyone in the room.

772
00:27:47,515 --> 00:27:49,625
So the first algorithm took indeed end steps.

773
00:27:49,715 --> 00:27:52,316
The second algorithm took half as many plus 1 maybe,

774
00:27:52,395 --> 00:27:53,345
but we'll keep it simple.

775
00:27:53,515 --> 00:27:54,845
So we'll call that N over 2.

776
00:27:55,124 --> 00:27:57,994
The third and final algorithm both in week 0 with the phone

777
00:27:57,994 --> 00:28:01,943
book and today with attendance is technically logbase 2 of N.

778
00:28:02,114 --> 00:28:03,713
And if you're a little rusty in your logarithms,

779
00:28:03,754 --> 00:28:04,303
that's fine.

780
00:28:04,453 --> 00:28:09,223
Just take on faith that logba 2 alludes to taking a problem of size N

781
00:28:09,504 --> 00:28:12,604
and dividing it in half and half and half as many times as you can

782
00:28:12,864 --> 00:28:16,663
until you're left with one person standing or one page in the phone book.

783
00:28:16,713 --> 00:28:18,543
That's how many times you can divide in half

784
00:28:18,754 --> 00:28:19,904
a problem of size N.

785
00:28:20,394 --> 00:28:20,514
Well,

786
00:28:20,524 --> 00:28:22,271
it turns out that we're a little more

787
00:28:22,271 --> 00:28:25,222
detailed than most computer scientists care to get

788
00:28:25,832 --> 00:28:26,881
when describing

789
00:28:27,062 --> 00:28:28,871
the efficiency of algorithms.

790
00:28:28,991 --> 00:28:32,232
So in fact we're going to start to use some notation.

791
00:28:32,602 --> 00:28:35,112
Instead of worrying precisely mathematically about how many

792
00:28:35,112 --> 00:28:37,182
steps today's and the future's algorithms take,

793
00:28:37,261 --> 00:28:41,501
we're going to talk in broader strokes about how many steps there are on the order of,

794
00:28:41,511 --> 00:28:43,862
and we're going to use what's called big O notation,

795
00:28:44,031 --> 00:28:46,972
which literally is like a big O and then some parentheses,

796
00:28:47,041 --> 00:28:47,871
and you pronounce it big.

797
00:28:48,069 --> 00:28:48,560
of

798
00:28:48,949 --> 00:28:49,550
such and such.

799
00:28:49,630 --> 00:28:52,430
So the first algorithm seems to be in big O of n,

800
00:28:52,550 --> 00:28:53,140
which means

801
00:28:53,790 --> 00:28:55,689
it's on the order of N steps,

802
00:28:55,750 --> 00:28:56,810
give or take some.

803
00:28:57,229 --> 00:28:58,540
This algorithm here,

804
00:28:58,550 --> 00:29:00,540
you might be inclined to do something similar.

805
00:29:00,750 --> 00:29:02,880
It's on the order of N divided by 2 steps,

806
00:29:02,910 --> 00:29:06,390
and this one's on the order of log based 2 of N steps,

807
00:29:06,510 --> 00:29:08,500
but it turns out what we really care about

808
00:29:08,709 --> 00:29:10,560
with algorithms is how

809
00:29:10,869 --> 00:29:11,859
the time

810
00:29:12,310 --> 00:29:14,310
grows as the problem it.

811
00:29:14,437 --> 00:29:15,797
Self grows in size.

812
00:29:15,907 --> 00:29:17,297
So the bigger end gets,

813
00:29:17,348 --> 00:29:20,797
the more concerned we are over how efficient our algorithm is.

814
00:29:21,027 --> 00:29:23,508
If only because today's computers are so darn fast,

815
00:29:23,628 --> 00:29:26,897
whether you're crunching 1000 numbers or 2000 numbers,

816
00:29:27,027 --> 00:29:29,218
like it's going to take like a split second no matter what.

817
00:29:29,427 --> 00:29:31,108
But if you're crunching 1000 numbers versus

818
00:29:31,108 --> 00:29:32,988
a million numbers versus a billion numbers,

819
00:29:33,027 --> 00:29:36,348
like that's where things start to actually be noticeable by us

820
00:29:36,348 --> 00:29:38,588
humans and we really start to care about these values.

821
00:29:38,628 --> 00:29:39,417
So in general,

822
00:29:39,588 --> 00:29:40,657
when using big O.

823
00:29:41,306 --> 00:29:41,895
like this,

824
00:29:42,115 --> 00:29:46,105
you ignore lower order terms or equivalently you only worry about

825
00:29:46,105 --> 00:29:49,975
the dominant term in whatever mathematical expression is in question.

826
00:29:50,105 --> 00:29:51,816
So big event remains big event.

827
00:29:52,026 --> 00:29:53,345
big O of N over 2,

828
00:29:53,826 --> 00:29:56,135
it's the same thing really as like big O over n.

829
00:29:56,265 --> 00:29:57,456
Like it's not really,

830
00:29:57,906 --> 00:29:58,296
but

831
00:29:58,505 --> 00:30:00,145
they're both linear in nature.

832
00:30:00,225 --> 00:30:01,186
One grows at this rate,

833
00:30:01,245 --> 00:30:02,546
one grows at this rate instead,

834
00:30:02,615 --> 00:30:04,615
but it's for all intents and purposes the same.

835
00:30:04,706 --> 00:30:07,186
They're both growing at a constant rate.

836
00:30:07,569 --> 00:30:12,040
This one too uh it's on the order of log of n where the base is who cares?

837
00:30:12,089 --> 00:30:12,800
In short,

838
00:30:13,050 --> 00:30:13,849
what does this really mean?

839
00:30:13,969 --> 00:30:14,010
Well,

840
00:30:14,209 --> 00:30:18,319
imagine in your mind's eye that we were about to zoom out on this graph

841
00:30:18,569 --> 00:30:22,239
such that instead of going from 0 to like a million,

842
00:30:22,410 --> 00:30:24,920
maybe now the x axis is 0 to a billion,

843
00:30:25,050 --> 00:30:27,199
and same thing for the y axis 0 to a million.

844
00:30:27,270 --> 00:30:28,250
Let's zoom out so you're seeing.

845
00:30:28,395 --> 00:30:29,505
0 to a billion.

846
00:30:29,656 --> 00:30:29,696
Well,

847
00:30:29,735 --> 00:30:30,416
in your mind's eye,

848
00:30:30,495 --> 00:30:32,245
you might imagine that as you zoom out,

849
00:30:32,615 --> 00:30:35,696
essentially things just get more and more compressed visually

850
00:30:35,696 --> 00:30:36,855
because you're zooming out and out and out,

851
00:30:36,895 --> 00:30:38,456
but these things still look like straight lines.

852
00:30:38,576 --> 00:30:40,296
This thing still looks like curved lines,

853
00:30:40,416 --> 00:30:43,156
which is to say as n gets large,

854
00:30:43,576 --> 00:30:44,975
clearly this green algorithm,

855
00:30:45,056 --> 00:30:45,776
whatever it is,

856
00:30:45,855 --> 00:30:46,686
is more appealing,

857
00:30:46,696 --> 00:30:47,446
it would seem

858
00:30:47,776 --> 00:30:49,056
than either of these two.

859
00:30:49,232 --> 00:30:52,302
Algorithms and if we keep zooming out like at some point the ink is going to be

860
00:30:52,302 --> 00:30:54,362
so close together that they all are for all

861
00:30:54,362 --> 00:30:56,781
intents and purposes pretty much the same algorithm.

862
00:30:56,862 --> 00:31:00,501
So this is to say computer scientists don't care about lower order

863
00:31:00,501 --> 00:31:03,552
terms like divide by 2 or base 2 or anything like that.

864
00:31:03,641 --> 00:31:07,651
We look at the most dominant term that really matters is N gets bigger and bigger.

865
00:31:07,862 --> 00:31:09,982
So that then is big O notation.

866
00:31:10,579 --> 00:31:11,060
And

867
00:31:11,260 --> 00:31:14,329
it's something we'll start to use pretty much recurringly any time we

868
00:31:14,329 --> 00:31:17,729
analyze or speak to how good or how bad some algorithm is.

869
00:31:17,859 --> 00:31:20,300
So here's a little cheat sheet of common running times.

870
00:31:20,420 --> 00:31:21,140
So for instance,

871
00:31:21,219 --> 00:31:22,739
here's our friend big O of N,

872
00:31:22,780 --> 00:31:25,300
which means the algorithm takes on the order of end steps.

873
00:31:25,780 --> 00:31:28,380
Here is one that takes on the order of log N steps.

874
00:31:28,500 --> 00:31:29,890
Here are some others we haven't seen yet.

875
00:31:30,060 --> 00:31:32,550
Some algorithms take n times logn steps.

876
00:31:32,805 --> 00:31:35,114
Some algorithms take squared steps,

877
00:31:35,125 --> 00:31:37,714
and some algorithms just take one step,

878
00:31:38,005 --> 00:31:38,244
maybe,

879
00:31:38,285 --> 00:31:40,165
or maybe 2 steps or 4 steps or 10,

880
00:31:40,364 --> 00:31:42,474
but a constant number of steps.

881
00:31:42,805 --> 00:31:43,444
So let me ask,

882
00:31:43,525 --> 00:31:45,875
if the algorithms we've looked at thus far,

883
00:31:46,125 --> 00:31:46,775
for instance,

884
00:31:46,925 --> 00:31:49,435
linear search being the very first today,

885
00:31:49,844 --> 00:31:52,474
what is the running time of linear search

886
00:31:52,805 --> 00:31:54,805
in big O notation?

887
00:31:55,510 --> 00:31:56,030
That is to say,

888
00:31:56,069 --> 00:31:57,229
if there's people,

889
00:31:57,390 --> 00:31:59,380
or if there's N lockers on the stage,

890
00:31:59,910 --> 00:32:04,260
how many steps might it take us to find a number among those

891
00:32:04,430 --> 00:32:05,069
N

892
00:32:05,430 --> 00:32:06,140
lockers?

893
00:32:06,310 --> 00:32:07,260
They go of,

894
00:32:07,390 --> 00:32:07,630
yeah.

895
00:32:09,000 --> 00:32:12,650
Big O of N in fact is exactly where I would put linear search.

896
00:32:12,790 --> 00:32:13,160
Why?

897
00:32:13,310 --> 00:32:13,430
Well,

898
00:32:13,510 --> 00:32:16,459
if you're using linear search in the very worst case,

899
00:32:16,520 --> 00:32:17,109
for instance,

900
00:32:17,150 --> 00:32:18,109
the number you're looking for,

901
00:32:18,150 --> 00:32:18,849
as with Jose,

902
00:32:19,030 --> 00:32:20,270
might be all the way at the end.

903
00:32:20,390 --> 00:32:21,380
So you might get lucky.

904
00:32:21,430 --> 00:32:22,859
It might not be at the very end,

905
00:32:23,030 --> 00:32:25,910
but generally it's useful to use this big O notation

906
00:32:25,910 --> 00:32:29,510
in the context of worst case scenarios because that really gives

907
00:32:29,510 --> 00:32:32,589
you a sense of how badly this algorithm could perform

908
00:32:32,589 --> 00:32:35,189
if you just get really unlucky with your data set.

909
00:32:35,550 --> 00:32:38,709
So even though BigO really just refers to an upper bound,

910
00:32:38,790 --> 00:32:40,619
like how many steps might it take,

911
00:32:40,699 --> 00:32:42,270
it's generally useful to think about it in

912
00:32:42,270 --> 00:32:44,069
the context of like the worst case scenario,

913
00:32:44,109 --> 00:32:44,219
like,

914
00:32:44,280 --> 00:32:44,390
ah,

915
00:32:44,510 --> 00:32:46,939
the number I care about is actually way over here.

916
00:32:47,150 --> 00:32:48,619
But what about binary search?

917
00:32:49,550 --> 00:32:51,290
Even in the worst case,

918
00:32:51,630 --> 00:32:52,910
so long as the data is sorted,

919
00:32:52,959 --> 00:32:55,800
how many steps might binary search take by contrast?

920
00:32:56,699 --> 00:32:57,670
Big O of log in.

921
00:32:57,829 --> 00:32:59,579
So binary search we're going to put here,

922
00:32:59,670 --> 00:33:01,000
which is to say that in general,

923
00:33:01,079 --> 00:33:02,979
and especially as N gets large,

924
00:33:03,069 --> 00:33:04,670
binary search is much faster.

925
00:33:04,709 --> 00:33:05,859
It takes much less time.

926
00:33:05,910 --> 00:33:06,270
Why?

927
00:33:06,510 --> 00:33:08,260
Because assuming the numbers are sorted,

928
00:33:08,390 --> 00:33:10,640
you will be dividing in half and half and half,

929
00:33:10,829 --> 00:33:12,380
just like with the phone book in week 0,

930
00:33:12,430 --> 00:33:13,089
that problem,

931
00:33:13,109 --> 00:33:14,660
and you will get to your solution

932
00:33:14,989 --> 00:33:15,790
much faster.

933
00:33:16,560 --> 00:33:18,750
Why should you not use binary search though

934
00:33:19,119 --> 00:33:22,589
on an unsorted array of lockers?

935
00:33:23,630 --> 00:33:24,709
Like a random

936
00:33:31,250 --> 00:33:31,290
set of numbers,

937
00:33:31,300 --> 00:33:31,310
yeah.

938
00:33:31,810 --> 00:33:32,260
Exactly,

939
00:33:32,380 --> 00:33:35,969
you're making these decisions based on inequalities less than or greater than,

940
00:33:36,219 --> 00:33:38,050
but based on like no rhyme or reason.

941
00:33:38,099 --> 00:33:39,300
You're going left going right,

942
00:33:39,420 --> 00:33:41,540
but there's no reason to believe that smaller numbers

943
00:33:41,540 --> 00:33:43,099
are this way and bigger numbers are that way.

944
00:33:43,180 --> 00:33:45,969
So you're just making incorrect decision after incorrect decision,

945
00:33:46,140 --> 00:33:48,020
so you're probably going to miss the number altogether.

946
00:33:48,099 --> 00:33:50,859
So binary search on an unsorted array is just incorrect,

947
00:33:50,949 --> 00:33:52,300
incorrect usage of the algorithm.

948
00:33:52,339 --> 00:33:53,380
But like Kelly did,

949
00:33:53,459 --> 00:33:56,250
if you sort the data in advance or you're handed sorted data,

950
00:33:56,459 --> 00:33:59,939
well then you can in fact apply binary search perfectly and much more efficiently.

951
00:34:03,520 --> 00:34:04,380
Sure there is more efficient.

952
00:34:07,180 --> 00:34:07,780
Absolutely.

953
00:34:07,880 --> 00:34:12,679
Is Linear search sometimes more efficient if it's going to take you more time

954
00:34:12,899 --> 00:34:15,330
to sort the data and then use binary search?

955
00:34:15,580 --> 00:34:16,050
Absolutely.

956
00:34:16,219 --> 00:34:17,139
And that's going to be one of

957
00:34:17,139 --> 00:34:19,600
the design decisions that underlies any implementation

958
00:34:19,600 --> 00:34:22,370
of an algorithm because if it's going to take you some crazy long time,

959
00:34:22,500 --> 00:34:23,739
not to sort like 7 numbers,

960
00:34:23,860 --> 00:34:24,620
but 70,

961
00:34:24,780 --> 00:34:25,300
700,

962
00:34:25,379 --> 00:34:25,938
7000,

963
00:34:25,978 --> 00:34:26,649
7 million,

964
00:34:26,860 --> 00:34:28,610
but you only need to search the data once,

965
00:34:28,739 --> 00:34:29,820
then what the heck are you doing?

966
00:34:29,899 --> 00:34:31,260
Like why are you wasting time sorting.

967
00:34:31,342 --> 00:34:31,542
Data,

968
00:34:31,612 --> 00:34:33,623
if you only care about getting an answer once,

969
00:34:33,812 --> 00:34:36,252
you might as well just use linear search or heck,

970
00:34:36,333 --> 00:34:39,802
do it even randomly and hope you get lucky if you don't care about reproducing

971
00:34:39,962 --> 00:34:40,762
the same result.

972
00:34:40,902 --> 00:34:41,002
Now,

973
00:34:41,012 --> 00:34:41,413
in general,

974
00:34:41,492 --> 00:34:43,462
that's not how much of the world works.

975
00:34:43,542 --> 00:34:43,933
For instance,

976
00:34:44,052 --> 00:34:48,242
Google's working really hard to make faster and faster algorithms because we

977
00:34:48,242 --> 00:34:52,782
are not searching Google once and then never again doing it.

978
00:34:52,812 --> 00:34:55,452
We're doing it again and again and again so they can amortize.

979
00:34:55,645 --> 00:34:56,083
So to speak,

980
00:34:56,094 --> 00:34:59,915
the cost of sorting data over lots and lots of searches,

981
00:35:00,084 --> 00:35:01,364
but sometimes it's going to be the opposite.

982
00:35:01,445 --> 00:35:02,455
And I think back to graduate school,

983
00:35:02,524 --> 00:35:05,195
where I was often writing code to analyze large sets of data,

984
00:35:05,364 --> 00:35:07,195
and I could have done it the right way,

985
00:35:07,284 --> 00:35:08,485
sort of the CS 50 way,

986
00:35:08,495 --> 00:35:11,604
by fine tuning my algorithm and thinking really hard about my code,

987
00:35:11,614 --> 00:35:12,274
but honestly,

988
00:35:12,645 --> 00:35:15,794
sometimes it was easier to just write really bad but correct code,

989
00:35:16,044 --> 00:35:17,274
go to sleep for 7 hours,

990
00:35:17,324 --> 00:35:19,604
and then my computer would have the answer by morning.

991
00:35:19,879 --> 00:35:20,500
The downside,

992
00:35:20,590 --> 00:35:21,949
as admittedly happened more than once,

993
00:35:22,030 --> 00:35:24,020
is if you have a bug in your code and you go to sleep

994
00:35:24,020 --> 00:35:26,149
and then 7 hours later you find out that there was a bug,

995
00:35:26,189 --> 00:35:27,510
you've just wasted the entire evening,

996
00:35:27,590 --> 00:35:31,060
so there too a trade off sometimes when making those resource decisions.

997
00:35:31,149 --> 00:35:33,189
But that's entirely what today is about making

998
00:35:33,189 --> 00:35:36,540
informed decisions and sometimes maybe it's smarter and wiser

999
00:35:36,790 --> 00:35:38,540
to make the more expensive decision,

1000
00:35:38,550 --> 00:35:39,389
but not unknowingly,

1001
00:35:39,469 --> 00:35:40,590
at least knowingly.

1002
00:35:41,100 --> 00:35:41,340
All right,

1003
00:35:41,540 --> 00:35:44,500
so there we have our first two algorithms,

1004
00:35:44,580 --> 00:35:46,780
but let's consider another way of describing

1005
00:35:47,010 --> 00:35:49,060
the efficiency of an algorithm.

1006
00:35:49,179 --> 00:35:50,929
Big O is an upper bound,

1007
00:35:51,100 --> 00:35:53,189
sort of how bad can it get in these

1008
00:35:53,780 --> 00:35:57,300
cases where maybe the data is really not working to our advantage.

1009
00:35:57,604 --> 00:35:57,975
Omega,

1010
00:35:58,034 --> 00:36:00,995
a capital Omega symbol here is used for lower bounds.

1011
00:36:01,094 --> 00:36:03,635
So maybe how lucky might we get in the best case,

1012
00:36:03,675 --> 00:36:04,304
if you will,

1013
00:36:04,554 --> 00:36:06,705
how few steps might an algorithm take?

1014
00:36:06,875 --> 00:36:06,995
Well,

1015
00:36:07,074 --> 00:36:07,814
in this case here,

1016
00:36:07,824 --> 00:36:10,074
here's just a cheat sheet of common run times,

1017
00:36:10,155 --> 00:36:11,554
even though there's an infinite number of others,

1018
00:36:11,594 --> 00:36:13,824
but we'll generally focus on

1019
00:36:15,675 --> 00:36:16,705
functions like these.

1020
00:36:17,034 --> 00:36:18,715
Let's consider those same algorithms.

1021
00:36:18,794 --> 00:36:21,754
So with linear search from left to right,

1022
00:36:22,034 --> 00:36:24,915
how few steps might that algorithm take?

1023
00:36:26,090 --> 00:36:26,530
For instance,

1024
00:36:26,540 --> 00:36:28,090
in like the best case scenario.

1025
00:36:29,419 --> 00:36:29,590
Yeah,

1026
00:36:29,689 --> 00:36:31,139
is this uh hand about to go up?

1027
00:36:31,570 --> 00:36:31,689
Yeah,

1028
00:36:31,850 --> 00:36:34,010
so one step why because maybe Jose could have

1029
00:36:34,010 --> 00:36:36,100
gotten lucky and opened the door and voila,

1030
00:36:36,290 --> 00:36:37,290
that was the 50.

1031
00:36:37,300 --> 00:36:38,719
It didn't play out that way,

1032
00:36:39,010 --> 00:36:39,969
but it could have.

1033
00:36:40,010 --> 00:36:40,919
In the general case,

1034
00:36:40,969 --> 00:36:43,560
the number you're looking for could very well be at the beginning.

1035
00:36:43,649 --> 00:36:47,120
So we're going to put linear search at omega of 1.

1036
00:36:47,409 --> 00:36:48,449
So one step,

1037
00:36:48,459 --> 00:36:50,469
and maybe it's technically a few more than that,

1038
00:36:50,489 --> 00:36:54,100
but it's a fixed number of steps that Nothing to do with the number of lockers.

1039
00:36:54,219 --> 00:36:54,620
Case in point,

1040
00:36:54,659 --> 00:36:55,550
if I gave you not 7,

1041
00:36:55,620 --> 00:36:56,580
but 70 lockers,

1042
00:36:56,820 --> 00:36:59,330
you could still get lucky and still take just one step.

1043
00:36:59,459 --> 00:37:01,250
So Omega is our lower bound,

1044
00:37:01,459 --> 00:37:03,050
Big O is our upper bound.

1045
00:37:03,419 --> 00:37:03,840
Ah,

1046
00:37:04,000 --> 00:37:05,050
spoiler,

1047
00:37:05,379 --> 00:37:08,870
what is binary search is lower bound.

1048
00:37:09,100 --> 00:37:09,219
Well,

1049
00:37:09,280 --> 00:37:11,330
apparently it's also omega of 1,

1050
00:37:11,340 --> 00:37:12,010
but why?

1051
00:37:12,939 --> 00:37:13,810
That is in fact correct,

1052
00:37:13,929 --> 00:37:14,300
yeah.

1053
00:37:16,489 --> 00:37:18,159
Same reason you could get lucky in the best case,

1054
00:37:18,250 --> 00:37:20,649
and it's just smack dab in the middle of all of the data.

1055
00:37:20,750 --> 00:37:21,040
So

1056
00:37:21,199 --> 00:37:24,540
the fewest number of steps binary search might take is also actually one.

1057
00:37:24,689 --> 00:37:28,360
So this is why we talk about upper bound and lower bound because you get kind of a,

1058
00:37:28,409 --> 00:37:30,239
a sense of the range of performance.

1059
00:37:30,689 --> 00:37:32,199
Sometimes it's going to be super fast,

1060
00:37:32,290 --> 00:37:33,000
which is great,

1061
00:37:33,169 --> 00:37:34,969
but something tells me in the general case we're not

1062
00:37:34,969 --> 00:37:37,239
going to get lucky every time we use an algorithm,

1063
00:37:37,330 --> 00:37:39,689
so it's probably going to be closer to those upper bounds,

1064
00:37:39,729 --> 00:37:40,010
the big.

1065
00:37:40,169 --> 00:37:40,209
Now,

1066
00:37:40,570 --> 00:37:41,250
as an aside,

1067
00:37:41,330 --> 00:37:43,570
there's a 3rd and final symbol that we

1068
00:37:43,570 --> 00:37:45,429
use in computer science to describe algorithms,

1069
00:37:45,489 --> 00:37:46,860
that of a capital theta.

1070
00:37:47,129 --> 00:37:54,159
Capital theta is jargon you can use when big O and Omega happen to be the same,

1071
00:37:54,280 --> 00:37:55,370
and we'll see that today,

1072
00:37:55,449 --> 00:37:56,050
not always,

1073
00:37:56,370 --> 00:37:57,929
but here's a similar cheat sheet.

1074
00:37:58,209 --> 00:38:02,330
None of the algorithms thus far can be described in this way with theta notation

1075
00:38:02,649 --> 00:38:03,929
because they are not all the same.

1076
00:38:04,040 --> 00:38:05,429
With their big O and Omega,

1077
00:38:05,489 --> 00:38:07,870
they differed in both of our analyses,

1078
00:38:07,989 --> 00:38:10,399
but we'll see at least one example of one where it's like,

1079
00:38:10,409 --> 00:38:10,550
OK,

1080
00:38:10,629 --> 00:38:11,679
we can describe this in theta,

1081
00:38:11,709 --> 00:38:14,409
and that's like saying twice as much information with your words

1082
00:38:14,709 --> 00:38:16,870
to another computer scientist rather than giving them

1083
00:38:16,870 --> 00:38:18,550
both the upper and the lower bounds.

1084
00:38:18,669 --> 00:38:21,100
The fancy way of describing all of what we're talking about here,

1085
00:38:21,110 --> 00:38:21,530
big O,

1086
00:38:21,830 --> 00:38:22,439
omega,

1087
00:38:22,510 --> 00:38:23,219
and theta

1088
00:38:23,429 --> 00:38:25,310
is asymptotic notation,

1089
00:38:25,350 --> 00:38:27,719
and asymptotic notation refer or.

1090
00:38:27,959 --> 00:38:33,100
Asymptoticle refers to a value getting bigger and bigger and bigger and bigger

1091
00:38:33,100 --> 00:38:37,719
but not necessarily ever hitting some boundary as N gets very large.

1092
00:38:37,949 --> 00:38:38,330
In short,

1093
00:38:38,409 --> 00:38:42,500
is what we mean when we deploy this here asymptotic notation.

1094
00:38:42,929 --> 00:38:43,239
All right,

1095
00:38:43,469 --> 00:38:47,449
so with the first of these things like linear search,

1096
00:38:47,530 --> 00:38:49,530
let's actually kind of make this a bit more real.

1097
00:38:49,610 --> 00:38:51,729
Let me actually go over to in just a moment.

1098
00:38:52,300 --> 00:38:53,100
Uh my

1099
00:38:53,340 --> 00:38:54,409
other screen here,

1100
00:38:54,580 --> 00:38:54,820
OK,

1101
00:38:54,939 --> 00:38:55,500
in VS code,

1102
00:38:55,540 --> 00:38:57,939
let me go ahead and create a program called Search.c.

1103
00:38:58,260 --> 00:38:59,300
and in search.c,

1104
00:38:59,419 --> 00:39:03,219
let's go ahead and implement a fairly simple version of Linar search initially.

1105
00:39:03,379 --> 00:39:04,489
So let me go ahead and include,

1106
00:39:04,540 --> 00:39:05,090
for instance,

1107
00:39:05,300 --> 00:39:09,169
CS50.h. Let me go ahead and include standardio.h.

1108
00:39:09,500 --> 00:39:11,929
Then let me go ahead and do main void,

1109
00:39:11,939 --> 00:39:14,570
so we're not going to bother with any command line arguments for now.

1110
00:39:14,860 --> 00:39:18,699
And then let me go ahead and just give myself an array of numbers to play with.

1111
00:39:18,794 --> 00:39:21,854
And we did this briefly last week in answer to a question,

1112
00:39:21,945 --> 00:39:24,614
but I'm going to do it now concretely rather than use something

1113
00:39:25,504 --> 00:39:27,844
more manual to get all of these numbers into the array.

1114
00:39:28,024 --> 00:39:30,745
I'm going to say give me an array called numbers,

1115
00:39:30,784 --> 00:39:33,864
and the numbers I want to put in this array initially are

1116
00:39:33,864 --> 00:39:37,145
going to be the exact same denominations we've been playing with 20,

1117
00:39:37,264 --> 00:39:37,864
500,

1118
00:39:37,985 --> 00:39:38,354
10,

1119
00:39:38,385 --> 00:39:38,705
5,

1120
00:39:38,754 --> 00:39:39,304
100,

1121
00:39:39,375 --> 00:39:39,774
1,

1122
00:39:39,945 --> 00:39:40,784
and 50.

1123
00:39:40,945 --> 00:39:41,185
Again,

1124
00:39:41,264 --> 00:39:44,735
this is a notation that I alluded to in answer to a question last week whereby

1125
00:39:44,905 --> 00:39:45,344
if you want.

1126
00:39:45,399 --> 00:39:48,790
To statically initialize an array that is give it all of your

1127
00:39:48,790 --> 00:39:51,979
values up front without having the human type them all in manually.

1128
00:39:52,110 --> 00:39:53,699
You can use curly braces like this,

1129
00:39:53,830 --> 00:39:55,110
and the compiler is pretty smart.

1130
00:39:55,229 --> 00:40:01,550
You don't have to bother telling the compiler how many numbers you want 1234567

1131
00:40:01,550 --> 00:40:04,699
because it can obviously just count how many numbers are in the curly braces,

1132
00:40:04,709 --> 00:40:08,780
but you could explicitly say 7 there so long as you're counting is in fact correct.

1133
00:40:08,989 --> 00:40:11,909
So on line 6 this gives me an array of 7 numbers.

1134
00:40:12,004 --> 00:40:15,715
Initialize to precisely that list of numbers from left to right.

1135
00:40:16,024 --> 00:40:16,114
All right,

1136
00:40:16,195 --> 00:40:18,544
let's ask the human now what number they want to search for,

1137
00:40:18,554 --> 00:40:22,715
just as I did our two volunteers and say in N equals get in,

1138
00:40:23,195 --> 00:40:26,185
then let's just ask the user for the number that they want to search for.

1139
00:40:26,395 --> 00:40:27,985
Then let's implement linear search.

1140
00:40:28,155 --> 00:40:30,205
And if I want to implement linear search in

1141
00:40:30,205 --> 00:40:32,584
terms of the programming constructs we've seen thus far,

1142
00:40:32,834 --> 00:40:33,425
like what

1143
00:40:33,705 --> 00:40:33,995
type,

1144
00:40:34,114 --> 00:40:36,705
what keyword in C should I use?

1145
00:40:37,074 --> 00:40:38,584
What programming technique,

1146
00:40:38,955 --> 00:40:39,354
yeah.

1147
00:40:39,969 --> 00:40:40,159
Yeah,

1148
00:40:40,239 --> 00:40:41,860
so maybe a 4 loop or a Y loop,

1149
00:40:41,889 --> 00:40:44,639
but 4 loop is kind of my go to lately.

1150
00:40:44,679 --> 00:40:48,629
So let's do 4 in I equals 0 because we'll start counting from the left.

1151
00:40:48,840 --> 00:40:50,560
I is less than 7,

1152
00:40:50,639 --> 00:40:52,070
which isn't great to hard code,

1153
00:40:52,120 --> 00:40:53,560
but I'm not going to use the 7 again,

1154
00:40:53,639 --> 00:40:55,669
so I think it's OK in one place for this demo.

1155
00:40:55,889 --> 00:40:56,989
Then I + plus,

1156
00:40:57,159 --> 00:40:58,830
then inside of this array.

1157
00:40:59,409 --> 00:41:02,010
Let's go ahead and ask a question just like Jose was

1158
00:41:02,010 --> 00:41:05,540
by opening each of the doors by saying if numbers 1

1159
00:41:07,000 --> 00:41:10,379
equals equals the number we asked about N,

1160
00:41:10,969 --> 00:41:12,810
well then let's go ahead and print

1161
00:41:12,810 --> 00:41:16,250
out some informative message like found backslashn.

1162
00:41:16,620 --> 00:41:17,790
And then for good measure,

1163
00:41:17,810 --> 00:41:18,530
like last week,

1164
00:41:18,729 --> 00:41:21,199
let's return 0 to signify success.

1165
00:41:21,370 --> 00:41:22,639
It's sort of equivalent

1166
00:41:22,850 --> 00:41:24,010
to returning true,

1167
00:41:24,090 --> 00:41:26,199
but in main recall you have to return an in.

1168
00:41:26,610 --> 00:41:30,669
That's why we revealed at the end of week 2 the return type of main

1169
00:41:30,669 --> 00:41:34,479
is an in because that is what gives the computer its so-called exit status,

1170
00:41:34,610 --> 00:41:36,229
which is zero if all is well,

1171
00:41:36,290 --> 00:41:37,050
or anything other.

1172
00:41:37,246 --> 00:41:38,696
0 if something went wrong,

1173
00:41:38,865 --> 00:41:41,135
but I think finding the number counts is all is well.

1174
00:41:41,426 --> 00:41:44,196
But if we get through that whole loop and

1175
00:41:44,196 --> 00:41:47,105
we still haven't printed found or returned 0,

1176
00:41:47,385 --> 00:41:51,476
I think we can go ahead and safely say not found backslashn,

1177
00:41:51,666 --> 00:41:54,186
and then let's just return 1 as our exit status

1178
00:41:54,186 --> 00:41:56,496
to indicate that we didn't find the actual number.

1179
00:41:56,785 --> 00:41:57,186
So in short,

1180
00:41:57,266 --> 00:42:00,322
I think in See this is linear search.

1181
00:42:00,481 --> 00:42:02,112
Let me open up my terminal window again.

1182
00:42:02,322 --> 00:42:04,471
Let me make search enter.

1183
00:42:04,802 --> 00:42:07,872
Let me do search enter,

1184
00:42:08,082 --> 00:42:08,922
and I'll search for,

1185
00:42:08,961 --> 00:42:09,771
as I asked Jose,

1186
00:42:09,842 --> 00:42:10,602
the number 50,

1187
00:42:10,612 --> 00:42:11,231
and

1188
00:42:11,602 --> 00:42:13,352
we indeed found it at the end.

1189
00:42:13,481 --> 00:42:16,082
Let me go ahead and rerunear and let's search

1190
00:42:16,082 --> 00:42:18,291
for the other number at the beginning 20.

1191
00:42:18,681 --> 00:42:19,832
That then works.

1192
00:42:19,922 --> 00:42:20,951
And just to get crazy,

1193
00:42:21,082 --> 00:42:23,562
let's search for a number we know not to be there like 1000.

1194
00:42:23,770 --> 00:42:24,820
And that in fact

1195
00:42:25,070 --> 00:42:26,060
is not found.

1196
00:42:26,229 --> 00:42:29,350
So I think we have an implementation then of linear search,

1197
00:42:29,469 --> 00:42:31,780
but let me pause here and ask if there's any

1198
00:42:32,310 --> 00:42:33,379
questions

1199
00:42:33,709 --> 00:42:36,790
with this here code and the translation of algorithm to.

1200
00:42:38,030 --> 00:42:38,040
See,

1201
00:42:39,419 --> 00:42:39,620
yeah,

1202
00:42:39,719 --> 00:42:40,290
in the back.

1203
00:42:42,389 --> 00:42:44,340
Why I did not specify the length of the array.

1204
00:42:44,709 --> 00:42:46,340
So it is not necessary

1205
00:42:46,669 --> 00:42:48,100
when declaring an array

1206
00:42:48,389 --> 00:42:48,739
and

1207
00:42:49,070 --> 00:42:53,300
setting it equal to some known values in advance to specify in the square

1208
00:42:53,300 --> 00:42:55,870
brackets how many you have because like the compiler is not an idiot.

1209
00:42:55,919 --> 00:42:57,790
It can literally count the numbers inside.

1210
00:42:57,909 --> 00:43:01,449
Of the curly braces and just infer that value you could put it there,

1211
00:43:01,780 --> 00:43:05,219
but arguably you're opening up the possibility that you're going to

1212
00:43:05,219 --> 00:43:07,659
miscount and you're going to put 7 here but 8 numbers

1213
00:43:07,659 --> 00:43:09,580
over there or 6 numbers there so it's best not to

1214
00:43:09,580 --> 00:43:12,689
tempt fate and just let the compiler do its thing instead.

1215
00:43:12,899 --> 00:43:13,750
A good question.

1216
00:43:14,179 --> 00:43:15,050
Other questions

1217
00:43:15,780 --> 00:43:17,209
on this code so far.

1218
00:43:19,219 --> 00:43:19,939
All right,

1219
00:43:20,100 --> 00:43:20,709
if none,

1220
00:43:21,040 --> 00:43:23,659
let's go ahead and maybe convert this linear

1221
00:43:23,659 --> 00:43:25,649
search to one that's maybe a little more interesting

1222
00:43:25,820 --> 00:43:28,139
that involves like searching for strings of text.

1223
00:43:28,179 --> 00:43:28,580
After all,

1224
00:43:28,689 --> 00:43:30,699
we started the class in week zero by searching

1225
00:43:30,699 --> 00:43:32,699
for names in a phone book like John Harbert.

1226
00:43:32,899 --> 00:43:38,459
Let's see if we can adapt our code for searching for strings instead of integers.

1227
00:43:38,560 --> 00:43:39,810
So in my code here,

1228
00:43:39,820 --> 00:43:41,939
let's go ahead and delete everything inside of

1229
00:43:41,939 --> 00:43:43,780
Maine just to give myself a clean canvas.

1230
00:43:43,962 --> 00:43:45,683
Let me go ahead and give me another array,

1231
00:43:45,782 --> 00:43:46,772
this one called,

1232
00:43:46,982 --> 00:43:50,012
let's just call it strings because that's the goal of this exercise,

1233
00:43:50,183 --> 00:43:52,433
and set them equal to some familiar

1234
00:43:52,782 --> 00:43:55,393
pieces from the game of Monopoly if you might have played.

1235
00:43:55,462 --> 00:43:57,833
So there's like a battleship piece in there.

1236
00:43:58,103 --> 00:43:59,532
There's a boot in there,

1237
00:43:59,653 --> 00:44:01,212
there's a cannon in there,

1238
00:44:01,462 --> 00:44:02,222
an iron,

1239
00:44:02,302 --> 00:44:03,252
a thimble,

1240
00:44:03,603 --> 00:44:04,623
and a top hat,

1241
00:44:04,663 --> 00:44:07,093
though it does vary nowadays based on the addition that you have.

1242
00:44:07,153 --> 00:44:08,252
So kind of a long array,

1243
00:44:08,502 --> 00:44:14,426
but I have 123456 total values in this array of strings.

1244
00:44:14,545 --> 00:44:16,746
Now let's ask the user for a string.

1245
00:44:16,785 --> 00:44:20,025
We'll call it S for short and say with get string,

1246
00:44:20,145 --> 00:44:23,496
what string are you looking for among those 6.

1247
00:44:23,716 --> 00:44:27,186
Then I think we can do a 4 loop again for in I equals 0,

1248
00:44:27,226 --> 00:44:29,535
I less than 6,

1249
00:44:29,666 --> 00:44:30,815
I plus plus,

1250
00:44:30,885 --> 00:44:32,615
and then inside of this loop,

1251
00:44:32,785 --> 00:44:33,936
let's do the same thing

1252
00:44:34,506 --> 00:44:34,976
if

1253
00:44:35,469 --> 00:44:35,899
Uh,

1254
00:44:36,149 --> 00:44:39,870
let's say strings

1255
00:44:40,280 --> 00:44:41,219
bracket i

1256
00:44:41,659 --> 00:44:43,310
equals equals

1257
00:44:43,709 --> 00:44:46,139
the strings that the human typed in.

1258
00:44:46,229 --> 00:44:51,070
I think we can go ahead and say print found backslashn and then as before return.

1259
00:44:51,820 --> 00:44:53,330
0 to signify success,

1260
00:44:53,340 --> 00:44:54,050
and if we don't,

1261
00:44:54,100 --> 00:44:55,629
after that whole 4 loop,

1262
00:44:55,699 --> 00:45:01,540
let's print print F not found backslash and down here and return 1 to signify error.

1263
00:45:01,659 --> 00:45:02,929
So it's really the same

1264
00:45:03,139 --> 00:45:04,409
thing at the moment,

1265
00:45:04,699 --> 00:45:07,459
except that I'm actually using strings instead.

1266
00:45:07,594 --> 00:45:08,304
Integers.

1267
00:45:08,495 --> 00:45:08,584
All right,

1268
00:45:08,625 --> 00:45:11,294
let me go ahead and open up my terminal window again and clear it.

1269
00:45:11,465 --> 00:45:13,024
Let me go ahead and recompile this code.

1270
00:45:13,185 --> 00:45:14,185
MakeSearch.c.

1271
00:45:14,784 --> 00:45:15,864
Seems to compile OK.

1272
00:45:15,985 --> 00:45:20,854
Let me do search and let's go ahead and search for the first one.

1273
00:45:20,985 --> 00:45:23,334
How about battleship enter.

1274
00:45:24,580 --> 00:45:24,600
Huh,

1275
00:45:25,929 --> 00:45:26,360
not found.

1276
00:45:26,449 --> 00:45:26,729
All right.

1277
00:45:26,889 --> 00:45:27,199
Well,

1278
00:45:27,449 --> 00:45:28,889
let's maybe a typo,

1279
00:45:28,969 --> 00:45:29,169
maybe.

1280
00:45:29,209 --> 00:45:30,679
Let me search for something easier to spell,

1281
00:45:30,709 --> 00:45:31,139
boot.

1282
00:45:32,169 --> 00:45:33,090
Not found.

1283
00:45:33,270 --> 00:45:33,699
That's weird.

1284
00:45:33,830 --> 00:45:35,270
Both of those are at the very start of the array.

1285
00:45:35,350 --> 00:45:38,060
Let's do slashear again and search for top hat.

1286
00:45:38,189 --> 00:45:38,669
Enter.

1287
00:45:39,570 --> 00:45:40,669
Not found.

1288
00:45:41,250 --> 00:45:42,510
What is going on?

1289
00:45:42,610 --> 00:45:42,689
Well,

1290
00:45:42,770 --> 00:45:46,159
this isn't actually that obvious as to what I'm doing wrong,

1291
00:45:46,290 --> 00:45:50,909
but it turns out that when we actually compare strings instead of integers and see,

1292
00:45:51,189 --> 00:45:53,409
we're actually going to have to use this other library,

1293
00:45:53,489 --> 00:45:54,260
at least today,

1294
00:45:54,449 --> 00:45:55,969
that we saw briefly last week.

1295
00:45:56,090 --> 00:45:58,840
Last week we introduced it because of a function called Stirling,

1296
00:45:58,969 --> 00:46:00,320
which gives us the length of a string.

1297
00:46:00,520 --> 00:46:01,419
Turns out that string.

1298
00:46:01,770 --> 00:46:04,330
H also comes per its documentation with

1299
00:46:04,330 --> 00:46:06,770
another useful function called Stircom for string.

1300
00:46:07,127 --> 00:46:11,837
Compare and its purpose in life is to actually compare two strings

1301
00:46:11,927 --> 00:46:14,958
left and right to make sure they are in fact the same.

1302
00:46:15,127 --> 00:46:15,937
So for today's purposes,

1303
00:46:16,048 --> 00:46:21,208
suffice it to say you cannot use equals equals apparently to compare two strings.

1304
00:46:21,288 --> 00:46:21,887
Intuitively,

1305
00:46:22,008 --> 00:46:22,687
why is that?

1306
00:46:22,808 --> 00:46:22,927
Well,

1307
00:46:23,127 --> 00:46:25,367
for a computer it's super easy to compare two integers

1308
00:46:25,367 --> 00:46:27,357
because they're either there or they're not in memory.

1309
00:46:27,528 --> 00:46:28,677
But with a string,

1310
00:46:28,877 --> 00:46:30,998
it's not just a character and another character,

1311
00:46:31,208 --> 00:46:32,518
it's like 7.

1312
00:46:32,916 --> 00:46:35,105
Characters over here and a few characters over here.

1313
00:46:35,236 --> 00:46:35,956
Maybe it's a few,

1314
00:46:36,115 --> 00:46:36,875
maybe it's more,

1315
00:46:37,075 --> 00:46:39,835
you have to compare each and every character in a

1316
00:46:39,835 --> 00:46:42,186
string to make sure they're in fact the same.

1317
00:46:42,506 --> 00:46:43,686
So Stir Compare

1318
00:46:43,996 --> 00:46:45,156
does exactly that,

1319
00:46:45,315 --> 00:46:47,916
probably in the implementation of Stir Co from like years ago

1320
00:46:47,916 --> 00:46:50,476
someone wrote a wild loop or a floor loop that looks at

1321
00:46:50,476 --> 00:46:53,406
each string left to right and compares each and every one of

1322
00:46:53,406 --> 00:46:56,426
the characters they're in and then gives us back an answer.

1323
00:46:56,635 --> 00:46:58,506
So how do we go about using this?

1324
00:46:58,634 --> 00:46:58,793
Well,

1325
00:46:58,864 --> 00:47:00,374
to use stir compare,

1326
00:47:00,704 --> 00:47:03,614
what I can actually do in VS code here is

1327
00:47:03,944 --> 00:47:06,053
go and change my code as follows.

1328
00:47:06,063 --> 00:47:07,654
Instead of using equals equals,

1329
00:47:07,704 --> 00:47:09,634
I'm going to actually use this function

1330
00:47:09,983 --> 00:47:11,063
per its documentation.

1331
00:47:11,104 --> 00:47:12,773
I'm going to call stir compare,

1332
00:47:13,063 --> 00:47:14,833
then I'm going to pass in one of the strings,

1333
00:47:14,904 --> 00:47:16,374
which is in strings bracket I.

1334
00:47:16,664 --> 00:47:18,414
Then I'm going to pass in the second string,

1335
00:47:18,424 --> 00:47:19,333
which is S.

1336
00:47:19,593 --> 00:47:20,093
However,

1337
00:47:20,184 --> 00:47:21,424
having read the documentation,

1338
00:47:21,503 --> 00:47:23,474
and this is a little nonobvious,

1339
00:47:23,664 --> 00:47:24,454
it turns out that

1340
00:47:24,842 --> 00:47:28,322
Comp will return 0 if the strings are equal.

1341
00:47:28,771 --> 00:47:31,122
Otherwise it's going to return a positive number

1342
00:47:31,612 --> 00:47:32,852
or a negative number.

1343
00:47:32,912 --> 00:47:35,531
So what I care about for now is does the

1344
00:47:35,531 --> 00:47:39,281
return value of stir comp when given those two strings,

1345
00:47:39,612 --> 00:47:40,852
give me back zero?

1346
00:47:40,931 --> 00:47:41,562
If so,

1347
00:47:41,832 --> 00:47:44,612
they are equal and I'm going to say unquote found.

1348
00:47:44,771 --> 00:47:46,441
So let's go ahead and open the terminal again.

1349
00:47:46,691 --> 00:47:50,322
Let me go ahead and clear it and do make search to recompile my code

1350
00:47:50,691 --> 00:47:51,402
and huh.

1351
00:47:51,860 --> 00:47:53,159
I've done something wrong.

1352
00:47:53,449 --> 00:47:53,770
Let's see.

1353
00:47:53,889 --> 00:47:55,290
Let me scroll up to the very

1354
00:47:55,610 --> 00:48:01,010
first line in line 11 error call to undeclared library function stir comp

1355
00:48:01,010 --> 00:48:04,679
would type in and something something which gets more complicated after that.

1356
00:48:05,290 --> 00:48:08,899
Why is line 11 not working despite what I just preached?

1357
00:48:09,330 --> 00:48:09,649
Yeah.

1358
00:48:11,570 --> 00:48:11,760
Yeah,

1359
00:48:11,840 --> 00:48:12,639
I just did something stupid.

1360
00:48:12,679 --> 00:48:15,199
I didn't include the string.h header library,

1361
00:48:15,280 --> 00:48:15,989
so all

1362
00:48:16,399 --> 00:48:19,750
clang our compiler is doing when invoked by Make

1363
00:48:19,750 --> 00:48:22,600
is it's encountering literally the word stir comp and

1364
00:48:22,600 --> 00:48:24,639
not knowing what it is because we haven't taught

1365
00:48:24,639 --> 00:48:27,840
it what it is by simply saying include string.

1366
00:48:28,209 --> 00:48:28,669
H at the top.

1367
00:48:28,760 --> 00:48:29,000
OK,

1368
00:48:29,159 --> 00:48:30,399
let me reopen my terminal window,

1369
00:48:30,560 --> 00:48:31,159
clear that message.

1370
00:48:31,245 --> 00:48:33,185
Way to make search again.

1371
00:48:33,475 --> 00:48:35,824
Now it's compiling search enter.

1372
00:48:36,195 --> 00:48:38,864
Now I'm going to go ahead and search as I did before for Battleship.

1373
00:48:39,165 --> 00:48:39,435
Ah,

1374
00:48:39,715 --> 00:48:40,524
now it's finding it.

1375
00:48:40,635 --> 00:48:41,965
Let me run ear again.

1376
00:48:42,074 --> 00:48:43,215
Search for boot.

1377
00:48:43,475 --> 00:48:43,715
Ah,

1378
00:48:43,834 --> 00:48:44,074
OK,

1379
00:48:44,114 --> 00:48:44,554
that's found.

1380
00:48:44,635 --> 00:48:46,534
Let me go ahead and search for top hat.

1381
00:48:46,834 --> 00:48:48,034
That too is in there.

1382
00:48:48,155 --> 00:48:50,754
Let me go ahead and search for something that's not there like the number 50.

1383
00:48:51,280 --> 00:48:52,560
Not in fact found,

1384
00:48:52,639 --> 00:48:54,989
so I think we've actually fixed that their problem.

1385
00:48:55,159 --> 00:48:56,989
But if we go back to this code for a moment,

1386
00:48:57,280 --> 00:49:00,830
it's indeed the case for the documentation that equals equals 0 is what I want to do.

1387
00:49:01,120 --> 00:49:02,760
Why in the world would Stir comp

1388
00:49:03,360 --> 00:49:07,320
be designed to return a positive or a negative number 2?

1389
00:49:07,439 --> 00:49:08,879
It's not returning true or false,

1390
00:49:08,919 --> 00:49:11,729
it's returning one of three possible values zero,

1391
00:49:12,000 --> 00:49:13,919
negative or positive.

1392
00:49:14,929 --> 00:49:16,370
Why might it be useful?

1393
00:49:16,449 --> 00:49:16,939
Yeah.

1394
00:49:17,409 --> 00:49:17,590
Um,

1395
00:49:17,969 --> 00:49:20,439
you could kind of like compare which of the ring is like.

1396
00:49:21,080 --> 00:49:21,320
Yeah,

1397
00:49:21,520 --> 00:49:22,040
super clever.

1398
00:49:22,169 --> 00:49:23,719
So if you're passing in two strings,

1399
00:49:23,800 --> 00:49:25,229
it's great to know if they're equal,

1400
00:49:25,399 --> 00:49:28,159
but wouldn't it be nice if this same function could also help us

1401
00:49:28,159 --> 00:49:32,330
sort these strings ultimately and tell me which one comes first alphabetically?

1402
00:49:32,429 --> 00:49:34,120
And technically it's not going to be alphabetically,

1403
00:49:34,159 --> 00:49:36,919
it's going to be a cute phrase askibetically because

1404
00:49:36,919 --> 00:49:39,040
it's actually going to look at the asy values of

1405
00:49:39,040 --> 00:49:41,719
the characters and do some quick arithmetic and tell you

1406
00:49:41,719 --> 00:49:44,550
which one comes first and which one comes later,

1407
00:49:44,719 --> 00:49:45,429
which is enough.

1408
00:49:45,625 --> 00:49:48,406
We'll eventually see for actually sorting these strings as well.

1409
00:49:48,575 --> 00:49:49,016
So in short,

1410
00:49:49,095 --> 00:49:51,375
the documentation will tell me that I should check

1411
00:49:51,375 --> 00:49:53,936
not only for zero if I care about equality,

1412
00:49:53,996 --> 00:49:55,335
but if I care about inequality,

1413
00:49:55,375 --> 00:49:57,446
that's checking if one comes first or last,

1414
00:49:57,656 --> 00:50:00,805
I should check whether something is less than 0 or greater than.

1415
00:50:00,936 --> 00:50:02,085
But for this demonstration,

1416
00:50:02,095 --> 00:50:03,256
implementing linear search,

1417
00:50:03,575 --> 00:50:05,805
I don't care about comparing them

1418
00:50:06,226 --> 00:50:07,095
for inequality.

1419
00:50:07,176 --> 00:50:09,686
All I care about is that they are in fact the same

1420
00:50:10,016 --> 00:50:11,152
or Not

1421
00:50:11,431 --> 00:50:12,342
in this case.

1422
00:50:12,771 --> 00:50:12,912
All right,

1423
00:50:12,981 --> 00:50:13,102
well,

1424
00:50:13,112 --> 00:50:14,441
let's go ahead and do one other

1425
00:50:14,951 --> 00:50:16,471
example of sort of linear search,

1426
00:50:16,511 --> 00:50:18,592
but let's make the problem more like that actually

1427
00:50:18,592 --> 00:50:20,191
in week zero of searching a phone book.

1428
00:50:20,312 --> 00:50:22,622
So let me go back to VS code here.

1429
00:50:22,941 --> 00:50:25,672
Close search.c and let's make an actual phone book.

1430
00:50:25,711 --> 00:50:28,872
So I'm going to say code of phonebook.c and then

1431
00:50:28,872 --> 00:50:31,352
inside of phonebook.c let's use our same header file.

1432
00:50:31,431 --> 00:50:32,471
So include CS50.

1433
00:50:32,711 --> 00:50:33,062
H,

1434
00:50:33,552 --> 00:50:34,892
includes standard IO.

1435
00:50:35,520 --> 00:50:37,830
Dot and let's include an advance

1436
00:50:38,199 --> 00:50:39,790
string.h.

1437
00:50:40,239 --> 00:50:42,780
Then let's as before do in main void,

1438
00:50:42,879 --> 00:50:44,389
no command line arguments today.

1439
00:50:44,679 --> 00:50:45,610
Then inside of here,

1440
00:50:45,639 --> 00:50:48,199
let me give myself first an array of strings.

1441
00:50:48,320 --> 00:50:49,639
How about some names in the phone book?

1442
00:50:49,699 --> 00:50:50,870
So I'm going to say string,

1443
00:50:51,199 --> 00:50:51,830
names,

1444
00:50:52,040 --> 00:50:52,659
equals,

1445
00:50:52,669 --> 00:50:55,510
and then three names just to make a demonstration.

1446
00:50:55,520 --> 00:50:58,790
Kelly and David and say John Harvard here.

1447
00:50:59,120 --> 00:51:00,080
But if it's a phone book,

1448
00:51:00,120 --> 00:51:01,320
I need more than just names.

1449
00:51:01,330 --> 00:51:03,280
So let me go ahead and give myself another.

1450
00:51:03,520 --> 00:51:08,040
Array string of numbers open bracket close bracket equals and

1451
00:51:08,040 --> 00:51:10,530
now the same phone numbers we used in week zero

1452
00:51:10,760 --> 00:51:16,179
for the three of us plus 1 617495 1000

1453
00:51:16,280 --> 00:51:17,270
same for both Kelly and me,

1454
00:51:17,320 --> 00:51:18,030
so plus 1,

1455
00:51:18,040 --> 00:51:19,870
617495

1456
00:51:20,600 --> 00:51:21,590
1000.

1457
00:51:21,639 --> 00:51:22,399
And then as before,

1458
00:51:22,439 --> 00:51:24,479
if you'd like to text or call John directly,

1459
00:51:24,560 --> 00:51:31,360
you can do so at plus 1-949-4682750 and semicolon.

1460
00:51:31,739 --> 00:51:32,570
So

1461
00:51:32,820 --> 00:51:33,889
one question first,

1462
00:51:34,110 --> 00:51:36,969
I obviously declared our names to be

1463
00:51:38,050 --> 00:51:40,639
an array of strings because that's what text is.

1464
00:51:40,979 --> 00:51:46,179
Why have I also declared phone numbers to be strings and not integers because

1465
00:51:46,179 --> 00:51:49,090
a phone number is like literally a number in the name of it,

1466
00:51:49,100 --> 00:51:49,510
yeah.

1467
00:51:51,330 --> 00:51:51,760
Yeah,

1468
00:51:51,919 --> 00:51:54,719
so even though we have phone numbers in the US,

1469
00:51:54,760 --> 00:51:57,360
even though we have Social Security numbers and a

1470
00:51:57,360 --> 00:51:59,159
bunch of other things that we call numbers,

1471
00:51:59,199 --> 00:52:02,340
if you have other non-digits in those,

1472
00:52:03,080 --> 00:52:04,040
in those values,

1473
00:52:04,239 --> 00:52:07,229
you have to actually use strings because if it's not an actual integer,

1474
00:52:07,239 --> 00:52:08,939
but it does have things like pluses or dashes

1475
00:52:08,939 --> 00:52:11,429
or parentheses or any other form of punctuation,

1476
00:52:11,520 --> 00:52:14,830
as is common in the US and other countries for phone numbers in particular,

1477
00:52:15,040 --> 00:52:17,760
you're going to actually want to use strings and not.

1478
00:52:18,125 --> 00:52:21,415
as well as for corner cases like if there are if you're in the habit back home,

1479
00:52:21,495 --> 00:52:23,895
if you're not from say the US and you actually have

1480
00:52:23,895 --> 00:52:26,804
to dial 0 1st to make like a local regional call,

1481
00:52:27,014 --> 00:52:29,165
you don't want to have a leading zero

1482
00:52:29,655 --> 00:52:30,614
in an

1483
00:52:30,895 --> 00:52:32,655
integer because mathematically,

1484
00:52:32,665 --> 00:52:34,594
as we know from grade school like leading zeros,

1485
00:52:34,655 --> 00:52:37,004
number 0s that come first have no mathematical meaning,

1486
00:52:37,175 --> 00:52:38,245
they're going to disappear

1487
00:52:38,495 --> 00:52:41,254
effectively from the computer's memory unless we store them

1488
00:52:41,254 --> 00:52:44,254
in fact as characters in strings in this way.

1489
00:52:44,570 --> 00:52:45,020
OK,

1490
00:52:45,149 --> 00:52:45,629
with that said,

1491
00:52:45,750 --> 00:52:49,030
let's go ahead and ask the human now after having declared those two

1492
00:52:49,030 --> 00:52:51,790
arrays for the name they want to look up the number of.

1493
00:52:51,830 --> 00:52:54,179
So let's say string name equals get string,

1494
00:52:54,429 --> 00:52:56,459
and let's go ahead and ask the human

1495
00:52:56,909 --> 00:52:58,780
for the name for which to search.

1496
00:52:58,949 --> 00:52:59,909
Then let's use a 4.

1497
00:53:00,094 --> 00:53:00,604
As before,

1498
00:53:00,725 --> 00:53:02,094
for in i equals 0,

1499
00:53:02,135 --> 00:53:03,594
I less than 3,

1500
00:53:03,725 --> 00:53:07,524
which again for demonstration purposes I'm just hard coding today I + plus and

1501
00:53:07,524 --> 00:53:10,875
then in the 4 loop I'm going to use our new friend Stircom if

1502
00:53:11,084 --> 00:53:15,485
the return value of stircompare passing in names bracket I.

1503
00:53:16,000 --> 00:53:19,149
And the name the human typed in equals equals

1504
00:53:19,149 --> 00:53:21,830
zero signifying that they are in fact the same.

1505
00:53:21,919 --> 00:53:22,030
Well,

1506
00:53:22,040 --> 00:53:23,350
that means we found

1507
00:53:23,479 --> 00:53:24,989
the location I

1508
00:53:25,320 --> 00:53:26,719
where the person's name is.

1509
00:53:26,879 --> 00:53:28,820
So let's go ahead and print out found,

1510
00:53:28,840 --> 00:53:29,479
but just to be fun,

1511
00:53:29,560 --> 00:53:31,310
let's print out whom we found.

1512
00:53:31,600 --> 00:53:32,600
So percent F.

1513
00:53:32,925 --> 00:53:35,604
Backslash N and then output there

1514
00:53:35,935 --> 00:53:40,054
the number which is going to be in the corresponding numbers array at that

1515
00:53:40,054 --> 00:53:44,044
same location I will return 0 and at the very end of this program,

1516
00:53:44,094 --> 00:53:47,245
let's go ahead and print out not found if we get that far

1517
00:53:47,614 --> 00:53:49,455
and return 1.

1518
00:53:50,100 --> 00:53:50,419
All right,

1519
00:53:50,739 --> 00:53:52,300
so a little more complexity this time,

1520
00:53:52,340 --> 00:53:55,899
but notice I'm comparing the names just like a normal person would in

1521
00:53:55,899 --> 00:53:59,290
your iOS app or your Android app when looking for someone's name,

1522
00:53:59,459 --> 00:54:01,270
but what I care about is getting back the number.

1523
00:54:01,459 --> 00:54:03,250
So that's why two lines later,

1524
00:54:03,459 --> 00:54:06,810
I'm printing out the number that I found at location I,

1525
00:54:07,179 --> 00:54:08,409
not the name,

1526
00:54:08,770 --> 00:54:09,780
because I already know the name.

1527
00:54:09,949 --> 00:54:10,370
All right.

1528
00:54:10,520 --> 00:54:11,739
In my terminal window,

1529
00:54:11,790 --> 00:54:13,689
let's go ahead and make this phone book.

1530
00:54:15,030 --> 00:54:15,510
phonebook.

1531
00:54:15,669 --> 00:54:16,949
Let's go ahead and search for John,

1532
00:54:16,989 --> 00:54:18,510
whose number is hopefully

1533
00:54:18,870 --> 00:54:20,699
indeed exactly that number.

1534
00:54:20,989 --> 00:54:23,540
So suffice it to say this code 2 does work.

1535
00:54:23,709 --> 00:54:26,020
This is a linear search because I'm searching left to right.

1536
00:54:26,229 --> 00:54:30,149
These aren't actually sorted alphabetically by name or let alone number.

1537
00:54:30,429 --> 00:54:32,679
So I think we're doing well here

1538
00:54:33,129 --> 00:54:33,889
but

1539
00:54:34,330 --> 00:54:37,679
I don't necessarily love this implementation

1540
00:54:37,969 --> 00:54:39,879
even if you're new to programming,

1541
00:54:40,250 --> 00:54:42,040
what might you not like

1542
00:54:42,330 --> 00:54:46,010
about how I've implemented a phone book in the computer's memory?

1543
00:54:48,459 --> 00:54:50,350
Why is this maybe not the best design,

1544
00:54:50,419 --> 00:54:50,770
yeah.

1545
00:54:55,340 --> 00:54:55,649
OK,

1546
00:54:55,770 --> 00:54:55,810
yeah,

1547
00:54:55,889 --> 00:54:56,479
and I would say,

1548
00:54:56,489 --> 00:54:59,530
so you're pointing out that we have this duality.

1549
00:54:59,570 --> 00:55:00,389
We've got two arrays.

1550
00:55:00,409 --> 00:55:01,540
They're the exact same length,

1551
00:55:01,570 --> 00:55:04,889
and it just so happens that location zero's name lines up

1552
00:55:04,889 --> 00:55:08,169
with location 0's number and location 1 and location 2,

1553
00:55:08,179 --> 00:55:10,489
but we're kind of on the honor system here whereby the

1554
00:55:10,489 --> 00:55:12,689
onus is on us to make sure we don't screw this

1555
00:55:12,689 --> 00:55:14,879
up and we make sure we always have the same number

1556
00:55:14,879 --> 00:55:18,719
of names and the same number of numbers and better and moreover

1557
00:55:18,889 --> 00:55:20,610
that we may get the order exactly.

1558
00:55:20,864 --> 00:55:21,384
right,

1559
00:55:21,543 --> 00:55:24,384
we are just trusting that when we print out the IT number,

1560
00:55:24,464 --> 00:55:25,093
so to speak,

1561
00:55:25,263 --> 00:55:27,194
that it lines up with the IT name.

1562
00:55:27,273 --> 00:55:28,093
So that's fine.

1563
00:55:28,184 --> 00:55:29,904
And honestly for 3 people who really cares,

1564
00:55:29,944 --> 00:55:30,384
it's fine,

1565
00:55:30,424 --> 00:55:31,573
but if you think about 30 people,

1566
00:55:31,664 --> 00:55:32,343
300,

1567
00:55:32,583 --> 00:55:33,184
3 million,

1568
00:55:33,263 --> 00:55:34,773
well we're not going to hard code them all here,

1569
00:55:34,823 --> 00:55:36,513
but even in some database

1570
00:55:36,823 --> 00:55:40,823
that will store them in later in the course feels like just trusting

1571
00:55:40,823 --> 00:55:43,063
that we're not going to screw this up is asking for trouble.

1572
00:55:43,083 --> 00:55:44,773
And indeed a lot of programming is just that,

1573
00:55:44,904 --> 00:55:46,063
like not trusting yourself.

1574
00:55:46,167 --> 00:55:49,107
And definitely not trusting your colleague not to mess something up,

1575
00:55:49,278 --> 00:55:52,827
but programming a bit more defensively and trying to encapsulate

1576
00:55:53,238 --> 00:55:56,877
related information a little more tightly together and not just assume,

1577
00:55:56,998 --> 00:56:01,147
as on the honor system that these two independent arrays will line up.

1578
00:56:01,357 --> 00:56:04,897
But at this point we have no means of solving this problem

1579
00:56:05,117 --> 00:56:09,568
unless we give ourselves just a bit new functionality and syntax.

1580
00:56:09,597 --> 00:56:11,478
So I used this phrase earlier to kick things off.

1581
00:56:11,582 --> 00:56:12,652
Data structures.

1582
00:56:12,691 --> 00:56:15,011
It's like how you structure your data in the computer's memory.

1583
00:56:15,102 --> 00:56:17,372
Arrays are the simplest of data structures.

1584
00:56:17,412 --> 00:56:21,201
They just store data back to back to back from left to right contiguously in memory,

1585
00:56:21,332 --> 00:56:22,412
but they all have to be,

1586
00:56:22,451 --> 00:56:22,892
as we've seen,

1587
00:56:22,931 --> 00:56:24,382
the same kinds of values in,

1588
00:56:24,392 --> 00:56:24,572
in,

1589
00:56:24,612 --> 00:56:24,882
in,

1590
00:56:25,211 --> 00:56:25,612
or string,

1591
00:56:25,622 --> 00:56:26,481
string string.

1592
00:56:26,691 --> 00:56:30,001
There's no mechanism yet for storing an in and a string together,

1593
00:56:30,132 --> 00:56:32,241
and then another in and another string together,

1594
00:56:32,251 --> 00:56:33,372
or let alone two strings,

1595
00:56:33,491 --> 00:56:33,971
2 strings,

1596
00:56:34,052 --> 00:56:34,882
2 strings

1597
00:56:35,132 --> 00:56:36,812
that are somehow a little bit different.

1598
00:56:37,065 --> 00:56:37,575
But

1599
00:56:37,785 --> 00:56:41,496
it would be nice if C gave us an actual data type to store

1600
00:56:41,496 --> 00:56:45,216
people in a phone book such that we could create an array called people

1601
00:56:45,676 --> 00:56:47,785
inside of which is going to be a whole bunch of persons,

1602
00:56:47,815 --> 00:56:48,456
if you will,

1603
00:56:48,585 --> 00:56:49,696
back to back to back,

1604
00:56:49,865 --> 00:56:50,785
and I want two of them.

1605
00:56:50,885 --> 00:56:53,666
So wouldn't it be nice if I could literally use this code and see?

1606
00:56:53,825 --> 00:56:53,906
Well,

1607
00:56:54,105 --> 00:56:55,406
decades ago when Sem was invented,

1608
00:56:55,466 --> 00:56:57,035
they didn't give us a person data type.

1609
00:56:57,125 --> 00:57:02,236
All we have is in and float and char and bull and string and so forth.

1610
00:57:03,229 --> 00:57:05,629
Person was not among the available data types,

1611
00:57:05,709 --> 00:57:08,340
but we can invent our own data types it turns out.

1612
00:57:08,510 --> 00:57:12,540
So in see what we can do if we want persons to exist

1613
00:57:12,750 --> 00:57:16,699
and every person in the world shall have a name and a phone number for now,

1614
00:57:16,969 --> 00:57:17,939
we can do this.

1615
00:57:18,570 --> 00:57:19,750
Name string number.

1616
00:57:20,060 --> 00:57:21,850
Now that's a decent start,

1617
00:57:21,939 --> 00:57:23,580
but it's going to be kind of a stupid implementation

1618
00:57:23,580 --> 00:57:26,219
if I then just do name string name 1,

1619
00:57:26,260 --> 00:57:27,149
string name 2,

1620
00:57:27,219 --> 00:57:28,060
string name 3,

1621
00:57:28,139 --> 00:57:28,780
string name 4.

1622
00:57:28,820 --> 00:57:29,409
We've already

1623
00:57:29,699 --> 00:57:33,699
started down that road last week and decided arrays were a better solution.

1624
00:57:34,060 --> 00:57:37,689
But here's an alternative when you want to just store related data together.

1625
00:57:37,939 --> 00:57:41,889
I can use these two keywords and see type death struct,

1626
00:57:42,100 --> 00:57:43,060
which albeit terse,

1627
00:57:43,080 --> 00:57:44,669
just means define a new type

1628
00:57:44,939 --> 00:57:46,489
that is a data structure.

1629
00:57:46,780 --> 00:57:48,290
So multiple things together

1630
00:57:48,659 --> 00:57:50,739
inside the curly braces you literally put the

1631
00:57:50,739 --> 00:57:52,260
two things you want to relate together.

1632
00:57:52,685 --> 00:57:55,955
Name string number and then outside the curly braces you specify

1633
00:57:55,955 --> 00:57:59,024
the name you want to give to this brand new custom type

1634
00:57:59,274 --> 00:58:00,445
that you have invented.

1635
00:58:00,794 --> 00:58:01,195
Technically,

1636
00:58:01,205 --> 00:58:01,824
stylistically,

1637
00:58:01,834 --> 00:58:04,185
you'll see that Style 50 prefers that the name

1638
00:58:04,475 --> 00:58:07,155
actually be on the same line as the last curly brace,

1639
00:58:07,195 --> 00:58:08,195
which looks a little weird to me,

1640
00:58:08,294 --> 00:58:10,024
but that's what industry tends to do so

1641
00:58:10,145 --> 00:58:10,834
so be it.

1642
00:58:11,120 --> 00:58:14,300
But these several lines together tell C

1643
00:58:14,699 --> 00:58:18,780
invent for me a new data type called person and assume that every person

1644
00:58:18,780 --> 00:58:22,290
in the world has a string called name and a string called number.

1645
00:58:22,540 --> 00:58:25,370
And now I can use this new data type

1646
00:58:25,620 --> 00:58:28,610
in my own code to solve this problem

1647
00:58:28,899 --> 00:58:30,010
a little bit better.

1648
00:58:30,219 --> 00:58:30,500
So in fact,

1649
00:58:30,580 --> 00:58:32,659
let me go ahead and do this as follows.

1650
00:58:32,669 --> 00:58:35,060
I'm going to go back to VS code here and at the

1651
00:58:35,060 --> 00:58:38,100
very top of my code above main just to make this.

1652
00:58:38,179 --> 00:58:41,560
Available to not only main but maybe any future functions I write.

1653
00:58:41,770 --> 00:58:43,679
I'm going to say type destruct,

1654
00:58:43,689 --> 00:58:44,879
as we saw on the screen.

1655
00:58:45,129 --> 00:58:46,330
Inside of my curly braces,

1656
00:58:46,409 --> 00:58:48,280
I'm going to say string name and

1657
00:58:48,449 --> 00:58:49,399
string number,

1658
00:58:49,530 --> 00:58:51,800
and then I'm going to name this thing person.

1659
00:58:52,090 --> 00:58:56,520
Now I'm going to go about using this and I'm going to go ahead and delete my previous

1660
00:58:56,889 --> 00:59:00,639
honor system approach of having names and numbers in separate arrays,

1661
00:59:00,649 --> 00:59:03,360
and I'm instead going to give myself an array

1662
00:59:03,689 --> 00:59:05,080
of people.

1663
00:59:05,250 --> 00:59:05,969
We can call it persons,

1664
00:59:06,040 --> 00:59:07,750
but I'm trying to be somewhat grammatically correct,

1665
00:59:07,959 --> 00:59:10,080
so I'm going to say people bracket 3

1666
00:59:10,280 --> 00:59:11,580
to give myself an array,

1667
00:59:11,679 --> 00:59:12,510
call people

1668
00:59:13,120 --> 00:59:15,209
inside of which is room for 3 persons,

1669
00:59:15,479 --> 00:59:18,949
inside of which is room for a name and number each.

1670
00:59:19,159 --> 00:59:20,879
So how do I now initialize these values?

1671
00:59:20,959 --> 00:59:21,030
Well,

1672
00:59:21,040 --> 00:59:21,949
I'm going to hard code them,

1673
00:59:21,959 --> 00:59:22,959
that is type them manually,

1674
00:59:23,040 --> 00:59:25,879
but you can imagine using get string or get or some

1675
00:59:25,879 --> 00:59:28,550
other function to get this data from the human themselves.

1676
00:59:28,699 --> 00:59:29,429
I'm going to say

1677
00:59:29,679 --> 00:59:32,070
go to the people array at location 0.

1678
00:59:32,330 --> 00:59:34,860
And access the name field,

1679
00:59:35,070 --> 00:59:36,350
and this is syntax we haven't seen yet,

1680
00:59:36,389 --> 00:59:37,300
but it's not that hard.

1681
00:59:37,429 --> 00:59:38,449
You literally use a dot,

1682
00:59:38,510 --> 00:59:39,340
a single period,

1683
00:59:39,350 --> 00:59:43,580
to say go inside of that structure and access the name field,

1684
00:59:43,669 --> 00:59:44,820
the name attribute,

1685
00:59:44,949 --> 00:59:45,500
so to speak,

1686
00:59:45,729 --> 00:59:47,379
and let's set that equal to Kelly.

1687
00:59:47,629 --> 00:59:50,739
Then let's go into that same array location,

1688
00:59:50,870 --> 00:59:54,780
people bracket 0 and set the number for the zeroth person

1689
00:59:54,949 --> 00:59:59,270
to be plus 1617495 1000.

1690
00:59:59,580 --> 01:00:02,810
Then let's go ahead and do the same thing for people 1.

1691
01:00:03,199 --> 01:00:04,699
Set that person's name to,

1692
01:00:04,780 --> 01:00:05,209
for instance,

1693
01:00:05,219 --> 01:00:05,570
mine,

1694
01:00:05,780 --> 01:00:06,330
David.

1695
01:00:06,500 --> 01:00:09,979
Then let's do people bracket 1.n number equals quote unquote,

1696
01:00:10,100 --> 01:00:11,780
same as Kelly because we're both in the directory.

1697
01:00:11,860 --> 01:00:14,770
So plus 1 617495

1698
01:00:15,020 --> 01:00:16,000
1000.

1699
01:00:16,060 --> 01:00:16,939
And then lastly,

1700
01:00:17,040 --> 01:00:22,120
people bracket 2.name equals quote unquote for John Harvard,

1701
01:00:22,340 --> 01:00:26,340
people 2.n number equals plus 1.

1702
01:00:27,010 --> 01:00:32,850
949-4682750 in this case.

1703
01:00:33,129 --> 01:00:35,080
And now the rest of the code is almost the same.

1704
01:00:35,290 --> 01:00:39,080
I'm going to now on the new line 24 still ask the user what name they want.

1705
01:00:39,209 --> 01:00:43,370
I'm going to still iterate from 0 to 3 because there's still 3 elements in this array,

1706
01:00:43,409 --> 01:00:45,199
even though each has two values within,

1707
01:00:45,320 --> 01:00:48,294
and I'm Compare now not names,

1708
01:00:48,405 --> 01:00:54,875
but people bracket I.name to go access the name of that person

1709
01:00:55,125 --> 01:00:56,554
and compare it to the name

1710
01:00:56,764 --> 01:00:57,995
that the human has typed in.

1711
01:00:58,004 --> 01:00:59,524
And when I find that person,

1712
01:00:59,594 --> 01:01:03,314
I'm going to go into the people array at location I but print out

1713
01:01:03,485 --> 01:01:04,814
the number instead.

1714
01:01:05,209 --> 01:01:08,040
So all we've done here is add this dot notation which

1715
01:01:08,040 --> 01:01:10,429
allows you to access the inside of a data structure,

1716
01:01:10,600 --> 01:01:14,709
and all we've done is introduce up here some new C keywords that let you

1717
01:01:14,709 --> 01:01:19,070
invent your own data types inside of which you can put most anything you want.

1718
01:01:19,239 --> 01:01:22,030
I have chosen a string name and a string number.

1719
01:01:22,590 --> 01:01:22,760
All right,

1720
01:01:23,000 --> 01:01:25,590
let me go ahead and open my terminal window and clear it from before.

1721
01:01:25,760 --> 01:01:28,110
Let me do make Phonebook to make this version.

1722
01:01:28,399 --> 01:01:29,310
So far so good.

1723
01:01:29,399 --> 01:01:30,560
Make Phonebook enter.

1724
01:01:30,719 --> 01:01:32,840
I'm going to go ahead now and search for say John.

1725
01:01:33,209 --> 01:01:35,239
And I have again found his number,

1726
01:01:35,340 --> 01:01:36,669
so this is still correct,

1727
01:01:36,790 --> 01:01:39,469
but even though this took more minutes in terms of

1728
01:01:39,469 --> 01:01:42,060
the voiceover and it took more lines of code,

1729
01:01:42,270 --> 01:01:45,310
it's arguably better designed now because at people bracket

1730
01:01:45,310 --> 01:01:48,080
0 is an actual person in everything about them.

1731
01:01:48,149 --> 01:01:51,550
At people bracket 1 is another person in everything about them.

1732
01:01:51,929 --> 01:01:52,580
And so forth.

1733
01:01:52,659 --> 01:01:54,370
This is what we mean by encapsulate,

1734
01:01:54,500 --> 01:01:57,169
you can think of these curly braces as sort of hugging

1735
01:01:57,379 --> 01:01:57,810
these

1736
01:01:57,979 --> 01:02:03,010
data types inside of the data structure together so as to keep them together

1737
01:02:03,260 --> 01:02:05,290
in the computer's memory as well.

1738
01:02:06,129 --> 01:02:06,489
All right,

1739
01:02:06,610 --> 01:02:06,770
well,

1740
01:02:06,810 --> 01:02:08,510
just to set the stage,

1741
01:02:08,810 --> 01:02:09,800
uh,

1742
01:02:10,370 --> 01:02:10,689
literally,

1743
01:02:10,850 --> 01:02:13,239
as we'll strike the lockers and put something else up,

1744
01:02:13,909 --> 01:02:17,929
the efficiency of binary search as implemented by Caitlin was predicated

1745
01:02:17,929 --> 01:02:21,540
on Kelly having in advance sorted the values up front.

1746
01:02:21,689 --> 01:02:23,449
But of course we've only considered now the running

1747
01:02:23,449 --> 01:02:26,370
time of searching for information using two algorithms,

1748
01:02:26,409 --> 01:02:27,250
and there can be many others.

1749
01:02:27,399 --> 01:02:27,979
In the real world,

1750
01:02:28,030 --> 01:02:29,419
but those are two of the most canonical.

1751
01:02:29,629 --> 01:02:31,580
We found that binary search was faster

1752
01:02:31,790 --> 01:02:32,550
than linear search,

1753
01:02:32,629 --> 01:02:34,699
but it required that we sort the data.

1754
01:02:34,770 --> 01:02:36,020
So to your question earlier,

1755
01:02:36,310 --> 01:02:39,949
maybe we should consider just how expensive it is in terms of time,

1756
01:02:40,070 --> 01:02:40,310
money,

1757
01:02:40,510 --> 01:02:40,709
space,

1758
01:02:40,830 --> 01:02:42,300
humans to sort data,

1759
01:02:42,510 --> 01:02:43,649
especially a lot of data,

1760
01:02:43,909 --> 01:02:46,179
and then decide whether or not it's worth using

1761
01:02:46,179 --> 01:02:48,500
something like binary search or perhaps even something else.

1762
01:02:48,590 --> 01:02:48,669
So.

1763
01:02:48,780 --> 01:02:52,580
The next problem we'll solve today ultimately is given generic input and output.

1764
01:02:52,729 --> 01:02:55,159
The input to our next problem is going to be unsorted data,

1765
01:02:55,330 --> 01:02:56,800
so like numbers out of order,

1766
01:02:56,969 --> 01:02:58,689
the output of which should be sorted data.

1767
01:02:58,770 --> 01:02:59,409
So for instance,

1768
01:02:59,489 --> 01:03:01,669
if we pass in 72541,

1769
01:03:01,679 --> 01:03:02,600
603,

1770
01:03:02,850 --> 01:03:05,409
I want whatever black box is implementing

1771
01:03:05,409 --> 01:03:10,120
my sorting algorithm to spit out 01234567.

1772
01:03:10,449 --> 01:03:12,199
So that's going to be the question we answer.

1773
01:03:12,209 --> 01:03:15,479
But first I think it's time for some delightful Hello Pandass chocolate biscuits.

1774
01:03:15,750 --> 01:03:15,760
Uh,

1775
01:03:15,770 --> 01:03:18,179
let's take a 10 minute break and snacks are now served.

1776
01:03:18,959 --> 01:03:18,969
All

1777
01:03:19,790 --> 01:03:20,020
right,

1778
01:03:20,189 --> 01:03:22,669
we are back and recall that the cliffhanger on which we

1779
01:03:22,669 --> 01:03:24,750
left was that how do we go about sorting numbers?

1780
01:03:24,870 --> 01:03:24,949
Well,

1781
01:03:25,070 --> 01:03:25,949
here are some numbers,

1782
01:03:26,070 --> 01:03:26,939
8 of them in fact,

1783
01:03:27,189 --> 01:03:28,110
from 0 to 7,

1784
01:03:28,149 --> 01:03:29,540
but currently unsorted.

1785
01:03:29,709 --> 01:03:29,790
Um,

1786
01:03:29,870 --> 01:03:31,750
we don't quite have enough monopoly boards for everyone,

1787
01:03:31,790 --> 01:03:33,500
but we do have some delightful,

1788
01:03:33,870 --> 01:03:34,379
uh.

1789
01:03:34,620 --> 01:03:36,370
For Mario Brothers Pez dispensers,

1790
01:03:36,409 --> 01:03:39,409
if I could get 8 volunteers for this final demo up here,

1791
01:03:39,489 --> 01:03:39,570
oh,

1792
01:03:39,580 --> 01:03:40,729
and not a lot of hands.

1793
01:03:40,780 --> 01:03:41,149
OK,

1794
01:03:41,360 --> 01:03:41,489
all right,

1795
01:03:41,530 --> 01:03:46,110
123456,

1796
01:03:46,370 --> 01:03:48,540
and let's go farther back 7 and 8.

1797
01:03:48,610 --> 01:03:49,290
How about alright,

1798
01:03:49,370 --> 01:03:50,320
come on up

1799
01:03:50,850 --> 01:03:52,350
hopefully I counted properly.

1800
01:03:52,649 --> 01:03:53,520
Come on over.

1801
01:03:55,330 --> 01:03:56,610
Upon arrival at the stage,

1802
01:03:56,719 --> 01:03:59,379
go ahead and grab your favorite illuminated number

1803
01:04:00,050 --> 01:04:03,800
and stand in that same order at the front of the stage if you all could.

1804
01:04:05,719 --> 01:04:06,669
Welcome to the stage.

1805
01:04:06,760 --> 01:04:07,189
All right,

1806
01:04:07,360 --> 01:04:08,389
grab your favorite number,

1807
01:04:08,429 --> 01:04:09,750
stand in that same order.

1808
01:04:11,649 --> 01:04:12,320
All right.

1809
01:04:14,500 --> 01:04:14,870
Good.

1810
01:04:14,939 --> 01:04:17,810
And 123456.

1811
01:04:17,820 --> 01:04:19,379
I definitely said 1 through 8.

1812
01:04:19,500 --> 01:04:20,860
Who is the number 8 then?

1813
01:04:21,139 --> 01:04:21,300
OK,

1814
01:04:21,340 --> 01:04:21,899
we need an 8.

1815
01:04:21,979 --> 01:04:22,600
Come on down.

1816
01:04:22,820 --> 01:04:23,020
All right.

1817
01:04:23,300 --> 01:04:23,340
Well,

1818
01:04:23,419 --> 01:04:24,290
technically we need a 4,

1819
01:04:24,300 --> 01:04:25,209
but come on down.

1820
01:04:25,879 --> 01:04:25,889
Yeah.

1821
01:04:25,979 --> 01:04:26,530
All right,

1822
01:04:26,780 --> 01:04:28,860
grab the 4 and let me start from this end first if you

1823
01:04:28,860 --> 01:04:30,850
want to give a quick hello and a little something about you.

1824
01:04:31,300 --> 01:04:31,610
Uh,

1825
01:04:31,659 --> 01:04:31,860
hi,

1826
01:04:31,909 --> 01:04:32,899
my name is Cameron.

1827
01:04:33,100 --> 01:04:36,649
I'm a first year and I want to study mechanical engineering.

1828
01:04:37,909 --> 01:04:38,379
Welcome.

1829
01:04:38,510 --> 01:04:38,780
Hi,

1830
01:04:38,909 --> 01:04:39,639
I'm Charlotte.

1831
01:04:39,709 --> 01:04:42,570
I'm also first year and I'm in Canada F.

1832
01:04:43,389 --> 01:04:43,790
Welcome.

1833
01:04:44,310 --> 01:04:44,540
Hi,

1834
01:04:44,600 --> 01:04:45,149
I'm Ella.

1835
01:04:45,189 --> 01:04:47,379
I'm also a first year and I'm in Thayer.

1836
01:04:48,189 --> 01:04:48,310
Hi,

1837
01:04:48,350 --> 01:04:49,010
I'm Precious.

1838
01:04:49,189 --> 01:04:50,189
I'm also a first year.

1839
01:04:50,229 --> 01:04:50,870
I'm in the.

1840
01:04:51,949 --> 01:04:52,090
Hi,

1841
01:04:52,110 --> 01:04:52,780
I'm Michael.

1842
01:04:52,909 --> 01:04:54,610
I'm just an Eventbrite guest.

1843
01:04:56,000 --> 01:04:56,219
Hi,

1844
01:04:56,310 --> 01:04:56,850
I'm Marie.

1845
01:04:56,929 --> 01:04:58,719
I'm a first year and I'm in Canada.

1846
01:05:00,060 --> 01:05:00,100
Welcome.

1847
01:05:00,129 --> 01:05:00,260
Hi,

1848
01:05:00,270 --> 01:05:00,790
I'm Rick.

1849
01:05:00,929 --> 01:05:02,489
I'm a first year and I'm in Holworthy.

1850
01:05:04,489 --> 01:05:04,510
Nice.

1851
01:05:04,520 --> 01:05:05,229
I'm Jay.

1852
01:05:05,550 --> 01:05:08,409
I'm a 1st year in Holworthy and I really like free stuff.

1853
01:05:08,850 --> 01:05:09,199
OK,

1854
01:05:09,370 --> 01:05:09,800
well,

1855
01:05:10,129 --> 01:05:10,959
let's see then,

1856
01:05:11,050 --> 01:05:11,239
uh,

1857
01:05:11,250 --> 01:05:12,820
if we can't award all these supermarket,

1858
01:05:12,889 --> 01:05:13,770
but there's Pez dispensers.

1859
01:05:13,850 --> 01:05:14,500
The first notice,

1860
01:05:14,530 --> 01:05:14,800
of course,

1861
01:05:14,850 --> 01:05:17,159
that all 8 of our volunteers are completely out of order,

1862
01:05:17,250 --> 01:05:19,959
but in an ideal world we would have the smallest number over here.

1863
01:05:20,290 --> 01:05:20,479
So

1864
01:05:21,810 --> 01:05:22,250
go over there,

1865
01:05:22,689 --> 01:05:23,379
number 0.

1866
01:05:24,040 --> 01:05:24,489
Wait a minute.

1867
01:05:25,560 --> 01:05:26,110
7,

1868
01:05:26,409 --> 01:05:26,979
take over here.

1869
01:05:28,350 --> 01:05:28,840
2,

1870
01:05:29,030 --> 01:05:29,209
OK,

1871
01:05:29,489 --> 01:05:29,649
OK,

1872
01:05:29,709 --> 01:05:31,020
make yourselves look like that.

1873
01:05:34,110 --> 01:05:34,879
No pez.

1874
01:05:35,070 --> 01:05:35,699
It's OK.

1875
01:05:35,830 --> 01:05:36,110
All right,

1876
01:05:36,310 --> 01:05:39,540
so 72541603.

1877
01:05:39,550 --> 01:05:39,830
OK,

1878
01:05:39,909 --> 01:05:41,070
we won't do the introductions again,

1879
01:05:41,169 --> 01:05:43,790
but now we have a list of numbers completely out of order

1880
01:05:43,790 --> 01:05:46,790
and wouldn't it be nice if zero were eventually over here?

1881
01:05:46,860 --> 01:05:48,350
7 were all the way over there and

1882
01:05:48,350 --> 01:05:50,709
everything else was sorted from smallest to largest.

1883
01:05:50,790 --> 01:05:51,060
Well,

1884
01:05:51,229 --> 01:05:54,580
if you all could go ahead and sort yourselves from smallest to largest,

1885
01:05:54,709 --> 01:05:55,100
go.

1886
01:06:00,679 --> 01:06:00,979
Alright,

1887
01:06:01,179 --> 01:06:01,899
and uh Jayden,

1888
01:06:01,939 --> 01:06:03,340
what was your algorithm for doing that?

1889
01:06:04,060 --> 01:06:04,530
Um,

1890
01:06:04,580 --> 01:06:04,989
I

1891
01:06:06,459 --> 01:06:06,699
I,

1892
01:06:06,820 --> 01:06:06,939
I,

1893
01:06:06,979 --> 01:06:09,060
I know that I have the least number because I

1894
01:06:09,060 --> 01:06:11,370
don't think anybody has the number less than 0,

1895
01:06:11,419 --> 01:06:12,850
so I put myself at the

1896
01:06:13,100 --> 01:06:13,739
last bottom line.

1897
01:06:13,830 --> 01:06:14,020
OK,

1898
01:06:14,100 --> 01:06:14,850
and I assume Precious,

1899
01:06:14,899 --> 01:06:16,659
what was your algorithm?

1900
01:06:16,860 --> 01:06:18,340
I knew I had the largest numbers,

1901
01:06:18,459 --> 01:06:20,370
so I just had to be at the end of the.

1902
01:06:20,679 --> 01:06:20,939
OK,

1903
01:06:21,260 --> 01:06:21,449
fair.

1904
01:06:21,540 --> 01:06:22,830
So you guys got the easy ones.

1905
01:06:22,860 --> 01:06:22,879
Uh,

1906
01:06:22,979 --> 01:06:23,629
number 4.

1907
01:06:23,739 --> 01:06:24,330
How about

1908
01:06:25,739 --> 01:06:28,580
You knew 3 was before me and 5 was after me.

1909
01:06:28,649 --> 01:06:28,879
Nice.

1910
01:06:28,939 --> 01:06:31,139
And number 4 didn't actually have to move coincidentally,

1911
01:06:31,219 --> 01:06:33,969
but as for 5 and 3 and 2 and 1 and 6,

1912
01:06:34,060 --> 01:06:36,090
they probably had to take into account some additional information.

1913
01:06:36,189 --> 01:06:36,780
Who's to their left,

1914
01:06:36,820 --> 01:06:37,570
who's to their right,

1915
01:06:37,659 --> 01:06:38,540
and it just kind of worked,

1916
01:06:38,620 --> 01:06:40,300
but it didn't look very algorithmic,

1917
01:06:40,419 --> 01:06:40,830
if you will.

1918
01:06:40,899 --> 01:06:42,969
It looked very organic and obviously correct,

1919
01:06:43,100 --> 01:06:45,300
but I'm not sure that same approach would work well if we

1920
01:06:45,300 --> 01:06:49,090
had not 8 but 80 or 800 or 8000 pieces of data.

1921
01:06:49,219 --> 01:06:49,939
So let's see if we can't form.

1922
01:06:50,080 --> 01:06:50,830
I this a little bit.

1923
01:06:50,909 --> 01:06:53,510
Let me take the mic and if you guys could reset yourselves to those

1924
01:06:53,510 --> 01:06:58,179
same original positions from 7 on the left to 3 on the right,

1925
01:06:58,350 --> 01:07:00,030
let me propose a couple of algorithms,

1926
01:07:00,120 --> 01:07:01,229
canonical ones if you will,

1927
01:07:01,310 --> 01:07:04,360
but see if maybe we can't formalize step by step what to do.

1928
01:07:04,419 --> 01:07:05,739
So the first one I'm going to do,

1929
01:07:05,989 --> 01:07:06,879
given all of these numbers,

1930
01:07:06,989 --> 01:07:08,709
is just try to select the smallest number.

1931
01:07:08,830 --> 01:07:09,139
Why?

1932
01:07:09,270 --> 01:07:10,270
To Jayden's point earlier,

1933
01:07:10,379 --> 01:07:12,590
I just want to put the smallest number over here.

1934
01:07:12,629 --> 01:07:14,340
At least that's a problem I can solve.

1935
01:07:14,530 --> 01:07:15,080
Well defined.

1936
01:07:15,120 --> 01:07:16,719
It's a nice bite out of the problem.

1937
01:07:16,830 --> 01:07:17,629
So 7,

1938
01:07:17,840 --> 01:07:18,040
OK,

1939
01:07:18,080 --> 01:07:19,189
it's the smallest so far.

1940
01:07:19,429 --> 01:07:19,909
2,

1941
01:07:20,000 --> 01:07:20,870
that's that's smaller.

1942
01:07:20,939 --> 01:07:23,709
So I'm going to remember that 2 is the now smallest number I've seen,

1943
01:07:23,959 --> 01:07:24,439
not 5,

1944
01:07:24,570 --> 01:07:26,080
not 41 is even smaller.

1945
01:07:26,090 --> 01:07:27,209
So I'm going to remember 1,

1946
01:07:27,439 --> 01:07:28,320
not 60.

1947
01:07:28,439 --> 01:07:29,030
That's pretty good,

1948
01:07:29,060 --> 01:07:30,399
but I'm going to check the whole list.

1949
01:07:30,479 --> 01:07:32,389
Maybe there's -1 or something like that,

1950
01:07:32,560 --> 01:07:32,909
but no,

1951
01:07:33,000 --> 01:07:33,399
3.

1952
01:07:33,469 --> 01:07:35,959
So I'm going to remember that 0 was the smallest element I found.

1953
01:07:36,040 --> 01:07:38,389
Let's select Jaden and put Jayden over here,

1954
01:07:38,560 --> 01:07:38,929
but

1955
01:07:39,409 --> 01:07:41,330
Before Precious or anyone else moves,

1956
01:07:41,449 --> 01:07:42,449
we don't really have room for you.

1957
01:07:42,629 --> 01:07:45,510
Like Precious is in the way because if this is an array

1958
01:07:45,770 --> 01:07:46,659
of 8

1959
01:07:46,929 --> 01:07:48,350
values for integers,

1960
01:07:48,449 --> 01:07:48,500
well,

1961
01:07:48,530 --> 01:07:51,469
we can't just kind of make room over here because if you think back to last week,

1962
01:07:51,489 --> 01:07:54,689
we might have some garbage values there or something else is going on.

1963
01:07:54,770 --> 01:07:57,159
We don't want to change data that doesn't belong to us.

1964
01:07:57,489 --> 01:07:58,550
So what to do with?

1965
01:07:58,560 --> 01:07:58,570
Well,

1966
01:07:58,929 --> 01:07:59,409
maybe precious,

1967
01:07:59,449 --> 01:08:00,439
maybe you can go over there.

1968
01:08:00,649 --> 01:08:03,290
So you just take Jade in spots and we'll swap these two values.

1969
01:08:03,429 --> 01:08:04,050
Accordingly,

1970
01:08:04,340 --> 01:08:04,770
now though,

1971
01:08:04,979 --> 01:08:06,409
Jayden is in the right space,

1972
01:08:06,500 --> 01:08:08,780
which is good because now I can move on to the second problem.

1973
01:08:08,860 --> 01:08:11,860
What's the next smallest element that's presumably greater than 0?

1974
01:08:11,919 --> 01:08:12,000
Well,

1975
01:08:12,020 --> 01:08:14,760
at the moment 2 is the next smallest element,

1976
01:08:14,979 --> 01:08:15,459
not 5,

1977
01:08:15,620 --> 01:08:17,899
not 401 is the next smallest element.

1978
01:08:17,979 --> 01:08:19,339
I'm going to remember that not 6,

1979
01:08:19,419 --> 01:08:19,859
not 7,

1980
01:08:19,959 --> 01:08:20,540
not 3.

1981
01:08:20,580 --> 01:08:20,740
OK,

1982
01:08:20,790 --> 01:08:21,620
so number 1,

1983
01:08:21,819 --> 01:08:23,450
if you could go to the right location,

1984
01:08:23,540 --> 01:08:26,490
but I'm afraid we're going to have to evict number 2 to make room.

1985
01:08:26,700 --> 01:08:26,859
All right,

1986
01:08:26,870 --> 01:08:27,740
let's do this again.

1987
01:08:28,288 --> 01:08:30,048
0 and 1 are in good shape,

1988
01:08:30,087 --> 01:08:32,877
so now I think I can ignore them as complete.

1989
01:08:33,127 --> 01:08:34,298
5 is the current smallest.

1990
01:08:34,368 --> 01:08:34,608
No,

1991
01:08:34,809 --> 01:08:35,688
4 now is no.

1992
01:08:35,769 --> 01:08:36,679
2 now is

1993
01:08:36,969 --> 01:08:38,179
67,

1994
01:08:38,207 --> 01:08:38,417
no,

1995
01:08:38,568 --> 01:08:39,019
3,

1996
01:08:39,188 --> 01:08:39,198
no.

1997
01:08:39,207 --> 01:08:39,408
OK,

1998
01:08:39,488 --> 01:08:40,877
so 2 is the next smallest.

1999
01:08:41,048 --> 01:08:42,599
So let's swap 2 and 5,

2000
01:08:42,769 --> 01:08:45,048
and now I've solved 3 out of the 8 problems.

2001
01:08:45,207 --> 01:08:45,877
Let's do this again.

2002
01:08:45,898 --> 01:08:47,639
4 is at the moment the smallest,

2003
01:08:47,889 --> 01:08:48,288
not 5,

2004
01:08:48,368 --> 01:08:48,769
not 6,

2005
01:08:49,318 --> 01:08:50,488
not 3 is the now smallest.

2006
01:08:50,568 --> 01:08:52,488
So let's swap 34 and 3.

2007
01:08:52,899 --> 01:08:55,750
Which unfortunately is making the 4 problem a little worse,

2008
01:08:55,859 --> 01:08:56,810
like he belongs there,

2009
01:08:56,819 --> 01:08:57,229
it would see,

2010
01:08:57,379 --> 01:08:58,899
but I think we can fix that later.

2011
01:08:58,930 --> 01:09:01,419
So now half of the list is sorted.

2012
01:09:01,580 --> 01:09:02,859
5 is the next smallest,

2013
01:09:02,879 --> 01:09:04,100
6 and 74,

2014
01:09:04,140 --> 01:09:05,100
and then we've got to fix the 4,

2015
01:09:05,140 --> 01:09:06,209
so 4 goes back there.

2016
01:09:06,500 --> 01:09:07,370
Now I messed up the 5,

2017
01:09:07,379 --> 01:09:08,459
but it will come back to that.

2018
01:09:08,680 --> 01:09:08,819
All right,

2019
01:09:08,859 --> 01:09:09,899
67,

2020
01:09:09,979 --> 01:09:10,140
OK,

2021
01:09:10,189 --> 01:09:10,729
5.

2022
01:09:10,859 --> 01:09:12,890
Let's put you where 6 is,

2023
01:09:13,100 --> 01:09:14,654
and One more mistake to fix,

2024
01:09:14,734 --> 01:09:15,215
so 7,

2025
01:09:15,536 --> 01:09:15,654
OK,

2026
01:09:15,694 --> 01:09:17,166
6 and 7 need to swap.

2027
01:09:17,435 --> 01:09:20,585
And now I've solved 8 problems in the aggregate,

2028
01:09:20,774 --> 01:09:21,604
so it's complete.

2029
01:09:21,715 --> 01:09:22,246
Now to be fair,

2030
01:09:22,375 --> 01:09:25,295
my approach is clearly way slower than your approach,

2031
01:09:25,375 --> 01:09:26,774
but you all were working in parallel,

2032
01:09:26,854 --> 01:09:29,295
whereas I was doing it more methodically step by step,

2033
01:09:29,335 --> 01:09:33,136
and I dare say my algorithm is probably going to be more translatable to code.

2034
01:09:33,145 --> 01:09:35,011
And indeed what I Just acted out is what the

2035
01:09:35,011 --> 01:09:38,812
world would call selection sort whereby on each iteration,

2036
01:09:38,852 --> 01:09:40,721
each pass in front of the humans,

2037
01:09:40,892 --> 01:09:43,932
I was selecting the smallest element I could find.

2038
01:09:44,361 --> 01:09:44,551
All right,

2039
01:09:44,852 --> 01:09:45,082
what,

2040
01:09:45,171 --> 01:09:46,492
how else could I do this though?

2041
01:09:46,571 --> 01:09:48,562
Let's do something that's maybe a little more

2042
01:09:48,932 --> 01:09:51,932
organic like your approach where you were actually comparing who was next to you.

2043
01:09:52,011 --> 01:09:54,532
Go ahead and reset yourselves one final time to this arrangement.

2044
01:09:54,930 --> 01:09:55,540
7 on the left,

2045
01:09:55,549 --> 01:09:56,450
3 on the right,

2046
01:09:56,620 --> 01:09:59,720
and let me propose again to walk through the list again and again,

2047
01:09:59,850 --> 01:10:03,310
but let me focus more narrowly on the problem right in front of me

2048
01:10:03,310 --> 01:10:05,850
because I felt like I was taking a lot of steps back and forth,

2049
01:10:05,939 --> 01:10:06,689
back and forth.

2050
01:10:06,879 --> 01:10:09,049
Maybe we can chip away at some of that wasted time.

2051
01:10:09,220 --> 01:10:10,890
Let's compare 7 and 2.

2052
01:10:11,020 --> 01:10:12,330
They're obviously out of order,

2053
01:10:12,500 --> 01:10:15,290
so let's just immediately swap you two if we could.

2054
01:10:15,560 --> 01:10:15,779
All right,

2055
01:10:15,939 --> 01:10:17,020
now 7 and 5,

2056
01:10:17,100 --> 01:10:17,779
clearly out of order.

2057
01:10:17,859 --> 01:10:19,379
Let's swap these two.

2058
01:10:19,779 --> 01:10:20,799
7 and 4 out of order.

2059
01:10:20,879 --> 01:10:23,399
Let's swap these 27 and 1 out of order,

2060
01:10:23,479 --> 01:10:27,200
let's swap these 2.7 and 6 out of order.

2061
01:10:27,290 --> 01:10:29,879
Let's swap these 2.7 and 0 out of order,

2062
01:10:29,939 --> 01:10:31,229
swap these two.

2063
01:10:31,750 --> 01:10:32,720
73 out of order,

2064
01:10:32,839 --> 01:10:34,470
swap these two.

2065
01:10:34,600 --> 01:10:36,000
So a lot of work for Precious there,

2066
01:10:36,089 --> 01:10:39,759
but I've now indeed solved one of the eight problems.

2067
01:10:39,879 --> 01:10:40,200
Moreover,

2068
01:10:40,279 --> 01:10:44,200
I don't need to keep addressing the 7 problem because notice that Precious

2069
01:10:44,200 --> 01:10:47,399
has essentially bubbled her way up to the end of the list.

2070
01:10:47,439 --> 01:10:49,120
And indeed that's going to be the operative term here.

2071
01:10:49,200 --> 01:10:50,319
Another algorithm

2072
01:10:50,479 --> 01:10:53,439
that computer scientists everywhere know is called bubble sort,

2073
01:10:53,520 --> 01:10:57,120
whereby the goal is to get the biggest elements to just bubble their way up to the.

2074
01:10:57,226 --> 01:11:00,125
Top of or the end of the list one at a time.

2075
01:11:00,346 --> 01:11:00,505
Now,

2076
01:11:00,576 --> 01:11:01,476
am I done?

2077
01:11:02,255 --> 01:11:02,496
No,

2078
01:11:02,655 --> 01:11:03,105
clearly not.

2079
01:11:03,215 --> 01:11:05,255
There's still stuff out of order except for Precious.

2080
01:11:05,335 --> 01:11:05,655
Indeed,

2081
01:11:05,695 --> 01:11:08,936
I have solved one of these eight problems and now fine,

2082
01:11:09,016 --> 01:11:12,215
I'll go back and I'm just going to try this same logic again 2 and 5,

2083
01:11:12,335 --> 01:11:12,726
good,

2084
01:11:12,815 --> 01:11:13,655
5 and 4,

2085
01:11:13,735 --> 01:11:13,826
nope,

2086
01:11:13,936 --> 01:11:15,416
swap those 5 and 1,

2087
01:11:15,456 --> 01:11:15,616
nope,

2088
01:11:15,695 --> 01:11:16,525
swap those

2089
01:11:17,096 --> 01:11:18,195
5 and 6 are good.

2090
01:11:18,286 --> 01:11:18,925
6 and 0,

2091
01:11:18,936 --> 01:11:19,096
nope,

2092
01:11:19,175 --> 01:11:20,456
swap those 6 and 3,

2093
01:11:20,525 --> 01:11:20,695
nope,

2094
01:11:20,735 --> 01:11:21,525
swap those.

2095
01:11:21,815 --> 01:11:22,655
And I already know that.

2096
01:11:22,801 --> 01:11:24,151
Precious is where she needs to be,

2097
01:11:24,191 --> 01:11:26,191
so I think I'm done with the second of 8 problems,

2098
01:11:26,231 --> 01:11:27,622
and I'll do this a little faster now.

2099
01:11:27,832 --> 01:11:29,711
2 and 44 and 1 swap,

2100
01:11:30,151 --> 01:11:31,032
4 and 5 are good,

2101
01:11:31,111 --> 01:11:32,291
5 and 0 swap,

2102
01:11:32,381 --> 01:11:33,662
5 and 3 swap,

2103
01:11:33,912 --> 01:11:35,622
and now we've solved 3 problems.

2104
01:11:35,631 --> 01:11:38,102
Let me reset 2 and 1 swap,

2105
01:11:38,432 --> 01:11:39,381
2 and 4 are good,

2106
01:11:39,392 --> 01:11:40,591
4 and 0 swap,

2107
01:11:40,651 --> 01:11:42,412
4 and 3 swap,

2108
01:11:42,551 --> 01:11:44,071
and now I've solved half of the problems.

2109
01:11:44,142 --> 01:11:44,782
4 out of 8,

2110
01:11:44,791 --> 01:11:45,582
we're almost done.

2111
01:11:45,821 --> 01:11:46,662
1 and 2 are good,

2112
01:11:46,711 --> 01:11:48,171
2 and 0 swap.

2113
01:11:48,689 --> 01:11:49,609
2 and 3 are good,

2114
01:11:49,819 --> 01:11:49,979
OK,

2115
01:11:50,060 --> 01:11:52,520
and now we're done with 5 out of the 8 problems,

2116
01:11:52,660 --> 01:11:54,169
1 and 0 swap.

2117
01:11:55,350 --> 01:11:55,540
Uh,

2118
01:11:55,549 --> 01:11:57,109
1 and 2 are good.

2119
01:11:57,310 --> 01:11:58,100
Those are all good.

2120
01:11:58,149 --> 01:12:00,020
And let me just do a final sanity check.

2121
01:12:00,310 --> 01:12:02,660
Everything now is sorted,

2122
01:12:02,910 --> 01:12:05,750
so now I'm done solving all eight of those problems.

2123
01:12:05,830 --> 01:12:06,830
So you all were wonderful.

2124
01:12:06,950 --> 01:12:07,709
We need the numbers back,

2125
01:12:07,750 --> 01:12:09,720
but Kelly has some delightful Pez dispensers for you on

2126
01:12:09,720 --> 01:12:10,930
the way out if you want to head that way,

2127
01:12:11,069 --> 01:12:12,629
just leave the numbers on the shelves and a round of

2128
01:12:12,629 --> 01:12:15,779
applause for our 8 volunteers for helping to act this out.

2129
01:12:18,910 --> 01:12:19,419
Thank you.

2130
01:12:21,169 --> 01:12:21,910
So

2131
01:12:22,290 --> 01:12:27,529
let's see if we can't formalize what these volunteers kindly just did with us,

2132
01:12:27,609 --> 01:12:28,939
starting with the first of those algorithms,

2133
01:12:29,049 --> 01:12:29,370
thank you,

2134
01:12:29,569 --> 01:12:30,770
namely selection sort.

2135
01:12:30,810 --> 01:12:33,399
Let's see if we can't slap some pseudo code on this,

2136
01:12:33,609 --> 01:12:36,879
thinking of our humans now as more generically in array.

2137
01:12:37,049 --> 01:12:39,609
So we had the first person at location 0 and

2138
01:12:39,609 --> 01:12:42,109
we had the last person at location N minus 1.

2139
01:12:42,290 --> 01:12:45,600
And just for clarity so that you've kind of seen the symbology,

2140
01:12:45,810 --> 01:12:48,279
this obviously is going to be location N minus 2.

2141
01:12:48,810 --> 01:12:51,620
Location and minus 3 and so forth until it's sort of

2142
01:12:51,620 --> 01:12:54,399
you hit the other end that we've already written out.

2143
01:12:54,609 --> 01:12:56,259
So that's just how we refer to all of our

2144
01:12:56,259 --> 01:13:01,040
8 volunteers' locations or in this case 1234567 locations,

2145
01:13:01,060 --> 01:13:03,620
but in the middle connoting that this can be a much,

2146
01:13:03,640 --> 01:13:05,160
much larger array.

2147
01:13:05,370 --> 01:13:07,209
So here's some pseudo code for the first algorithm

2148
01:13:07,209 --> 01:13:11,279
selection sort for I from 0 ton minus 1.

2149
01:13:11,529 --> 01:13:12,729
So from the first element

2150
01:13:12,970 --> 01:13:14,080
to the last element,

2151
01:13:14,450 --> 01:13:16,569
find the smallest number between.

2152
01:13:17,009 --> 01:13:19,049
The numbers bracket I and numbers

2153
01:13:19,350 --> 01:13:20,290
and minus 1.

2154
01:13:20,350 --> 01:13:21,129
In other words,

2155
01:13:21,529 --> 01:13:23,879
if you're starting I at 0,

2156
01:13:24,209 --> 01:13:29,970
look at specifically every lighted number between 0 and location N minus 1.

2157
01:13:30,640 --> 01:13:32,669
When you have found that smallest element,

2158
01:13:32,919 --> 01:13:33,680
swap it

2159
01:13:34,040 --> 01:13:35,910
with the number at location I,

2160
01:13:35,919 --> 01:13:36,970
which starts again at 0.

2161
01:13:37,160 --> 01:13:37,839
That's how we got,

2162
01:13:37,879 --> 01:13:38,169
I think,

2163
01:13:38,180 --> 01:13:40,709
Jaden into place at the very beginning.

2164
01:13:40,959 --> 01:13:41,799
Then I,

2165
01:13:41,810 --> 01:13:43,390
by nature of how 4 loops work,

2166
01:13:43,600 --> 01:13:46,359
gets updated from 0 to 1 so that we do the same thing.

2167
01:13:46,439 --> 01:13:49,149
Find the smallest number between numbers 1,

2168
01:13:49,399 --> 01:13:52,439
so the second element through the 8th element because this

2169
01:13:52,439 --> 01:13:54,720
number is unchanged and is the total number of values,

2170
01:13:54,759 --> 01:13:56,509
so the end point there is not changing.

2171
01:13:56,720 --> 01:13:58,359
Once we found the second smallest person,

2172
01:13:58,399 --> 01:13:59,520
we swap them with.

2173
01:13:59,669 --> 01:14:02,129
Location I aka 1,

2174
01:14:02,189 --> 01:14:04,399
and that's how we got the number 1 into position and then

2175
01:14:04,399 --> 01:14:06,509
the number 2 and then the number 3 and number 4.

2176
01:14:06,680 --> 01:14:09,830
So this then was selection sort in pseudo code form

2177
01:14:09,830 --> 01:14:12,470
and that allowed us to actually go through this list

2178
01:14:12,839 --> 01:14:16,680
again and again and again in order to find the next smallest element.

2179
01:14:16,759 --> 01:14:20,310
So what was happening a little more methodically if it helps just to map

2180
01:14:20,600 --> 01:14:23,370
that symbology of the bracket notation in the eyes,

2181
01:14:23,560 --> 01:14:25,629
if this is where we started with location I

2182
01:14:25,629 --> 01:14:28,799
and we did everything between location and minus 1.

2183
01:14:29,220 --> 01:14:31,930
Essentially I traversed this whole list from left to right,

2184
01:14:32,049 --> 01:14:35,129
literally walking in front of our volunteers looking at each element,

2185
01:14:35,209 --> 01:14:36,939
and the first element I saw was 7.

2186
01:14:37,330 --> 01:14:39,720
At the moment that was the smallest element I had found,

2187
01:14:39,729 --> 01:14:40,310
and who knows,

2188
01:14:40,370 --> 01:14:41,080
in a different list.

2189
01:14:41,129 --> 01:14:42,939
Maybe 7 would be the smallest element,

2190
01:14:43,009 --> 01:14:45,319
so I kind of stored it in a variable in my mind,

2191
01:14:45,520 --> 01:14:46,859
but I checked then 2 and remembered,

2192
01:14:46,930 --> 01:14:47,049
no,

2193
01:14:47,089 --> 01:14:47,129
no,

2194
01:14:47,160 --> 01:14:47,250
no,

2195
01:14:47,339 --> 01:14:49,649
2 is clearly less than now I'm going to remember 2.

2196
01:14:50,100 --> 01:14:50,399
OK,

2197
01:14:50,479 --> 01:14:52,149
now I'm going to remember one when I find it,

2198
01:14:52,200 --> 01:14:54,029
and then I'm going to remember 0 when I find it,

2199
01:14:54,040 --> 01:14:58,069
and then what I did once I found jade in it with the value of 0,

2200
01:14:58,779 --> 01:14:59,589
light it up.

2201
01:14:59,799 --> 01:15:02,509
I moved that location to here

2202
01:15:02,759 --> 01:15:05,830
and then evicted Precious recall and moved Precious over

2203
01:15:05,830 --> 01:15:07,520
to that location that we had freed up.

2204
01:15:07,640 --> 01:15:08,069
Why?

2205
01:15:08,279 --> 01:15:09,950
Why all this sort of back and forth?

2206
01:15:10,080 --> 01:15:10,240
Well,

2207
01:15:10,399 --> 01:15:13,799
you have to assume with an array that you're not entitled to the memory over here.

2208
01:15:13,913 --> 01:15:16,542
You're not entitled to the memory over here if you've

2209
01:15:16,542 --> 01:15:19,612
already decided that you have 7 lockers or 8 people,

2210
01:15:19,823 --> 01:15:21,382
you have to commit to the computer in advance.

2211
01:15:21,422 --> 01:15:23,982
That's why we put the number typically in the square brackets or the

2212
01:15:23,982 --> 01:15:28,812
compiler infers from the curly brackets how big the array actually is.

2213
01:15:29,022 --> 01:15:29,172
All right,

2214
01:15:29,223 --> 01:15:31,893
and suffice it to say when I went through this again and again and again,

2215
01:15:32,062 --> 01:15:33,502
I did the same thing over and over.

2216
01:15:33,592 --> 01:15:36,612
Now you might have thought me sort of dumb for having

2217
01:15:37,022 --> 01:15:37,583
asked the same.

2218
01:15:37,735 --> 01:15:40,726
Questions again and again like I was surprised to discover the number 1.

2219
01:15:40,766 --> 01:15:42,806
I was surprised to discover the number 2,

2220
01:15:43,005 --> 01:15:46,956
even though on my very first pass I literally looked at all eight of those numbers.

2221
01:15:46,965 --> 01:15:49,596
But you have to think about what memory I'm actually using

2222
01:15:49,806 --> 01:15:49,925
now.

2223
01:15:49,936 --> 01:15:53,155
I certainly could have memorized all of the numbers and where they are,

2224
01:15:53,315 --> 01:15:56,005
but I proposed that just very simply I was using like a single

2225
01:15:56,005 --> 01:15:59,875
variable in my brain just to keep track of the then smallest element.

2226
01:15:59,976 --> 01:16:01,516
And once I'm done finding that

2227
01:16:01,766 --> 01:16:02,686
and solving that problem,

2228
01:16:02,786 --> 01:16:04,686
I moved on to do it again and again.

2229
01:16:04,939 --> 01:16:06,029
But that's going to be a trade off,

2230
01:16:06,049 --> 01:16:08,359
and this is going to be thematic in the coming weeks whereby,

2231
01:16:08,569 --> 01:16:08,729
well,

2232
01:16:08,850 --> 01:16:12,180
sure you could use more memory and I could have been smarter about it

2233
01:16:12,180 --> 01:16:16,330
and maybe that would have improved or hurt the running time of the algorithm.

2234
01:16:16,410 --> 01:16:20,560
There's often going to be a trade-off between how much memory or how much time

2235
01:16:20,770 --> 01:16:21,709
you actually use.

2236
01:16:21,810 --> 01:16:23,620
So we'll discover that over time.

2237
01:16:23,890 --> 01:16:27,049
So how fast or slow is selection sort?

2238
01:16:27,129 --> 01:16:27,209
Well,

2239
01:16:27,450 --> 01:16:29,200
consider when I had 8 humans on stage,

2240
01:16:29,410 --> 01:16:30,689
I first went through.

2241
01:16:31,209 --> 01:16:31,450
Uh,

2242
01:16:31,459 --> 01:16:32,359
all of them,

2243
01:16:32,569 --> 01:16:34,270
but how many comparisons did I make?

2244
01:16:34,410 --> 01:16:34,569
Really,

2245
01:16:34,629 --> 01:16:37,959
I was doing N minus 1 comparisons because if I've got N people,

2246
01:16:38,089 --> 01:16:41,560
I've got to compare the smallest number I found against everyone else,

2247
01:16:41,649 --> 01:16:42,520
and you compare

2248
01:16:42,810 --> 01:16:44,100
N people left to right,

2249
01:16:44,229 --> 01:16:45,759
N minus 1 times total.

2250
01:16:45,930 --> 01:16:47,359
So the first pass I was making,

2251
01:16:47,490 --> 01:16:49,129
I was asking N minus 1 questions.

2252
01:16:49,209 --> 01:16:49,930
Is this the smallest?

2253
01:16:49,950 --> 01:16:50,750
Is this the smallest?

2254
01:16:50,930 --> 01:16:52,729
Is this the smallest N minus 1 times?

2255
01:16:52,930 --> 01:16:56,279
Once I solved one problem when we got Jayden into Jayden's right place,

2256
01:16:56,529 --> 01:16:56,910
then

2257
01:16:57,209 --> 01:16:58,399
I had one fewer problem,

2258
01:16:58,490 --> 01:16:58,649
then.

2259
01:16:58,770 --> 01:17:00,330
One fewer fewer problem and so forth.

2260
01:17:00,410 --> 01:17:03,140
So it was like n minus 1 steps plus

2261
01:17:03,250 --> 01:17:08,129
N minus 2 steps plus N minus 3 steps plus one final

2262
01:17:08,129 --> 01:17:10,790
step once I got to the final of the eight problems.

2263
01:17:10,890 --> 01:17:13,410
Now if you remember kind of the cheat sheet at the back of your math books,

2264
01:17:13,729 --> 01:17:14,479
say growing up,

2265
01:17:14,689 --> 01:17:19,890
you'll note that this series here can be more simply written as N times N minus 1,

2266
01:17:19,930 --> 01:17:20,970
all divided by 2.

2267
01:17:21,089 --> 01:17:22,169
And if you've not seen that before,

2268
01:17:22,250 --> 01:17:26,370
just take on faith that this is identical to this series of numbers up here.

2269
01:17:26,750 --> 01:17:28,509
So now we can just kind of multiply this out.

2270
01:17:28,609 --> 01:17:31,919
So that's technically n2 minus N all divided by 2,

2271
01:17:32,129 --> 01:17:34,129
which is great if we multiply that out,

2272
01:17:34,140 --> 01:17:36,069
that's n2d over 2 minus n over 2.

2273
01:17:36,250 --> 01:17:37,209
We're getting 2 into the weeds.

2274
01:17:37,290 --> 01:17:40,330
Let's whip out our big O notation now whereby we

2275
01:17:40,330 --> 01:17:42,959
can wave our hands at the lower order terms,

2276
01:17:43,209 --> 01:17:44,600
only care about the biggest,

2277
01:17:44,649 --> 01:17:47,689
most dominant term which mathematically in this expression,

2278
01:17:47,729 --> 01:17:49,680
if you plug in a really big value of n,

2279
01:17:49,930 --> 01:17:52,060
which is going to matter more the N squared,

2280
01:17:52,169 --> 01:17:52,729
the 2,

2281
01:17:52,850 --> 01:17:53,319
the N,

2282
01:17:53,330 --> 01:17:54,009
or the 2.

2283
01:17:55,310 --> 01:17:56,310
Like the N squared,

2284
01:17:56,390 --> 01:17:59,430
like the others absolutely contribute to the total value,

2285
01:17:59,509 --> 01:18:01,310
but if you plug in a really big value,

2286
01:18:01,350 --> 01:18:03,509
the dominant force is going to be this n squared

2287
01:18:03,509 --> 01:18:05,540
because that's really going to blow up the total value.

2288
01:18:05,790 --> 01:18:09,149
So we can say that selection sort when analyzed in this way,

2289
01:18:09,200 --> 01:18:09,419
ah,

2290
01:18:09,669 --> 01:18:14,879
it's on the order of n squared steps because I'm doing so many comparisons

2291
01:18:15,140 --> 01:18:16,220
so many times.

2292
01:18:16,629 --> 01:18:17,979
So if that's the case,

2293
01:18:18,149 --> 01:18:19,359
the question then is,

2294
01:18:19,819 --> 01:18:20,140
Um,

2295
01:18:20,399 --> 01:18:22,879
what is indeed not just its upper bound but

2296
01:18:22,879 --> 01:18:24,950
maybe it's lower bound as we'll eventually see.

2297
01:18:25,000 --> 01:18:26,439
So for selection sort for now,

2298
01:18:26,479 --> 01:18:29,000
let's stipulate that it's indeed in big O of N2,

2299
01:18:29,040 --> 01:18:30,830
and that's actually the worst of the algorithms we've seen.

2300
01:18:30,879 --> 01:18:33,399
Like that's way slower than linear search because at

2301
01:18:33,399 --> 01:18:35,240
least linear search was big O of N.

2302
01:18:35,680 --> 01:18:37,080
Selection sort is n square,

2303
01:18:37,120 --> 01:18:38,479
which of course is n times n,

2304
01:18:38,560 --> 01:18:40,200
which is and will feel much,

2305
01:18:40,439 --> 01:18:42,149
much slower than that.

2306
01:18:42,479 --> 01:18:46,609
So what if though we consider the lower bound of selection sort?

2307
01:18:46,680 --> 01:18:46,799
All right,

2308
01:18:46,879 --> 01:18:48,160
maybe it's bad in the worst case,

2309
01:18:48,200 --> 01:18:50,750
but maybe it's really good when the numbers are mostly sorted.

2310
01:18:51,040 --> 01:18:54,069
Unfortunately this is the same pseudo code for selection sort.

2311
01:18:54,319 --> 01:18:58,430
We make no allowance for checking the list to make sure it's already sorted,

2312
01:18:58,600 --> 01:19:01,589
and in fact that's kind of a perverse case to consider for any algorithm.

2313
01:19:01,759 --> 01:19:03,120
What if the problem's already solved?

2314
01:19:03,129 --> 01:19:04,520
How's your algorithm going to perform?

2315
01:19:04,754 --> 01:19:05,615
All of my volunteers,

2316
01:19:05,634 --> 01:19:07,904
as they kind of almost did accidentally,

2317
01:19:08,104 --> 01:19:09,865
they started lining up roughly in order.

2318
01:19:10,024 --> 01:19:12,495
Suppose they literally had been in order from 0 to 7.

2319
01:19:12,745 --> 01:19:12,794
Well,

2320
01:19:12,825 --> 01:19:16,225
my stupid algorithm would still have me walking back and forth,

2321
01:19:16,334 --> 01:19:17,015
back and forth,

2322
01:19:17,075 --> 01:19:17,625
back and forth.

2323
01:19:17,665 --> 01:19:18,015
Why?

2324
01:19:18,185 --> 01:19:21,575
Because the code literally tells me do this this many times

2325
01:19:21,575 --> 01:19:24,495
and every time I do that find the smallest element.

2326
01:19:24,625 --> 01:19:26,265
So it's going to be sort of a stupid output

2327
01:19:26,265 --> 01:19:28,214
because the list is not going to be any change,

2328
01:19:28,345 --> 01:19:29,975
any any at all changed,

2329
01:19:30,265 --> 01:19:31,455
but my code is not

2330
01:19:31,754 --> 01:19:33,785
taking into account in any way.

2331
01:19:34,149 --> 01:19:35,970
The original order of the numbers.

2332
01:19:36,049 --> 01:19:36,890
So no matter what,

2333
01:19:37,009 --> 01:19:40,029
this is to say that if we consider whether the lockers or the humans,

2334
01:19:40,200 --> 01:19:42,169
the omega notation for this algorithm,

2335
01:19:42,330 --> 01:19:44,720
even in the best case where the data is already sorted,

2336
01:19:44,890 --> 01:19:45,839
is crazily

2337
01:19:46,209 --> 01:19:46,799
also

2338
01:19:46,970 --> 01:19:48,120
n squad.

2339
01:19:48,350 --> 01:19:49,930
Now I could certainly change the pseudo code,

2340
01:19:50,049 --> 01:19:52,810
but selection sort as the world knows it is more of a.

2341
01:19:53,049 --> 01:19:55,330
Constrative algorithm or sort of a quick and dirty one,

2342
01:19:55,629 --> 01:19:58,910
its running time is going to be in omega of N2,

2343
01:19:58,919 --> 01:20:01,140
and now we can actually deploy our fader notation

2344
01:20:01,549 --> 01:20:05,770
because the big O notation is N2d and the omega notation is n2 1 and the same.

2345
01:20:05,910 --> 01:20:09,009
We can also say that selection sort is in theta of N2,

2346
01:20:09,029 --> 01:20:11,700
which is not great because that's annoyingly slow.

2347
01:20:12,100 --> 01:20:14,669
So maybe the solution here is don't do that.

2348
01:20:14,799 --> 01:20:15,979
Let's use bubble sort instead.

2349
01:20:16,080 --> 01:20:20,029
The second algorithm where I just compared everyone side by side again and again.

2350
01:20:20,200 --> 01:20:20,319
Well,

2351
01:20:20,399 --> 01:20:22,000
here's some pseudo code for bubbleor,

2352
01:20:22,040 --> 01:20:24,310
which you can assume applies to the same kind of array

2353
01:20:24,640 --> 01:20:26,709
from 0 on up to n minus 1.

2354
01:20:27,000 --> 01:20:28,479
Here's one way to write bubble sort.

2355
01:20:28,799 --> 01:20:30,629
Repeat the following N times.

2356
01:20:31,040 --> 01:20:31,830
For I,

2357
01:20:32,080 --> 01:20:34,069
from 0 ton minus 2,

2358
01:20:34,600 --> 01:20:36,509
if the number at location I

2359
01:20:36,799 --> 01:20:39,950
and the number at location I + 1 are out of order,

2360
01:20:40,509 --> 01:20:41,270
swap them.

2361
01:20:41,870 --> 01:20:44,490
And there's kind of an elegance to this algorithm and that like that's

2362
01:20:44,490 --> 01:20:47,120
it and you just assume that when you go through the list,

2363
01:20:47,209 --> 01:20:49,759
this is how from I from 0 ton minus 2,

2364
01:20:49,890 --> 01:21:01,000
this is how I was effectively comparing elements 0 and 11 and 22 and 33 and 476 and 7,

2365
01:21:01,529 --> 01:21:02,620
but notice I didn't say 8,

2366
01:21:02,689 --> 01:21:03,660
there were 8 total people.

2367
01:21:03,850 --> 01:21:07,339
Why do we go from 0 ton minus 2 instead of

2368
01:21:07,779 --> 01:21:09,890
from 0 ton minus 1?

2369
01:21:10,819 --> 01:21:11,089
Uh,

2370
01:21:11,100 --> 01:21:11,370
yeah.

2371
01:21:12,500 --> 01:21:12,790
Yeah

2372
01:21:13,609 --> 01:21:14,620
You already checked the glass.

2373
01:21:17,279 --> 01:21:17,750
Not quite.

2374
01:21:17,839 --> 01:21:19,490
So it's not that we've already checked the last one.

2375
01:21:19,560 --> 01:21:21,350
I'm saying with this line of code here,

2376
01:21:21,470 --> 01:21:23,859
we never even go to N minus 1 technically.

2377
01:21:24,359 --> 01:21:26,279
If we have N minus 345,

2378
01:21:26,290 --> 01:21:29,470
and it's going to compare against N minus 1 because that's.

2379
01:21:30,100 --> 01:21:30,509
Exactly,

2380
01:21:30,740 --> 01:21:32,379
because we're doing this simple arithmetic here,

2381
01:21:32,419 --> 01:21:34,500
we're checking current location I plus 1.

2382
01:21:34,620 --> 01:21:36,259
You can think of these as my left and right hand.

2383
01:21:36,379 --> 01:21:37,500
Left hand is pointing at 0,

2384
01:21:37,540 --> 01:21:38,729
right hand's pointing at 1.

2385
01:21:38,899 --> 01:21:42,689
I don't want to do something stupid and have my left hand point at N minus 1

2386
01:21:42,689 --> 01:21:46,109
because then my right hand arithmetically when you add 1 is going to point at N,

2387
01:21:46,660 --> 01:21:47,490
which does not exist.

2388
01:21:47,580 --> 01:21:50,930
That's beyond the boundary of the array because the array goes from 0

2389
01:21:51,299 --> 01:21:52,419
ton minus 1.

2390
01:21:52,470 --> 01:21:53,470
So just a live.

2391
01:21:53,540 --> 01:21:57,959
A bit of a safety check there to make sure we don't walk right off the end of the array,

2392
01:21:58,169 --> 01:22:02,000
but we do this end times because recall that Precious ended up being where

2393
01:22:02,649 --> 01:22:05,109
7 needed to be at the very end of the list,

2394
01:22:05,129 --> 01:22:10,379
but that didn't mean there weren't 77 more problems still to solve 0 through 6.

2395
01:22:10,450 --> 01:22:13,140
So I did it again and I did it again and per its name bubble sort,

2396
01:22:13,279 --> 01:22:14,890
the biggest element bubbled up first,

2397
01:22:15,049 --> 01:22:15,959
then the next biggest,

2398
01:22:16,049 --> 01:22:16,770
then the next biggest,

2399
01:22:16,850 --> 01:22:17,009
then.

2400
01:22:17,779 --> 01:22:19,000
biggest that is 7,

2401
01:22:19,080 --> 01:22:19,520
then 6,

2402
01:22:19,600 --> 01:22:20,009
then 5,

2403
01:22:20,100 --> 01:22:20,709
then 4,

2404
01:22:21,000 --> 01:22:22,069
and we got lucky on some of them,

2405
01:22:22,080 --> 01:22:24,029
but eventually we finished with 0.

2406
01:22:24,240 --> 01:22:25,910
So how do we analyze this thing?

2407
01:22:26,040 --> 01:22:26,100
Well,

2408
01:22:26,160 --> 01:22:29,640
we could also technically do this N minus 1 times as an aside if

2409
01:22:29,640 --> 01:22:32,600
you're thinking through that I'm wasting some time because we get one for free.

2410
01:22:32,680 --> 01:22:33,709
Once we get to

2411
01:22:34,200 --> 01:22:35,250
solving 7ve problems,

2412
01:22:35,319 --> 01:22:38,549
you get the 8th 1 for free because that person is obviously where they need to go.

2413
01:22:38,799 --> 01:22:40,589
So when we had these numbers initially,

2414
01:22:40,990 --> 01:22:42,859
And we were comparing them with bubbleword again,

2415
01:22:42,979 --> 01:22:43,669
left hand right hand.

2416
01:22:43,729 --> 01:22:44,700
It's like treat this as I,

2417
01:22:44,740 --> 01:22:45,810
this is I plus 1,

2418
01:22:46,020 --> 01:22:47,689
and we just kept swapping

2419
01:22:47,979 --> 01:22:50,970
pair wise numbers if in fact they were out of order.

2420
01:22:51,180 --> 01:22:56,009
So all this is saying is what our humans were doing for us organically.

2421
01:22:56,220 --> 01:22:58,660
So how do we actually analyze the running time of this?

2422
01:22:58,740 --> 01:23:03,540
Last time I just kind of spitballed that it was minus 1 steps plus N minus 2 steps.

2423
01:23:03,620 --> 01:23:03,669
Well,

2424
01:23:03,700 --> 01:23:07,049
you can actually look at pseudocode sometimes and if it's neatly written,

2425
01:23:07,220 --> 01:23:11,839
you can actually Infer from the pseudo code how many steps each line is going to take.

2426
01:23:12,049 --> 01:23:12,490
For instance,

2427
01:23:12,609 --> 01:23:14,479
how many steps does this first line take?

2428
01:23:14,729 --> 01:23:14,930
I mean,

2429
01:23:15,009 --> 01:23:16,370
like literally n minus 1.

2430
01:23:16,410 --> 01:23:19,759
The answer is right there because it's saying to the computer or to me acting it out,

2431
01:23:20,129 --> 01:23:21,759
repeat the following N minus 1 times.

2432
01:23:22,000 --> 01:23:22,129
All right,

2433
01:23:22,209 --> 01:23:23,040
so that's helpful.

2434
01:23:23,250 --> 01:23:23,979
How many lines,

2435
01:23:24,250 --> 01:23:26,569
how many steps does this inner loop

2436
01:23:26,850 --> 01:23:27,529
induce?

2437
01:23:27,770 --> 01:23:27,810
Well,

2438
01:23:27,890 --> 01:23:29,890
you're going from 1 ton minus 2,

2439
01:23:29,930 --> 01:23:32,080
so that's actually N minus 1,

2440
01:23:32,609 --> 01:23:33,790
total steps,

2441
01:23:33,939 --> 01:23:34,439
not n.

2442
01:23:34,810 --> 01:23:36,500
And then this question here,

2443
01:23:36,509 --> 01:23:39,939
if numbers bracket 1 and numbers 1 are out of order,

2444
01:23:40,069 --> 01:23:41,259
it's a single question.

2445
01:23:41,350 --> 01:23:42,470
It's like our Boolean expression,

2446
01:23:42,479 --> 01:23:43,310
we'll call it one.

2447
01:23:43,470 --> 01:23:43,700
I mean,

2448
01:23:43,709 --> 01:23:45,470
maybe you need to do a bit of more work than that,

2449
01:23:45,520 --> 01:23:47,200
but it's a constant number of steps.

2450
01:23:47,229 --> 01:23:48,540
Doesn't matter how big the list is,

2451
01:23:48,669 --> 01:23:50,990
comparing two numbers is always going to take the same amount of time.

2452
01:23:51,319 --> 01:23:52,390
And then swapping them,

2453
01:23:52,500 --> 01:23:52,720
oh,

2454
01:23:52,790 --> 01:23:53,149
I don't know,

2455
01:23:53,270 --> 01:23:56,109
it's going to take like 1 or 2 or 3 steps,

2456
01:23:56,120 --> 01:23:58,669
but constant doesn't matter which the numbers are,

2457
01:23:58,910 --> 01:24:00,140
takes the same amount of work.

2458
01:24:00,390 --> 01:24:01,270
So let's stipulate,

2459
01:24:01,350 --> 01:24:01,990
let me rewind,

2460
01:24:02,069 --> 01:24:03,979
stipulate that the real things that matter

2461
01:24:04,229 --> 01:24:04,870
are the loops,

2462
01:24:04,990 --> 01:24:06,310
these constant number of steps,

2463
01:24:06,390 --> 01:24:07,509
who really cares?

2464
01:24:07,540 --> 01:24:09,990
But the loops are what are going to add up as N gets large.

2465
01:24:10,069 --> 01:24:11,109
So this really then is.

2466
01:24:11,225 --> 01:24:12,424
If this is the outer loop

2467
01:24:12,734 --> 01:24:13,584
and this is the inner loop,

2468
01:24:13,665 --> 01:24:16,125
think about our two dimensional Mario square from week one.

2469
01:24:16,154 --> 01:24:17,774
We did something on the outside and then something

2470
01:24:17,774 --> 01:24:19,935
on the inside to get our rows and columns.

2471
01:24:20,055 --> 01:24:23,064
This is equivalent to N minus 1 times N minus 1.

2472
01:24:23,294 --> 01:24:28,174
If we do our little foil method N2 minus N minus N + 1 combined like terms,

2473
01:24:28,225 --> 01:24:29,895
N2 minus 2 N + 1,

2474
01:24:30,214 --> 01:24:31,334
who cares?

2475
01:24:31,495 --> 01:24:34,935
This is ultimately going to be on the order of big O of.

2476
01:24:36,689 --> 01:24:39,129
N squared only because again if you ask yourself when

2477
01:24:39,129 --> 01:24:41,140
I plug in a really big value for N,

2478
01:24:41,450 --> 01:24:44,520
which of these is really going to contribute most to the answer,

2479
01:24:44,649 --> 01:24:48,200
it's obviously going to be n2d again and we can ignore the lower order terms.

2480
01:24:48,370 --> 01:24:50,279
So this doesn't seem to have made any progress.

2481
01:24:50,330 --> 01:24:54,879
Like selection sort was on the order of big events was on the order of N2d.

2482
01:24:55,049 --> 01:24:55,810
Bubble sort,

2483
01:24:56,089 --> 01:24:57,169
based on this analysis is.

2484
01:24:57,283 --> 01:24:58,553
Also on the order of N2d,

2485
01:24:58,592 --> 01:25:00,272
maybe we're getting lucky in the lower bound.

2486
01:25:00,312 --> 01:25:01,772
So on the upper bound for bubble sort,

2487
01:25:02,312 --> 01:25:03,393
it's indeed N2d,

2488
01:25:03,402 --> 01:25:04,473
as was selection sort.

2489
01:25:04,553 --> 01:25:06,632
But with this pseudo code for bubble sort,

2490
01:25:07,312 --> 01:25:08,333
unfortunately

2491
01:25:09,033 --> 01:25:09,192
we,

2492
01:25:09,283 --> 01:25:11,902
or rather unfortunately we were not doing anything clever

2493
01:25:12,112 --> 01:25:15,263
to catch that perverse case where maybe the list was already sorted.

2494
01:25:15,272 --> 01:25:15,763
After all,

2495
01:25:16,192 --> 01:25:17,833
consider if the list was sorted from 0 to.

2496
01:25:18,375 --> 01:25:20,965
I was still asking all the same darn questions.

2497
01:25:21,215 --> 01:25:22,605
Even if I did no work,

2498
01:25:22,655 --> 01:25:25,605
I was going to repeat that n minus 1 times back and forth,

2499
01:25:25,616 --> 01:25:26,806
making no swaps,

2500
01:25:26,855 --> 01:25:28,616
but making all of those comparisons.

2501
01:25:28,735 --> 01:25:31,215
But here's an enhancement to Bobble So that we can

2502
01:25:31,215 --> 01:25:33,766
add that selection So didn't really have room for.

2503
01:25:34,175 --> 01:25:38,686
I can say after one pass of this inner loop walking from left to right,

2504
01:25:39,016 --> 01:25:40,375
if I made no swaps,

2505
01:25:40,445 --> 01:25:41,125
quit.

2506
01:25:41,335 --> 01:25:42,056
So put another way,

2507
01:25:42,136 --> 01:25:44,655
if I traversed the list from left to right,

2508
01:25:44,735 --> 01:25:45,576
I make no swaps.

2509
01:25:45,616 --> 01:25:47,655
I might as well just terminate the algorithm then.

2510
01:25:48,180 --> 01:25:48,689
Because

2511
01:25:48,970 --> 01:25:51,569
there's no more work clearly to be done.

2512
01:25:51,779 --> 01:25:51,979
All right,

2513
01:25:52,060 --> 01:25:53,129
so based on that

2514
01:25:53,299 --> 01:25:54,250
modification,

2515
01:25:54,379 --> 01:25:58,330
the lower bound of bubble sorts running time

2516
01:25:58,500 --> 01:26:00,779
would be said to be an omega then of.

2517
01:26:02,270 --> 01:26:02,279
And

2518
01:26:03,660 --> 01:26:07,540
because I'm minimally going to need to make one pass through the list.

2519
01:26:07,580 --> 01:26:11,379
You can't possibly claim that the list is sorted unless you actually check it once.

2520
01:26:11,459 --> 01:26:12,220
And if there's an elements,

2521
01:26:12,259 --> 01:26:15,049
you're going to have to look at all of them to make sure that it's in order.

2522
01:26:15,339 --> 01:26:15,899
But after that,

2523
01:26:16,009 --> 01:26:17,970
if you've done no work and made no swaps,

2524
01:26:18,180 --> 01:26:21,169
no reason to traverse the list again and again and again.

2525
01:26:21,500 --> 01:26:21,839
So

2526
01:26:22,020 --> 01:26:27,180
a bubble sort can be said to be an omega of N because indeed we can just terminate.

2527
01:26:27,290 --> 01:26:29,109
After that single pass if we've done no work,

2528
01:26:29,240 --> 01:26:31,040
we can't say anything about theta because they're not

2529
01:26:31,040 --> 01:26:32,709
one and the same big O and Omega,

2530
01:26:32,879 --> 01:26:35,520
but that does seem to have given us some savings.

2531
01:26:35,600 --> 01:26:36,120
Unfortunately,

2532
01:26:36,160 --> 01:26:40,350
it really only saves us time when the list is already or mostly sorted,

2533
01:26:40,479 --> 01:26:42,399
but in the average case and in the worst case,

2534
01:26:42,439 --> 01:26:46,319
odds are they're both going to perform just as bad on the order of n2.

2535
01:26:46,399 --> 01:26:46,680
In fact,

2536
01:26:46,720 --> 01:26:48,520
let's take a look at a visualization that will make this

2537
01:26:48,520 --> 01:26:52,080
a little clearer than our own humans and voices might have.

2538
01:26:52,700 --> 01:26:56,180
Explained here is a bunch of vertical purple bars made

2539
01:26:56,180 --> 01:26:57,939
by a friend of ours in the real world,

2540
01:26:58,020 --> 01:26:59,339
and this is an animation that has a bunch

2541
01:26:59,339 --> 01:27:01,919
of buttons that lets us execute certain algorithms.

2542
01:27:02,020 --> 01:27:04,060
A small bar represents a small number.

2543
01:27:04,100 --> 01:27:05,850
A big bar represents a big number,

2544
01:27:05,859 --> 01:27:07,939
and the goal is to get them from small numbers or

2545
01:27:07,939 --> 01:27:10,810
small bars to big numbers or big bars left to right.

2546
01:27:11,020 --> 01:27:13,979
So I'm going to go ahead and click on selection sort initially,

2547
01:27:14,220 --> 01:27:16,129
and what you'll see from left to right

2548
01:27:16,339 --> 01:27:19,620
is in pink the current smallest element.

2549
01:27:19,742 --> 01:27:20,492
That's been discovered,

2550
01:27:20,532 --> 01:27:21,682
but also in pink,

2551
01:27:21,921 --> 01:27:24,881
the equivalent of my walking across the stage left to right

2552
01:27:25,131 --> 01:27:26,812
again and again and again trying to find

2553
01:27:26,812 --> 01:27:29,562
the next smallest element and you'll see clearly

2554
01:27:29,852 --> 01:27:31,571
just like when we put Jayden at the far left,

2555
01:27:31,651 --> 01:27:33,562
the smallest element ended up over here,

2556
01:27:33,771 --> 01:27:35,452
but it might take some time for Precious,

2557
01:27:35,532 --> 01:27:35,852
for instance,

2558
01:27:35,892 --> 01:27:39,171
or number 7 to end up all the way over on the right because

2559
01:27:39,171 --> 01:27:43,821
with each pass we're really just fixing one problem at a time and there's N

2560
01:27:44,282 --> 01:27:45,321
problems total,

2561
01:27:45,611 --> 01:27:46,812
which is giving us on the order of.

2562
01:27:47,124 --> 01:27:49,844
N squared steps and now the list is getting shorter,

2563
01:27:49,934 --> 01:27:51,724
so we're at least doing some work that you don't have to

2564
01:27:51,724 --> 01:27:54,434
keep touching the elements you already sorted with just like I was.

2565
01:27:54,693 --> 01:27:56,434
So now selection sort is complete.

2566
01:27:56,563 --> 01:27:58,523
Let's visualize instead bubble sort.

2567
01:27:58,583 --> 01:28:01,673
So let me re-randomize the array just so we're starting with a random order.

2568
01:28:01,854 --> 01:28:03,604
Now let's click on bubble sort and you'll

2569
01:28:03,604 --> 01:28:05,233
see the pink bars work a little differently.

2570
01:28:05,324 --> 01:28:08,644
It connotes which two numbers are being compared at that moment in time,

2571
01:28:08,724 --> 01:28:11,514
just like my left hand and right hand going left to right,

2572
01:28:11,764 --> 01:28:14,043
and you'll see that even though it's not quite as pretty.

2573
01:28:14,125 --> 01:28:16,505
A selection sort where I was getting at least

2574
01:28:16,505 --> 01:28:18,545
the smallest elements all the way to the left.

2575
01:28:18,795 --> 01:28:21,786
Here we're just fixing pair wise problems,

2576
01:28:21,795 --> 01:28:22,215
but

2577
01:28:22,516 --> 01:28:25,875
the biggest elements like Precious's number 7 are indeed

2578
01:28:25,875 --> 01:28:28,735
bubbling their way up to the top one after

2579
01:28:29,025 --> 01:28:29,666
the other.

2580
01:28:29,916 --> 01:28:30,636
But as you can see,

2581
01:28:30,715 --> 01:28:33,985
and this is where n2d is sort of visual visualizable,

2582
01:28:34,315 --> 01:28:39,065
we're touching these elements or looking at them so many times again and again.

2583
01:28:39,116 --> 01:28:41,235
We are making so many darn comparisons.

2584
01:28:41,509 --> 01:28:43,560
This is taking frustratingly long,

2585
01:28:43,689 --> 01:28:44,569
and this is only what,

2586
01:28:44,609 --> 01:28:46,919
a few dozen bars or numbers.

2587
01:28:47,009 --> 01:28:49,149
You can imagine how long this might take with hundreds,

2588
01:28:49,209 --> 01:28:50,839
thousands or millions of values.

2589
01:28:51,089 --> 01:28:54,370
I dare say we're gonna have to do better than bubble sort and

2590
01:28:55,540 --> 01:28:58,330
Selection sort because we're not stun even yet,

2591
01:28:58,939 --> 01:29:02,330
just trying to give the satisfaction of getting to the end and now we are,

2592
01:29:02,660 --> 01:29:05,979
but neither of those algorithms seems incredibly performing because

2593
01:29:05,979 --> 01:29:08,660
it's still taking us quite a bit of time

2594
01:29:08,890 --> 01:29:11,459
to actually get to that there solution.

2595
01:29:11,500 --> 01:29:13,899
So how can we actually do better than that?

2596
01:29:13,979 --> 01:29:14,410
Well,

2597
01:29:14,620 --> 01:29:17,370
we can try taking a fundamentally different approach,

2598
01:29:17,529 --> 01:29:19,399
and this is one technique that you might have

2599
01:29:19,399 --> 01:29:21,299
encountered in math or even in the real world,

2600
01:29:21,379 --> 01:29:24,220
even if you haven't sort of applied this name to it.

2601
01:29:24,549 --> 01:29:25,430
Recursion

2602
01:29:25,669 --> 01:29:29,470
is a technique in mathematics and in programming that allows you to take

2603
01:29:29,470 --> 01:29:32,720
sort of a fundamentally different approach to a problem and in short,

2604
01:29:32,990 --> 01:29:36,819
a recursive function is one that's defined in terms of itself.

2605
01:29:36,990 --> 01:29:39,109
So if you had like F of X equals F of

2606
01:29:39,109 --> 01:29:41,229
something on the right hand side of a mathematical expression,

2607
01:29:41,240 --> 01:29:42,459
that would be recursive in that

2608
01:29:42,790 --> 01:29:44,560
the function is dependent on itself.

2609
01:29:44,790 --> 01:29:47,140
More practically in the world of programming,

2610
01:29:47,310 --> 01:29:49,950
a recursive function is a function that calls it.

2611
01:29:50,040 --> 01:29:50,419
Self.

2612
01:29:50,669 --> 01:29:53,080
So if you are writing some function in C

2613
01:29:53,430 --> 01:29:56,259
and in that function you call yourself.

2614
01:29:56,310 --> 01:30:00,299
You actually have a line of code that says call that same function by the same name,

2615
01:30:00,549 --> 01:30:02,100
that function is recursive.

2616
01:30:02,350 --> 01:30:02,740
Now

2617
01:30:03,229 --> 01:30:05,750
this might feel a little weird because if a function is calling itself,

2618
01:30:05,790 --> 01:30:08,069
it feels like this is the easiest way to get into an infinite

2619
01:30:08,069 --> 01:30:10,569
loop because why would it ever stop if the function is calling itself,

2620
01:30:10,640 --> 01:30:11,060
calling itself,

2621
01:30:11,149 --> 01:30:11,589
calling itself,

2622
01:30:11,669 --> 01:30:12,350
calling itself?

2623
01:30:12,509 --> 01:30:14,740
We're going to have to actually address that kind of problem.

2624
01:30:14,830 --> 01:30:15,589
But in the real world.

2625
01:30:15,689 --> 01:30:16,790
We've actually,

2626
01:30:16,910 --> 01:30:18,100
or rather in this class already,

2627
01:30:18,109 --> 01:30:20,859
we've actually seen implicitly an example of this,

2628
01:30:20,870 --> 01:30:22,790
including today as well as in week 0.

2629
01:30:22,990 --> 01:30:25,180
So here's that algorithm for searching

2630
01:30:25,430 --> 01:30:29,629
the doors of the lockers and recall that after we did this

2631
01:30:29,629 --> 01:30:31,500
check at the very top if there are any doors left,

2632
01:30:31,549 --> 01:30:32,149
returned false,

2633
01:30:32,189 --> 01:30:33,750
if not,

2634
01:30:34,109 --> 01:30:35,299
we did these

2635
01:30:36,270 --> 01:30:36,720
conditions.

2636
01:30:36,910 --> 01:30:39,680
We said if the numbers behind the middle door returned true because we found it,

2637
01:30:39,870 --> 01:30:41,149
but things got interesting here.

2638
01:30:41,319 --> 01:30:44,779
I said if else if the number is less than the middle door,

2639
01:30:45,169 --> 01:30:46,899
then search the left half.

2640
01:30:47,109 --> 01:30:48,600
Else if the number is greater than the middle door,

2641
01:30:48,669 --> 01:30:50,270
then search the right half.

2642
01:30:50,509 --> 01:30:50,560
Well,

2643
01:30:50,589 --> 01:30:51,259
at that point in time,

2644
01:30:51,270 --> 01:30:53,140
you should be asking me or yourself,

2645
01:30:53,310 --> 01:30:53,390
well,

2646
01:30:53,430 --> 01:30:55,430
how do I search the left half?

2647
01:30:55,509 --> 01:30:56,850
How do I search the right half?

2648
01:30:57,149 --> 01:30:57,350
Well,

2649
01:30:57,390 --> 01:30:57,939
here you go.

2650
01:30:58,069 --> 01:31:01,620
Like on the screen right now is a search algorithm,

2651
01:31:01,830 --> 01:31:05,580
and even though it says down here search the left half or search the right half,

2652
01:31:05,870 --> 01:31:06,270
which is like,

2653
01:31:06,330 --> 01:31:06,390
well,

2654
01:31:06,470 --> 01:31:06,870
how do I do?

2655
01:31:06,959 --> 01:31:09,839
That we'll just use the same algorithm again

2656
01:31:10,069 --> 01:31:14,100
and this is how in terms of my voiceover you end up searching the left half

2657
01:31:14,100 --> 01:31:18,700
of the left half or the right half of the left half or any such combination.

2658
01:31:19,109 --> 01:31:21,060
This line here search left half,

2659
01:31:21,229 --> 01:31:23,939
this line here search right half is representative of

2660
01:31:24,229 --> 01:31:25,620
a recursive call.

2661
01:31:25,790 --> 01:31:29,580
This is an algorithm or a function that calls itself,

2662
01:31:29,830 --> 01:31:32,430
but why does it not induce an infinite loop?

2663
01:31:32,959 --> 01:31:37,830
Like why is it important that this line and this line are written exactly as they are,

2664
01:31:38,240 --> 01:31:40,910
so as to avoid this thing just forever searching

2665
01:31:41,479 --> 01:31:42,200
aimlessly,

2666
01:31:42,319 --> 01:31:42,830
yeah.

2667
01:31:45,129 --> 01:31:46,850
We do have this condition at which it stops,

2668
01:31:46,930 --> 01:31:47,930
but more importantly,

2669
01:31:48,089 --> 01:31:51,609
what is happening before I make these recursive calls?

2670
01:31:54,540 --> 01:31:54,979
Exactly,

2671
01:31:55,040 --> 01:31:55,939
I'm recursing,

2672
01:31:55,990 --> 01:31:56,970
that is calling myself,

2673
01:31:57,049 --> 01:32:00,160
but I'm handing myself a smaller problem,

2674
01:32:00,379 --> 01:32:01,379
a smaller problem,

2675
01:32:01,459 --> 01:32:02,600
a smaller problem.

2676
01:32:02,779 --> 01:32:05,649
It would be bad if I just handed myself the exact

2677
01:32:05,649 --> 01:32:07,660
same number of doors and just kept saying search these,

2678
01:32:07,819 --> 01:32:08,140
search these,

2679
01:32:08,259 --> 01:32:10,250
search these because you would never make any progress.

2680
01:32:10,419 --> 01:32:10,770
But

2681
01:32:10,939 --> 01:32:12,180
just like our volunteers earlier,

2682
01:32:12,299 --> 01:32:14,339
so long as we did divide and conquer and

2683
01:32:14,339 --> 01:32:16,540
we searched smaller and smaller numbers of doors,

2684
01:32:16,680 --> 01:32:18,379
eventually indeed we're going to bottom out and

2685
01:32:18,379 --> 01:32:20,770
either find the number we're looking for or

2686
01:32:21,080 --> 01:32:21,770
we're not.

2687
01:32:21,990 --> 01:32:22,279
So.

2688
01:32:22,637 --> 01:32:24,876
we're going to call these kinds of conditions that sort of

2689
01:32:24,876 --> 01:32:27,827
just ask a very obvious question and want an immediate answer

2690
01:32:28,157 --> 01:32:29,466
base cases.

2691
01:32:29,597 --> 01:32:33,276
Base cases are generally conditionals that ask a question to which the

2692
01:32:33,276 --> 01:32:35,546
answer is going to be yes or no right then and there.

2693
01:32:35,836 --> 01:32:36,986
A recursive case,

2694
01:32:37,046 --> 01:32:37,796
by contrast,

2695
01:32:37,997 --> 01:32:40,316
these two down here is when you actually need to do

2696
01:32:40,316 --> 01:32:42,876
a bit more work to get to your final answer.

2697
01:32:42,887 --> 01:32:44,106
You call yourself,

2698
01:32:44,157 --> 01:32:47,387
but with a smaller version of the problem.

2699
01:32:47,597 --> 01:32:50,356
So we could have in fact in week 0 have written this.

2700
01:32:50,503 --> 01:32:51,494
Sort of similarly,

2701
01:32:51,574 --> 01:32:53,463
if you go back to in your mind to week 0,

2702
01:32:53,854 --> 01:32:55,613
we had more of a procedural approach,

2703
01:32:55,693 --> 01:32:56,054
so to speak.

2704
01:32:56,133 --> 01:32:57,204
When we were searching the phone book,

2705
01:32:57,213 --> 01:33:01,054
I proposed that this induced what we called loops on line 8 and line 11,

2706
01:33:01,173 --> 01:33:03,324
which is literally said go back to line 3,

2707
01:33:03,423 --> 01:33:06,604
and that was more of a mechanical way of sort of inducing a loop structure.

2708
01:33:06,733 --> 01:33:08,333
But if I really wanted to be elegant,

2709
01:33:08,494 --> 01:33:09,273
I could have

2710
01:33:09,653 --> 01:33:09,963
said,

2711
01:33:10,054 --> 01:33:10,133
well,

2712
01:33:10,213 --> 01:33:10,574
you know what,

2713
01:33:10,583 --> 01:33:13,883
7 and 8 together really just means search the left half and

2714
01:33:13,883 --> 01:33:16,293
10 and 11 together really mean just search the right half.

2715
01:33:16,374 --> 01:33:18,454
So let's condense these.

2716
01:33:18,791 --> 01:33:21,840
Pairs of lines into shorter instructions.

2717
01:33:21,980 --> 01:33:23,070
Search the left half of the book,

2718
01:33:23,230 --> 01:33:24,261
search the right half of the book.

2719
01:33:24,391 --> 01:33:25,900
I can then delete two blank lines,

2720
01:33:25,911 --> 01:33:29,920
and now I have a recursive algorithm for searching a phone book.

2721
01:33:30,030 --> 01:33:33,480
It's a little less obvious because you have to ask yourself when you get to line 7 or 9,

2722
01:33:33,701 --> 01:33:34,070
Wait a minute,

2723
01:33:34,110 --> 01:33:35,780
how do I search the left half or the right half?

2724
01:33:35,791 --> 01:33:37,061
And that's when you need to realize

2725
01:33:37,351 --> 01:33:41,701
you start the same algorithm again but with a problem that's half as large.

2726
01:33:41,871 --> 01:33:44,471
In week 0 we do the procedural approach where we

2727
01:33:44,471 --> 01:33:46,471
literally tell you what line of code to go to.

2728
01:33:46,910 --> 01:33:47,580
But today

2729
01:33:47,750 --> 01:33:49,379
we're offering a different formulation,

2730
01:33:49,430 --> 01:33:52,459
a recursive approach where it's more implicit what you should do.

2731
01:33:52,779 --> 01:33:55,490
And we'll see now a couple of examples from the real world,

2732
01:33:55,620 --> 01:33:56,279
so to speak.

2733
01:33:56,490 --> 01:33:58,970
So here's a screenshot from Super Mario Brothers

2734
01:33:58,970 --> 01:34:01,779
1 on the original Nintendo Entertainment System.

2735
01:34:02,009 --> 01:34:03,770
Let me go ahead and get rid of some of the distraction,

2736
01:34:03,810 --> 01:34:06,680
like the ground and the mountains there,

2737
01:34:06,799 --> 01:34:08,569
and here we have a sort of half pyramid,

2738
01:34:08,609 --> 01:34:11,220
not unlike that you implemented in Problems set 1,

2739
01:34:11,450 --> 01:34:15,200
but this is an interesting real world physical structure

2740
01:34:15,490 --> 01:34:17,790
in that you can define it recursively,

2741
01:34:17,959 --> 01:34:19,609
like what is a pyramid of height.

2742
01:34:19,694 --> 01:34:20,274
4,

2743
01:34:20,314 --> 01:34:21,064
if you will.

2744
01:34:21,375 --> 01:34:21,625
Well,

2745
01:34:21,754 --> 01:34:22,584
just to be a little,

2746
01:34:22,665 --> 01:34:23,754
a little difficult,

2747
01:34:23,995 --> 01:34:26,645
a pyramid of height 4 is really just a pyramid of height 3

2748
01:34:26,955 --> 01:34:28,544
plus one more row.

2749
01:34:28,875 --> 01:34:29,154
OK,

2750
01:34:29,314 --> 01:34:29,354
well,

2751
01:34:29,475 --> 01:34:30,834
what is a pyramid of height 3?

2752
01:34:30,935 --> 01:34:30,995
Well,

2753
01:34:31,075 --> 01:34:35,825
a pyramid of height 3 is really just a pyramid of height 2 plus one more row.

2754
01:34:36,035 --> 01:34:36,134
Well,

2755
01:34:36,194 --> 01:34:37,595
what's a pyramid of height 2?

2756
01:34:37,654 --> 01:34:37,694
Well,

2757
01:34:37,754 --> 01:34:42,125
a pyramid of height 2 is really just a pyramid of height 1 plus one more row.

2758
01:34:42,354 --> 01:34:42,415
Well,

2759
01:34:42,475 --> 01:34:43,865
what's a pyramid of height 1?

2760
01:34:44,194 --> 01:34:46,435
A single brick on the screen.

2761
01:34:46,759 --> 01:34:49,379
And I sort of changed my tone with that last remark to convey

2762
01:34:49,379 --> 01:34:52,700
that this could then be our base case whereby I just tell you

2763
01:34:52,700 --> 01:34:56,020
what the thing is without sort of kicking the can and inviting you

2764
01:34:56,020 --> 01:34:59,200
to think through what a smaller structure is plus one more row,

2765
01:34:59,379 --> 01:35:00,649
whereas every other

2766
01:35:00,899 --> 01:35:03,669
definition I gave you then of a pyramid of some height

2767
01:35:03,939 --> 01:35:05,890
was defined in terms of

2768
01:35:06,220 --> 01:35:07,330
that same structure,

2769
01:35:07,410 --> 01:35:09,450
albeit a smaller version thereof.

2770
01:35:09,930 --> 01:35:11,660
So we can actually

2771
01:35:12,140 --> 01:35:13,029
see this in the real world.

2772
01:35:13,060 --> 01:35:15,100
Let me go ahead and pull up one thing here.

2773
01:35:15,180 --> 01:35:16,339
I'm going to go to.

2774
01:35:16,729 --> 01:35:18,600
Give me one sec before I flip over.

2775
01:35:18,850 --> 01:35:20,169
Here I am on Google.com,

2776
01:35:20,209 --> 01:35:22,359
if you'd like a little computer science humor here.

2777
01:35:22,529 --> 01:35:22,609
Uh,

2778
01:35:22,660 --> 01:35:26,259
if you ever Google search for recursion and hit enter,

2779
01:35:27,009 --> 01:35:27,950
you'll see

2780
01:35:28,330 --> 01:35:29,339
uh a joke that

2781
01:35:29,649 --> 01:35:31,279
computer scientists at Google find funny.

2782
01:35:33,319 --> 01:35:33,350
Ha ha,

2783
01:35:34,029 --> 01:35:34,830
12,

2784
01:35:34,870 --> 01:35:35,160
lasts.

2785
01:35:35,310 --> 01:35:36,459
Does anyone see the joke?

2786
01:35:36,629 --> 01:35:37,859
I did not make a typo,

2787
01:35:38,350 --> 01:35:39,580
but Google's asking me,

2788
01:35:39,750 --> 01:35:40,859
did I mean recursion?

2789
01:35:40,890 --> 01:35:42,009
And if I click on that,

2790
01:35:42,270 --> 01:35:44,629
I just get the same ha ha page.

2791
01:35:45,220 --> 01:35:45,600
OK,

2792
01:35:45,759 --> 01:35:45,919
all right,

2793
01:35:46,000 --> 01:35:46,759
that didn't go over well.

2794
01:35:46,830 --> 01:35:47,350
Anyhow,

2795
01:35:47,560 --> 01:35:48,029
so

2796
01:35:48,399 --> 01:35:50,819
there are these Easter eggs in the wild everywhere because

2797
01:35:50,819 --> 01:35:52,589
computer scientists are the ones that implement these things.

2798
01:35:52,680 --> 01:35:54,379
But let's go ahead and actually

2799
01:35:54,959 --> 01:35:55,520
implement,

2800
01:35:55,600 --> 01:35:56,160
for instance,

2801
01:35:56,319 --> 01:35:57,520
a version of this in code.

2802
01:35:57,580 --> 01:36:00,189
Let me go back over here in a moment to VS code,

2803
01:36:00,399 --> 01:36:01,479
and in VS Code,

2804
01:36:01,520 --> 01:36:03,310
let me propose that in my terminal window.

2805
01:36:03,479 --> 01:36:05,839
Let me create one of two final programs.

2806
01:36:05,879 --> 01:36:06,279
This one's.

2807
01:36:06,375 --> 01:36:08,924
Going to be called iteration.c just to make

2808
01:36:08,924 --> 01:36:11,685
clear that this is the iterative that is loop-based

2809
01:36:11,685 --> 01:36:16,995
version of a program whose purpose in life is to print out a simple Mario pyramid.

2810
01:36:17,125 --> 01:36:19,044
I'm going to go ahead and include CS50.

2811
01:36:19,245 --> 01:36:22,174
H at the top as well as standardio.h.

2812
01:36:22,365 --> 01:36:23,595
I'm not going to need string.h.

2813
01:36:23,805 --> 01:36:25,484
I don't need any command line arguments today,

2814
01:36:25,575 --> 01:36:27,524
so this is going to start off with main void.

2815
01:36:27,759 --> 01:36:30,020
And now I'm going to go ahead and ask a question like,

2816
01:36:30,410 --> 01:36:30,779
uh,

2817
01:36:30,790 --> 01:36:33,540
give me a variable called height of type integer

2818
01:36:33,750 --> 01:36:37,620
and ask the human for the height of this Mario like pyramid.

2819
01:36:37,830 --> 01:36:39,069
And then let's assume for the moment

2820
01:36:39,069 --> 01:36:40,709
that I've already implemented a function called

2821
01:36:40,709 --> 01:36:44,830
Draw whose purpose in life is to draw a pyramid of that height semicolon.

2822
01:36:44,915 --> 01:36:48,375
So I've abstracted away for the moment the notion of drawing that pyramid.

2823
01:36:48,705 --> 01:36:50,145
Now let's actually implement Dra,

2824
01:36:50,225 --> 01:36:53,984
whose purpose in life again is to print out a pyramid akin to

2825
01:36:53,984 --> 01:36:56,814
the one we saw a moment ago like this here on the screen.

2826
01:36:57,024 --> 01:36:57,104
Well,

2827
01:36:57,185 --> 01:36:59,314
in order to print out a pyramid of a given height,

2828
01:36:59,504 --> 01:37:01,904
I think I need to say void.

2829
01:37:02,540 --> 01:37:02,810
Uh,

2830
01:37:02,939 --> 01:37:07,979
drawn for instance because I'm not going to bother returning a value.

2831
01:37:08,060 --> 01:37:09,850
I just want this thing to print something on the screen,

2832
01:37:09,939 --> 01:37:11,290
so void is the return type,

2833
01:37:11,459 --> 01:37:14,720
but I do want to take as input an integer like the height of the thing I want to print.

2834
01:37:14,859 --> 01:37:17,339
I can call this argument or parameter anything I want.

2835
01:37:17,419 --> 01:37:18,609
I'll call it N for number.

2836
01:37:18,910 --> 01:37:22,339
So how can I print out a pyramid that again looks like this?

2837
01:37:22,540 --> 01:37:22,700
Well,

2838
01:37:22,819 --> 01:37:25,020
I'll do this quicker than you might have in problem set 1,

2839
01:37:25,060 --> 01:37:28,200
but it seems obvious that like on the first row I want 1 brick.

2840
01:37:28,379 --> 01:37:29,580
On the second row I want 2.

2841
01:37:29,660 --> 01:37:30,500
On the 3rd I want 3.

2842
01:37:30,540 --> 01:37:30,890
On the 4th,

2843
01:37:30,899 --> 01:37:31,569
I want 4.

2844
01:37:31,700 --> 01:37:33,580
So it's actually a little easier than problem set

2845
01:37:33,580 --> 01:37:36,129
1 in that it's sloped in a different direction.

2846
01:37:36,339 --> 01:37:38,379
So let me go ahead and do exactly this in code.

2847
01:37:38,490 --> 01:37:39,750
Let me say 4

2848
01:37:40,040 --> 01:37:42,709
NI equals 01 less than n,

2849
01:37:42,959 --> 01:37:43,589
the height,

2850
01:37:43,839 --> 01:37:44,830
I plus plus.

2851
01:37:45,000 --> 01:37:46,430
So this is going to be really

2852
01:37:46,720 --> 01:37:49,279
for each row of the pyramid

2853
01:37:49,660 --> 01:37:50,229
pyramid.

2854
01:37:50,439 --> 01:37:51,770
Let me go ahead now

2855
01:37:52,040 --> 01:37:55,910
and in an inner loop for in J equals 0,

2856
01:37:56,120 --> 01:37:57,959
let's do J less than.

2857
01:37:58,689 --> 01:38:03,560
I plus 1 for reasons we'll see in a moment and then J++ and then inside of this loop,

2858
01:38:03,689 --> 01:38:05,279
let's just print out a single hash,

2859
01:38:05,410 --> 01:38:06,240
no new line,

2860
01:38:06,560 --> 01:38:07,890
but at the end of the row,

2861
01:38:08,009 --> 01:38:11,700
let's print out a single new line to move the cursor to the next line.

2862
01:38:11,890 --> 01:38:13,000
Now why am I doing this?

2863
01:38:13,049 --> 01:38:13,140
Well,

2864
01:38:13,250 --> 01:38:14,279
this represents

2865
01:38:14,649 --> 01:38:16,879
for each column of

2866
01:38:17,029 --> 01:38:17,879
pyramid,

2867
01:38:17,919 --> 01:38:19,770
and if you think about it on the first row,

2868
01:38:19,970 --> 01:38:21,520
which is row 0,

2869
01:38:21,890 --> 01:38:24,759
I actually want to print not zero bricks but one brick.

2870
01:38:25,100 --> 01:38:29,609
That's why I want to go ahead here and go from 0 to I plus 1,

2871
01:38:29,689 --> 01:38:32,359
because if I is +01 + 1 is 1,

2872
01:38:32,529 --> 01:38:34,899
so my inner loop is going to go from 0 to 1,

2873
01:38:34,930 --> 01:38:36,529
which is going to give me 1 brick.

2874
01:38:36,569 --> 01:38:38,040
It's a little annoying to think about the math,

2875
01:38:38,089 --> 01:38:41,359
but this just makes sure that I'm actually getting bricks in the order I want them.

2876
01:38:41,529 --> 01:38:44,359
And then it's going to give me 2 bricks and then 3 and then 4,

2877
01:38:44,689 --> 01:38:47,240
and between each of those rows it's going to print a new line.

2878
01:38:47,370 --> 01:38:49,970
So let's go ahead and do make iteration to compile this code.

2879
01:38:50,069 --> 01:38:50,319
Ah,

2880
01:38:50,810 --> 01:38:51,529
I messed up.

2881
01:38:52,569 --> 01:38:54,629
Why do I have a mistake online?

2882
01:38:55,799 --> 01:38:57,080
8 of this code.

2883
01:38:57,200 --> 01:38:59,310
Let me hide my terminal and scroll back up.

2884
01:38:59,600 --> 01:39:00,359
It seems clang.

2885
01:39:00,410 --> 01:39:02,560
My compiler does not like my draw function.

2886
01:39:03,370 --> 01:39:03,709
Yeah.

2887
01:39:05,680 --> 01:39:05,899
Yeah,

2888
01:39:05,990 --> 01:39:06,910
I forgot the prototype.

2889
01:39:06,990 --> 01:39:09,830
So this is the one and only time where it seems reasonable to copy paste.

2890
01:39:09,850 --> 01:39:12,140
Let's grab the prototype of that function up here

2891
01:39:12,509 --> 01:39:15,069
and go ahead and teach the compiler from the

2892
01:39:15,069 --> 01:39:16,839
get-go what this function is going to look like,

2893
01:39:16,870 --> 01:39:19,629
even though I'm not defining it now until line 13 onward.

2894
01:39:19,939 --> 01:39:20,029
All right,

2895
01:39:20,109 --> 01:39:22,109
let's go ahead and make iteration again.

2896
01:39:22,490 --> 01:39:22,759
Ah,

2897
01:39:23,129 --> 01:39:24,490
iteration enter.

2898
01:39:24,689 --> 01:39:27,049
Let's do a height of say 4 and voila.

2899
01:39:27,209 --> 01:39:28,859
Now I've got that there pyramid.

2900
01:39:29,049 --> 01:39:31,290
So I did it a little quickly and it's certainly to be expected if it

2901
01:39:31,290 --> 01:39:34,609
took you hours on problems set one to get the other type of pyramid printed,

2902
01:39:34,770 --> 01:39:37,250
but the point for today is really to demonstrate how we can

2903
01:39:37,250 --> 01:39:41,169
print a pyramid like this using indeed what I'd call iteration.

2904
01:39:41,250 --> 01:39:45,120
Iteration just means using loops to solve some problem,

2905
01:39:45,370 --> 01:39:45,649
but we can.

2906
01:39:46,140 --> 01:39:50,350
Alternatively use recursion by reimplementing our draw function in

2907
01:39:50,350 --> 01:39:52,700
a way that's defined in terms of itself.

2908
01:39:52,950 --> 01:39:55,299
So let me go into my code here

2909
01:39:55,470 --> 01:39:57,850
and I'm actually going to leave the prototype the same.

2910
01:39:57,990 --> 01:39:59,629
I'm going to leave main the same,

2911
01:39:59,790 --> 01:40:01,589
but what I'm going to go ahead and do is delete

2912
01:40:01,589 --> 01:40:05,709
all of this iterative code that's doing things very procedurally,

2913
01:40:05,870 --> 01:40:08,020
step by step by step with loops,

2914
01:40:08,109 --> 01:40:09,899
and I'm instead going to do something

2915
01:40:10,229 --> 01:40:10,979
like this.

2916
01:40:11,310 --> 01:40:11,509
Well,

2917
01:40:11,669 --> 01:40:14,700
if I want to print a pyramid of height N.

2918
01:40:15,549 --> 01:40:16,750
What did I say earlier?

2919
01:40:16,830 --> 01:40:16,910
Well,

2920
01:40:16,990 --> 01:40:22,859
a pyramid of height N is really just a pyramid of height N minus 1 plus 1 more row.

2921
01:40:23,229 --> 01:40:25,700
So how do I implement in code that idea?

2922
01:40:25,830 --> 01:40:25,890
Well,

2923
01:40:25,950 --> 01:40:27,850
let me go back in code here and say,

2924
01:40:28,189 --> 01:40:28,439
well,

2925
01:40:28,509 --> 01:40:32,910
if a pyramid of height N first requires drawing a pyramid of height N minus 1,

2926
01:40:33,270 --> 01:40:34,520
I think I can just write this,

2927
01:40:34,620 --> 01:40:35,950
which is kind of crazy to look at,

2928
01:40:36,029 --> 01:40:36,419
but

2929
01:40:36,629 --> 01:40:38,569
because you're calling yourself in yourself,

2930
01:40:38,910 --> 01:40:40,259
but let's see where this takes us.

2931
01:40:40,419 --> 01:40:43,470
Once I have drawn a pyramid of height and minus 1.

2932
01:40:43,990 --> 01:40:46,009
That is a height 3 for instance.

2933
01:40:46,180 --> 01:40:49,569
What remains for me to do is to myself print one more row.

2934
01:40:49,859 --> 01:40:51,509
And so to print one more row,

2935
01:40:51,580 --> 01:40:53,819
I think I can do that really easily with fewer loops.

2936
01:40:53,899 --> 01:40:55,009
I can do 4 in,

2937
01:40:55,299 --> 01:40:58,899
I equals 01 less than N I plus plus,

2938
01:40:58,910 --> 01:41:01,419
and then very simply in this loop I can.

2939
01:41:01,479 --> 01:41:03,549
Print out a single hash one at a time.

2940
01:41:03,560 --> 01:41:04,430
At the end of this loop,

2941
01:41:04,509 --> 01:41:06,259
I can print out a new line,

2942
01:41:06,390 --> 01:41:08,149
but no more nesting of loops.

2943
01:41:08,310 --> 01:41:09,939
What I've done is

2944
01:41:10,330 --> 01:41:12,740
print one more row,

2945
01:41:12,950 --> 01:41:13,660
and here

2946
01:41:13,830 --> 01:41:15,259
I've done print

2947
01:41:15,549 --> 01:41:18,830
a pyramid of height and minus 1.

2948
01:41:19,990 --> 01:41:21,450
I'm not quite done yet,

2949
01:41:21,620 --> 01:41:24,899
but I think this is consistent with my verbal definition that a pyramid of height 3

2950
01:41:24,899 --> 01:41:29,609
is a pyramid of a pyramid of height 4 is a pyramid of height 3,

2951
01:41:30,140 --> 01:41:31,169
which I can implement

2952
01:41:31,459 --> 01:41:33,089
per line 16.

2953
01:41:33,299 --> 01:41:35,930
Just draw me a pyramid of height and minus 1,

2954
01:41:36,259 --> 01:41:40,490
and then I myself will take the trouble to print the 4th and final row.

2955
01:41:41,140 --> 01:41:43,209
But something's missing in this code.

2956
01:41:43,580 --> 01:41:45,020
Let me go ahead and try running it.

2957
01:41:45,100 --> 01:41:45,890
Let's see what happens.

2958
01:41:45,979 --> 01:41:46,410
Make,

2959
01:41:46,500 --> 01:41:47,620
oh darn it.

2960
01:41:48,259 --> 01:41:49,729
I meant to call this something else,

2961
01:41:49,810 --> 01:41:50,879
so I'm going to do this.

2962
01:41:51,089 --> 01:41:52,560
I'm going to close this version here.

2963
01:41:52,770 --> 01:41:56,490
I'm going to rename iteration.c to recursion.c to

2964
01:41:56,490 --> 01:41:59,000
make clear that this version is completely different.

2965
01:41:59,330 --> 01:42:02,200
Let me now go ahead and make the recursion version

2966
01:42:02,529 --> 01:42:03,270
and huh,

2967
01:42:03,529 --> 01:42:06,660
Klang is noticing that I have screwed up on line 14,

2968
01:42:06,709 --> 01:42:07,569
it says error.

2969
01:42:07,850 --> 01:42:10,640
All paths through this function will call itself,

2970
01:42:10,759 --> 01:42:12,089
and Klang doesn't even want to let me

2971
01:42:12,089 --> 01:42:14,120
compile this code because that would mean literally

2972
01:42:14,330 --> 01:42:15,209
just forever.

2973
01:42:16,209 --> 01:42:16,600
Loop

2974
01:42:16,890 --> 01:42:18,319
effectively by calling yourself.

2975
01:42:18,529 --> 01:42:23,049
So what am I missing in my code here if I open up what we're now calling recursion.c.

2976
01:42:23,990 --> 01:42:25,180
In my editor

2977
01:42:26,120 --> 01:42:27,290
What's missing here over here?

2978
01:42:28,350 --> 01:42:28,540
Yeah,

2979
01:42:28,620 --> 01:42:29,709
I'm missing a base case,

2980
01:42:29,740 --> 01:42:31,729
and I can express this in a few different ways,

2981
01:42:31,810 --> 01:42:35,290
but I would propose that before I do any drawing of anything at all,

2982
01:42:35,500 --> 01:42:38,339
let's just ask ourselves if there is anything to draw.

2983
01:42:38,459 --> 01:42:41,660
So how about if N equals equals 0?

2984
01:42:41,819 --> 01:42:43,330
Well then don't do anything,

2985
01:42:43,540 --> 01:42:44,220
just return.

2986
01:42:44,259 --> 01:42:46,750
You don't return a value when your return value is void,

2987
01:42:46,819 --> 01:42:47,930
it means you don't return anything,

2988
01:42:48,009 --> 01:42:51,299
so you just return period or return semicolon.

2989
01:42:51,755 --> 01:42:53,235
Or just to be super safe,

2990
01:42:53,326 --> 01:42:54,826
I could actually do something like this,

2991
01:42:54,875 --> 01:42:57,235
which is arguably better practice just in case I get into

2992
01:42:57,235 --> 01:42:59,866
this perverse scenario where someone hands me a negative number,

2993
01:43:00,155 --> 01:43:03,355
I want to be able to handle that and not print anything either.

2994
01:43:03,476 --> 01:43:04,235
So just to be safe,

2995
01:43:04,275 --> 01:43:06,315
I might say less than or equal to 0.

2996
01:43:06,476 --> 01:43:07,625
I'm not doing one

2997
01:43:07,875 --> 01:43:09,125
because if I did do one,

2998
01:43:09,235 --> 01:43:11,866
then I would want to at least myself print out one brick,

2999
01:43:11,875 --> 01:43:12,425
which is fine,

3000
01:43:12,476 --> 01:43:12,996
but I have to like

3001
01:43:13,275 --> 01:43:14,315
change all of my code.

3002
01:43:14,461 --> 01:43:15,001
Little bit,

3003
01:43:15,171 --> 01:43:18,111
so I think it's safer if my base case is just

3004
01:43:18,452 --> 01:43:19,521
if n

3005
01:43:19,892 --> 01:43:21,532
is less than or equal to 0,

3006
01:43:21,541 --> 01:43:22,202
you're done.

3007
01:43:22,372 --> 01:43:23,321
Don't do anything.

3008
01:43:23,492 --> 01:43:25,691
And this then ensures that even though thereafter,

3009
01:43:25,771 --> 01:43:29,251
I keep calling draw again and again and again and the problem's

3010
01:43:29,251 --> 01:43:32,262
getting smaller and smaller from 4 to 3 to 2 to 1,

3011
01:43:32,412 --> 01:43:33,722
as soon as I hit 0,

3012
01:43:34,012 --> 01:43:36,001
the function will finally

3013
01:43:36,932 --> 01:43:37,401
return.

3014
01:43:38,339 --> 01:43:40,589
So let's go ahead and open up my terminal,

3015
01:43:40,779 --> 01:43:45,209
rerun make recursion to make this version did compile this time recursion enter.

3016
01:43:45,379 --> 01:43:47,370
Let's type in 4 cross my fingers,

3017
01:43:47,859 --> 01:43:50,450
and this too prints the exact same thing.

3018
01:43:50,580 --> 01:43:52,500
And even though it doesn't look like fewer lines of code,

3019
01:43:52,589 --> 01:43:55,490
I would offer that there's an elegance to what I've just done,

3020
01:43:55,540 --> 01:43:57,600
whereas with the iterative version with all the loops,

3021
01:43:57,660 --> 01:43:58,560
it was very clunky,

3022
01:43:58,580 --> 01:43:59,339
like step by step,

3023
01:43:59,419 --> 01:44:02,410
just print this and print that and have a nested loop inside of another.

3024
01:44:02,660 --> 01:44:03,450
But with this,

3025
01:44:03,740 --> 01:44:05,870
especially if we distill it into its essence.

3026
01:44:06,250 --> 01:44:08,640
By getting rid of my comments like this and

3027
01:44:08,640 --> 01:44:11,390
frankly I can get rid of the unnecessary curly braces

3028
01:44:11,680 --> 01:44:15,029
only because for single lines in conditionals you don't need them.

3029
01:44:15,240 --> 01:44:16,720
Like this is arguably like a

3030
01:44:16,720 --> 01:44:20,319
very beautiful implementation of drawing Mario's pyramid

3031
01:44:20,560 --> 01:44:24,069
even though it's calling itself and arguably because it is calling

3032
01:44:24,600 --> 01:44:25,029
itself.

3033
01:44:25,990 --> 01:44:29,939
Questions then on this idea of recursion or this implementation

3034
01:44:30,270 --> 01:44:31,459
of Mario,

3035
01:44:33,709 --> 01:44:33,720
yeah.

3036
01:44:35,359 --> 01:44:35,640
Call

3037
01:44:37,180 --> 01:44:37,540
Good question.

3038
01:44:37,580 --> 01:44:39,020
Are there any scope issues involved?

3039
01:44:39,100 --> 01:44:40,169
Short answer No.

3040
01:44:40,540 --> 01:44:41,169
However,

3041
01:44:41,379 --> 01:44:43,009
the current value of I,

3042
01:44:43,140 --> 01:44:43,540
for instance,

3043
01:44:43,660 --> 01:44:45,009
will not be visible

3044
01:44:45,379 --> 01:44:46,979
to the next time the function is called.

3045
01:44:47,020 --> 01:44:49,089
It will have its own copy of I

3046
01:44:49,660 --> 01:44:50,259
if that's what you mean.

3047
01:44:50,339 --> 01:44:52,979
And we'll next week talk in more detail about what's going on here.

3048
01:44:53,060 --> 01:44:53,589
And in fact,

3049
01:44:53,779 --> 01:44:56,770
I probably can't break this in class very easily,

3050
01:44:56,859 --> 01:44:57,250
but

3051
01:44:57,500 --> 01:45:00,979
it turns out if I use a very large version for heights,

3052
01:45:01,100 --> 01:45:02,939
let's just hit a lot of zeros and see what happens.

3053
01:45:03,020 --> 01:45:03,740
That was too many.

3054
01:45:04,160 --> 01:45:05,029
Let's see what happens.

3055
01:45:05,240 --> 01:45:06,200
That's also too many.

3056
01:45:06,279 --> 01:45:07,459
Let's see what happens

3057
01:45:07,959 --> 01:45:08,479
there.

3058
01:45:09,419 --> 01:45:12,339
That's the first time at least I and class have encountered this error.

3059
01:45:12,379 --> 01:45:15,689
You might have encountered this weird bug in office hours or in your problem set,

3060
01:45:15,700 --> 01:45:16,569
and that's fine if you did.

3061
01:45:16,819 --> 01:45:18,490
We'll talk about what this means next week too,

3062
01:45:18,700 --> 01:45:19,430
but this is bad.

3063
01:45:19,500 --> 01:45:22,089
Like this clearly hints at a problem in my code.

3064
01:45:22,379 --> 01:45:23,089
However,

3065
01:45:23,259 --> 01:45:26,540
the iterative version of this program would not have that same error.

3066
01:45:26,620 --> 01:45:29,339
So this relates to something involving memory because it

3067
01:45:29,339 --> 01:45:31,339
turns out as a little teaser for next week.

3068
01:45:31,485 --> 01:45:32,596
Each time I call Draw,

3069
01:45:32,706 --> 01:45:33,956
I'm using a little more memory,

3070
01:45:33,996 --> 01:45:34,706
a little more memory,

3071
01:45:34,726 --> 01:45:35,395
a little more memory,

3072
01:45:35,436 --> 01:45:36,025
a little more memory,

3073
01:45:36,036 --> 01:45:37,786
and my computer only has so much memory.

3074
01:45:37,956 --> 01:45:40,985
This program in its current form is using too much memory.

3075
01:45:41,116 --> 01:45:42,346
There are workarounds to this,

3076
01:45:42,395 --> 01:45:46,425
but that is a trade off to the elegance we're gaining in this solution.

3077
01:45:46,636 --> 01:45:49,465
So what's the point of all this and how do we get sidetracked by Mario?

3078
01:45:49,675 --> 01:45:51,076
There's another sorting algorithm,

3079
01:45:51,155 --> 01:45:54,921
the 3rd and final one that we'll consider today that actually Is recursion

3080
01:45:55,131 --> 01:45:57,762
to solve the problem not only elegantly

3081
01:45:57,892 --> 01:45:58,642
arguably,

3082
01:45:58,812 --> 01:46:01,151
but also way faster somehow

3083
01:46:01,291 --> 01:46:02,892
than bubble sort and selection sort.

3084
01:46:02,932 --> 01:46:09,041
And in essence it does so by making far fewer comparisons and wasting a lot less work.

3085
01:46:09,131 --> 01:46:11,841
It doesn't keep comparing the same numbers again and again.

3086
01:46:12,091 --> 01:46:15,861
Here in its essence is the pseudo code for merge sort.

3087
01:46:16,459 --> 01:46:18,049
Sort the left half of the numbers.

3088
01:46:18,169 --> 01:46:19,529
So the right half of the numbers,

3089
01:46:19,609 --> 01:46:21,049
then merge the sorted halves,

3090
01:46:21,080 --> 01:46:23,419
and this is kind of a weird implementation of

3091
01:46:23,419 --> 01:46:25,290
an algorithm because I'm not really telling you anything.

3092
01:46:25,330 --> 01:46:27,359
It seems like you're asking me how do I sort numbers,

3093
01:46:27,370 --> 01:46:27,689
and I say,

3094
01:46:27,729 --> 01:46:28,569
we'll sort the left half,

3095
01:46:28,810 --> 01:46:29,410
sort the right half.

3096
01:46:29,419 --> 01:46:30,680
It's like someone being difficult

3097
01:46:30,970 --> 01:46:34,680
and yet implicit in this third line is apparently some magic,

3098
01:46:34,700 --> 01:46:38,049
this notion of merging halves that are somehow already.

3099
01:46:38,544 --> 01:46:41,694
is actually going to yield a successful result.

3100
01:46:41,865 --> 01:46:42,345
As an aside,

3101
01:46:42,384 --> 01:46:44,345
we're actually going to need one base case here too.

3102
01:46:44,384 --> 01:46:45,694
So if you're only given one number,

3103
01:46:45,865 --> 01:46:48,214
you might as well quit right away because there's nothing to do.

3104
01:46:48,504 --> 01:46:50,345
So we'll toss that in there as well.

3105
01:46:50,365 --> 01:46:54,915
And base cases are often for 0 or 1 or some small num sized problem.

3106
01:46:55,104 --> 01:46:58,305
In this case it's a little easier to express it as one because if you have one element,

3107
01:46:58,384 --> 01:46:59,944
it's indeed already sorted.

3108
01:47:00,470 --> 01:47:03,910
So what does it mean to merge two sorted halves?

3109
01:47:03,950 --> 01:47:04,009
Well,

3110
01:47:04,109 --> 01:47:04,919
let's actually consider this.

3111
01:47:04,990 --> 01:47:06,859
I'm going to reuse some of these same numbers here.

3112
01:47:07,009 --> 01:47:08,629
I'm going to put my 1,

3113
01:47:08,950 --> 01:47:09,939
my 3,

3114
01:47:10,149 --> 01:47:10,750
my 4,

3115
01:47:10,790 --> 01:47:12,419
and my 6 on the left,

3116
01:47:12,669 --> 01:47:15,620
and these together represent a list that is indeed

3117
01:47:16,029 --> 01:47:17,580
sorted of size 4.

3118
01:47:17,669 --> 01:47:19,169
And then I'm going to put 4 other numbers

3119
01:47:19,169 --> 01:47:21,069
on the right there that are similarly sorted.

3120
01:47:21,169 --> 01:47:21,919
As well,

3121
01:47:22,080 --> 01:47:24,359
and by merging these two lists,

3122
01:47:24,479 --> 01:47:25,149
I mean

3123
01:47:25,600 --> 01:47:27,709
start at the left end of this list,

3124
01:47:27,959 --> 01:47:29,229
start at the left end of this list,

3125
01:47:29,240 --> 01:47:32,850
and just decide one step at a time which number is the next smallest,

3126
01:47:32,939 --> 01:47:35,709
and then I'm going to put it on the top shelf to make clear what is sorted.

3127
01:47:35,879 --> 01:47:37,430
So if my left hand's pointing at this list,

3128
01:47:37,600 --> 01:47:38,990
my right hand's pointing at there,

3129
01:47:39,259 --> 01:47:41,180
which hand is obviously pointing to the smaller element,

3130
01:47:41,240 --> 01:47:41,879
left or right.

3131
01:47:42,759 --> 01:47:43,359
Like the right,

3132
01:47:43,600 --> 01:47:46,879
so I'm going to grab this and I'm going to use a little more space up top here

3133
01:47:46,879 --> 01:47:49,709
and put the 0 in place and then I'm going to point to the next element there.

3134
01:47:49,879 --> 01:47:51,200
So my left hand has not moved yet.

3135
01:47:51,259 --> 01:47:52,200
It's still pointing at the 1.

3136
01:47:52,240 --> 01:47:53,669
My right hand is pointing at the 2,

3137
01:47:53,839 --> 01:47:55,470
which number comes next clearly?

3138
01:47:55,959 --> 01:47:56,279
Left,

3139
01:47:56,399 --> 01:47:59,959
so I'm going to grab the 1 and put it up there and update where my left hand is pointing.

3140
01:48:00,040 --> 01:48:02,600
So now I'm pointing at the 3 here and the 2 there.

3141
01:48:02,680 --> 01:48:03,439
What comes next?

3142
01:48:03,520 --> 01:48:04,399
Obviously the 2.

3143
01:48:05,399 --> 01:48:06,470
What comes next?

3144
01:48:06,549 --> 01:48:07,910
Obviously the 3.

3145
01:48:08,359 --> 01:48:09,229
What comes next,

3146
01:48:09,359 --> 01:48:10,830
obviously the 4.

3147
01:48:11,399 --> 01:48:12,270
What comes next,

3148
01:48:12,279 --> 01:48:13,459
obviously the 5,

3149
01:48:13,560 --> 01:48:15,759
but notice my hands are not going back and forth,

3150
01:48:15,879 --> 01:48:16,279
back and forth,

3151
01:48:16,359 --> 01:48:18,629
back and forth like any of the algorithms thus far.

3152
01:48:18,799 --> 01:48:20,359
I'm just taking baby steps,

3153
01:48:20,479 --> 01:48:21,990
moving them only to the right,

3154
01:48:22,319 --> 01:48:26,750
effectively pointing at for a final time each number once and only once.

3155
01:48:26,899 --> 01:48:27,419
What comes next,

3156
01:48:27,430 --> 01:48:27,950
6,

3157
01:48:28,200 --> 01:48:29,279
and now my left hand is done.

3158
01:48:29,359 --> 01:48:30,240
What comes last,

3159
01:48:30,560 --> 01:48:31,410
the number 7.

3160
01:48:31,689 --> 01:48:33,709
What I just did is what I mean by

3161
01:48:34,359 --> 01:48:36,120
merge the sorted halves.

3162
01:48:36,160 --> 01:48:38,720
If you can somehow get into a scenario where you've

3163
01:48:38,720 --> 01:48:42,080
got a small list sorted and another small list sorted,

3164
01:48:42,240 --> 01:48:46,390
it's super easy now to merge them together using that left right approach,

3165
01:48:46,600 --> 01:48:48,720
which I'll claim only takes end steps.

3166
01:48:48,839 --> 01:48:49,229
Why?

3167
01:48:49,580 --> 01:48:51,209
Because every time I asked you a question,

3168
01:48:51,319 --> 01:48:51,959
I was taking one.

3169
01:48:52,129 --> 01:48:52,930
Out of the problem,

3170
01:48:52,959 --> 01:48:53,990
there's 8 bytes total.

3171
01:48:54,120 --> 01:48:57,149
I asked you 8 questions or I would have if I verbalized them all.

3172
01:48:57,399 --> 01:49:00,629
So it's N steps total to merge lists of that size.

3173
01:49:01,080 --> 01:49:01,549
So

3174
01:49:01,879 --> 01:49:03,160
what then is merge sort?

3175
01:49:03,229 --> 01:49:06,160
Mergesort is really all three of these steps together,

3176
01:49:06,240 --> 01:49:07,750
only one of which we've acted out,

3177
01:49:07,839 --> 01:49:10,709
2 of which are sort of cyclical in nature.

3178
01:49:10,759 --> 01:49:12,439
They're recursive by design.

3179
01:49:12,819 --> 01:49:13,640
So what does this mean?

3180
01:49:13,729 --> 01:49:13,810
Well,

3181
01:49:13,890 --> 01:49:15,839
let's start with this list of eight numbers,

3182
01:49:15,850 --> 01:49:17,890
which is clearly out of order 63,

3183
01:49:17,930 --> 01:49:18,890
4152,

3184
01:49:18,930 --> 01:49:20,479
70 and let's apply

3185
01:49:20,729 --> 01:49:23,970
mergesor to this set of numbers and I'll do it digitally here because

3186
01:49:23,970 --> 01:49:26,899
it'll take forever to keep moving the numbers up and down physically.

3187
01:49:27,169 --> 01:49:30,089
So let's move it to the top just to give ourselves a little bit more room

3188
01:49:30,390 --> 01:49:32,640
and let me propose that we apply mergesort.

3189
01:49:32,770 --> 01:49:35,600
What was the very first step in mergesort,

3190
01:49:35,609 --> 01:49:36,410
at least that we highlighted,

3191
01:49:36,450 --> 01:49:37,339
the juicy steps.

3192
01:49:39,240 --> 01:49:40,790
What's the first step in mergesor?

3193
01:49:41,529 --> 01:49:42,680
Sort the left half,

3194
01:49:42,759 --> 01:49:43,029
yeah.

3195
01:49:43,160 --> 01:49:45,390
And then the second step was going to be sort the right half

3196
01:49:45,390 --> 01:49:47,640
and then the third step was going to be merge the sorted halves.

3197
01:49:47,689 --> 01:49:50,950
So let's see what this means by actually acting it out on these numbers.

3198
01:49:51,080 --> 01:49:52,149
So here's my 8 numbers.

3199
01:49:52,279 --> 01:49:54,160
Let's go ahead and sort the left half.

3200
01:49:54,359 --> 01:49:54,399
Well,

3201
01:49:54,439 --> 01:49:57,509
the left half is obviously going to be the 4 numbers on the left,

3202
01:49:57,589 --> 01:50:00,830
and I'm just going to pull them out just to draw our attention to them over here.

3203
01:50:01,160 --> 01:50:03,870
Now I have a list of size 4,

3204
01:50:04,040 --> 01:50:05,729
and the goal is to sort the left half.

3205
01:50:05,799 --> 01:50:07,689
How do I sort a list of size 4?

3206
01:50:10,470 --> 01:50:11,040
Uh,

3207
01:50:11,290 --> 01:50:12,620
be what was yes,

3208
01:50:12,649 --> 01:50:13,930
but just be more pedantic.

3209
01:50:14,009 --> 01:50:16,859
Like how do I sort any list using merge sort?

3210
01:50:17,649 --> 01:50:18,419
Sort the left half.

3211
01:50:18,490 --> 01:50:19,919
So let's do just that.

3212
01:50:20,129 --> 01:50:21,970
So of the list of size 4,

3213
01:50:22,129 --> 01:50:22,810
how do I sort this?

3214
01:50:22,850 --> 01:50:22,930
Well,

3215
01:50:23,020 --> 01:50:24,330
I'm going to sort the left half.

3216
01:50:24,569 --> 01:50:26,089
How do I sort a list of size 2?

3217
01:50:27,279 --> 01:50:28,240
Sort the left half,

3218
01:50:28,439 --> 01:50:28,560
right,

3219
01:50:28,759 --> 01:50:28,870
well,

3220
01:50:28,959 --> 01:50:30,350
I'm just gonna write the 6 here.

3221
01:50:30,479 --> 01:50:32,330
How do I sort a list of size 1?

3222
01:50:33,770 --> 01:50:34,359
I just don't.

3223
01:50:34,399 --> 01:50:34,759
I'm done.

3224
01:50:34,839 --> 01:50:37,319
That was the so-called base case where I just said return,

3225
01:50:37,399 --> 01:50:39,549
like I'm done sorting the list.

3226
01:50:39,799 --> 01:50:40,080
OK,

3227
01:50:40,240 --> 01:50:40,589
so

3228
01:50:40,959 --> 01:50:42,910
here I here's the story recap.

3229
01:50:43,240 --> 01:50:44,520
So the left half,

3230
01:50:44,720 --> 01:50:45,979
sort the left half,

3231
01:50:46,160 --> 01:50:47,160
sort the left half,

3232
01:50:47,200 --> 01:50:48,330
and I just finished sorting this.

3233
01:50:48,439 --> 01:50:49,319
So what comes next?

3234
01:50:50,060 --> 01:50:51,399
Sort the right half,

3235
01:50:51,779 --> 01:50:52,700
which is this,

3236
01:50:53,100 --> 01:50:55,930
and now I've sorted the left half of

3237
01:50:56,299 --> 01:50:58,399
the left half of the left half,

3238
01:50:58,899 --> 01:51:00,419
which is a big mouthful,

3239
01:51:00,660 --> 01:51:04,819
but what do I do as a third and final step when sorting this list of size 2.

3240
01:51:05,569 --> 01:51:06,089
Merge them.

3241
01:51:06,290 --> 01:51:07,479
This part we know how to do.

3242
01:51:07,609 --> 01:51:08,689
I point left and right,

3243
01:51:08,790 --> 01:51:10,450
and I now take the smallest element first,

3244
01:51:10,529 --> 01:51:11,339
which is the 3.

3245
01:51:11,569 --> 01:51:15,000
Then I take the 6 and now this list of size 2 is sorted.

3246
01:51:15,049 --> 01:51:17,959
So if you remind in your mind's eye what step are we on,

3247
01:51:18,009 --> 01:51:18,250
well,

3248
01:51:18,290 --> 01:51:19,600
we have now sorted

3249
01:51:19,759 --> 01:51:21,759
the left half of the left half.

3250
01:51:21,970 --> 01:51:23,319
So what comes after

3251
01:51:23,930 --> 01:51:24,970
the left half is sorted?

3252
01:51:26,049 --> 01:51:26,850
We sort the right half.

3253
01:51:26,890 --> 01:51:28,640
So we're sort of rewinding in time,

3254
01:51:28,850 --> 01:51:29,649
but that's OK.

3255
01:51:29,770 --> 01:51:31,520
I'm keeping track of the steps in my mind.

3256
01:51:31,729 --> 01:51:32,549
I want to now

3257
01:51:32,930 --> 01:51:34,529
sort this list of size 2.

3258
01:51:34,569 --> 01:51:35,850
How do you sort a list of size 2?

3259
01:51:35,859 --> 01:51:36,279
Well,

3260
01:51:36,470 --> 01:51:38,299
you divide it into a list of size 1.

3261
01:51:38,370 --> 01:51:38,970
How do you sort this?

3262
01:51:39,049 --> 01:51:39,529
You're done.

3263
01:51:39,910 --> 01:51:42,160
You then take the other right half and you sort it.

3264
01:51:42,290 --> 01:51:42,720
Done.

3265
01:51:43,049 --> 01:51:44,930
Now you merge the two sorted halves.

3266
01:51:44,970 --> 01:51:46,250
So I point at the 4 and the 1,

3267
01:51:46,290 --> 01:51:47,279
obviously the one comes first,

3268
01:51:47,330 --> 01:51:48,000
then the 4.

3269
01:51:48,250 --> 01:51:52,839
Now I have sorted the right half of the uh the right half

3270
01:51:53,200 --> 01:51:56,310
of the left half of the original numbers.

3271
01:51:56,410 --> 01:52:01,850
What's the next step now that I have the left and right halves of this list of 4 sorted?

3272
01:52:02,879 --> 01:52:03,439
Merge those,

3273
01:52:03,479 --> 01:52:04,919
so same idea but fewer elements.

3274
01:52:04,959 --> 01:52:06,089
I'm pointing at the 3 and the 1.

3275
01:52:06,189 --> 01:52:08,839
Obviously the 1 comes now I'm pointing at the 3 and the 4.

3276
01:52:08,950 --> 01:52:10,350
Obviously the 3 comes next,

3277
01:52:10,520 --> 01:52:11,560
pointing at the 6 and the 4,

3278
01:52:11,569 --> 01:52:12,540
the 4 comes next,

3279
01:52:12,720 --> 01:52:14,270
and now the 6 comes last.

3280
01:52:14,479 --> 01:52:19,640
Now I have sorted the left half and it's intentional that 1346 is the

3281
01:52:19,640 --> 01:52:22,990
original arrangement of the lighted numbers I had on the shelves a moment ago.

3282
01:52:23,310 --> 01:52:23,359
All right,

3283
01:52:23,399 --> 01:52:24,600
it's a long story it seems,

3284
01:52:24,680 --> 01:52:28,520
but what comes after you sorting the left half of the original list?

3285
01:52:29,000 --> 01:52:30,149
You sort the right half.

3286
01:52:30,189 --> 01:52:31,100
So let's put some,

3287
01:52:31,229 --> 01:52:31,609
uh,

3288
01:52:31,629 --> 01:52:32,549
put those numbers over here.

3289
01:52:32,750 --> 01:52:33,990
How do I sort a list of size 4?

3290
01:52:34,100 --> 01:52:34,399
Well,

3291
01:52:34,629 --> 01:52:35,649
you sort the left half.

3292
01:52:35,709 --> 01:52:37,350
How do you sort this thing of size 2?

3293
01:52:37,390 --> 01:52:38,229
You sort the left half,

3294
01:52:38,350 --> 01:52:39,149
you sort the right half,

3295
01:52:39,169 --> 01:52:40,580
and now you merge

3296
01:52:40,790 --> 01:52:41,779
those together.

3297
01:52:41,990 --> 01:52:44,669
How do I now sort the right half of the right half?

3298
01:52:44,750 --> 01:52:45,149
Well,

3299
01:52:45,479 --> 01:52:47,589
I sort the left half,

3300
01:52:47,799 --> 01:52:49,160
I sort the right half,

3301
01:52:49,240 --> 01:52:51,509
and then I merge those together.

3302
01:52:51,910 --> 01:52:52,350
Now,

3303
01:52:52,560 --> 01:52:55,379
I have sorted the left half and the right half

3304
01:52:55,879 --> 01:52:58,000
of the right half of the original elements.

3305
01:52:58,080 --> 01:52:58,600
What's next?

3306
01:52:58,680 --> 01:52:59,430
The merging,

3307
01:52:59,529 --> 01:53:01,609
025.

3308
01:53:01,879 --> 01:53:02,660
And 7.

3309
01:53:02,910 --> 01:53:06,129
Now we're exactly where we were originally with the lighted numbers.

3310
01:53:06,310 --> 01:53:07,540
I've got 1346,

3311
01:53:07,549 --> 01:53:08,580
the left half sorted,

3312
01:53:08,790 --> 01:53:09,899
02 57.

3313
01:53:09,910 --> 01:53:10,629
The right half sorted.

3314
01:53:10,669 --> 01:53:12,660
What's the third and final step?

3315
01:53:12,990 --> 01:53:14,040
Merge those two halves,

3316
01:53:14,109 --> 01:53:14,430
of course,

3317
01:53:14,470 --> 01:53:19,149
0123456.

3318
01:53:19,830 --> 01:53:20,830
And 7

3319
01:53:21,299 --> 01:53:23,049
And hopefully even though there's a lot of words that

3320
01:53:23,049 --> 01:53:24,839
come out of my mouth as acting this out,

3321
01:53:25,370 --> 01:53:26,810
there wasn't a lot of back and forth.

3322
01:53:26,850 --> 01:53:29,290
Like I definitely wasn't like walking back and forth physically and

3323
01:53:29,290 --> 01:53:32,279
I also wasn't comparing the same numbers again and again.

3324
01:53:32,410 --> 01:53:35,259
I was doing sort of different work at different conceptual levels,

3325
01:53:35,450 --> 01:53:36,589
but that was like only what,

3326
01:53:36,649 --> 01:53:37,890
like 3 levels total.

3327
01:53:37,930 --> 01:53:38,810
It wasn't N

3328
01:53:39,169 --> 01:53:40,919
levels on the board visually.

3329
01:53:41,370 --> 01:53:43,649
So where does this get us with merge sort?

3330
01:53:43,770 --> 01:53:43,850
Well,

3331
01:53:43,970 --> 01:53:44,959
with mergesort,

3332
01:53:45,330 --> 01:53:46,500
it would seem that

3333
01:53:46,729 --> 01:53:50,160
we have an algorithm that I claim is doing a lot less work.

3334
01:53:50,250 --> 01:53:50,689
The catch.

3335
01:53:50,816 --> 01:53:54,066
Is that merge sort requires twice as much space just as we saw

3336
01:53:54,066 --> 01:53:57,687
when I needed two shelves in order to merge those two lists.

3337
01:53:57,887 --> 01:54:00,836
So how much less work is actually going to be possible?

3338
01:54:01,046 --> 01:54:01,126
Well,

3339
01:54:01,166 --> 01:54:05,687
let's consider sort of the analysis of the original list and how we

3340
01:54:05,687 --> 01:54:09,236
might describe its its running time in terms of this big O notation.

3341
01:54:09,407 --> 01:54:12,356
Hopefully it's not going to be as bad as n2d ultimately.

3342
01:54:12,486 --> 01:54:15,157
So here are some like bread crumbs that if I hadn't kept

3343
01:54:15,157 --> 01:54:17,836
updating the screen and deleting numbers once we move them around,

3344
01:54:18,006 --> 01:54:20,247
here's sort of like traces of every.

3345
01:54:20,333 --> 01:54:21,443
Bit of work that we did,

3346
01:54:21,483 --> 01:54:22,474
we started up here,

3347
01:54:22,604 --> 01:54:23,543
we did the left half,

3348
01:54:23,793 --> 01:54:25,003
the left half of the left half,

3349
01:54:25,083 --> 01:54:26,124
the right half of the right half,

3350
01:54:26,133 --> 01:54:27,594
and then everything else in between,

3351
01:54:27,713 --> 01:54:31,394
and you'll see that essentially I took a list of size 8 and I did

3352
01:54:31,644 --> 01:54:35,414
3 different passes through it at this conceptual level,

3353
01:54:35,523 --> 01:54:36,594
at this conceptual level,

3354
01:54:36,604 --> 01:54:37,394
and at this one.

3355
01:54:37,563 --> 01:54:40,124
And each time I did that I had to merge elements

3356
01:54:40,124 --> 01:54:42,113
together and if you kind of think about it here,

3357
01:54:42,324 --> 01:54:46,724
I pointed at 4 elements here and 4 elements here and in total I pointed at 8 elements.

3358
01:54:46,804 --> 01:54:48,914
So there was end steps here for merging

3359
01:54:49,233 --> 01:54:49,793
and if you.

3360
01:54:49,851 --> 01:54:50,320
Trust me,

3361
01:54:50,520 --> 01:54:53,360
I'll claim that on this level conceptually there were also 8 steps.

3362
01:54:53,440 --> 01:54:55,391
I wasn't merging lists of size 4,

3363
01:54:55,541 --> 01:54:59,920
but I was merging 2 lists of size 2 over here and 2 more lists of size 2 over there.

3364
01:55:00,000 --> 01:55:00,601
So if you add those up,

3365
01:55:00,610 --> 01:55:04,110
those are in total steps or or merges if you will.

3366
01:55:04,181 --> 01:55:06,190
And then down here this was kind of silly.

3367
01:55:06,400 --> 01:55:06,820
I was,

3368
01:55:06,891 --> 01:55:11,630
but I was merging ultimately 8 single lists altogether

3369
01:55:11,920 --> 01:55:13,811
into the higher level of

3370
01:55:14,110 --> 01:55:15,311
of conceptually.

3371
01:55:15,520 --> 01:55:19,201
So from a list of size 8 we sort of had 3 levels of work.

3372
01:55:20,060 --> 01:55:22,279
And on each level we did n steps,

3373
01:55:22,359 --> 01:55:23,069
the merging.

3374
01:55:23,200 --> 01:55:24,140
So whereas 3?

3375
01:55:24,160 --> 01:55:24,270
Well,

3376
01:55:24,359 --> 01:55:26,669
it turns out if you have 8 elements up here,

3377
01:55:26,799 --> 01:55:29,549
the relationship between 8 and 3 is actually something formulaic,

3378
01:55:29,560 --> 01:55:31,870
and we can describe it as log base 2 of n.

3379
01:55:32,029 --> 01:55:32,270
Why?

3380
01:55:32,479 --> 01:55:33,479
Because if n is 8,

3381
01:55:33,560 --> 01:55:35,470
if you don't mind doing some logarithms here,

3382
01:55:35,600 --> 01:55:39,430
logba 2 of 8 is the same thing as logbase 2 of 23 power.

3383
01:55:39,600 --> 01:55:41,520
The log 2 and the 2 cancel itself out,

3384
01:55:41,600 --> 01:55:43,919
which gives you exactly the number 3.

3385
01:55:44,209 --> 01:55:45,359
That I sort of

3386
01:55:45,600 --> 01:55:48,669
visualized with those traces on the screen,

3387
01:55:49,020 --> 01:55:50,069
which is to say,

3388
01:55:50,160 --> 01:55:52,080
irrespective of the specific value of N,

3389
01:55:52,310 --> 01:55:56,439
the big O running time of merge sort is apparently not n squared,

3390
01:55:56,759 --> 01:55:58,109
but it's log n

3391
01:55:58,700 --> 01:56:03,560
times n or more conventionally n times log n.

3392
01:56:04,049 --> 01:56:05,580
Because you're doing things,

3393
01:56:05,759 --> 01:56:08,629
log n times technically based 2,

3394
01:56:08,669 --> 01:56:10,740
but we don't care about that generally for big O notation.

3395
01:56:10,770 --> 01:56:13,220
And indeed in big O notation we would say that

3396
01:56:13,509 --> 01:56:16,640
merge sort is on the order of N log N.

3397
01:56:16,910 --> 01:56:19,069
That's its big O running time sort of at the upper bound.

3398
01:56:19,109 --> 01:56:20,660
What about the lower order bound?

3399
01:56:20,669 --> 01:56:20,910
Well,

3400
01:56:21,189 --> 01:56:23,229
there's no clever optimization in our current

3401
01:56:23,229 --> 01:56:25,069
implementation as there was for bubble sort,

3402
01:56:25,109 --> 01:56:26,080
and so it turns out

3403
01:56:26,470 --> 01:56:29,109
the lower bound would be in omega of N log N

3404
01:56:29,390 --> 01:56:30,669
and in theta,

3405
01:56:30,689 --> 01:56:30,990
therefore,

3406
01:56:31,044 --> 01:56:35,705
Of and log in as well because Big O and Omega are in fact in this case one and the same.

3407
01:56:35,834 --> 01:56:38,915
And if we actually go back to our visualization from earlier,

3408
01:56:38,995 --> 01:56:41,234
give me just a moment to pull that up here in

3409
01:56:41,234 --> 01:56:46,234
our earlier implementation or an earlier demonstration of these algorithms,

3410
01:56:46,435 --> 01:56:47,305
we had

3411
01:56:47,634 --> 01:56:49,555
a side by side comparison of all of the comparisons,

3412
01:56:49,595 --> 01:56:52,515
but here if I go ahead and randomize it and click Merge sort,

3413
01:56:52,794 --> 01:56:55,865
you'll see a very different and clearly faster algorithm,

3414
01:56:55,955 --> 01:56:58,035
even though the computer speed has not changed.

3415
01:56:58,669 --> 01:57:03,729
But it's touching these elements so many fewer times it's wasting a lot less time

3416
01:57:04,140 --> 01:57:06,859
because of this cleverness where it's instead dividing and conquering

3417
01:57:06,859 --> 01:57:09,979
the problem into smaller and smaller and smaller pieces.

3418
01:57:10,100 --> 01:57:12,049
And to give this a final flourish,

3419
01:57:12,379 --> 01:57:13,060
since that was,

3420
01:57:13,259 --> 01:57:13,589
yes,

3421
01:57:13,660 --> 01:57:14,080
faster,

3422
01:57:14,140 --> 01:57:17,290
but not necessarily obviously faster than other things that we've done,

3423
01:57:17,500 --> 01:57:21,770
how might we actually compare these things side by side by side?

3424
01:57:21,979 --> 01:57:22,020
Well,

3425
01:57:22,060 --> 01:57:23,259
in our final moments together,

3426
01:57:23,339 --> 01:57:23,779
let's go ahead and.

3427
01:57:23,950 --> 01:57:25,580
Amatically and for no real reason,

3428
01:57:25,589 --> 01:57:29,439
just dim the lights so that I'll hit play on a visualization that at the

3429
01:57:29,439 --> 01:57:32,629
top is going to show you selection sort with a bunch of random data.

3430
01:57:32,799 --> 01:57:36,189
On the bottom it's going to show you show you bubble sort with a bunch of random data

3431
01:57:36,359 --> 01:57:39,319
and in the middle is going to show you merge sort and the takeaway

3432
01:57:39,319 --> 01:57:45,770
ultimately for today is the appreciable feel of difference between big O of N2d

3433
01:57:45,959 --> 01:57:48,959
and now the big O of N log N.

3434
01:58:55,779 --> 01:58:56,259
All right,

3435
01:58:56,339 --> 01:58:57,859
the music just makes sorting more fun,

3436
01:58:57,939 --> 01:58:58,700
but that's it for today.

3437
01:58:58,799 --> 01:59:00,180
We will see you next time.