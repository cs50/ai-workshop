All right, this is CS 50, and this is already week 6, wherein we transition away from C to a programming language called Python. And that's not to say that the past several weeks haven't been among the goals of the course. Indeed, in learning C, I very much think that you'll have at the end of this class so much more of a bottom up understanding of how computers work, of how programming languages work, and in particular you'll appreciate and understand better how Python and Java and C++ and Swift and so many other languages. are actually doing their thing nowadays. But recall that we started with Scratch some weeks ago, and in Scratch what was nice was that the first program we wrote, Hello World, was just all too accessible. All you had to do was interlock two puzzle pieces in order to make the cat in that case say Hello world. Well, thereafter, of course, we transitioned to C and recall that in week one we asked you to take on faith that you can sort of ignore that first line in a lot of these parentheses and the curly braces and really just focus on the essence of the program, which Clearly is still about hello world and printing it, albeit using a different function and a bit new syntax. Today, very excitingly, all of that is truly going to go away and be distilled into a single line of code when you indeed want to have the computer say something like Hello world. And this is what we mean by Python being a higher level language. So humans over the decades learned from earlier designs, earlier programming languages, what worked well, what did not. Computers got faster. Computers had more memory, and so you were able to start. Spending more of those resources in order to have the computer do more for you. And so you don't need to be as pedantic syntactically anymore. You don't need to write as much code anymore and frankly you can just start solving problems of interest to you, building products of interest to you, so much more readily by choosing the right tool for the job. And so in the real world, if you continue coding after CS 50, like sometimes C will be the right tool for the job, sometimes Python will be the right tool for the job, and sometimes it's going to be a different language. Together that you'll never have studied in school. And in fact what's compelling, I think, about this week 6, much like when I took the class back in the day, is that after CS 50 you'll have a taste of 12, maybe a few different programming languages, and that's going to be enough to bootstrap yourself and teach yourself new languages because you're going to start to recognize in the real world similarities with past languages that you've seen, programming paradigms that are still sort of with us, and the syntax, yeah, that's invariably going to change, but that's the. that you are going to Google or ask Chat GPT or some other AI about down the line so long as you know enough of it to sort of get real work done, you'll focus mostly ultimately on the ideas and the problems you want to solve and less on the syntax. And so among the goals for this week and this week's problem set and really the rest of the course is to get you more comfortable feeling uncomfortable in front of your keyboard because we're not going to give you and tell you everything you need to know for a language like Python. You're going to turn to the documentation. You're going to turn to the duck, and you're going to learn to to. Yourself ultimately a new language. So let's actually write our first program and compare and contrast with how we might do that in C. So recall that in C. We were in the habit for the first couple of weeks of doing make hello and make this build utility just kind of magically new to look for a file called hello.c and magically to create a program called hello, and then you could run it with hello. And then a week or so later we revealed that make is really just automating compilation of your. And with the actual compiler clang in this case and passing it command line arguments like 0 to get a specific output like the file name hello instead of the default, which recall was a out passing in the name of the file you want to compile and turning on any libraries that you might want to compile into your program, link into your program beyond the standard ones. But then you could still run it in exactly the same way. Starting today, when you write Python code and then want to run it, you're simply going to run. The Python program itself. So just as Klang is a C compiler, Python is itself not only a programming language but a program as well. And with the Python program, which understands the Python programming language, can you run code that you'll have written in a file called hello.ie? And what this program is doing is a little bit different from what Clang is doing, but we'll see that difference before long. But first, let me go over to BS code and let's write our simplest, our first of Python programs by doing code hello.ie, and then in this file without any includes, any in main voids, I'm simply going to say print quote unquote, hello world, close quote. All right, now I'm not going to. Make. I'm instead just going to do Python of hello.ie, cross my fingers as always, and voila, my first program in Python. So it's sort of obvious that we got rid of the hash and clue. We got rid of the Imain void, no curly braces, only a couple of parentheses here, but what else is different to your eyes? That's a little more subtle here versus C. Yeah, yeah, so there's no F, so the print function is a little more human friendly. It's print instead of print F where the F did mean formatted, but we'll see that we still have that functionality. So no need for the line breaks, specifically the backslash n, and yet here's my cursor on the next line. So I dare say humans over the years realized we are more commonly wanting a new line than we don't want it. And so they made the default to actually give it to you automatically. And there's one more detail, yeah. So there's no semicolon, so I finished my thought at the end of the line, but I didn't need to explicitly terminate it with a semicolon. This is just with one program, all of these salient differences, but I'd argue that we got rid of all of the annoying stuff thus far anyway, so we can really focus on what this program itself is doing. But what's exciting with Python 2 is just how quickly you can solve certain problems, and this isn't true of just Python. It's really any higher level language than C. In fact, just for fun, let me go ahead and implement. Problem set 5, wherein you're challenged with implementing the fastest spell checker possible. So let me go back here to VS code. Let's close out hello.ie and clear my terminal window, and let me go ahead and do this. Let me first split my terminal by clicking this rectangular icon over here, and that's going to give me two terminal windows now, left and right, because in the first one at left, I'm going to CD into a directory I came with today, which is the staff's solution to. Problemset 5's spell checker in C. And on the right hand side here I'm going to CD into another directory I brought with me today called Python, inside of which is a translation of Problemset 5 into Python. In particular, I've implemented in advance a speller.pi file, which is the analog in Python of speller.cnc, and I've also prepared a dictionary. Pi file. Unfortunately, if we open up dictionary.i. You'll see that it's not actually implemented yet. So in dictionary.ie, let's implement in Python problem set 5 and see how long it takes. Well, the first thing I'm gonna do is declare a global variable, we'll call it words, and set that equal to the return value of a Python function called set, which essentially gives me a set object wherein I can store a whole bunch of words without duplicates. Python's gonna manage all of that for me. In effect, it's going to implement what I needed to implement myself in Problems at 5 a hash table. Now down here I'm going to go ahead and define a function called check, pass in as input a parameter called Word because of course that's how it was implemented in C. But notice the difference already in Python we use a new keyword called deaf to define a function, and we don't have to specify the. Type of the variable being passed in word in this case, and we also don't have to specify a return type for the function. Now inside of this checks function, it suffices to do this I'm going to return word. lower in words, which is effectively a boolean expression asking is the lower case version of this word in the set? If so, returned true, otherwise returned false. Done with the check function. Now let's go ahead and define another function called load, which recall took an argument of the dictionary that you want to load into memory. And let's go ahead now and do this with open dictionary as file, which effectively opens the dictionary, as in C we used FO in Python we use open. And it gives it a variable name of file. Then once that file is open, I'm gonna go ahead and update that entire set of words which starts out empty by taking the file, reading the entire contents top to bottom, left to right, and splitting all of the lines therein on the. New lines that terminate each of the strings, effectively updating the set with every word in that their dictionary. Then I'm gonna assume that it all just worked because there's a lot less effort for me to uh to perform myself in Python, and I'm just gonna go ahead and return true T in Python. Done. Next, let's go ahead and define that other function from Palm set 5 size, whose purpose in life was to tell me the size of the dictionary I had loaded. Well, in Python, that's pretty easy. I can just return the length, or LEN for short, of the set in which I've stored all those words. Done. And then lastly I'm gonna go ahead and define an unload function which recall was responsible for freeing any memory I myself had allocated. I don't seem to have done any of that in Python. In fact, that's managed for me now, so I'm gonna go ahead and simply say return true because there's no work to be done. And that's it in like 19 lines of code in Python, most of which are blank lines. I claim I have reimplemented Problem set 5 in Python. Well, let's take a look now at the difference. I'm going to go ahead and reopen my terminal window, and I'm gonna go ahead and maximize it so we can see more output. And now I'm gonna go. And run Python, which is going to be not only the name of the language but the name of the program we use today to start running our Python code, and I'm going to run it on speller.ie, which I brought with me today, specifically on the largest of problems that finds files, homes.text. Enter. And as with Problem set 5 itself, we'll see a whole bunch of misspelled words being printed to the screen, some of which might very well be misspelled, some of which are just not in the dictionary, some of which are simply possessives of words that are in the dictionary, but at the very end of this output I should see not only how many words were found, but the total time involved, which appears to be 1.87 seconds. Not bad, seeing as it only took me like what, a minute or two to write the actual code. But there is going to be a trade-off, we'll see, even though it took me much less human time and arguably was a lot easier to implement this this spell checker in Python than I dare say it was for most everyone in C, let's see what that tradeoff might be. Over in my left hand terminal window in which I'm in the C directory which I brought with me as the staff solution in C to problem set 5, let's go ahead and make that spell checker. Then let's go ahead and do slash speller and run it on the same file, uh, Holmes.text, and see how long the C implementation takes. Enter. And we see some of the same output might be slower sometimes just because of the cloud and there total time spent in the CPU, not necessarily printing everything to the screen, which might take longer, is only 1.32 seconds versus the 1.87 seconds in Python. Now, while only half a second, that's a decent percentage of the total amount of time spent running this spell checker in each of the windows, and so that it alone seems to be one of the trade-offs, even though it seems to be much faster. They're easier to implement a problem in Python, there's going to be trade-offs insofar as the code might very well run slower. And as we'll see today, that's in large part because whereas C is of course compiled. That's why Iran make and in turn clang, and then the zeros and ones, the so-called machine code is what you're running in Python generally, the the computer is interpreting your code, essentially reading it top to bottom, left to right, much like a human in between two. Other humans might slowly translate one spoken language to the other if those two people don't in fact speak the same language themselves. So there's a bit of overhead when using Python, but I will say that the Python community has been working on this problem for some time and so in general it's not necessarily going to be as significant a trade off because there's certain tricks we can do. And in fact underneath the hood, what the Python language can do for you and the specific interpreter you're using is technically. Semi-secretly compile your code for you into something called bytecode and then run that bytecode, which is more efficient than actually reinterpreting it again and again, but we'll see more of this over time. For now, let's take a look at maybe two other problems that we might solve, dare say more easily, more quickly than we could have in C for problem at 4. Let me go ahead and shrink down my terminal window here, close out dictionary.ie, close one of my terminal windows and CD back to my main directory, and let's go. Go ahead and open up that bridge bitmap photograph that we used in Problem set 4 and how to apply a number of Instagram-like filters there too. Well, now let's go ahead and implement maybe one of those filters, the blur filter, whose purpose in life is just to blur this image. Well, let's see how long this takes. Let me go ahead and open up, say, uh, blur.ie, which is now going to be a Python program for blurring images. It's empty initially, but I can pretty much write this. Quite quickly now let me go ahead and at the top of this file write the Python keyword from PIL for Python image library, import an object called Image and another one called Image filter in particular two features of the Python image library that's gonna make this so much easier to actually solve. And then let's go ahead and define a variable we'll call it before, representing the before version of this image and set that equal to image. open. bridge.bmp where that is of course is the name of the file we want to blur. Then let's go ahead and create a variable called after representing the after version of this same filter and set that equal to before. filter parenthesis, image filter.bo blur, and then just to be a little dramatic, I'm going to blur it more so than you needed to in problem set 4, but we'll see it more visibly now on the screen. Let's do an argument of 10. And then at the very end of this process, let's do after.save and save it in a file called say out.bmp. Done. So in just 4 lines of code, I claim I've implemented the blur function now in Python of what we did previously in C. Let me open my terminal window. Let me run the Python command this time on blur.ie. Cross my fingers as always. And indeed I've made a mistake. Perhaps even if you've never written Python before, you can see it and in fact we'll see a number of these errors, some intentional, some unintentional, but on line 4 what I intended to do was set equal to before. filter, that variable I created called after. All right, that's all right. Let's go back down to my terminal window, clear it to get rid of all that, and rerun Python of Blur.ie.ross my fingers even harder this time. Nothing bad seems to be happening. Indeed, now let's go ahead and open up out. BMP and before we reveal that, let's go back to the original, which is bridge. BMP and now dramatically, let's see the blurred version thereof. Voila, hopefully to your eyes too. It looks quite a bit blurry. Well, how about one more flourish? Those of you who are feeling more comfortable last week and implemented perhaps, uh, edge edge detection in see. Well, let's see if we can whip that up quite quickly too. Let's go ahead and write a file called edges.ie using that same bridge. BMP file, and in this file, let's go ahead and do the following. As before from the Python image library, let's import, uh, the image feature and the image filter feature. Then as before, let's create a variable called before. Set it equal to image. open passing in bridge.bmp. So so far the same as before. Now let's create a variable called after. Set it equal to before. filter passing in this time image filter.fi edges, which is different from box blur, and by definition it's going to find the image the edges of this here image, and then after, as before, let's do after.save of out.bmp and just clobber the version of the blurred file that we just created. All right, that's it. Let's go ahead and open up my terminal window now. Let's go ahead and again run Python, but this time on Edges.ie, cross my fingers real hard. So far so good, and that was quite fast. Recall that the bridge. BMP image looked like this, but now when we open up this new and improved version of Out. BMP thanks to Python and just 4 lines of code, we now have all of our edges detected. So what can we then learn from C itself? Well, C had of course functions, and functions were those actions or verbs that simply got worked on. And let's go ahead and compare side by side, much like we did with scratch and C. The idea is that today onward are still going to be the same. And how they could translate to Python. So on the left here we'll now have our friend scratch. This of course was one of the first puzzle pieces we saw. It's a purple puzzle piece saying say, and it was a function insofar as it said the value of its argument, which in this case is hello world. What we've already seen in Python what this looks like. It looks similar to the version in C, but it's no longer print F. There's no longer a semicolon, and there's no longer an Explicit new line. So in Python it's quite simply this. Meanwhile in Python there are a whole bunch of libraries as well. Now in C we had simply header files, and those header files gave you access to the prototypes of that is the signatures of the functions that you want to use from those libraries. Python uses somewhat different vernacular whereby Python has what are called modules and packages, and a package is just a collection of modules. But a lot, a module is just a library using Python Speak, so to speak. So anytime you hear someone discussing a module or a package in Python, they're just talking about using a library, and that library might come with the language itself just built in as standard, or it might be a third party library that you might download and install yourself much like I did a few weeks back when we installed the cow sayy program so that I could actually have a cow or other animals on the screen. Display text. So in C recall we had something like this include CS50.h, which was the header file preinstalled for you somewhere, but we will have for at least this week an analog of the CS50 library in C also in Python just to make this transition from C to Python a bit easier. These two though are meant to be training wheels that you can take off and should take off, you know, even within a week or so. It's just meant to smooth that transition. Clear what's the same and what's different. So in the CS 50 library for Python, we also have a function called get string whose purpose in life is to get a string. To access it though, you don't use hash include CS50.h. That's a C thing. In Python you would say from CS50 import get string. It's a little more verbose, but it's also a little more precise as to what you want from the library, especially if you don't want the whole thing loaded into memory. So here for instance is now a scratch program that was a little more interesting than just printing out HelloWorld. This was the first program we wrote that actually got some user input. So in fact, let me go back to VS Code and let's see if we can't resurrect this C program real quickly in the form of a new hello.c. So I'm going to run code of hello.c. And then in my, in my code tab, I'm going to do include CS50. H, include standardio.h, and then below that, I'm going to go ahead and whip up our familiar version of this, I made void, and then inside of the curly braces we'll bring back string. Even though we now know it's Chart star, we'll call our variable answer, set it equal to get string, ask the user, quote unquote, what's your name with a space just to move the cursor over. Still need my semicolon and C. And then after that, recall back in week one we did hello slashn. And then plugged in the variable answer so as to see Hello David, hello Kelly, or something else. Just to be safe, let me do make hello. All is well so far. hello, type my name, and this version in C seems to be working OK. So in C, these lines of code here translate pretty literally to what we just saw, although we got the answer variable in. for free. That blue puzzle piece just existed without our having to create it, but it's a decent number of hoops to jump through in order to just get user input and print it out. Well, in Python, this is going to get a little more succinct in that the Python version of this code is now going to look like this. PrintF is now print. The semicolons are gone, and what else seems a little bit different. Yeah. I don't need any placeholders. Yeah, so we don't need the percents anymore. In fact, I'm curiously using a plus, which if some of you studied Java or some other language, you might have actually seen this before. Even if you've never seen Python before, you've only seen C in CS 50, you can probably guess what the plus is doing, even if you don't know the technical vocab. What is the plus probably doing here? Yeah, so it's concatenating or joining together the thing on the left with the thing on the right, and we actually had that vernacular in the world of Scratch. We had the joint puzzle piece that joins hello, comma space and the value inside of answer. A plus in Python can do exactly the same thing. So it's a little more user friendly. Having to anticipate, let's put the placeholder here and then come back later and plug in the variable. Humans over time just realize that it's a lot easier to sort of do this in this way than bother with placeholders, though you can still use placeholders for other purposes. Another subtle difference between the C and Python version of these two lines. More subtle Than that What's missing? Yeah, I'm back. Uh, so the backslash N is again gone for Python, so that sort of happens for free, indeed, and one more difference. Yeah, we don't need to declare the type of answer. Recall that if you rewind in the C version, you needed to tell the compiler that this is a string, and last week we could have changed string to charge star, but we still had to tell the compiler what data type we're putting into that variable. In Python we can now get rid of that data type, and Python will just figure it out from context. If get string returns a string, well then obviously the variable should store a string. If a function returns an in, well then obviously the variable should store an in, and the length. It's just doing more of that decision making for you just to save you time and save you thought. There's a subtlety here though where we can make this program a little bit different. In fact, let's whip it up first in Python. Let me go back to VS code here, clear my terminal, and let's go ahead and create a program that again called Hello.ie. That'll open up my previous version thereof. And just so we can see these things side by side, I'm going to drag that tab over to the right of VS code and let go. And now you can see the C version still on the left and the Python. Version at the right. What I'm going to do here now in my Python version is change it to be quite like the version in C now at left. So as promised, I'm going to do from CS 50 import get string. Then below that I'm going to say simply answer equals get string, quote unquote, what's your name? question mark space no semicolon, but then on the next line, what I'm oops, but uh parenthesis, then on the next line I'm going to do print, quote unquote. space close quote plus answer. Down here I'm going to go ahead and run Python if hello.ie again, no compilation step. I'm just going to interpret it line by line. What's my name David? And it seems now to work exactly the same. Now it turns out in Python there's even more ways to solve problems like this, even trivial problems like this. So here we're using the plus sign, not as addition per se, but as the concatenation operator, the joint operation. If you want though, you can take it. Advantage of the fact that print in Python can take more than one argument. It can take 2 or 3 or 4 or even 0 by simply changing the plus to a comma, getting rid of that seemingly superfluous space, and just give print two things to print because it turns out per the documentation of print, which we'll eventually see, it knows that if it takes +12 arguments by default, separate them for you by a single space, and that's something we can override as well. Which one is better? Like, uh, like I don't know, like they're sort of equivalent. It's such a trivial difference, but it speaks to the flexibility that you'll start to have whereby the language is a little less rigid than C was certainly when it comes to printing strings. So in fact, if I go back to VS code here and I go ahead and change that plus to a comma and get rid of the space inside of the quotes, I can rerun Pythonof hello.ie, type in my name, and we see exactly the same results there. But we can take this one step further, even though it's going to look a little cryptic. This is sort of the more pythonic way to do things, and that too is actually a term of art. To do something pythonically is to do it the way that most Python programmers would do it. It's not the only way. It's not necessarily the right way, but it's sort of the recommended way in the community. So here we have that latest version where I'm passing two arguments to print. The first is quote unquote hello, comma, and then the second of which is the value of answer. I could similarly write this same program. With this crazy syntax, it takes a little getting used to, but it turns out it's actually kind of nice overall. What's obviously different? Well, one, there's these weird curly braces are back. They're not part of the logic of the program. They're literally inside of the double quotes, but you can probably guess how this, what this does for me because there's one other crucial difference. What else has changed between before and after? Yeah, there's this weird F which is not part of print F. It's actually inside of the parenthesis and next to the double quotes. And even this one this came out was a little weird looking to people, but this is how you get this thing to be a formatted string, AKA an F string, as opposed to it being just a literal string of text. Now you can probably guess what it means to put the variable's name inside of the curly braces. It means the value of that variable is going to be substituted right there, similar in spirit to the percentage. S in C, but a little more explicit with the percents, you had to remember that that percents corresponds to this variable's value or something like that, which was just annoying if anything else, if anything, but this time you have a placeholder in curly braces that just says what you want there, that particular value, and what this means more technically is that the answer variable will be interpolated by the interpreter, which means its value will be plugged in right there. So let's try this. Let me go back over to VS code. And quite simply, on my last line of code here, let's change the input to print to be quote unquote, hello, comma, and then Curly brace, answer. Then close curly brace, close quote, and I've done this, this is intentional, but let's see. Let me go ahead and rerun Python of hello.ie DAVID. What are we about to see? Hello comma. Answer, so this is a bug, but just to demonstrate like what is going on and what's therefore missing, what, what did I forget? Yeah. Yeah, I didn't declare that this is a so-called F string or format string. The fix for this weirdly is just to put an F right there. And now if I rerun Pythono hello.ie, type in my name again, cross my fingers, now I see that the variable has indeed been interpolated and its value plugged in where I wanted it. All right, turns out we can take off one of these training wheels already. I propose that Get string just exists in the library just to smooth the transition, but honestly it's not really doing anything all that interesting. So let's take this first training wheel off. It turns out that Python comes with a function appropriately named input such that if you want to get input from the human via their keyboard, you can just use the input function. So we can already for this program get rid of the CS 50. Library because input essentially behaves just like the get string function. So if I go back to my Python version here, I can change get get string to input, and I can even go and delete this training wheel up there, rerun Pythono hello.ie in my terminal, DAVID enter, and we're still in business as well. So input is generally going to be the way you go about getting input now from the user. All right, let me pause here and see if there's any questions as we try to bridge these two worlds from C to Python. Yeah. uh, so in Python, we don't need a name. Good question. In Python, why don't we need the main function anymore because clearly that's been omnipresent in like every program we've written thus far, and here we have it in all of our Python programs thus far absent. It turns out that humans realize it's just so common that you want the file you're editing to be the main part of your program. Like, why bother adding the additional syntax of saying in main void or something analogous? It's just easier if you want to write two lines of code to get some work done. Why do you have to waste my time adding all of these this boilerplate code which we've been doing. Up until now, now that said, we're going to bring back Maine in a little bit because it will solve a problem, but generally speaking, what I'm doing here is indeed a program, but people in the real world would also call these scripts where a script is like a lightweight program that pretty much just reads top to bottom, left to right. It might be fairly lightweight. It's really synonymous with writing a program, but this is again one of the appeals of a language like Python. You can just get right in and get out and get the job done. Even Java has moved to this in recent years where you don't have to put everything in a class, uh, public static void main for those familiar, you can just write, uh, system.out.print line and get some work done. Yeah. Good question. Is input only for a string? Yes, right now, it will get input from the user via their keyboard and you'll get back a string just like get string, and we'll come back to why that's maybe not a good thing. All right, so what's more what we want to do at this point? Well, let's tease apart some differences now with C. So up until now, every argument we've ever passed into a function in C, and scratch for that matter is a so-called positional parameter, and a parameter is the same thing as an argument, but generally when you're looking at the function from the functions perspective, it's a parameter that it accepts, but when you're Calling the function and passing in an input, you call it typically an argument, but they refer to essentially the same thing, and all of the parameters we've been passing into functions thus far have been positional in the sense that the order matters. The first thing, then the second thing, then the third thing, and so forth. For instance, with print F, the first thing has to be the quoted string, maybe with the placeholder, and then if there's another argument after the comma, that can be the 2nd argument, the 3rd argument, and. So forth, but it turns out Python additionally supports what are called named parameters whereby you don't have to rely only on the order in which you're enumerating the arguments to a function, and that's helpful because some functions, especially in the real world, when you start using other people's libraries that have lots of functionality, they might not take just one or two arguments. They might take 4 arguments, 10 arguments, maybe even more, and it can just be. Wieldy to have to remember the precise order of all those arguments, you're just asking for trouble if you're going to screw up or a colleague is going to get the order out of out of whack. So with name parameters you can actually be explicit with Python and tell it what argument you are trying to pass in by giving it an actual name. So let me go over to BS code here and propose that we use this for really the simplest of programs in order to Override that default new line that we seem to be getting for free just by calling print. In other words, let me go ahead here and clear my terminal window. Let me close hello.c and focus only on hello.ie for just a moment and let's make it much simpler, like the very first version, and just print out using Python's print function, not print F, quote unquote hello. close quote. And now here I'm going to do Pythono hello.ie. Enter and we still see that the cursor moves to the next line, the dollar sign moves to the next line, because I'm automatically getting a new line. Well, what if you don't want that? How can you override that behavior? Well, you can actually use a named parameter in Python, and I can go up here and add a second argument. That if it were just something like this that would literally print out the word this because it's just another string, but if I give it a name like end equals quote unquote, I can override the default behavior of the Python print function by changing the value of its end parameter to be the so-called empty string, quote unquote, which means literally there's nothing there. Watch what happens now if I run Python of hello.ie and hit enter, the dollar sign is weirdly and sort of in the ugly way on the same line just like it was when I made the mistake in C in week one of omitting the backslash N. That is to say, what the default value of this end parameter really is is quote unquote backslashn, and I can make it explicit by changing my code as such. I'm going to go ahead and rerun Pythono hello.ie, and now the cursors back on the next line. And not that this is that useful other than overriding that default, but you could do fun things like, if you really want print to be excited to print some. Things for you. And if I now run Python of hello.ie a third time, now you see that it's ending with exclamation looks a little stupid with the dollar sign, so you could even toss in a new line there, run it yet again, and now we sort of get both of those there. But I would say the common case is to use that end named parameter simply to override it. So how do you learn more about these kinds of things? Well, if you go to The official documentation for Python, which is a thing more so than with C, like if you want to learn more about Python and the functions it offers and the arguments it takes, you go to the official documentation docs.python.org. This is essentially analogous to the so-called manual pages or man pages that CS50 has a version of, but there is no one de facto source for those man pages. Several different versions of them exist in the wild, whereas Python itself. A community maintains its own official documentation. So for instance, if you go to a specific URL like this ending in functions.html, you'll see an exhaustive list of all of the functions that come with Python besides just the print function, and we'll see a bunch of more today. If specifically you scroll down to the print documentation, you'll see something that's a little arcane that looks like this, but this is represented. of a Python prototype, if you will, also called a signature that just tells you the name of a function and then how many and what type of arguments it takes. So how to read this? Well, the print function takes some number of objects. So in Python specifically, this syntax of star objects just means zero or more objects, whatever that is, like a number or a string or something else. The stuff you want to. Print out after that, if you start using named parameters, you can specify what the default separator is the separator between arguments to print. So recall that when I did quote unquote hello, quote unquote or quote unquote hello, comma answer it was separated automatically for us by a single space even without my hitting the space bar inside of my quotes. That's because. As the default value here is in fact a single space. The default value for and as promised is indeed backslashn. And then there's some other stuff related to file IO that print can also deal with, but more on that perhaps another time. There's one curiosity here in Python, it turns out that you can use double quotes or single quotes around strings, where in C it was much more regimented. Double quotes are for strings and single quotes are for. Chars characters only single characters. It doesn't matter in Python which one you use so long as you're consistent and stylistically you should really pick one and go with it. And the only time you should really alternate between the two is maybe if you want to put like an apostrophe for some human's name inside of double quote inside of single quotes or something like that, but generally you have a little more flexibility. in Python and you'll see in different languages Python community tends to use single quotes at least in the documentation. The JavaScript world tends to use single quotes. Um, we in CS 50 often use double quotes just for consistency with what we do and see, but any, uh, community or company would typically have its own style guide that dictates which one you should use if only for consistency. Questions then on this here print function. As just representative of all of the docks that you'll see. All right, well, let's take a quick look at variables. We've used these a few times already, but let's focus in a little more detail on what's actually different in Scratch, if you wanted to create a variable called counter and set it equal to 0, you would use this orange puzzle piece here. In C, you would do something like this the type of the variable, the name of the variable, and then set it equal to the initial value semicolon. In Python, it's going to be a little similar, but you can probably guess where we're going with this. How is this line of code probably about to change? Yeah, Good, we're not going to bother with in or the data type more generally, we're just gonna say counter because obviously like a smart interpreter can just figure it out from context that you're putting a 0 in there. It's obviously an integer, and what else is about to go away? The semicolon. So this is the C version and voila, this now is the Python version and this is as silly as this example is, it's kind of representative of how languages like Python just tend to be a little more programmer friendly because you just type less and get the same work done. All right, so if we wanted to do something now and scratch like. Increment the counter by 1. You would use this puzzle piece here. In C we could do something like this in Python it's going to be almost exactly the same, except of course no semicolon. In C we could alternatively do this, and you can also do this in Python. In C though, You could also do what other technique? Plus plus, I'm sorry, but Python has taken that away from us. So if you got into the habit of using plus plus or minus minus, that's great. Use them and see all you want in Python, they just don't exist, so you'll see this more commonly instead as the heuristic. All right, what about the various types that exist in Python? Because even though you don't have to specify the types when declaring your variables, they do in fact actually exist underneath the hood, and it's worth knowing a little something about them because Not knowing will lead to some form of bug. So in C we had types like this bull, char, double, float in long, and string, the last of which was thanks to the CS 50 library. But last week we would have started calling a string chartar instead, which it still is a data type, the address of some char. In Python, we're going to whittle this list down to a subset of those essentially whereby we still have bulls, we still have floats, we still have ints, and we do have strings, but they're literally. Called ss STR so it's not a CS 50 thing. The Python community calls strings STRs, but absent from this list is any mention of star, not to mention chartar, there are no pointers in Python, and indeed as powerful as I'd hope you found weeks 4 and 5 to be, I dare say you also found them incredibly frustrating and challenging and want to yield bugs in your code because with that. Power of memory management comes a whole slew of potential mistakes that you can make, and that's true not just for CS 50 students but for programmers, adult programmers, full time programmers around the world. And so among the other features of languages like Python is they try to take away certain features of languages like C that were just too dangerous in the first place. It might be wonderfully powerful. It might help you solve problems more quickly, more precisely, but if they tend to do more damage than they're worth, some. it's worth just abstracting those details away. Similarly, Java has references, as some of you might know, but does not have pointers per se. You can't go poking around arbitrary locations in memory in the same way that you can with C. So let's take some of these data types out for a spin and see what's the same and what's different. Let me go back to VS code here and let me propose that we bring back one of our old calculators from a while back. So let me clear my terminal, close hello.ie. And let me go ahead and open up a version of this program that I brought in advance, which was our calculator version 0 from back then. So just to remind you, one of the first versions of our calculator had the CS 50 library as well as the standard IO library, and then we simply got an IT using GetIT in week 1. We got another in in week one using GetIT, and then we simply performed some additions. It was a very Trivial calculator that we did very early on just to demonstrate some of the operators and syntax of C. Well, let's go ahead and try converting this to Python by creating our own program, calculator.i. So in my terminal window I'm going to write code of calculator.i. It's going to open another tab which I'm just going to drag over to the right just so we can see both side by side. I won't bother with, say, well, Let's do it for parity here. Let me copy the C code into the Python file, even though this will not work in the same way. But let's keep what we need and get rid of what we don't. So instead of the slash slash for comments in Python, it turns out the convention is to use a single hash symbol like this. So it's a minor difference. It's half as many keystrokes, so that's nice, but we're not going to include anything like this. But we are going to do from CS 50. Let's import a function that I promised would exist called get in, but we'll soon get rid of that training wheel as well. We don't need main or this curly brace. We don't need this curly brace, and we don't need all of this indentation as a result. So I'm going to move all of that over to the left. I'm going to fix all of the comments to be Python comments by changing the slash slash to hash symbols. And now I'm going to change each of these three lines of code, as you might expect to the Python version. So you probably can guess already. We can get rid of the in there and the in there. We can get rid of the semicolon here and the semicolon here. We can get rid of the F in print F here and we can get rid of the semicolon here. And there's a few different ways we could do this, but I dare say the simplest is going to be to get rid of the format code altogether in that first argument and just tell Python to print X plus Y. So there's a few different ways we can do this, but that's probably the most literal translation of the program at left. To the program at right. Let's reopen the terminal window and run Python of calculator.ie and hit enter. Let's do something like X is 1, Y is 2, and hopefully, we do in fact get 3. All right, so that's all fine and good, but let's take off one of our training wheels now. So let me get rid of our C version here and focus just for the moment on Python. Let's take away this C code and what was the function we can use to get user input. Yeah, it was called a little louder. It's just called input. So let's get rid of CS 50's get in already and use input instead. All right, so this program is much simpler already. So let's go ahead and reopen the terminal window, run Python of calculator.pi, do one again for X, 2 again for Y, and of course, 1 + 2 equals 12. So what's going on here? Cause clearly this is a step backwards, yeah. Yeah, so in the context of strings, plus represents concatenation, the joining of two arguments on the left and the right. Here that seems to be what's happening because it's not 12 per se, it's more literally +12 concatenated together, but why is that? Well, apparently the input function indeed. Returns a string that is those are the key strokes that came back from the user might look like numbers in Arabic numerals to us 1 and 2, but it's being treated as a string. More technically like underneath the hood, there is some char star stuff going on there, even though we're not using that same terminology. So intuitively, what's going to be the solution without just reverting to using the training wheel that is the get in function from CS 50? Put another way, how did CS 50 probably implement get in, might you think? Yeah. Yeah, so we'recall that in C. We could cast some data types to other data types, typically ends to chars or charges to ends. It's not quite as simple as casting in this case, because underneath the hood, thanks to our knowledge of C, there's a bunch of stuff going on. There's probably a 1 and there's a null character. There's a 2, and there's a null character, so Not quite as literal as a char to an end or an end to a char, so we're going to more properly convert the H string or the stirr to an end. We're not casting, but converting, and converting just implies that there's a little more work that has to be done. But thankfully Python can do this for us. In fact, let me go up to line 4 here and say, A pass the, well, actually let's do it in this a couple ways. Let's first convert the X value to an integer. Let's convert the Y value to an integer as well. So funny enough, it's very similar syntactically to casting, but in C, when you cast something, you actually wrote the data type in parentheses. Now the data type itself is a function that takes an argument which is the stir or string that you want to convert. So let me go back to my terminal, do Python of calculator.ie, enter, type in 1, type in 2, and now I get back my 3 answer. Now as you might imagine, just like in C, we can kind of play around with where we're performing some of these operations, and this looks, you know, arguably a little less obvious now as to what is being added. So I really like the simplicity of X + Y. It just does what it says. So I could convert these in other ways. I could say after line 4, you know what, rechange. X to be the in version of X, but generally speaking, that's kind of wasting a line of code by just doing something you could do on a single line. So let me delete that and instead just say that well if I know the return value of the input function is a stir, let's just pass that output as the input to the end function and it'd be a little more pythonic. So to speak, to just pass the input functions output as the input to in, which is really hard to say, but we've done this in C, just nesting function calls like this. All right, so if I run this one more time, Pythonocalculator.pi type in 1, type in 2, we're back now in business. Now what I won't trip over just yet is a subtlety that Whereby I'm deliberately typing in actual numbers like 1 and 2, but if you are following along at home or on your laptop, if you were to type in cat and dog, like bad things will happen, but we'll come back to that before long. Our questions though on any of this conversion of our strings to our. Integers in this case. All right, well, what more does Python offer to us? Well, in addition to these data types, there's actually going to be a bunch of others, a few of which we'll actually use today. In fact, we'll see ranges of numbers that's like that's a thing built into Python. We'll see lists of numbers which is going to be like a new and improved version of an array that solves like all of last week's problems when we talked about the downsides of using arrays. There's going to be tups for things like X Y. Coordinates or GPS coordinates or anything where you have collections of values. There's going to bed or dictionaries whereby you can have key value pairs provided to you without having to write a whole hash table yourself and you can have sets which you can use to just contain unique sets of values that you just want to check for membership and there's bunches of other data types as well. And this is where languages like Python start to get really powerful because all of the Data structures we talked about in C we really only got from the language itself in array. Everything else we had to build, or at least talk about building in class, these now and more come with the language. Meanwhile, in the CS 50 library for Python, just so you know, there are a whole bunch of functions. These were the C versions in Python it stands to. And that we don't need as many because there's fewer data types in Python, but get flow, get in and get string do all exist in the CS 50 library for Python. You're welcome and encouraged to use it because indeed among the goals for problems set 6 are going to be to redo some of your C problem set problems in Python where you can look at your own C code and hopefully. Uh, you like that solution and figure out how to convert it line by line essentially to the corresponding Python version, but clearly we've seen ways of taking these training wheels off quite quickly as well. And in fact, if you wanted to import all three of those functions for a larger program, you could do this just following the approach that I took so already, but you can also just separate them by com. like this or it turns out you can also import the whole CS 50 library as you'll see in some code and then just access the functions within with slightly different syntax as well. All right, how about another construct from scratch and from C now in fact in Python. So in Scratch, if we wanted to do a comparison like is X less than Y where each of those are variables, then say. Much here in C it looked like this and nicely enough you can probably guess already which what's going to change here. Like the F is about to go away, the backslash n is about to go away, the semicolon is about to go away, but some other stuff's about to go away as well. Focus your attention on the syntax like parentheses and curly braces because in Python it's just that. So we got rid of the parentheses because they didn't really add all that much logically. We got rid of the curly braces, which technically we could do in C anytime there's a single line of code inside of a conditional, but for consistency stylistically we always use them as well. Python though does not have you use any of those curly braces at all, but Python requires that you indent your code. Properly. So if you've ever been among those who are writing out your program and like everything is just crazily like left aligned and just a big mess until Style 50 swoops in and cleans it up for you, you're not going to be able to write Python code like that anymore. That's been such a societal problem among programmers, newbies and professionals alike, that the language itself requires logically that if you want this line of code to execute if this boolean. Expression is true, you've got to indent this line by convention 4 spaces. You can't be lazy and leave it all left aligned and sort of fix it up later. This has made Python code arguably more readable because of these language-based requirements. Meanwhile, let's look at a ifE construct in Scratch, which looked a little something like this and see, it looked like this, which is kind of a lot of lines just to express a simple idea. All of those same things. Going to go away whereby in Python it looks like this instead and the only other difference worth calling out is that because you don't have the curly braces, you do have a colon which precedes the subsequent indentation as well. Meanwhile, if we've got an if if els in scratch in C, of course it looked like this. A lot of this is going to go away in the flash of a screen, but there's going to be a curiosity, which is not in fact a typo. Notice what happens with the LSIF. It's abbreviated L if, and honestly to this day, all these years later, I can never remember if it's L if or LSI because different languages use different shorthand spellings of this phrase. It's LF in Python, because that's maybe the most succinct you can make the two words themselves, but everything else is effectively the same, including the additional colon this time. OK, questions on. Any of those conditionals and syntax, yeah. What a good question. What language did they code Python in? The interpreter we are using within VS Code is itself written in C, AKA C Python. However, you can implement a Python interpreter really in any language, including machine code like raw zeros and ones if you have that much free time in assembly. Language which we saw briefly weeks ago. You could write an interpreter for Python in Python if you really want to be meta about it or in C++ or in Java. This is the thing about programming languages you can use any language to create a compiler for or interpreter for another language. What's going to vary is just how easy or difficult it is and how much time it therefore takes you. Good question. Other questions on any of these here features. All right, well, let's do something a little bit different in Python visa VC by opening up maybe a comparison program that we looked at some time ago. So let me go back to VS code here. I'm going to close my calculator and I'm going to open up now from my distribution code today a version of our comparison program from a while back which was essentially the Uh, version 30 index thereof. So this one has comments, which the very first one in week 1 did not, but notice as a refresher what this comparison program was doing. It was including CS 50.H and standard.O.H. It was prompting the user for two integers via get in X and Y. It was then doing a very simple comparison comparing X against Y to determine if it's less than, greater than, or the same as. X and uh the same or equal to the same. So, just so that we can go through the motions of converting one of these to the other, let's do that side by side. Let me code a program called Compare.i. Let me close my terminal, drag the Python version over to the right here. And without comments this time, let's just do from CS 50 import get in. Then below that let's do x equals get in and ask the user for what's X question mark. Then let's ask the user for Y using get in quote unquote what's why mark. Then below that let's do if x less than Y call in. Go ahead and print quote unquote X is less than Y L if X greater than Y, go ahead and print quote unquote X is greater than Y else coin, let's go ahead and print out quote unquote X is equal toy. So I dare say these are now equivalents. It's clearly fewer lines because a lot of the lines that left were admittedly comments, but also some curly braces and there's more syntax like parentheses that we got rid of too. Let me open my terminal window. Let me run Python of compare.i. We'll type in 1 and 21 is less than uh X is less than Y. Let's do it again using 2 and 1. X is greater than Y. Let's do it one last time, 1 and 1, and of course those two now are equal to. Each other. all right, but why go down this road again because that was kind of a simple exercise but recall that we introduced this comparison of ants because it was so sort of stupidly simple, even if the syntax of that week was completely new but we ran into an issue pretty fast when we started comparing. Strings and that was a problem we really only fixed in week 4 when we finally revealed what a string actually is. If we focus a bit more on Python strings, it turns out that we can solve that problem much more easily in the world of Python. In fact, let me go back to VS code here. Let me close these two versions of in comparison. Let me open up at left a version of my program. That I brought with me here that contains a version from week 2 wherein we finally revealed that a string is just a char star but recalled that the solution in week 4 as well as in week 1 when we first encountered this problem was to use stom, a function that whose purpose in life is to compare two strings character by character by character using a 4 loop or something like that. But they have knowledge, therefore, of how to navigate pointers, how to look for the null character, the backslash zero at the end, and all of that came from our friend string.h. Well, how can we go about implementing the same idea in Python? Well, let's open up VS codes, Terminal window, open up a new program called Compare.ie, but this time, let's get rid of the integer version there. Of let's get 2 ins from the user, and I won't even use any CS 50 training wheels. Let's just use the input function to get S and ask the user for a value of S. So S colon close quote with a space, T equals input ask the user for a variable T. And then let's just ask the question if S equals equals t, then print out quote unquote same. Else, go ahead and print out quote unquote different. Let me move these side by side, just so you can see the difference. Notice how much code we have to write and how much we needed to understand in order to compare something as trivial as two strings and see. But in Python we're literally just using equals equals and let's see if it actually works. So Python of compare.pi enter. Let's type in maybe cat for S and dog for T, and those are in fact different, but we would have gotten the same answer in C. Let's rerun Pythonfcompaed.pi and type in cat, type in cat again. And now it's detecting them the same. So wonderfully, Python has solved that seemingly annoying problem of not taking us literally like don't compare the pointer against the pointer. Compare what a reasonable programmer probably really cares about the values of those strings. So the equal equals is doing all of the 4 loop or the Y loop, iterating over those things character by character and actually giving us the answer we want. So what else gets easier in Python? Well let's focus a bit more on these strings. Let me go back into VS code here. Let me close out our two comparison programs and clear my terminal, and let me go ahead and open up a prior program that we wrote, that one called Agree.c, and namely in the staff version of the code online, this was agree2.c, which is where we left it. Now recall in this C program that we did the following. We first, using CS50's GetHA function, prompted the user for a char, hopefully Y or N for yes or no, respectively. And then we used a Boolean expression and actually the combination of two using the two vertical bars to ask whether the inputted character is capital Y or the inputted character is lowercase y. And if so, we went ahead and printed out that the user agreed. Otherwise if they type in anything else for that character, we simply print it out, not agreed. Well, how can we go about implementing that same program in Python, for instance, in a file called agree.ie? Well, let me go ahead. And open up my terminal window again. Let's create a file called agree.i. As before, let me go ahead and drag it over to the right so we can see these two things side by side, and let me go ahead and do this. I'm going to set a variable, say, called S equal to the return value of input, quote unquote. Do you agree there by asking the user the same question as before. No need to use the CS 50 library because the input function here suffices. And instead of using C, I Deliberately using S because it turns out in Python there is no way to get a single character per se, but you can get a string that has a single character. Indeed, char is not a data type in Python, but once we have this input from the user, let's now go ahead and implement a conditional using one or more Boolean expressions. Well, let's ask if S equals equals quote unquote Y or S equals equals. Or Casey, then let's go ahead and print out as before, quote unquote agreed. And now notice what's different this time. I'm literally using the word or instead of the two vertical bars because in the spirit of Python things tend to be a little more English like, a little more readable, top to bottom, left to right, and indeed or hits that nail on the head. Otherwise, if it is not in capital Y or a lowercase y, let's go ahead and print out, quote unquote not agreed. And that's it for converting this program from C here into Python. But of course this isn't the most robust version of the program because it would be nice if the user could type in something like yes, YES capitalize maybe in different ways. So how might we go about implementing that? Well, we could do this in a few ways. I could, of course, and let's go ahead and get rid of my C version now and focus just on the Python. I could do something like this and just start oring together more possibilities like or S equals. Quote unquote yes or S equals equals quote unquote yes very emphatically or and so forth, but you can imagine that this doesn't scale very well. If I want to consider all the possible permutations, maybe of the caps lock key being up or down, that's quite a few possibilities to enumerate. So perhaps we could do this a little bit differently. And in fact we can by maybe storing all of the possibilities in a so-called list. So whereas C had of course arrays, Python has what are called lists which. Effectively underneath the hood are indeed linked lists as we explored in week 5. Now a linked list of course can dynamically grow and even shrink, and that's indeed what Python does for us. I can simply create a list of values from the get-go, or as we'll eventually see, I can add things to it, remove things from it, and all of the underlying memory gets managed for me. And in fact with lists we get a whole bunch of features that can make this possible. But for now, let's use them simply as statically initialized list with values I know from the get-go that I want and I'm gonna go. And do this in VS code. I'm going to delete most of this Boolean expression, the combination of all of those phrases, and I'm going to simply say if S is in using a Python keyword in, literally the following list of values unquotey, yes. And for now I'm going to use just those two, but let's see how it works. Let me open up my terminal window again. Let me run Pythonore.ie really for the first time, but let me claim that it would have worked even in the previous version. Enter. I'm going to go ahead and type in lowercase y, and I've agreed. I'm gonna go ahead and run it again and type in lowercase n, and I've not agreed. I'm gonna go ahead and run it again and I'm going to type in all caps, yes, because I really agree, and yet I don't because there is a bug still in this version. So even though up here. In my Python implementation, I do have a list of values that I'm looking for. Python's gonna look literally for those values, so lowercase y and lower cases. So how can I go about tolerating different capitalizations by the user? Well, I can do this in a few different ways. I could, for instance, after getting the user's input in a variable called S, I could updates to be S.lo, which is going to have the effect of lower casing the word for me and then updating the value itself of S. And now I think this will work. Even for an uppercase version, let me go ahead and run Pythonore.ie emphatically type in yes enter, and yet this time I've agreed because I forced the user's input to lowercase and then I have compared against the canonical forms I've written which are all lowercase. I could have done the opposite. I could have forced the user's input to uppercase and then enumerated in my Python list in between those square brackets, capital Y and YES, but either approach here is fine. Now technically I don't need this additional line here. I can go ahead and delete. that line wherein I lowercased it and in Python I can actually chain some of these function calls together by saying input. lower so that the return value of input ultimately gets forced to lowercase by using dotlo here. Alternatively still, I could just lowercase the very at the very moment I'm actually comparing it, and down here I could do s. lower and then compare the lower case version of what's going on toy or yes. Now what's really this all about? Well, this is actually an example. Of what's generally known as object oriented programming or OOP for short, whereby in Python and a lot of other languages now you can have variables and data types more generally that have not only values associated with them like why or yes, but also functionality built in. In other words, whereas in C we would have used a function from like the C type library called 2 upper or 2 lower, and we would have passed as an argument to those functions the very character that we wanted to force to uppercase. Or to lower case well in Python and indeed object oriented programming languages in general, the developers behind the language recognize that sometimes there's functionality that's inherently related to the values in question. Indeed, when we're dealing with strings, it's pretty reasonable to want to sometimes uppercase them or lowercase them, capitalize them or do any number of other things and so built into the string type in Python is in fact the lower function itself, as well as a whole bunch of others. In fact, at this URL here, can you see the document. for all of the string functions built into Python and more technically when a function is built into a data type and you access it via this dot notation instead of by calling some global function and passing an argument into it, you are using what are called methods. So methods are simply functions that are inside of objects and in this case the object in question itself is a string. So what's really happening with this here example when I'm checking whether the user has agreed or not is I'm taking that value that's. Strings, which is technically now an object in memory, and inside of that object is not only the user's input but some built in functionality otherwise known now as methods, and those methods were written by the same people who invented the string data type itself. So this is just the first of these examples, but we'll see yet others. But notice the syntax is actually quite similar to C, just isn't C when you wanted to go inside of a structure. You can similarly go inside of an object in Python and access not just the values ultimately, but also these built in methods. All right, how about another comparison of C to Python again involving strings? Well, let me go ahead and reopen and clear my terminal and close out of agree.ie. Let me go ahead and open up a version of copying strings from a couple of weeks back whereby we finally started solving it correctly by doing some proper memory management. So here in the staff version of Copy 5.c we have not only a commented version of what we did a couple weeks back, but we also have a reminder of how what was involved in. Copying strings and C. Recall for instance that we prompted the user in this example using CS 50's get string function for a string that they wanted to make a copy of, and then we did some error checking ultimately to make sure that there was enough memory and nothing went wrong. Then recall that the right solution to this problem in C was not to just use the assignment operator and assume that S can be copied into T, but rather to allocate using Malock enough memory for the copy plus one more byte for the null character again. Making sure that all is well by checking the return value of that and then actually copying character by character by character the characters from S into the chunk of memory now known as T or ultimately recall we used the built in stir copy function which does all of that looping for us. And then when it came time to capitalize just the copy, we did a quick sanity check. Is the length of T greater than 0, otherwise there's nothing to capitalize? And if so, go ahead and use the C type libraries to upper function. Passing as input that specific character T 0 and then updating T 0 itself. So here's an example of procedural programming in contrast with object oriented programming again, I'm passing the argument to be uh uppercase into the two upper function as opposed to simply going to that character and asking it via some dot operator to, for instance, uppercase itself. Now I went ahead in the C version and printed out the two strings. I freed up my copy of memory that I myself had allocated, and that was it for this program. So it was a decent amount of work we're calling C to actually go about just copying a string. Well, as with so many things in Python, it's going to be so much easier. Let me go ahead and do this. Let me open my terminal window. Let me create a file called copy.ie. Let me move it over to the right hand side so we can see them side by side, closing my terminal window, and let's do roughly the same. Let's create a variable called S, set it. Equal to on the right hand side, the return value of Python's own input function because we don't really need CS 50's own get string function and ask the user for S. Then let's go ahead and create a second variable called T, set it equal to literally S.capitalize, whose purpose in life, if we read Python's documentation for string methods, will be to uppercase the first letter of the word that the user has presumably just typed in. Then I'm going to go ahead and print out as before. The user's input, and I can do this in a couple of different ways, but I'm going to use one of our format strings and say S colon and then interpolate that variables by using my curly braces to say put the value of S here. Then I'm going to go ahead and print out T by saying T colon, interpolate its value here inside of quotes, close parenthesis. So let's see if this works. Let me go ahead now and run Python of copy.ie. I'm going to go ahead and type in, say cat and all. Case and hit enter and now notices remains in all lower case, but the copy indeed has been capitalized alone. All right, well let's take a look at one other example involving strings between C and Python equivalents. Uh, let me go ahead and remind us that a few weeks back too, we created this uppercase program whose purpose in life was to prompt the user using Get string for a string, saying, Here's the before string, then it prints out after. Because the purpose in life of this program was to uppercase all of the characters in the string, not just capitalize the first one. So as you might expect, we used a loop a few weeks back and we iterated from zero on up to the length of the string using plus plus to increment I in each iteration, and then each time we went ahead and printed out one character at a time. So strictly speaking, we didn't change the string from lower case perhaps to uppercase, we just changed each letter uppercase and print. It out right away. Well, how might we do something similar in Python? Well, here too, we have a couple of different approaches. Let me go ahead and open up my terminal now, run a code of, say, uppercase. i, close my terminal window, and let's drag this to the right so we can see them side by side, and let's do roughly the same. Let me create a variable this time called before, set that equal to the return value of input and just prompt the user for that before string. Then after that, let's go ahead and print out preemptively after colon space space just to align everything nicely, but let me not print a new line yet because I want to go ahead and see uh the following string on that same line. And then let's go ahead and do this analogously to the C version first, but then tighten things up. Here's how we can iterate in Python over every character in a string. I don't need to bother. I and indexing into the string or anything like that, I can using a Python 4 loop, simply say for each character C in that string called before, go ahead and print out the uppercase version of that character, but don't yet print out a new line. But at the very end of this loop, go ahead and print out nothing but a new line. Let me go ahead and open my terminal, run. Python of uppercase.ie enter type in cat in all lower case, cross my fingers, and after each and every one of the characters is uppercase. And what's nice about this, if nothing else, is that this 4 loop in Python there on line 3 is pretty elegant, whereby you implicitly get access to each character in the string because that's how Python knows how to iterate over a string object. But it turns out we don't have to do this quite as analogously in Python as we did in see we don't have to do it character by character in so far as Python is object oriented and these strings are objects and those objects have methods. Those methods will actually operate on the entire string at once, unlike the more pedantic work we had to do character by character in C. So in fact, let me go ahead and close the C version here. Uh, clear my terminal and hide it, and let's go ahead and make this quite simpler. Let's get rid of the 4 loop altogether and let's simply and let's get rid of that print statement altogether, leaving only the before variable and getting the user's input. And now let's create an after variable, set it equal to 4. upper, thereby upper casing the entire string called before and setting the return value. To the after variable and then let's go ahead and print using our old friend F string, uh, after colo uh space space, and then interpolate the value of that after version. So now we're down to just 3 lines at that. Let me go ahead and reopen my terminal python of uppercase.ie enter, type in cat in all lower case, and voila, now I have capitalized the cat all at once. All right, before we take a break for some fruit by the foot, let's go ahead and take a look at Python's implementation of loops further. So in Scratch, recall that we implemented a loop with something like this. If I wanted to me meow 3 times on the screen, I would literally use a repeat block. In C, it was a little clunkier to mimic that same idea. Like we could implement a variable called I and set it equal to 0. Then we could ask a Boolean expression is I less than 3? If so, print me out and then increment I using our old. plus friend, which in Python is now gone. In Python we can do this almost the same, except I don't think we need the data type. I don't think we need the semicolon. We don't need the parentheses while still exists. We don't need the curly braces, and we can't use the plus plus. We don't need the F. I mean, we're mostly just trimming clutter from this here implementation. So this is the C version. This now is the Python version, a little tighter, a little easier to read. It's pretty much the minimal syntax available to get the job done. So how can we actually have a cat meow in this case? Well, let me go into VS code and I'll stop doing everything side by side and just stipulate that we've done most of these examples previously in C and in my first cat, well, I could certainly do it the easy way and let me go ahead and create cat.ie and like we always started in the past with, I could just do meow and then our old friend copy paste, and this of course was bad for bunches of reasons, but it gets the job done. In Python, if I want to do this, well, I can just borrow. That same inspiration and I could say set i equal to 0, then do while I is less than 3, colon, then go ahead and print out meow, and then go ahead and do I equal or rather I plus equals 1 is maybe the most succinct way to express that same idea. All right, just to confirm that this works, python of cat.pi enter meow meow meow. All right, so how else can we do this and how can we do this more pythonically? This is perfectly correct. Many people might implement it this way, but it's not quite as succinct as we could alternatively do in Python, yeah. Yeah, so we could maybe use a 4 loop, and in fact let's let's go there because we don't quite have the same types of 4 loops in Python as we did in C. While loops are essentially the same, but 4 loops are actually a little bit different and actually a little bit better. So let me go into my code here, delete all 4 of these lines, and literally just say 4, I in this list of values 01 and 2 colo, print, meow. In other words, in 4 loops and Python, you don't have the parentheses, you don't have the two semicolons, you don't have the initialization and the Boolean expression and the update. You just say a little more English like for each i in the following list or for each value of I in the following list. And what Python will do for us is automatically on the first iteration set i equal to 0. On the second iteration set I to 1. On the 3rd iteration set i to 2, and then there's only 3 things in the list, so that's it. And so just as before with the Y and the yes example where I use square brackets similar to arrays and C, I was using a Python list of strings in that case. Here I'm using a Python list of integers 01 and 2, and they're integers in the sense that they have no quotes around them, so they're obviously not strings, and I'm printing out meow this many times. And indeed if I do Python of Cai again. I get meow meow meow. This is correct. This is arguably better, at least in the sense that it's two lines of code instead of 4, and it's arguably more readable as well, but what do you not like about this perhaps, even if you're only seeing it for the first time. Yeah, it's going to be a lot more difficult to do things more than 3 times because we're calling Python and Scratch at least, and in C we had the ability to either express ourselves literally or at least in C we could just change that 3 to any number we want 30, 300, no big deal. It's a super simple change even though it was kind of annoying to type all of this out. Well, in Python. Yeah, I could do this and say for 1 and 01 and 2 just to mimic the numbers that we'd be setting i equal to in the C version. Frankly, this can be any list. It could be 123456, cat, dog, bird, or any three things whatsoever, but I'm just using 01 and 2 for consistency with the way C would have done it. But slightly better than this is to use one of those other data types that was briefly on the screen earlier. We have not just floats and ins and stirrs and lists and tups. We also have what are called ranges, and range is not only a data type in Python but more literally a function that you can call to get a range of values from zero on up. So I can change this list of three values to a function call to a function called range, passing how many things I want, and by default. Per the documentation, I'll get back a list of numbers 01, and 2. And nicely, Python's pretty smart about this. It technically doesn't hand you back all of the numbers at once, whether it's 3 or 30 or 300 or 3 million. It sort of hands them back to you one at a time so you're not using more memory just because you're doing more iterations. So now if I do want to iterate 4 times, 5 times, 30 times, 300 times, I again can just change this single value. And if you want to be fancy too, you can skip numbers. You can go. Count all the way through odd numbers or even numbers. You can change the incrementation factor, but the default and the most canonical is indeed just to count up like that. So if I go back to VS code here and improve this, I can change that hard coded list to just range of 3, clear my terminal, run this cat one more time, and now I'm back in business as well. In fact, this is so common, let me throw up one alternative to this. You'll notice that in the previous example, both in VS code and on the screen, um. I am not actually using I in any way. In fact, if you look back at how we converted the scratch to Python code, I'm using I because when you use a 4 loop in Python, you have to give it a variable in some list or range of values. That's just the way it is. But I'm technically not using or printing I anywhere, and that's fine. And so it's arguably Pythonic too if you have a variable out of necessity, but you're not actually going to use it for anything useful, just. Call it an underscore instead. And even though this is weird looking, an underscore is a valid symbol for a variable name in Python, so it is Pythonic to just use this just to signal to yourself later and to colleagues that, yeah, I'm using a variable because I have to, but it's not one I'm actually going to use elsewhere. It's a minor subtlety and not strictly necessary but perhaps commonly done. All right, how about a couple final versions of cats then. So recall that if we wanted to do something in scratch forever, we had a forever block, which literally did that. Well, in C we couldn't quite translate that literally. So the closest approximation was probably this while true, whereby you have a boolean expression that by definition is always true, so the loop is never going to stop, thereby infinite if you wanted to print out. Meow meow meow on the screen ad nauseam. In Python you can do it almost the same, but the curly braces are about to go, the F is about to go, the backslash N, the semicolon, and the parentheses. But for whatever reason in C we lowercase true and false. In Python we capitalize true and false. So a minor subtlety, but it's now indeed capital T. But the indentation has to be the same and the colon has to be there as well. So with that we can of course induce intentionally or otherwise some infinite loops. As with C you can break out of them if need be with control C to interrupt the process. But let's just see lastly with this cat how we can make it a little more abstract like the final versions of our cat in scratch and see. So let me propose to open up here in a pro version of CAT that we looked at that we wrote in the past. It was version 12 at the time, which looked a little something like this. This was one of the final versions of our cat in C that simply allowed me in Maine to call meow function that took an argument, which is the number of times I wanted to meow. This in C is how we implemented that helper function, so to speak, that returned nothing, so its return type was void, but take an integer called N as its input and then there was a 4 loop inside of there that printed meow that many times. So long story short, this was how both in Scratch and in C we invented our own functions. Well, how can we do this now in Python? Well, let me bring this version of CAT over to the right here, delete that previous version, and let me propose that. We do this for I in range of 3. Let's go ahead and assume for the moment that there is a meow function in Scratch whose purpose in life is to just meow on the screen. Well, that of course does not exist. So in Python I'm going to use a trick that allows me to define my own function, and the keyword for this is literally deaf for define. The name of the function and then parentheses if it takes no arguments. You don't need the void keyword even if it takes no inputs. So let's do a simpler version of the cat first that takes no arguments, and then we'll add back that argument. How do, how does a cat meow? It literally just says meow on the screen. So already we seem to be an improvement. I've got like 4 lines of actual code here versus like 20 or so on the left hand side. Let's go ahead and run Pythonoca.ie. Enter and we see the first of our errors, which is remarkable because usually I would have messed up by now. So here we have in Python the equivalent of like a compiler error message. The program has not run. It's tried to run. It's tried to be interpreted, but it encountered some error. These are generally called trace backs in the sense that you. See a trace back in time of everything the program was trying to do just before it failed. So if you call it the function, which called the function, which called the function, you'd see all of those function calls on the screen. I've just tried to call one function, so it's a relatively short error. This is clearly a problem, and here's the type of problem name error. The name meow is not defined. So intuitively, even if you're seeing Python for the first time, why is meow not defined even though it's literally defined. Right there, yeah. Yeah, as smart as Python is vis a visc, still kind of naive in that meow doesn't exist until line 4. So if you try to use it on line 2 too soon. All right, so in C we fix this problem by initially just kind of hacking things together by just, all right, well, let's just define it up here and then move that down there and that's totally reasonable. And in fact if I clear my terminal and rerun Python of Capi, we're Back in business, but I'd argue you can only do that so many times, especially once you've got a bunch of functions. You don't want to relegate like the main part of your program, which really this loop is to the very bottom of the screen, if only because like that's the first thing you care about. I want to see at the top of the screen that's the whole point of putting main at the very top. So what was the solution in C? The solution in C was to put the prototype for the function at the top of the file. That though is not a thing in Python. You don't just copy that first line of code, put it at the top of the file, add a semicolon, and then it works. Instead, the Pythonic way to solve this problem, for better or for worse is to actually put your code in a main function. Main and Python has no special significance in this sense. It's just convention to borrow the name that so many other languages use as the main function in those languages, but you just wrap your function in a function main so that you're defining main, then you're defining meow before you're actually using the meow function per se. But I have made a mistake. If I run Python of cattai now, cross my fingers for good measure, and Now the program does nothing. Why is that? Yeah, why is that? Oh, sorry, go ahead. Yeah, curiously, I never called the main function. So whereas in C and in Java and C++ and a bunch of other languages, Maine is special. Like Ma is the function by definition that is automatically called Python has no such special magic. It's not going to call Maine for you just because you created it. In fact, I didn't even call that main function Main. It's just a convention, but the solution is exactly that. Well, if the problem is that Maine wasn't called at the bottom of this file, what I can do is just literally call Maine, which we would never have done in C, but this is conventional to do in Python, so that after you've defined Maine up here and then define Mao down here, now you can call Maine, which in turn will call meow, but at that point in the story, both of those functions functions exist. So if I go down here and run cat.ie again, now I see my meow, meow, meow. Now let me add one final flourish because this version of the code in C recall actually let me specify how many times I want to meow, whereas here I actually have my 4 loop in Maine at the right, and I'm calling meow that many times. Well, what if I want to get rid of this loop over here? And deindent meow here and pass in literally the number 3 here. Well, in Python you can just say inside of the definition of a function that it takes an argument like N. You don't have to specify the data type. Python's smart enough to figure it out. Then in your function you can use that as with 4 i in range of n. Go ahead and print meow. So now the right hand version of this program is pretty much equivalent to the left hand version of this program as always using fewer lines of code. Let me go ahead and run Python of cat up i meow meow meow. We're good. And then let me make one final change, if only because most every documentation you see online or website you. Orals on Python will actually have you not just literally call Maine at the bottom, but you'll do this crazy syntax that is solves a problem that we won't trip over in this class, but typically it's Pythonic to actually call Maine after asking the question if name equals equals quote unquote_ma__ colon Ma. This is a stupid mouthful of code that even I had to think about when I was typing it out if I got all the underscores correct, but long story short. This convention of using a conditional before you call main allows you to write more modular code in Python so that some of your files don't actually do anything other than define, define, define, defined functions that you can then import into other files you write. So in short, this is the right way to do it even though in CS 50 it is unlikely that we are to trip over this bug. Questions now on that last piece of how we define functions in Python, yeah. Ah, good question. Good eye. Why do I have two lines between my functions in Python? As you will see via Style 50, it is Pythonic, that is Python convention, to separate functions in your code by two lines, whereas there is no such convention in C. So I'm trying to be consistent with what the world does, yeah. If you want to count backwards in a loop, can you do that? Absolutely. You could use the range function in a different way. Start start with a much larger value and count down. How but you can alternatively do that with a while loop. I would say that yeah, you can make that work, but you shouldn't. It's just people don't do that unless it does actually solve a problem for you. Other questions on this. All right, well, when we looked at C, recall there was a bunch of things that ultimately like we couldn't do well. We ran into issues of like full loading point precision and integer overflow and truncation and like all of these world's problems. Um, there's still going to be some of those, but first, let's take a fruit by the foot brake and we'll be back in 10. Help yourself to seconds today. All right, so we're back, and let's use our remaining time together to focus not only on some of the problems that Python can solve more readily than C, but also some of the problems that remain. So here was a program early on in our discussion of C that had this weird bug whereby when we implemented a relatively simple calculator to divide two numbers x divide. By we experienced what we called truncation at the time whereby 1 divided by 3 was curiously 0 and like something like 4 divided by 3 was curiously 1 and we were losing everything after the decimal point and this was true even if we tried using floats because with truncation recall everything. the decimal point with integer math is simply discarded. So if you do in divided by in, you're going to lose what is after the decimal point. So let's take a look in Python at whether this is still actually a problem. So let me go back into BS code here. We'll close out the C version thereof, and let's go ahead and create our own program called Calculator.i. And in this version, let's modify the original which just did some addition and instead have it do some. Division instead. I'll get rid of my outdated comments and perform now division instead of uh addition by doing X divided by Y. Python of calculator.pi, let's try 1 and let's try 3. And oh, our fractions are actually back. So it turns out in Python, even when you're manipulating integers, if you divide one by the other and the result logically should actually be a floating point value, that's what in fact you're going to get back and you don't have to jump through the same hoops that we did before to actually force things to float and then do floating point arithmetic and so forth. In fact, if you Want the old behavior, it's still actually there and you can use two slashes in Python to use the old integer division as opposed to what we're seeing here. But a typical programmer, I dare say nowadays, would want it to behave in exactly the same way. So truncation seems to be less, therefore of an issue for us. All right, well, what other problems did we encounter at the time? We'll recall we had issues of Floating point in precision whereby even when we divided something simple like 1 divided by 3 and in grade school we learned that was like 0.3333333 repeating infinitely many times, we started seeing weird numbers that were not 3 at the end of that value back in the day and see unfortunately that's a problem that's still with us. In fact, if I use this same program here. Let me go into VS code and instead of printing out just X divided by Y, let's go ahead and do this temporarily. Let me give myself a variable called Z and set it equal to x divided by Y only because it'll be a little easier to see the formatting trick I'm going to use. Let's go ahead and print out a format string that prints out Z, and for the moment, let me just claim that this is going to do the exact same thing. It's just completely gratuitous that I'm using an F string now as opposed to just printing out Z, but I do 1 divided by 3, we're still seeing 0.333, but we're only seeing just over 10 or so digits here. What if we want to see like 50 digits and really start poking around at what's being represented? Well, the syntax is a little weird, but in Python using an F string, you can do tricks similar to what we did with the percent F with print F and C. And if after my variables name in this set of curly braces, I do a colon. And then a dot because I want to see numbers after the decimal point and say something arbitrary like show me 50 digits after the decimal point and treat this as a float. This is a crazy incantation I do think of a format string even I am sort of cheating off of the paper in front of me, but this is how you format strings if you want to see them with a little more precision or so I think if I rerun Python of calculator.ie and do 1 divided by 3, darn it, we're still in the same mess that we were before. Now why is this? Well, it's still. The case that I'm running the code on the same kinds of computers that I did before, it's still the case that these computers only have a finite amount of memory. And so even though I'm manipulating clearly floating point values, Python is only allocating, say, 64 bits to those float variables, and so there's only so much precision that's possible. And so what we're seeing is essentially the closest representation to an infinite number of 3s that we can represent using binary, using a floating point representation therein. So still a problem. But I do think in Python you'll find that there's so many more libraries out there, third party software that comes not just with the language itself but from others, whereby you can use libraries for more precise scientific computing that essentially implement their own versions of floating point values so that you can use not 64 but 128 or more bits than that when it really matters to some level of precision. Thankfully though, one problem is at least solved for us, namely integer overflow. So recall that this was another problem we ran into. Whereby if you try counting higher than say 4 billion or even higher than 2 billion if you're representing negative numbers, which haves the total range that you have available to you in the positive range, we ran into the situation where it somehow wrapped around, became negative, and then even ended up being zero as a result. Well, Python wonderfully nowadays just gives you more and more bits. As needed if your integers are getting larger and larger, so this is a wonderful feature and that we've at least addressed one fundamental limitation we ran into in C and this time the language itself provides us a solution. Python 2 has some pretty handy features as well. One of them is what are called exceptions, and so an exception in Python is. A way of handling error conditions without relying on return values alone. So recall that and see if you ever wanted to signify that something went wrong, you have to return like most recently like null, N U L L, which was a special sentinel value. Technically it's just the zero address and by checking for that you can make sure that you know if you're getting back a valid pointer or not. And in other functions, if something went wrong you might similarly have to check the return value, maybe checking for 0 or -1 or 1 or something like that, but return values were the only way in C that functions could communicate back to the programmer that something went wrong, and this is problematic because if you imagine implementing a function that's supposed to return maybe an integer, whether positive, negative, or zero. It's kind of unfortunate sometimes if you have to steal one of those values and say uh uh you can't use this value. It's fine in the world of pointers because the world decided years ago we're never going to use the actual address OX0, the zero address, but that's still technically costing us one or more bytes of space. But in general it's a bit annoying if your function can't truly return all possible values. Think about a function like get string. If something went wrong in get string, what do you want to return? Well, we saw in the CS 50. Library we do in fact return null once we introduce that. But in general, wouldn't it be nice if functions could somehow signal out of band, so to speak, that something went wrong. So by that I mean this. Let's go into a new program that's inspired by one of our programs today, and in VS code I'm going to go ahead and close my calculator, open my terminal window, and create a new program called Integer.i. So in integer.ie, let's just play around with some integers and see what we can break. So here I'll define a variable. And and set it equal to the input function which comes with Python, just asking the human for some input. Then I'm going to go ahead and ask a question. Is the user's input numeric? And it turns out if you read the documentation for strings in Python, they come with not just an upper function, a lower function, aka methods, but also it is numeric function or method that tells you whether or not the string itself happens to be numeric. That is, looks like a number. All right, so I think if I do that. I could then do something like this. If N is numeric, I'm gonna go ahead and claim that in fact it is an integer. Else if it's not numeric, I'm going to claim that it's not an integer. I have no idea what it is. Maybe it's cat, maybe it's dog, maybe it's a mix of numbers and letters, but it's definitely not an integer as defined by a sequence of decimal digits in this case. All right, so let's try this out. Python. Of integer.pi enter we'll type in 1. That's an integer. We'll type in 2. That's an integer. We'll type in 0. That's an integer type in cat, not an integer. So that seems to in fact work. But what if I wanted to immediately convert this to an end as we did in the past? And so let me modify this a. Bit here and say instead this N equals not just input sing the user for an integer or rather let's just ask them more generally for input, but let's assume that we want to convert this input to an end and actually we can go ahead and say integer here. All right, well, here I'm going to go ahead and just print out the claim that yep, this is an integer because if we get to line 2, well, clearly we've handled the user's input correctly. In other words, how can I get rid of constantly checking the return sorry, how can I get away from constantly checking the return values of functions to make sure it is what I expect? All right, well, let's go ahead and run Python of integer.ie now. Enter, type in 1. It tells me it's an integer. Type in 2, tells me it's an integer 0 tells me it's an integer. Type in cat. Notice this time what goes wrong. Whereas last time we saw this kind of trace back error message, it was a name error because I was using the meow function name too early. Now I'm getting a value error, which is a different type of error that relates to invalid literal for in with base 10A. Now that's a mouthful, so unfortunately Python's error messages aren't all that much better than. error messages, but clearly the interpreter does not like the fact that I'm passing something to in related to base 10, but that's quote unquote CA and really the best you can do with this kind of error is realize like, OK, it's clearly the case that cat is not an integer, so it's having trouble converting cat to an integer. It makes no logical sense. All right, so what's the gist of the problem? Well, I'm just blindly converting the user's input to an integer. Even if it's not input, even if it's not an integer. Well, all right, well, I could rewind to the previous version of my function, use the is numeric function, and then conditionally convert it, but I'm trying to move away from constantly checking return values of error messages. And wouldn't it be nice if I could somehow catch this value error and just deal with it if it happens? And in fact you can with Python exceptions which exist in other languages as well, Java among them. You have the ability to sort of listen for errors happening inside of functions without having to rely on return values alone. So let me go back to VS code here, clear my terminal just to simplify things a bit, and let me literally say to the interpreter, please try to execute the following two lines of code, except if something goes wrong like a value error, in which case go ahead and print out something like not integer. So wouldn't it be nice if you could just wrap all of the code you've written in CS 50 thus far with try and sort of ask the computer politely like please try to execute this code, but that really is the semantics behind it. Try to execute these lines of code except if there's an error, then do this other thing instead and therefore you don't have to check any return values. You can just blindly pass the output of the input function. As the input to the IT function knowing that if something goes wrong inside of there, Python is going to execute this code instead, except when something goes wrong. So let me go ahead and run Python of integer.ie now. I'll type in one, and that works because it's trying to execute line 2 and succeeding. It's trying to execute line 3 and succeeding, so lines 4 and 4 never actually kick in. But if I try again here with cat, line 2 is going to fail. Li 3 is never going to get reached because Python is immediately going to jump to this exception handler, so to speak, thereby catching the error or the exception and printing not integer instead. So it's a little bit of a weird convention. It's different from what C offers, but a lot of newer languages nowadays do offer this because it's a better way of just writing code that you know should work 99% of the time. But if something does go wrong out of memory, the human types something wrong in or something like that, you can handle all of those exceptional cases, exceptional in a bad sense, using this accept keyword instead. Questions on. Any of this here technique. Yeah. A really good question. In this case, I used a value error. Do I need to define every possible thing that can go wrong? Short answer yes. Now there aren't terribly many. There's some standard ones and they're all capitalized in this way, capital letter, capital letter, something error typically you can even invent your own, and it's good practice to enumerate the kinds of things that you think can go wrong. Value error is pretty. Generic, but there could be memory related errors. There could be file not found related errors. There's a bunch of different exceptions that are all documented in Python that you can listen for. That said, as nice as Python's documentation is overall, it is not good at documenting four specific functions, what exceptions they can throw, and I've never understood this after all of these years that no human has gone. The documentation and painstakingly enumerated all of the possible things that can go wrong. What's too often the case in the real world with some of my own code included is if you encounter an exception that you didn't think was going to happen, you go in and improve your code and add to this list of accept clauses. What else might go wrong? It shouldn't be that way, and different libraries are better about documenting these things. All right, well, with that in mind, let me propose that in the CS 50 library for Python, get in and get float, they work just like the C library, whereby if you type in cat or dog or bird into those functions, they just reprompt you. They just reprompt you. And long story short, this is the kind of code we wrote in Python. Try to get input from the user, except if something goes wrong, prompt them again, prompt them again. So we too are using precisely these features even though it wasn't something that was available to us in C. All right, but something else that we didn't see was play around with Mario in a few different forms. And in Lecture recall a few weeks back, we experimented with like using some Asky arts, some very simple text to print out something like this pyramid of height 3. Well, how can we go about printing something like this? Well, I would propose that if I go back to BS code here, let's close out my integer examples, code up a new version of Mario and Mario.ie. This one's kind of simple. I can say something like 4 I in range of 3, go ahead and print out, quote unquote a hash down in my terminal window. Python of Mario.3 and I've got really the closest analog to 3 bricks stacked on top of each other in this way. But in C and eventually our implementation of Mario started to get a little fancy, and we started to prompt the user for the height of the of the wall and therefore we could have not just 3 but maybe 4 or even more bricks being printed. So let me actually open up that version from a few weeks back whereby from week 1 we had a version of Mario. That looked like this whereby we after including some header files, declared in main a variable called N. Then we saw a new construct at the time, a do while loop that just keeps using get in, get in, get in, so long as n is not 1 or greater. Equivalently, so long as n is less than 1 and kept prompting the user again and again, the reason for having N up here recall was issues of scope. This therefore it's accessible lower in the function as opposed to it being confined to those curly braces. And then down here we used a 4 loop to actually print out that many hashes. So in short, the do while loop solve the problem in C, whereby you want to get user input at least once and maybe again and again and again if they don't cooperate the first time. And that's where do wild loops really shine. Do something at least once and maybe again, again and again. Otherwise it's a little more annoying to do it with wild loops or 4 loops. Unfortunately, Python does not offer a do while loop. And so here too we have an opportunity to introduce you to what the world would call Pythonic. What is Python's solution there too? Well, on the right hand side here in Mario.ie, let's change this a little bit and let's do from, uh, let's go ahead and do. Uh, while, whoops, while true, capital T, go ahead and use a variable N, set it equal to in input. Height asking the human for the height of the wall, and I'm going to just cross my fingers that they're not going to type in cat or dog or something that's not an in in this case. I'm going to say if N is greater than 0, that is a positive number that's useful, we can proceed. I'm going to now break out of this loop and then lower in the file I'm going to say for I in range of N, go ahead and print. Out the hashes. So we still have that same lesson as before like the Python version seems to be shorter, more concise, even if you ignore the comments on the left hand side, and I've completely avoided using a do while loop, but there are a few things that are different nonetheless that feel like versus C shouldn't even work. Like what's weird about this solution, even though I think it's actually correct. Yeah. I have 2. OK, so it's not correct. That's one of the first things to point out. So too many prepositions for this was supposed to say for I in range. OK, so now that this program is correct, what looks weird to you and probably could break it, yeah. Yeah, so the N variable should be, it seems to be scoped to the Y loop, at least insofar as it's indented inside the Y loop, which feels analogous to being inside of curly braces and C. And so it seems weird that I'm presuming to use N on line 6 even though it was only defined on line 2. It turns out this is possible in Python. The issue of scope that we encountered in C is not as rigorously enforced, we'll say for today, such that when you define N up here you can actually use it down here and you can think of this as being a little reasonable because if there's no more specific. of what data type N is and no more semicolon, just imagine it would look kind of stupid if you just put a blank end there and hit enter just so it kind of exists. There's no way to express the idea of create this variable in advance without actually assigning it a value, whereas in C we could do that. So this is in fact OK and correct. What else is going on here? Well, instead of a do while we're kind of just implementing the idea of it. I'm just blindly inducing deliberately in infinite loop like do the following forever. But then as soon as I have the answer I want, like a positive integer from the human, break out of this loop, and this is indeed the Pythonic way to say get user input because this will minimally ask the user for a height once and maybe more and more times. So no do while loops, only while loops and 4 loops, and only while loops are really the same as in C. Even 4 loops we've seen are a bit different. All right, well, how about instead of just that Mario example, recall this one where we wanted to print like 4 question marks in the sky side by side. We can do this in a few different ways. Let me go back to VS code, close the C version, and let's just completely change Mario.ie to implement this now. I want 4 question marks in the sky, so I think I can do something like 4 I in range of 4. Go ahead and just print out quote unquote question mark. Do you like this Python? Of Mario.ie, Should I run it? No. why? This is how I did it in C, yeah. Yeah, I've got to edit the end value, the named parameter for the print function, because otherwise if I hit enter they're all on different lines, which is not the effect I want when all four question marks are meant to be side by side. All right, well, that's an easy fix. I can pass the named parameter called and into the print function, set it equal to quote unquote with double quotes or with single quotes, as always stylistically I would be consistent. So I'm going to use double quotes even though the documentation is consistent with its single. Quotes. Now I'm going to rerun Mario of Python Mario.ie, and I'm so close now they're on the same line, but the stupid cursor didn't move to the next line. That's fine. How to fix this? Well, just logically, I can put a blank print statement below, and even though I'm not passing anything in, you get a new line for free when calling print. So even though I'm not passing in any arguments, I am getting the aesthetic effect that I want. So that is a perfectly reasonable way to do it. Now if you feel yourself becoming a bit of a geek though in learning about Python and previously see, you can even solve this problem even more pythonically by saying print, quote unquote question mark 4 using multiplications similar in spirit to the plus operator for concatenation and now multiply the exclamation point by itself 4 times. So now if I go down here and run Python of Mara. i, I got a very elegant solution to exactly that same problem even more concisely than my previous version. What if I want to do something in two dimensions? We'll recall that we moved to the underground of Mario Brothers here and we had like a 3 by 3 grid of bricks. How can we do that? Well, see, we had nested 4 loops using I and J back in the day. And I can do the same thing in Python. Let me go back into VS code here and let me do one outer loop for I in range of 3. Then let me do an inner loop for J in range of 3. Then let me go ahead and print out a hash, but let me learn from my past mistakes. I don't want to print out a new line every time, so let's override that default. But after each row, let's print a new line so that down here I can go and Mario.ie, run it, and I've got my 3 by 3. of bricks. I could change this a little bit and call this row and column, even though here too, even more so I'm not literally using row and column anywhere explicitly, but semantically it kind of explains maybe a little clearer to the reader what's actually going on. So that might help, but we can tighten this up too, right, if I just want to print a 3 by 3. Well, I know that the top thing here will iterate 3 times, and I know how to very elegantly print things out with a one liner, so I could just print out a hash times 3 in this case. And then down here I can go to Pythonomaiodai and voila, I'm back in business too. So it's just sort of easier to do these kinds of things and express yourself all the more succinctly. Well, what else can we do? Well, it turns out in Python. That unlike arrays, you can ask lists how long they are, so you don't have to keep around a variable of how large an array is. You can just add stuff to a list and then ask Python how long is this list, how many elements are in it. Case in point, let me go back to BS code and clear out Mario.ie and let's reimplement from a few weeks back the notion of calculating like in the average quiz score that you might have in a class. So in score.ie, Let's go ahead and create a program that's got a list called scores of three scores that we've seen before 72, 73, and 33 and recall that we tried a few weeks back and see to average these together. And to do that, we had to add them all together. We had to divide by the total number of elements in the list. It wasn't that hard. It was sort of like grade school arithmetic to calculate an average. But Python has more functions available to us, not just length, but even summation. So let me go ahead and do this. Let me say that my average variable shall be the sum of those scores divided by the length of those scores. And indeed per the documentation, Python has a lang function, LEN for short, a sum function. In which takes the which adds together all of the elements in that list. And so down here now I can say something like print with an F string or format string that the average is whatever that value is and I don't have to do any loops or math myself. I can just call the function like I could in Excel or Google Sheets or Apple Numbers, Python of score.ie. Enter and my average is in fact 59.3333 and then some weird imprecision at the end there. And in fact just for consistency with our C code, let me rename this. I'm going to rename score to scores plural. That's going to close the window, but now at least you'll see online that we have a program indeed called Scores. Well, this is not that interesting because I've just hard coded my 72, my 73, and 33. What if we want the human to be able to type that in? Well, I think we can do that too. So let me actually open up. That version of the file now pluralized. Let me go ahead and not initialize the list for the human, but let me set it equal to an empty list just using an open square bracket and closed square bracket like an array that has nothing in it, but this one is literally a size 0 at the moment. And now let me do 4 I in range of let's just for now ask the user for 3 scores, even though we could certainly ask the user how many scores do they want to input and then use that number instead. So in each of these iterations, let's ask the user for a score using something like in input score. I'm going to set aside the reality that if the user types in cat or dog, the whole thing's going to break and therefore I should really add my try and my accept, but I'm going to discard that error checking and focus only on the essence of this program for now. Now after line 3, if I have in a score variable, the user's quiz score, how do I put it into that array? Well, in in that list, well, with an array I had to use the square bracket notation, keep track of how big it is, and use like bracket I or something like that. No longer in Python because a A list is an object that has not only data but functions, aka methods associated with it. I can just call a method that comes with every Python list called a pan. And pass in that score using that same dot notation as before. The rest of my code can stay exactly the same. If I now run Python of scores.ie and I type in 72, 73, 33 manually though, I still get that same average and notice I did not need to decide in advance how big that list of scores was going to be. Questions on what we've just done with lists. No. All right, even cooler for some definition of cool is that we can now implement hash tables or more generically dictionaries, sets of key value pairs by just using a data type that comes with Python. I claimed last week that like Python, the dictionaries are sort of hash tables in particular are sort of the Swiss Army knives of data structures and that they just let you associate some piece of data with others with Python, you do not need to jump through the hoops that you needed to with problem set 5 implementing your own spell. in your own hash table, you just create a dict object in Python, a dictionary that gives you the ability to associate keys with values. So case in point, let's do this. Let me go back into VS code and close outscores.ie, and let's create a new and improved version of our phone book in phonebook.ie. Let's go ahead and come up with a list of names just to demonstrate how we could store a bunch of names in the phonebook irrespective of numbers and set those equal to say Kelly's name. And my name and John Harvard's name just by putting 4 quoted strings or stirrs inside of this list. Now let's ask the human using the input function for the name that they want to search for in this list, and now let's implement linear search using Python. I can do this in a bunch of ways, but one way. is to say for each name we'll call it N in names go ahead and ask the question if the name I'm looking for equals the current name in the list that I'm iterating over, go ahead and print out just something generic like found and then break out of this loop. And let's see if we can find Kelly or David or John or someone else. Python of phonebook.ie enter, searching for the name say David enter, and it was in fact found. Let me go ahead and search for someone else's name that's not in there, Brian. And now it's not in fact found, although it's not all that enlightening to just ignore the question altogether, it would be nice to say not found and here where is where and see it would be kind of non-obvious to do this and see if you wanted to print out found or if you get through the whole list and you still haven't found the user print not found, you'd have to like keep track with the variable of whether or not you found the person or you'd have to return from the code prematurely just to get out of it logically. Turns out somewhat weirdly but wonderfully usefully for loops in Python can have ETS clauses associated with them, whereby I can say down here print not found. If I run this version of the program and search for someone who's not in the phone book like Brian, now I actually see not found semantically it's a little weird, but essentially what's happening is if you get through this whole loop and you never call break. Then you've not actually broken out of the loop, so you're going to hit the ETS and in that case you're going to print out not found, and this is such a common thing to like do this kind of bookkeeping and keep track of whether or not something has happened inside of a for loop and if so, do this, Els do that. ELTS literally handles that scenario in Python, and this is the most unlike thing that we've perhaps seen in terms of features with regard to at least loops. All right, well this is great that I've kind of implemented linear search, but like we did that in C and it's getting a little tedious. Can't we do better? We actually can. Let me clear my terminal and tighten this up instead of iterating over every name in names just like we keep iterating over in. In ranges and checking for each name if it equals the thing we're looking at, you can actually do something much more clever. You can just literally ask Python if the name you're looking for is in the names list, then go ahead and print out. A found else print not found. And so this is where Python 2 gets kind of cool. In line 5 you have just a simple if condition with a Boolean expression name and names. How does Python know if name is in names? It uses linear search presumably to search over the whole list of names looking for what you care about and then tells you true or false if it found it. You don't have to write the code to iterate over it with a Y loop or for loop or whatnot. You. Just say what you mean. And so here too it's a little more English like if name in names question mark then print found much more so than it would be pronounceable in C. So that's one other cool feature that we now have at our disposal. What's yet another? Well, when it comes to dictionary objects in C, or rather in Python, a dict object really just gives you a set of key value pairs, and we've seen this kind of chart before whereby we might have name and number and name and. Number and name and number. How do we translate this to code? Because in C, as with problem set 5, it was going to be quite an undertaking to be able to store a whole bunch of things in memory in the form of something like a hash table. Well, in Python we can actually define a dictionary ourselves, so these square brackets represent a list, but I can alternatively use curly braces for a very new purpose. I'm going to go ahead and hit enter just to move the second curly brace to a new line. And I am going to now enumerate a bunch of key value pairs, namely, quote unquote Kelly for the first key, Colin, then we'll do plus 1, 617495, 1000 as the number. Then I'm going to go ahead and do quote unquote David for the second key, and since we both work here, I'm going to go ahead and just use that same number as we've done it before. Then a third key for John Harvard Colin and for John we'll use + 1949. 4,682,750, which is fun to call or text. This now, even though it's syntactically a little different, gives me the equivalent of this chart here key value pairs where the keys are the staff names and the values are the staff numbers that implements all of that, a hash table, if you will, in Python's own syntax. So how do I now use this? Turns out I can actually use it in exactly the same way. I'm going to go ahead and generalize this now to people because it contains not just names but names and numbers. So I'm going to change this variable down here to people too. But notice the syntax now. I can still ask the human for a name they want to look up. I can now still say if the name is in the people dictionary, and by definition Python's going to interpret that preposition in as meaning. Is the following key in the dictionary and if so, it's going to return true. But what's cool about this is that besides just making this work as follows Python a phonebook.ie and let's type in David and there's my number. Oh, that's not my number. It just says found. Let's run it again and type in say Brian, not found. OK, that's as expected, but I'd like to know what my number is or Kelly's number or John's number. Well, that's an easy fix too. Inside of this conditional, I can say something like this number equals people bracket name. And we've not seen this before, but we have seen square brackets in C, when we had arrays, this square bracket notation is how you indexed into an array to get a specific value 0123, 4th. What's amazing about dictionaries, not just in Python but in other languages as well, you can now index into a dictionary just as you can index into an array, but whereas in array you use numeric indices. In dictionaries you use string indices. You can use strings to look up their corresponding value. So to be clear, name at this point is given to us by the human's input. So if I typed in DAVID, name equals David. So this is like saying people square bracket, quote unquote David find David's number that stores the answer. From this two column chart in the variable called number and all that remains is for me to print it out, which I can do using an old F string now. Let me go down into my print statement, change this to an F string, add a colon, add the number variable to be interpolated, rerun this program as Pythonfhonebook.ie, type in my name, and there's my number as found. And this is incredibly powerful and why again. hash tables and in turn more generally dictionaries are sort of the Swiss Army knife being able just to look up data with such simple syntax is wonderfully useful and powerful. And in fact we can even do more than this, for instance, let me propose that if you think about other incarnations of key value pairs, you see them all the time, for instance, in like spreadsheets like here's a. screenshot of Google Sheets whereby I've got the beginnings of a spreadsheet with names and numbers. But in this model I want to actually associate some metadata with my data. So the data I care about is the actual names and numbers. But you could imagine having a third column like email address and maybe home address or any number of other pieces of data associated with these 3 people. For now I've Got two columns or two attributes, names and numbers. Each of the rows in a spreadsheet, as most anyone knows who's used a spreadsheet before, represents different records or different pieces of data like this is Kelly, this is David, this is John, and so forth. We can implement this idea using dictionaries and lists together. So the syntax is going to be a little strange at first, but let me go back to VS code here and let me change my people dictionary to be a people list. Between square brackets and the elements of this list now are going to be uh dictionaries themselves. I'm going to use some curly braces inside of these square brackets and say that the name of one person is quote unquote Kelly, and the number for that person is quote unquote plus 1617495 1000. Close quote. Then comma on the outside of the curly braces. Then I'm gonna have another quote unquote name Colin D A V I D comma, then another number, Colin. I'm gonna borrow the same phone number because we both work here. Then lastly, comma and finally, quote unquote name Colin quote unquote John. And then, lastly, a quote unquote number for John Coen + 1 9,494,682,750. Whew. All right, so what's going on here now? Our people variable is now not just a simple dictionary with just individual key value pairs name, number, name, number, name, number. We now have a more generalized way of storing not just a name or a number, but an email address or a home address or any number of other values. How will the commas just separate the key value pairs now. So if I do have email addresses for us, I can put comma, quote unquote email. Colin, like male at Harvard.edu and I can just keep adding these key value pairs to each of the dictionaries because the dictionary is a collection of key value pairs. So it stands to reason that I can associate name with David, number with the number, email with mail at harvard.edu, and so forth, effectively implementing this idea now in the computer's memory and at the risk of significantly oversimplifying, this is what Google and Microsoft and Apple are doing with their spreadsheet soft. Where they have written code that presents to you a nice table with a graphical user interface on the screen, but underneath the hood what they effectively have is lists of dictionaries representing each of those rows, and we're going to come back to this when we start experimenting before long with our own databases in the back rows of data from databases, we are going to store that data in lists of dictionaries for the same reason as well. So how can we use this? Well, let me hide my terminal for a second and tweak the program just a little bit. I'm still going to get the name of a person to look up their number. I'm still going to, uh, how about iterate over this because I've lost the ability, at least for now, to just ask a question like is this name in the structure because it's a list. I do now need to iterate a little bit differently, so I'm going to do for each person in the people list, go ahead and check is the current person's name. Equal to the name I'm looking for and if so, go ahead and create a variable called number set it equal to that person's number, and then go ahead and print out for instance found colon then in my curly braces that specific number and then after all that break out of this. So this is a mouthful, but. Recall that it's all the same syntax we've seen before in smaller parts. Square brackets and square brackets means here comes a list. What are the elements of this list?dict, dict, dict three dictionaries back to back to back, each of which has a key and a value and a key and a value called name and number respectively. The second one temporarily has name and number and email as keys plus. 3 values and the third one has keys of name and number as well with their corresponding values. So when I iterate over each person in the people list, that means on each iteration person is going to be set to this dictionary, then this dictionary, then this dictionary. On each iteration I'm asking this question Is that current person's name key? Uh, is, rather, is the value of that person's name key equal to the name I'm looking for, and if so, grab a variable called number, set it equal to the value of that person's number key, and then just print it out. And if we wanted to email instead, I tweak the word uh number to email. If I wanna look up anything else you can tweak that code there, but being able to index into dictionaries using strings is sort of the fundamentally powerful new technique that we have here. Question now on any of this, yeah. Good question. If you wanted both name and number on the screen, do you concatenate? Sure, you could do that or print them out by passing a comma into the print function and printing one out each way. Absolutely, however you want to format it. And actually, just as an aside too, even though this becomes a little less readable, this is a little silly that on line 11 I'm declaring a variable called number only to use it one line later and then never again. Technically with those curly braces and format strings, I could just take this code on the right, plug it into those curly braces, and get rid of this variable altogether. Just at some point though, F strings start to get a little too hard to read with quotes inside of quotes, and so like I kind of prefer being a little more pedantic about it and explicitly putting it in a variable and then interpolating just that variable, but you could do it in different ways still. All right, a couple of final features of Python that will get us on our way with doing other things. Turns out there's a whole bunch of libraries that come with the language itself that you nonetheless have to import, even though they're not third party. You don't have to install them. You just need to add them to your code by importing them. One of them is SIS, and among the things that the SIS library has in Python is the ability to give you access to command line arguments. After all, we've lost access to command line arguments because there's no more main, at least by. There's no in main void. There's no in Main RVRC stuff going on in our code, but all of that functionality is still available in a library called SIS. So how do we use this? Well, let me go back to VS code here now. Let me create a relatively simple program called greet.ie, similar to a few weeks back, that's just going to greet the user using command line arguments instead of get string or the input function. I'm going to do this by saying from the SIS library import RV. In this case, RV is essentially just the list. It is a list of the command line arguments that the human has typed. It's a list, which means you can just ask the length function LEN what its length is. So there's no need for RGC anymore. You can just literally ask RV how long it is, which is kind of nice. So I'm going to say this if the length of RGV. Uh, equals equals 2, which means the human type two words at the prompt. OK, let's go ahead and greet them, assuming that's their name and say hello, comma, and then whatever their name is. Let me make this a format string and to be pedantic, let me create a variable called name and set it equal to RV1. Which is going to be the second word that the human typed in, as has been our convention in the past, else if they didn't type exactly two command line arguments, let's just go ahead and print out something like hello world as generic. Let me run Pythonogreet.ie, E, and you see hello world, because I apparently did not type in exactly two words, and yet I did. So let's see where this is going. Let me rerun Pythonogreet.ie but type in my name David at the command line. Enter. And huh, I screwed up unintentionally. What did I do wrong? All right, print F is not a thing. So that's an easy fix. Let's delete it. Let me clear my terminal window, rerun Python of greetie David, enter, and now I get hello David. The only thing that's weird here is that I typed in 3 words at the prompt, and yet I'm checking for 2. And it's a bit subtle, but with Python and RV, it ignores the Python interpreter. It goes without saying that you're using the Python interpreter to run a Python program. So the only things that are being counted are the words after the Python interpreter itself. So when I type greet.ie and David, that's 2, when I only typed greet.ie, that's 1. Instead All right, so now that I've done that, I have access to my command line arguments again. What about my exit statuses? This was getting a little low level, but in recent C programs we've had you all returning 0 on success, returning 1 on error. Can we still do that? Well, yes, and in fact, the SIS library is used for that as well. So if I want to actually add some exit statuses to a program to facilitate Check 50 and automated tests in the real world, I can do that with a program called, let's call this exit.ie. And in exit up I, I'm similarly going to import uh CIS, but in a different way, I'm gonna give myself access to. Well, yes, let's go ahead and import the whole library just to demonstrate how you can access things inside of it without explicitly saying from SIS, import such and such. as before, if uh the length of sys.orgv. So this is a little bit different, but I'm asking the same kind of question, does not equal to. I want to go ahead and print out to the user missing command line argument, which is something we did a while back as well. And then I want to exit with code 1 CIs.exit 1. El if I don't run into that issue, I'm going to go ahead, actually, let's not even bother with the NELTS. Let's for parity with our C version, let's do this print Fo hello. Uh, sis.RV1 close quotes.exit. All right, that's a whole mouthful, but what's really going on? So I could have done from sys import RV, but I don't need to enumerate every single variable or every single function that I want from a library. I can also just more generally say import the whole library. Give me access to everything, and then I'll tell you what I want from it later. Therefore, on line 3, I can still access RV. I just have to scope it to the SIS library so that I say sI.RV means go inside of that library and find me RGV instead of elevating it to a variable unto itself in my own code. Why am I saying not equal to 2? Well, if they don't give me two words after the interpreter's name, I want to yell at them and say missing command line argument and then exit 1. I'm not going to give them a default hello world anymore. I want them to give me their name. Meanwhile, if I get this far and I haven't exited from the program, I can print out sI.RV1, which is going to be David in the example I typed before, and this means success, so sys.exit 0 signifies success. It's more syntax than before than it was in C, but we have the exact same functionality available to us as we have in the past. How about one other example that we've had in the past? Let's convert it to Python as well. So you have a few more tools in your toolkit. How about implementing a version of this phone book that actually persists? So instead of hard coding into it, Kelly and David and John in this way, let's actually let the user type in a name and a number just like on your iPhone or Android phone and add it to a text file, like a CSV file as we did before using comma separated values. Well, it turns out that Python comes with a library to handle CSV files. We don't need. Hackishly implement our own CSV support by printing the commas ourselves. Instead, we can import the CSV library. We can then create, say, a variable called file, set it equal to open and open a file called phonebook.csv in a pend mode. So this is almost the same as C, except it's open instead of F open, which we saw a couple of weeks back. Now let's ask the user via the input function for the name they want to add to their contacts and the number that they want to add to their contacts, and then And so after that, let's go ahead and do this, which is a bit of muscle memory to remember, but I'm going to create a variable called writer, but I could call it anything I want. Set it equal to csv.writer, which means there's a function called writer in the CSV library that I'm simply accessing it because I didn't import it explicitly by name, and I'm going to pass it that file. This tells Python, turn that file into a CSV that can be written to. The next line of code I'm going to literally say writer. write row. Write row is a method, aka function associated with this writer object, and I know that only because I did actually read the documentation for the CSV library. What do I want to write? Well, I want to write out a list of values, namely a name. And a number and I'm using square brackets to tell the right row function that here you go, here's a list of values, 2 of them a name and a number. After all that, I'm going to do file.close and just close the whole file. All right, so where does this actually get me? Well, let me go ahead and open up phonebook. CSV, which is initially empty. I'll move this over to the right hand side. But when I now run this program with Python of phonebook.ie, I'll type in say Kelly's name, E + 16,174,951,000 enter and voila, it ends up in the CSV using a little bit less code than we had to last time with C. Let's run it once more and I'll type in my name and I'll again use +1 617495 1000 enter. It's being appended to that file as well. And one last time for John + 19494. 682,750 enter voila. So it's pretty easy that is to say in Python to start creating files like this, but this isn't really Pythonic. Let me in fact close the CSV file, hide my terminal, and propose that we can tighten up this code a bit too. I don't need to open up the file way up here. I can go ahead and get my variables values this way first. And in fact, I could have done that code a little later anyway. But I can do this in Python. I can say with the following file opened phonebook. CSV in a pended mode and refer to it as a variable called file, do this stuff and close the file yourself. So this program's suddenly significantly shorter because this one line has the effect of opening the file for me in a pen mode, assign it to a variable, do this stuff, and. As soon as the program's indentation ends and there's code over here or no code whatsoever, the file gets closed for me automatically. This just helps us avoid like memory leaks and like stupid mistakes we've made in C because you forget to close a file that you have to open and you don't necessarily notice unless you run Valgrind or something on it. Python tries to avoid this by giving you a new keyword with that doesn't really make sense semantically except with the following file open and it will close the file for you. So that's 2 among the features that you sort of get. With Python, the catch though is that the CSV is fairly simplistic. In particular, it's missing a header row that actually indicates what is in each of the columns. In fact, if I go ahead and run code of phonebook. CSV, we'll see again that the file contains just one row for Kelly, for me, and for John, whereas ideally it would look a little something more like this Google Sheet version, which actually has at the very first row something saying name and number, which then describes the data therein, after which are the three actual rows. Now the simplest. here frankly would probably be to just start with name number at the top of the file and then assume that my phonebook.ie program is just going to append, append, append additional rows to the file containing the names and numbers respectively. I could have done that from the get-go, and in fact that would be better than putting some code inside of phonebook.ie that writes out that specific row because after all, if I'm running this program again and again, I don't want the header row to appear again and again and And unless I complicate the program a little bit to ensure that I only do that once. But assuming that I do go into phonebook.csv and from the get-go do have a file that contains name and number, we can actually start to improve upon the implementation of Phonebook.ie because we can take advantage of the fact that my dictionary can actually that my writer can actually read that same header. In fact, let me put these files side by side here and then in phonebook.ie, let's go ahead and transition away. From using a writer to using a so-called dictionary writer or dict writer for short, capital D W and then let me go ahead and specify one additional argument to this particular function, namely field names, which I know exists because I looked it up in the documentation, and the value of this argument is supposed to be a list of the fields that are presumed to exist in the CSV that we're about to write to. So I'm going to do quote unquote name, unquote number. The lines a bit long, so it's scrolling there, but if I scroll back to the left. We see that the line is otherwise unchanged, but when I go down now to right each respective row, notice that I don't have to rely on this list, which just assumes somewhat naively that name will always be in the first column or column 0 and number will always be in the second or column 1. After all, if someone were to move that data around, at least in the spreadsheet using Excel or Google Sheets or something else, my code would end up being fairly fragile because at the moment it's just assuming blindly that name goes first, followed by. Number, but once we have that header row in there and tell dict writer about it, we can actually now pass in not a list but an actual dictionary of key value pairs and let the dictionary writer figure out where in the file which column those values should go in. So inside of this dictionary, I'm going to have one key called name, the value of which is indeed the name the user typed in. The second key of which is going to be quote unquote number, the value of which is the number that the user typed in. And let me go back actually now and fix a typo from earlier. We're only asking the user for. Number. So all this time I should have just requested one number aesthetically with my input function there. Now notice I have the file ready to go. Indeed, name and number are there. That matches the field names I've provided to my code and it matches the key value pairs that I'm subsequently passing to right row. So let's go ahead and give this a try. Let me go ahead and run again with this otherwise empty CSV file, say for the header phonebook.ie with Python of phonebook.ie. Enter. I'm gonna now go ahead and type in, say the first name, which was Kelly before, plus 1617495 1000 and watch what happens at top right. Kelly and her number end up in the file, even though I didn't actually specify explicitly as with the list or numeric indices which value goes where. Let's run it once more and put in myself again plus 1617495 1000. Enter and there again I am. And lastly, just for good measure, let's go ahead and put John back in the file with. Plus 1949468-2750, which if you still haven't called or texted, do feel free. Enter and voila in phonebook. CSV we have all of those same rows and code that's a little more resilient now against any changes we might subsequently make there too. All right, how about now some final flourishes using some other features of Python that we did see a glimpse of some time ago, namely the ability to install libraries of our own choice. So up until now in CS50.dv, we CS 50. have pre-installed most of what you need, including back in the earliest weeks of the class when we had that Calay program that I wrote that was using a third party library that I had installed into my codespace in advance. Well, you can use a program called PIP to install Python packages into your own code space and if you're using your own Mac and PC onto your own Macs and PCs as well, if those libraries are freely available as open source online and in the repository from which the Python. Uh, PI program actually draws. Let me go back to VS code and let me go ahead and create a new program called Cow.i. And with this program, I'm going to go ahead and import that library CalSay, and after that I'm going to call coa.cal quote unquote, say this is CS 50 to have a cute little cow on the screen, say exactly that. Now in a previous lecture I had pre-installed this library, but suppose I had forgotten to do so today. Let's see what other type of error we'll see on the screen. Well, let me go ahead and run Python of cow.ie. Enter and there's another one of those trace backs. This one's a little more straightforward than the name error and the value error we saw in the past. This is a literally module not found error, no module named CalSay. Well, this is where the PI command comes in. If something hasn't been preinstalled for you in CS50.dev or in the real world on whatever system you're using, you can use PI install CalSay, and assuming you've spelled it correctly and assuming the library is publicly available, hitting E will result in Pip automatically download. In the latest version installing it in this case into your code space, and solving hopefully that problem. Let me clear my terminal window. Run Python of cow.ie again, definitely cross my fingers, and there's the most adorable cow, and if we full screen the terminal, we'll see that he's indeed saying this is CS 50. Now that's just one of the things we can install with Coway. I could also install libraries onto my own Mac and PC. In fact, in just a moment I'm going to switch over to another computer here where I have a terminal window open on my. My own actual Mac and I'm doing this because I'd like to play around with some speech, some text to speech library functionality which you can't really do in CS50.dev because it's browser based and when you run code in the cloud, it's not going to pass the audio along to your speakers on your laptop or desktop. But if I'm running Python and my own code on my own computer, a Mac in this case or a PC in someone else's case, I can install that kind of library, speech to text, and have my own code on my own computer use my own. Speakers to verbalize some string quite like that. So how can I go about doing this? Well, I read some documentation, I'm going to go ahead and install with PI a library called Pi to Text to Speech version 3. Hitting Enter goes and spines and downloads as needed the library if it's not already installed and then brings me back to my terminal. And I'm going to use an older school program here called Vim or VI to actually implement a Cal program on this computer whereby I'm going to go. Head and write some code using this library without VS code but with just another text editor instead. To do this at the very top of my file, I'm going to import this library called Python Text to Speech, so PY TT SX3 for version 3, and then I'm going to use only 3 lines of code to synthesize some voice. I'm going to say a variable called engine, set it equal to pittsX3. in it because the documentation taught me that I need to initialize the library the first time I use it. I can then use this variable called engine to actually say something quite like scratch, albeit verbally instead of pictorally, like this is CS 50, quote unquote, and then lastly I can use engine.ru and wait similar to some scratch blocks so that the whole Expression is actually verbalized before my program actually quits. Now, the first time I run this, it might take a moment for the library indeed to initialize itself, but on my own Mac here I'm going to run Pythono cow.ie. If we could raise the volume just a little bit, hopefully we'll not see but hear this cow's greeting. This is CS 50. It was very much in a rush to say it, but after initializing for that long, and if we ran it again and again and added some optimizations, we could get it talking much more quickly than that. But we now have a version of the program that indeed verbalizes what string or stir it is that I've passed into it here CS 5. It's really in a rush to finish there. All right, let's try one final flourish of another library that's fun to play around with, if only because it'll motivate some of the things you can now do in Python yourself. Let me go into VS code in my code space because this one does not require my speakers. I'll close that first version of the cow, and I'm going to go ahead and create a QR code generator after installing with PI a library called QR code, which I read about online, and now it's Installed in my code space. I'm going to now go ahead and create a file called qr.ie. So let's go ahead and code up QR.ie, and I want to generate my own QR codes. Most of you in the are in the habit. If you've ever generated a QR code before, you probably just Google around for some generator online for which someone else wrote code to generate the QR code, but I can do that for myself and actually generate my own images. I'm going to go ahead and import the library that I just installed, import QR code. And then below that I'm going to create a variable called, for instance, image and set that equal to this library's QR code.make function, no relation to the make that we use for C, and I'm going to make a QR code containing a URL, maybe of one of the lecture videos. So let's do HTTPS call in slash Youtube.com, the short version, and then XVFZJO5PG. Uh, GG 0 if I got that just right. Then after that I'm going to go ahead and call image.save to save that URL as a file called qr.png quote unquote, and then PNG will be the format which is portable network graphic, which is akin to a JPEG or a GIF but with different features. I'm just going to double check my writing here so we go to the right lecture video and I think we are indeed good. And what that should do after running my code is leave me with today's final flur. a ping file in my code space that when opened is going to be QR code that you can scan with your phone. So if you'd like to get ready for this final flourish, I'm going to go ahead and run Pythonoqr.ie and hit enter. Thankfully it worked. I'm going to now open up QR.png and close my terminal window and for our final moments together this year in week 6, after which we'll ultimately transition to yet more languages and problems to be solved. Here is a final code for you to scan. Of today's here lecture. All right, that's it for today. We'll see you next time.