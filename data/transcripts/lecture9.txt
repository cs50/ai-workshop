All right, this is CS 50. This is already week 9, and I dare say this week is the most representative of what you'll be doing after the class if you so choose to program in the future and tackle some project that's new to you. In fact, the closest to this week was perhaps week 6, wherein we didn't really introduce all that many new concepts but really translated them from C into Python. And so this week, in particular, the goal is to really synthesize the past 10 weeks of class, drawing upon a lot of the building blocks that are. Hopefully now, metaphorically in your toolbox and gives you an opportunity now to apply those ideas to new problems, in particular web programming. So every day you and I are using the web in some form, every day you and I are using mobile apps in some form, and we said last week that the languages underlying a lot of those applications are HTML and JavaScript for the layout and aesthetics, and then also in part JavaScript for a lot of the client side interactivity that you might experience nowadays. Well today we come full circle and bring back a server. Side component whereby we'll again write some Python, we'll again write some SQL code and use it to make our full fledged own web applications and in turn if you so choose mobile applications as for your final project as well. So up until now when we did anything with the web, you ran this command last week, HTTP server, which literally did just that. It spawned a so-called HTTP server that is a web server whose purpose in life is just to serve up content from like your current folder, any files they're in, any folders therein. And so all of the U. URLs generally followed a certain format. So if your URL were example.com recall just denotes the root of the web server. And so in there typically by default you would see a directory index. We'll see today that that goes away because generally when you visit something.com/, you want to see the actual website, not the contents of everything in the server. So we'll see how to address that. But the URLs up until now have been a form like file. HTML, literally referencing a file in that folder or. folder slash, which just means whatever is inside of that folder or folder file. HTML or you can nest these things however long that you want and recall that more generally we said that you're referring to some kind of path on the server where path is a step of folders ending in perhaps a file name. So today we're going to generalize that at least in terms of nomenclature and start talking more about routes because essentially in web programming we are going to exercise a lot more control over what is in the URL. So back in the day. It referred to literally a file on the server, and as recently as last week, the URLs referred to literally a file on the server. However, we'll see in code that we can actually just parse this, that is analyze what is after the domain name in a URL and just use this as generic input to the server to figure out what kind of output to produce. We're going to see the same convention though if you want to pass in specific parameters, key value pairers, we'll use a question mark after our so-called route, key equals. And then if there's another one or more, we'll just separate them by ampersands. And to do all of this we're going to recall the inside of those virtual envelopes recall that if we did something like on Google.com to search for cats, what was really being sent to the server was a request for slash search, which notice is not search. HTML. There's no folder per se there. This is just the name of a program really running on Google servers, and that's going to be the so-called route that we ourselves start programming today. Question mark. cats just meant that the query parameter, the input from the web form, is going to contain in this particular example the word cats. So how are we going to do I'll do this? So we could implement our own web server in C. It would be a nightmare to like use a language as low level as C and actually deal with something as high level as writing code for the web. We're instead going to use Python for the most part, if only because it's much higher level, but even then we would probably, if we wanted to do this thing from scratch, we would have to write a A lot of Python code to like analyze the insides of these envelopes, figure out what inputs are being passed to the server, and then figure out how to access that in Python code. It's just a lot of work to just get a web application up and working. And so what the world generally does is they don't reinvent the wheel of writing their own web server. rather they use an off the shelf fairly generic web server or application server as it might be called, and we, for instance, are going to use something called Flask. Now Flask is a framework as the world would say, or More specifically, a micro framework, which just means it's a library of code that other people wrote to make it easier for us to implement web applications. So they took the time to figure out how to handle get requests on a server, post requests on a server, figure out how to extract key value pairs from URLs, the sort of commodity stuff that like literally every web application on the internet has to do anyway, so we don't have to retrace those steps ourselves. What this will allow us to do is only implement the problems that we care about by using. This framework and to be clear, a framework much like bootstrap is not only a library that someone else has written for you, but it's like a set of conventions that you follow in order to use the library in their recommended way. So it's more of a generic term that includes library and a set of conventions. And how do you know how to use either? You just read the documentation or take a class in which we're about to give you an introduction to some of this right here. So instead of running today HTTP server to start a web server that just serves up static content. Files and folders in our account. We're instead going to run the command moving forward flask space, run, and this is going to look for code that we've written in our current directory. And if it is in accordance with the conventions to which I'm alluding by using this so-called framework, then it's going to start our web application on some TCP port, for instance, 8080, as we discussed last week. To do this, all we have to have in our current folder is minimally a file called app.ie by default. This is hinting at an. Application written in the language called Python and what code we put in there we'll soon see. And then ideally we would have another text file called requirements.text by convention inside of which is just one per line, the name of all of the libraries that we want this web application to include. In other words, if I go over here to VS code, if I don't have such a file, that's fine, but I want to use a framework like Flask, recall our PIP command for installing Python packages. I could just say PI, install, flask, E. And that would go ahead and install the flask framework or library for me just like we did a few weeks ago with installing the silly little cow say library as well. I've already done that in advance and better still, I've installed, I've come with uh my code today, both of these files AAinerequirements.text. And in fact, if I go ahead and create one just for fun here, all you need to do in a requirements.text file is literally put the name of the library that you want to include, and then you run PIP in a slightly different. Way to install that library or any other libraries that are in that file as well. So let me wave my hands at the requirements.text for moving forward. It just means what libraries do you want to use with this web application so you don't have to remember or memorize them and type them all out manually. All right, so what's going to go inside of app.ie? Well, the minimal amount of code that we can write to make our own web application that does something like print out Hello world to my browser could look like this. Now there's a bit of new syntax here, but All that much today moving forward, the very first line just says from Flask import flask, which is a weird way of just saying give me access to the flask library. Capitalization no matters, and so the package that we're using is called Flask lowercase, but we want to have access to a special function in there called Flask F. So this is sort of a copy paste line. The next one's a little weird looking, but it essentially says Give me a variable called app and turn this file into a flask application. We haven't seen. In a few weeks, but there was that weird if conditional that we put at the bottom of some of our Python code a few weeks back that just said if and it mentioned in there name if name equals equals_ma_co. So we've seen an illusion to name for our purposes. Name just refers to whatever the name of this file here is, no matter what I call it, you can sort of access the current file by way of this special global variable. So this line collectively just means turn this file. into a flask application and store the result in a variable called app so I can now do stuff with flask. And what am I going to do? Well, down here, let me first point out a familiar syntax. I'm defining a function that I called index by convention, but I could have called it anything I want, whose sole purpose in life is just to return quote unquote hello world, which is the super simple output this web app is going to display. But, and this is the new syntax I'm using here what's generally called a Python decorator. Which is a type of function that essentially affects the behavior of the function right after it. So by saying at app. routes, this is telling the flask framework, associate this index function with this route, the single forward slash, and that's how we're going to take over the default behavior of the slash portion of the URL by telling it to return whatever this function returns, and we'll see this in action. Now, so let me go over here, say to VS code, and within VS code, I'm going to whip up exactly that application in a file called app.ie just so as to combine this and some subsequent examples maybe the same folder. I'm going to first create a directory or folder called hello. I'm going to go into that hello folder. I'm going to go ahead and recreate that same requirements file just for good measure to Tell the world that I want to use the flask library here and then I'm additionally gonna create now A.ie, and I'll type this fairly quickly, but I'm just reciting what we saw a moment ago from the flask package, import the flask function, lowercase F F respectively, then give me a variable called app, set it equal to that function call passing in the name of this file, whatever it actually is. And then lastly, let's go ahead and call at. App. route la which says hey Python, whatever the next function is associate it with this slash route and so I'm going to define that function. I can call it anything I want oo or bar or baz but insofar as slash represents the index of the website like the default page, I'm just gonna go ahead and call it by convention index and then return for now hello world. And that's it. So whereas last week when I was writing code in HTML files I was making web pages. Now I've created what we'll call a web application, and it's an application in the sense that there's actually some logic going on there. There's some functions, there could be some conditionals, there's clearly a variable. There could be loops and all of the sort of stuff we've seen in Scratch andC and Python as well, we'll now see back in this Python. File. So how do we now run this? Well, let me go back into my terminal window here and I'll clear it just for good measure. I'm going to go ahead and run flask, run, enter. I'm going to see some cryptic looking output, but there's that familiar pop up with the green button that wants to open up this application, whereas HTTP Server uses 8080 by default. Flask uses Port 5000 by default, and here we have it. I've just opened up my Second tab and we spent a lot of time there last week. This is the server I'm running, not on Port 8080, but on Port 5000 today, and there is the contents of what was spit out by my very first application. Now even though the browser is rendering this like it is a webpage, notice this if I inspect, if I right click or control click anywhere on the screen and go to View page source, you'll see. There's no actual HTML on this page. It's literally a single line of text, Hello, world. If I close that and right click or control click again and go to inspect like we did last week to open up developer tools, you'll see that the browser has actually filled in some blanks here for me by just rendering as it should the minimal possible web page, but the content I actually sent to the web browser is only literally hello world. So how can I actually send a web page of my own rather than letting the browser do something like this? Well, I could go ahead and. Close that and go back to my application. I'm gonna go ahead now and hide the terminal just because the server is still running, and what I'm gonna go ahead and do here is, well, nothing's really stopping me from returning not just a string of texts, but a string of HTML, and this might not look pretty, but let me go ahead and do open bracket doc type, HTML close bracket, then HTML, then head, then title, and I'll just title this for instance hello to keep it simple. backslash title, backslash head open bracket bod. hello world backslash backslash HTML close quotes and I used single quotes in this case, but I could have just as easily used double quotes, but that's a full fledged web page. Like that's the minimal amount of content we saw last week. Actually, you know what, for good measure, let's actually add lang equals. So it's actually fortuitous that you use single quotes because now I have some double quotes inside. And even though this is not pretty printed, it's just one massive mouthful of HTML all along one line. When I now go back to the browser, reload the page. As by clicking here and then view page source again, here's what my browser received this time. Indeed it's the full fledged HTML and in fact if I close that tab and reopen developer tools by inspect, now we'll see in the tab absolutely everything that I sent over, including a title, including the lang equals the N, and had I typed even more, we would have seen that too. All right, so what was the point of this exercise? It feels as though that I've really just taken more time, added more complexity to achieve literally what I could have done last week by just creating Index. HTML myself without any Python code. But I dare say what we're trying to do is lay the foundation for a full-fledged interactive website that maybe has forms that we can submit to the application that allows us to generate not just one page, but maybe 2 or 3 or any number. So what you're seeing here is sort of the beginning. Of Google.com's search application or gmail.com itself or Facebook.com or any web application you can think of begins with a little code that theoretically looks a little something like this. But this is kind of stupid to put HTML hard coded no less in one long string here inside of my application. Let's try to factor this out. That was a lesson we preached last week about sort of factoring out our JavaScript, factoring out our CSS. We can do the same thing with our actual. HTML here and so what I'm actually going to do is import not only the flask function but also another function that per its documentation comes with Flask called render template with an underscore in between. This is a function whose purpose in life is to render a template, so to speak, of HTML. We'll see what we mean by template in just a bit. But down here what I'm going to do is now delete all of that code and let me just assume that I'm going to put that same code in a file called index. HTML just. I did last week. So let's instead return the return value of render template of quote unquote index.html. Now that file does not yet exist. Indeed, if I go into my terminal window, create a second terminal just so I can leave the server running but still see what's going on, I'm going to CD into that same Hello directory type LS to list my files, and I only see app.ie requirements.text. But it turns out per flask's documentation. If you want to create your own HTML files, you simply have to add a directory that by convention is called templates, and that's it. So in addition to app.pi requirements.text, I need a folder called Templates. So let's go back into VS code, maker templates capitalization matters, all lowercase. Now let me go ahead and CD into templates and run the code command and create a file called index.html in the templates folder and then super. Quickly, let me hide this. Let me whip up that same page again. Doc type HTML, HTML lang equals EN close bracket head close bracket, title close bracket, hello, and then down here body close bracket, hello, comma world. So autocomplete is helping me type quickly, but now I have a file with my HTML that this application I claim is going to spit out automatically for me. So let's see the effect. Let me go back into my other browser tab. Let me close the developer tools and let me quite simply just click reload. And no apparent change. It's working exactly as it did before, but I've laid the foundation for making a much more useful layout of my files so that I can actually keep my logic, my Python code, and my HTML a bit separate from that. All right, well, how can we make this into something even more interesting? Well, let's start to take some actual user input, for instance. So wouldn't it be nice if I could pass in via the URL something like Q equals cats, but maybe something like name equals David or name equals Kelly and actually see the name that's being outputted. In other words, let me zoom in up here and let me pretend like this happened automatically. Let me do question mark, uh, name equals David E. Well, it would be nice if I saw hello David. I'll I'll propose rather than just hello comma world. So how do I actually get access to everything after the question? Well, here is where a framework like Flask and any number of alternatives starts to shine. It gives me that answer for automatically. And so it turns out in Flask, once you've used it, you have access to a special global variable, as we'll call it called request.orgs, where args just means the arguments or the parameters that were passed in to this HTTP request. So how do we use this? Well, let me go back to VS code here. And at the very top line, in addition to importing Flask F render template, let's also import request, which is a global variable that comes with the flask framework, and then I'm gonna use it as follows. I'm gonna go ahead and say um. A second argument to the render template function where I'm going to say placeholder equals request actually let me not do that yet. Let me first create a variable name equals request.args and then let me go ahead and get the name key from the arguments. And then down here, let's go ahead and pass in placeholder equals name. So what am I doing here on line 8? I'm creating a variable called name. I'm storing in that the value that's in the request global variable in what's apparently a dictionary called AGs, specifically the name key therein. So if the thing after the question mark name equals is David, this should give me David. If it's Kelly, it should give me Kelly instead. Then what I'm doing is rendering this template called index. HTML, but I'm additionally passing in some named parameters. We talked. Briefly about that in week 6 when we introduced the idea that Python can take not only a comma separated list of arguments but some of which can have names. So I'm proposing that one such name of an argument to this render template function can be placeholder, for instance. Now at the moment this code isn't going to do anything useful if I go back indeed to the other tab, click reload after zooming in, even with my name in the URL, you'll see that we still see hello David. But here's where things now get interesting and here too is what we mean by template. If I go back into VS code, open up index. HTML again, and instead of putting the word world there, what I'd like to see is not hello world, but hello placeholder, but of course if I literally type that I'm gonna see literally placeholder unless I surround placeholder with pairs of curly braces like this. By using these pairs of curly braces, I'm telling Flask that I want to interpolate, so to speak, that variable. I want to substitute in its value. So this is yet another syntax in Python. We saw F strings. In C we saw percent S when using something like print F. In an HTML file when using flask specifically, we use these pair of curly braces to denote this is indeed a placeholder whose value should be plugged in. So now let's go back over to the second tab, recall if I zoom in that passed in already to this URL is question mark name equals David, and this time when I click reload, voila, now I see my actual name. And unlike the JavaScript examples last week which were doing everything client side, notice here if I. Go to right click or control click and view page source. What's noteworthy today is that David in this case literally came from the server. This was not rendered client side. The server sent this HTML and specifically this text. So if I go back to the same tab here, zoom in. And change David for instance to Kelly. What I should see instead when I hit enter is hello Kelly, and indeed if I go back to the source code and reload the page there, I should see in the view page source that the server sent indeed hello Kelly. So it's in this sense that it's an application. The URL is providing input to the application by way of this URL format, the so called get the get string that's being passed in. And if I look at the. that I'm running app.ie is the code that's running. It is grabbing that name from the URL. I am then passing it into my index.html file, and then my HTML file is plugging the actual value in for me. And so what's going on with, for instance, these curly braces? Well, here too is where we're actually using a library and included in Flask is another library called Jinja and Gina is what's called a templating library, and there's so many templating libraries in the world. G Jinja is actually fairly simple, which is nice, and which is why Flask uses it. And for now you can just think of Gina as being the library that knows how to interpolate variables inside of pairs of curl. braces. So why are we introducing it another frame, another library? Well, the folks who implemented Flask decided that it was not worth their time reinventing the wheel of a templating language, a language via which you can figure out what values to plug in where. So they just lean on another library that someone else wrote years prior so as to not reinvent that wheel themselves, and that's all that's going on with the framework in this case. It's using perhaps multiple libraries instead. All right, so what then is a template? So this then is a template. What you're looking at here, hellocom placeholder is a template in the sense that it's kind of the blueprint for the web page I want the user to see, but it's going to be dynamically generated using indeed this blueprint by plugging in the value. Placeholder inside of those pairs of curly braces. And so that's why index. HTML starting today is in a folder called Templates because this is not just static HTML like the stuff we wrote last week. This is the the blueprint for the actual HTML that we want the browser to spit out. But there's a bug here. Notice what's going to happen here. If I go up to this URL and I get rid of the name altogether. For instance, I just visit the slash route without any key value pairs and hit enter. This is sort of bad, bad request. It's an HTTP 400. In fact, if you look at the tab, here's another HTTP status code that we probably haven't seen before, but 400 just means the user did something wrong by not passing in. The parameter that was expected. Well, that's a little bad design if like the user has to manually type in things to the URLs. Like no human actually does that. That's not good for business or customers in general. So I can go back into app.ie and just make a little bit of conditional code here, and here's to where we see what makes this an application and not just a static page. Instead of just blindly getting the name here, I could instead do something like this. Well, if the name parameter is in request.orgs, and this is just Python syntax for asking if this key is in this dictionary, then I'm going to go ahead and define name and set it equal to request.org's quote unquote name. Else if there is no name in the request, well then I might as well give some default value like name equals quote unquote world, and that alone logically makes sure that I only try to access request.org's name if the key is actually there. So if I go back to the browser now, reload without any. Thing else in the URL now we're back in business and it's saying hello world, but if I go up to the URL bar and add name equals David enter that too now works. So it's a web application in the sense that not only does it have function calls as well as a variable, but now we've got some conditional logic with Boolean expressions as well. All right, questions on anything we've done thus far, because it was a lot, all. At once, questions thus far, yeah. Good question. Let's try that. What if I just did question mark name equals nothing? Well, let me go back to that other tab, uh, delete the name David and hit enter, and I indeed see hello, nothing. Why? Because the name key is provided now. It just doesn't have a value. And so the conditional has the same answer. Well, yes, name is in request.orgs, but there's just no value associated with it. And here again is the value or a hint at the value of using a framework like Flask. The The fact that I can just import the request global variable and then ask questions like is this parameter in this dictionary means I don't have to write any of the code that like figures out what the URL looks like, break it apart between the question mark and the equal signs and any ampersands therein. Like that's all sort of generic logic that every web application has to do. So again, Flask is sort of doing that lift for me and I can just focus on focus on the logic that I actually care about. All right, well, a quick convention here. It's I've used the word placeholder here just to kind of hit the nail on the head and make clear this is a placeholder, but frankly it's a little more readable stylistically to not just put hello generic placeholder, but to say something like hello common name so that a colleague or even myself looking at this file down the line knows that OK, we're trying to print out the user's name here. That's fine. You can change the name of these variables to be anything you want, and even though it looks weird, it's conventional in Flask to do something like this name equals name. But each of these names means something different. This is the name of the placeholder that I'm going to put in my actual template. This is the value that I actually want to give it, and it just keeps me a little saner by just reusing the same name instead of calling it placeholder or placeholder 1, placeholder 2, placeholder 3, or something generic like that. Now it's just a little clear, even though it looks weird to say name equals name. Again, that just allows me to do this in my template. All right, well, what more can I do after that? Well, let me propose that we can actually go in. And simplify this code a little bit. It turns out this is so common to just ask a question as to whether the parameter is there and then do something with it or not that flask comes with some logic to do this. And in fact, I can get rid of all four of these lines, just go ahead and with confidence declare a variable called name, set it equal to request.orgs, but in the so-called dictionary use a function called get that comes with it. Technically doesn't relate to the verb that was used by HTTP. This just means literally get me the following. And if you want to get the parameter called name, you literally just say quote unquote name. However, in case there is no name parameter, you can also give this function a default value like world. And so now we've collapsed into 4 lines from 4 lines into 1, that exact same. Logic. So this gets me the HTTP parameter called name, but if it's not there, it gives me a default value of world so that no matter what, this name variable has what I care about. Indeed, if I go back over here, let's type in how about name equals David again E that's there. If I type in uh no name enter that too is now working as well. All right, well, let's see if we can refine this a bit more. Let me propose that in our next version of this, let's introduce a second route. So two URLs, much like what Google has many different URLs, as does most any web application. At the moment I'm doing everything in my slash route. So how might I move away from this? Well, let me go ahead and not only add a Second route, but in actual form via which the user can type in their name. So to do this, let me propose that in index. HTML, instead of just printing out the user's name and trusting that they're going to have typed their name in manually to the URL, which again is not normal behavior, let's actually show the user a form via which they can do exactly that. So here's my form tag. Uh, let's say the method I'm going to use is get so that I see everything in the URL. Let's give myself an input, uh, that whose name is name because this is the human's name, and notice somewhat confusingly this name on the left is the HTTP sorry, this name on the left is the HTML attribute that we saw last week, so it's different from what we just did in Python, even though they're all called the same thing. The type of this input is going to be text. And let's go ahead and make this a little more user friendly. Let's put some placeholder text called name so the human knows what what to type in. Let's go ahead and disable autocomplete just so we don't see previous input into this text box, and let's autofocus it so that the cursor is blinking in the text box by default. Then lastly, let's go ahead and have a button, the type of which is submit, so that clicking this button actually submits the form, and I'm just gonna call this button like greet because I want the user to be able to greet themselves by clicking this button. Now I should specify action. The only other time we used action is when we actually went to HDPS www.google.com/search. That's not relevant today because I'm trying to print hello world, not search for cats and such, but this is where I too have control. If I want to submit this form to a specific location on in my web application, action is where I can specify it. So why don't I pretend that they're. exists a route in my application called slash greet, and if you go to example.com/greet, question mark name equals David, this now will greet the user with hello David, for instance. But slash greet does not exist. If we go back to app.ie, literally the only route that currently exists is single slash, but I can change that. I can go into my app.ie as I have here. And below this function I can go ahead and define app.route quote unquote slash greet and just invent any route that I want. I can then define a function that will be called whenever that route is visited by convention to keep myself sane. I'm going to call the function the same thing as the route, but you don't have to do this. It's just to minimize decisions I have to make. And then in this function, what I'm going to do is this return render template. Greet. HTML, which doesn't exist yet, but there's a problem to be solved, and then I can pass in the name of the user. I'm gonna go ahead and save myself a line of code and just say request.orgs.get name world. In other words, strictly speaking, I don't need that variable on its own line. This has the effect of what we already did in index, but I'm doing it all in one elegant one liner. And now in index, insofar as I want the index of the site to just show the user the form via which they can type in their name, this one's easy now render template quote unquote index. HTML and return that template. So to recap, here's index. HTML, which is now a form instead of a template for hello, such and such. App.ie is going to return that template whenever I visit the index or slash of the page, and then this greet route is going to handle the case of printing out. Greet. HTML passing in the user's name. All right, I think I'm not quite good to go yet, but let's try this out. Let me go back to my browser tab, reload, and there we have it. I have a web form now instead of the uh the hello so and so. I'm going to go ahead and type in my name and notice the URL at the moment, even though Chrome is hiding it, technically it's there slash, but Chrome and most browsers today sort of hide as much stuff as they can if it's not all that intellectually interesting, but watch what happens when I click greet to the URL. It automatically sends me to slash greet question mark name equals David, and this is just like the way the forms worked last week when we recreated our own version of Google in search. HTML because the action there was google.com/search. The user was whisked away to Google Server. Today I stay on the same server because the action I used was quite simply slash greet, which is assumed to be on my own server, but clearly I screwed something up because I have a big internal server error in front of me as you soon will too. Odds are as you dive into this 500 is the status code that means your fault somehow. Now why is that? Well, it's unclear from this generic black and white message. However, because I'm the developer, I can go back to VS code, open my terminal window, and recall that I have two terminals open now, one that I can type stuff in, the other of which is still running from before. Let me open up that one and you'll see if I maximize my terminal window, a whole bunch of scary error messages here, but the relevant one is probably going to be, let's see, down here, raise template not found error, ginja exceptions, template not found, greet. HTML. So there's a lot of esoteric error messages here, more so than usual, but the simple fact is that I just. Screwed up and I did not create re. HTML, so file not found by the server. So the user doesn't see all that complexity. That's deliberate by design. It's generally not good for cybersecurity if you're revealing to the user all of the error messages that are happening on your server because maybe that suggests they can hack in some some way by taking advantage of those error messages and the information implicit in them, but they are there in your terminal window to actually see and die. No. So how do I fix this? Well, not a problem. Let me shrink my terminal window back down. Let me code a file called greet. HTML. And in greet. HTML, let's create the template via which I'm going to greet the user, which ironically is the exact same as index. HTML used to be. So let me recreate that real quick. Doc type HTML. Let me close my terminal. HTML lang equals EN head. Uh, title, hello, hello, comma, and there's my, uh, here's my placeholder hellocom name. So to be clear, the index. HTML template doesn't have any curly braces or anything dynamic. It just spits out the HTML for the form. Greet. HTML spits out HTML and the actual greeting, and it's app.ie that decides which of these to show the user, either index.html if they visit. Slash route or greet. HTML if they somehow find their way to the slash greet route, which they will automatically by simply submitting that form. All right, so let's go back into this internal server error and go back to the form. Nothing has changed with the form, but now when I type in David, click greet, not only will the URL change to be slash greet question mark name equals David, I actually now see the content that I expected a moment. Ago. All right, well, now it's an opportunity to critique. I have these two templates open index. HTML and greet. HTML and even if you've never done web programming before and even if you never did HTML before last week, what is bad about this design intuitively? Say again? Abstraction in what sense? Yes, so that's exactly the hang up I have here. There's a lot of duplication and technically I didn't copy paste, so I might as well have because notice as I very hintingly go back and forth, almost every line of code in these files is the same except for the form, which is there or not there, or the hello comma, like all of the boilerplate HTML, namely everything I just highlighted here. 1 through 7 in greet. HTML and this and this is what we really start to mean about a template. Like wouldn't it be nice if we could factor out all of that HTML that's common to both files, put it in literally a template that both routes can use so that I can write that boilerplate code once instead of again and again, because imagine in your mind's eye, well, if I have 3 routes. Or 4 routes or 5 routes. I'm going to be like typing the same darn HTML 345 times. That's got to be dumb and that's got to be solvable as we've seen in other languages as well. So let me indeed go ahead and try to improve this and the syntax is a little weird, but it's the kind of thing you get used to quite quickly. I'm going to go ahead and create a third HTML file now by going back to my terminal window. inside still my templates directory and by convention this file is going to be called layout. HTML. Why this? That's what the flask documentation tells you to do. So in layout. HTML, I can put all of my boilerplate HTML, the stuff that is invariant and doesn't change. So here we go, doc type HTML, uh, HTML tag lang equals EN, close bracket, uh, open bracket head, open bracket title, we'll call it hello for all of the pages, open bracket body, and here's where it gets interest. The body is the only thing that has been changing in these two examples. In Index. HTML, it was a web form. In Greek. HTML, it was just a simple string of hello so and so. So what I want to tell Flask is that everything in the body will just be a dynamic block of code and the syntax for that, which takes a little bit getting used to, but it's also sort of copy pasteable, block body using percent signs this time and because I don't want any. Such body in the template. I'm going to literally close this block as follows. And here you see another example of sort of HTML like syntax, but instead of using angled brackets, Gina, the templating library that Flask uses, uses curly brace and percent sign to open the tag, and then the opposite to close it. So what you really have here are two ginja tags, as we'll call them. This one is called Block, and I'm defining an arbitrary name here. I could have called it Foo bar or baz, but because I want this block to refer to the. Body of the page by convention I'm going to call it body and then this weird syntax, which is used in some other languages too, just means end whatever block you just began. And so again you just see reasonable people disagreeing. The people who invented HTML used nice angled brackets and words like these. The people who came up with ginja used curly braces and percent signs. Why? Well, odds are these are not normal symbols that a human would type when writing code, at least in HTML, so they just chose something that probably wouldn't collide with. Actual syntax the human wants to use. So that's it for the template. This is now a, this is essentially a blueprint that doesn't have just a placeholder for a single word or value like name. I can put a whole chunk of code here now instead. And how do I do that? Well, let me go into index.html with the moment, which at the moment is a little duplicative in that it's got all of this boilerplate. So you know what? I'm going to go ahead and delete everything that is already in my layout, both above and below that web form. And now I'm going to use a bit more gina syntax. This tube takes a little while to memorize or copy paste, but if I want index. HTML to use the layout. HTML blueprint, I can simply say extends layout. HTML and then close tag using percent sign close bracket here. And then if what I want to plug into that layout is the following code, I can say as before block body. And then down here, I can say. End block and that's it. And just to be a little nitpicky, I'm gonna deinent that slightly and now even though it looks like web pages suddenly look a lot uglier, well they do because like this is weird looking syntax, but I have now distilled index. HTML into its essence. This is the only thing that changes vis a vis the greeting page and so I've put my HTML here that I care about. I've said to Flask, this is what index. HTML. Body block shall be where to put it, well, put it into that particular layout. HTML file. And so the logic for greet. HTML is the same thing. It's going to look just as weird, but again, you get used to it. Let's go ahead and delete everything that's boilerplate in greet. HTML, both above and below. Up at the top, let's tell Flask that greet. HTML2 extends layout. HTML. And let's go ahead and say to Flask that the block uh called Body shall be this for greet. HTML. And the end of this block is now down here and just to be nitpicky, I'll deinvent that too. So again, the pages look a little weirder now, but it's going to follow a paradigm that we just see again and again such that the only juicy stuff is what's inside of that body block. So now if I go back to my layout, it looks exactly like this. This indeed is a placeholder, not just for a single variable like name. The placeholder we did before, this is the placeholder for a whole block of code that came from a file, not from a variable. And so if I go back into my other tab here, go click back to go back to the web form and reload, notice that I have the familiar looking form. But if I now look at my developer or if I look at view page source, notice everything that came. from the web page from the server. Here's that boilerplate up here. Here's that boilerplate down here, and here's the stuff that's unique to this page. And recall too, aesthetically I de indented it, which is why it's now no longer pretty printed and what the browser sees. Like that's OK. There's no reason to obsess over the indentation and the pretty printing of what the browser sees ultimately the reason I Did this indentation is because arguably when I'm in VS code here and I look at index. HTML, this is clearly indented inside of the body block just so I know what's part of that block. The browser does not care about superfluous white space or less thereof. All right, questions on what we've just done here, which is to truly take this template out for a spin and now remove what redundancies I had accidentally introduced. Questions No, OK, amazing. All right, well, let's go ahead and look at this URL again. I'm not liking the fact that every example we've done thus far involves putting my name or Kelly's name right there in the URL bar. Well, why is that? Well, if I have like a nosy sibling and they sit down in my browser, they're gonna see like every URL I visited, including whose name was greeted. Now that's not all that big a deal, but now imagine it's a username and a password that the form. Submitting or a credit card number that the form is submitting or just search terms that you don't want the world knowing you're searching for, they're going to end up in the URL bar. Why if you are using method equals get for the form. That's how get works. It literally puts all of the HTTP parameters in the URL, which is wonderfully useful if it's sort of low stakes stuff like the Google search box or if it is. Or potentially low stakes stuff like the Google search box or if you just want to be able to hyperlink directly to a URL like this. In other words, if I put this into an anchor tag, open bracket A H ref, and a URL like this, I could deep link a user to a web page that just always says hello, David. So get strings contain all of the requisite information to render a page for the user, but this isn't really good for privacy. So recall that there's not only gets, but there's also something called post, and post is just a different HTTP verb that essentially with respect to those virtual envelopes next last week sort of puts the information more deeply inside of the envelopes such that it's not written right there in the URL bar, but it's still accessible by the server. So if I do this, watch what happens. Let me go back in. To VS code, let me go back into index. HTML, which has the form, and let me quite simply change the method from get to post. And now let me go back to my other browser tab, back to the form and reload so that the form knows that the method has changed. Now type in David and click greet and before I do that, let me zoom in on the URL bar. Notice that. The URL does change. I'm at slash greet, but I haven't revealed to the world or to anyone with physical access to my browser what URL I just searched for. All they know is that I went to slash greet, but not the key value pair or pairs that were passed in. Of course this clearly hasn't worked. I've got an HTTP status code of 405, which means method, not. That's because flask by default, when defining routes, simply assumes that you want get instead of post. Now get is good for the default page. In fact, when I go back here, this is equivalent to me visiting the Slash route just in the browser, so I want my index to generally support get. But the greet route should support post, and the simplest way to do this is to pass in another argument to the route function which we haven't needed before because the default is get, and I can instead tell Flask a comma separated list of the HDP methods that I want this route to support. So if I wanted to support just post, I can pass. In a list containing just post and recall Python uses square brackets for lists, which are their version of arrays in C. Now by default this argument is this methods equals get and that's why the only thing supported a moment ago was get. That's why I'm now changing it to be post instead. I have to make one other change though. It turns out if you read the documentation. When accessing HDP parameters via post instead of get, you move from using request.orgs to request.form. This is completely unintuitive that request.orgs is get and request. form is post. because they all come from forms, so it's bad naming admittedly. So you just kind of have to remember request.orgs is used for get requests. form is used for post. So all I need to do further is change this to be request.form. And that's it. Now my web application will support web forms submitting to it via post instead of get. Let me go ahead and type in my name now. I'll zoom in. Not that the URL will again change to slash greet with no parameters evident, but I will be greeted this time because the server knew to look deeper into that envelope. For those key value pairs instead and just to be now uh sort of diagnostic about this, let me go back once more, let me right click or control click on my desktop and go to inspect. Here's where developer tools can be super useful as well. I'm gonna go in here. And I'm going to go ahead and clear this, and now I'm going to type in David again and I'm going to click agree. But because I have the network tab open like we played with last week, it's going to show me all of the requests going from my browser to server, which is going to be useful here because not only do I see, OK, it obviously worked because I got back at 200, but if I click on this diagnostic output, I can actually go to The payload tab here and I'll see that the form data that was submitted was name, the value of which was David. So you can see what you're submitting. So you can do this today. Like if you want to log into some website, Gmail, or otherwise, you can actually see all of the data that your own keyboard is submitting to the server, even if it's using posts because the browser that you control, of course, can see the same there. All right, any questions now on this transition from get to post? Well, kind of on a roll or not going so well. We'll see. All right, so what more can we do with this? Well, let's give ourselves a couple more building blocks before we transition to actually implementing some real world problems as I did years ago with one such example. Suppose that I don't like this direction I'm going in insofar as every time I have a page with a form, it submits to another route altogether because in your mind's eye I just kind of extrapolate. Well, if I have two forms on my page. I now need 4 routes. If I have 3 forms, I need 6 routes. It seems a little annoying that you use one route just to show the form and another route to process the form. This is going to get annoying over time because it's like twice as many routes as might be ideal. So is there a way to get kind of the best of both worlds and combine these two routes into one so that everything related to greeting the user all happens in one place? Well, you can as follows. What I'm going to go ahead and do. I delete my greet route altogether and most of my index route, but I'm going to ask a question. I'm going to first say that the methods that the index route support now shall be both get and post as a comma separated list there, and then inside of my index route I can simply ask a question of the form if the request that is submitted to the server has a method. Of post then assume that form was submitted. This is just a Python comment note to self that I'm gonna go back to in a moment. Else if the request method is not post, so I could technically say if if uh if request dome equals equals get, then, but this is kind of dumb because I only support two verbs, so I might as well just assume for efficiency. Else handles the get implicitly then go ahead and assume that no form was submitted so show form. So just notes to self as to what I want to do. So how do I show the form? Well this line was easy return render template of index. HTML. If though the form was submitted, what do I want to do? Well, just as before, let. Return render template greet. HTML passing in a name value of request. form.ge quote unquote name else a default value of world. So the exact same logic from each of the two. Functions a moment ago, but I've now combined them into one by just using some conditional logic and just asking the server if the user got here via post. Well, the only way they could have gotten here via post is by having clicked that button and submitted the form. So let's just go ahead and greet them, else if they got here via get by just typing in example.com or whatever the actual URL is, let's. Go ahead and show them the template. So it's still good design in that I have a separate template for each of these pieces of functionality that is only minimally different, but I'm sort of deciding which of those to show based on the actual logic in this here app. All right, so this is almost perfect except for one bug. What else needs to change if I've just combined my greet route and this default slash route as well? Yeah Yeah, so in the form that has index. HTML, recall that there's an action line that specifies like to what URL do you want to submit this. Well, let me go back to index.html. It can't be slash greet anymore because that doesn't exist, so I'm just going to delete the word greet and submit it to slash instead. Which will have the effect of also just omitting it entirely if you don't specify an action, it submits to the very location that it came from, but if you want to be pedantic and even more clear, just specifying that the action now of this form is just this, then that will work here too. All right, so let's test it. Let's go back to the other tab, back to the form, reload. It's blank now. Type in David, click greet, and this too is working. But again, if I go back and reload, get is working as well. But there's nothing ending up in the URL because I'm now using posts, which again tends to be a good thing for privacy reasons as well. Let me show one final flourish before we transition. Something real world motivated. If I go into app.ie for a while now, I've been passing in this default value of world, which is fine, especially if it's something short and sweet that's the default value, but I can actually put a bit of conditional logic in my template as well. So in fact, let me go into greet. HTML and trust that I will now be passed in a name variant. but I can decide for myself in the template whether I want to say hello name or if it's blank hello world instead. And how might I do this? Well, I can always say hello, but then I'm going to use some ginja syntax that we haven't seen yet. But it turns out in Jinja, the temping language that Flask uses, you can use Python-like syntax too, and you can ask questions like, well, if uh the name variable has a value, well then go ahead and output the value of that name. Else if the name variable does not have a value, go ahead and output a literal value like world and then down here and if. So ginja again is a little weird and then it says end block and if, but that's the way it is. But even though this looks a little weird, it's just a nice clever way of. A bit of logic into my template and if the name has a value, so it's not empty or none, go ahead and display it. Hence the curly braces else go ahead and literally say world. Why is it not problematic and you can see the dots here that there's all of this white space after the word hello, comma. Like otherwise this would seem to create quite a messy paragraph or phrase of text in terms of whitespace, but. HTML ignores superfluous white space, so anything more than a single space just gets canonicalized or collapsed into a single space. And we saw that recall last week accidentally when I had those three paragraphs of text from from the duck, but I wanted them deliberately to be separate paragraphs and they weren't because all of that white space was ignored until I actually. Introduced the paragraph tag instead. So this just moves some of that logic now to the templates. So for all this logic and more, here's the official documentation for Flask and specifically Jinja's own documentation, but for the most part we've seen what's possible already, and I promised a real world example. So here now it is. So. Um, back when I took CS 50 as a sophomore, there was no web programming in the class, and frankly there was barely any web actually in the world because it was all so new, HTML and the like. But it was my sophomore spring maybe or junior fall that I also got involved in the freshman intramural sports program or Frosh IMS for short, and back in the day we would walk from say Matthew's Hall to Wigglesworth freshman year at least, to register for sports by filling out what was called the sheet. Paper and then you would go to the Proctor's dorm room and slide it like under their door or through the mail slot and that's how we registered for sports. It was sort of ripe for disruption before that was even a phrase. And so one of the very first projects I took on myself personally after taking CS 50 was to figure out how web programming worked and Python wasn't really wasn't a thing yet, nor was half of the topics we've been talking about thus far. But at the time I learned a programming language called Perl. I learned a little something about CSV files, which we did a couple of weeks back too. And I built this the Freshman intramural sports website via which you could click on a bunch of links and get some information, but most importantly, you could register for sports as by typing in your name, selecting the sport for which you want to register, click submit, and no longer walk across Harvard Yard with a piece of paper to actually register for sports. So we thought we'd use this as sort of the beginning of a motivation for how we can now solve problems using web-based interfaces using code and also what not to do, like background images that repeat like this are not really. In fashion anymore, nor arguably in 1997, but let's leave that as a cliffhanger and come back in 10 minutes after a snack with reimplementing the Frosh IM's website. All right, we are back. So among the goals now are to recreate the beginnings of a site like this for Frosh IMs whereby we want to enable students to visit a form, fill out that form, and submit it to a server, and then register, and we'll dispense with all of the amazing graphics and such, and keep it fairly simplistic and. Core HTML. So let's go ahead and do this. Back here in BS code, I've gotten ready now for this next set of examples and in particular I've created in advance a directory called Frosh IMs inside of which are App.ie, requirements.text, and templates, which are essentially the same as the ones we just created, but I stripped out the hello and greeting specific stuff. I'm going to go ahead in this terminal and do flask runs, so I get the server up and running again on port 5000, and then I'm going to go ahead and open up another terminal here as I did before. CD and Frosh IMs in that terminal where I'll see the exact same files and I'll give you a quick tour of what I created in advance. So here in A.ie is quite simply the simplest of applications that just renders the index. HTML template with an expectation in a moment that we're going to make it more interesting than that. Meanwhile, if I open my, my terminal again and open up Requirements.txt, it just mentions flask, but it's already installed, so no more to say about that for now. Now let me go ahead lastly and open up template. It's the templates folder, two files they're in, the first of which is layout. HTML, which looks almost the same except I did add a slightly more user friendly tag to the head of the page, which you might not have seen before, but this is a tag that essentially you can copy and paste into templates of your own that help the content of a page resize to be mobile friendly. In fact, without this line, if you were to develop Problems at 9 or your final project for the web and then try to access the site on a phone, everything might look quite a bit. Small font sizes and more. This line tends to help the browsers resize dynamically so that it actually matches the width of the device's own with, for instance, a phone versus a laptop or desktop. But otherwise everything else is the same there, including the placeholder for the body block that I've find here on line 9. Lastly, there's one more file that at the moment doesn't do anything all that interesting except is ready to contain the contents of the registration form for Frosh. I am. So let's go ahead and start with actually that. Let me quickly whip up a form that minimally gives the user something that they can submit to the server to register for sports, and then we'll improve upon it a bit iteratively. So here inside of the body of index. HTML, which is going to extend the actual layout, the blueprint we already created, I'm gonna have a quick title for the page like register just to make clear to the student what they need to do using the H1, which is the big and bold tag. Then I'm gonna go ahead and have a form tag. Uh, whose action is going to be anything I want, but since I want the user to register, I'm gonna have it go to slash register, which makes more sense romantically than greet now because we're doing something else. The method I'm gonna have the student use is post, if only because they don't want their roommates knowing what they visited in their browser, so this way it will tuck the HTP parameters deeper in that virtual envelope so it's not stored in the browser's history. Inside of this form. I'm going to have minimally an input box for the student's name, so I'll call that aptly name and set name equal to name in my HTML. The type of this text box will be exactly that text. And then just to make it a little more user friendly, I'm going to add a placeholder of names so they know what to do. I'm going to go ahead and turn off autocomplete in case multiple roommates want to sign in from the same computer, register from the same computer, and then we'll turn on Autofocus to put the cursor in that name box. And then, and you didn't see this last week. But if you've ever wondered how drop down menus are implemented in HTML, if you've never done this yourself, those drop down menus on web pages are called select menus. And if I want the user to select a sport to register for, I'm going to call this input a sports, and this is an alternative to just having a generic text box where we have the students type in the sport they want to register for, which would be fraught with typographical errors and changes in capitalization. A drop down menu, of course, standardizes what the human can select. So inside. This drop down, I'm going to have a few options. The first of which will be, uh, basketball, for instance, the second of which will be soccer, and the third of which, which I think was the 1st 3 with which we debuted back in the day, was ultimate frisbee. Now these option tags can take some attributes by default. They will take on the value of whatever words are typed in between the open and closed tags. But just to be pedantic, I'm going to make clear that the value of selecting this. shall be basketball, but I could change it to be something else if I so chose. The value of this selection will be soccer, and the value of this last option will be ultimate frisbee just in case I want to store something else in my database ultimately. Now that is a complete index. HTML, I think. So if I go back to my browser tab, which previously was showing me the Hello program because I stopped and restarted Flask, and you can stop Flask by just hitting control C. Uh, for interrupting it, I'm going to reload the page and I should now see, OK, a slightly more interesting form with the name box with the cursor is blinking there, and then a select menu, a drop down with three options. Now it's a little presumptuous of me to select basketball by default, and in fact this is kind of inviting user error if they type in their name, don't really think about it, and now register for basketball accidentally. So I'm going to make a couple of improvements here. I'm actually going to have essentially a blank option at the top whose value is nothing. And I'm going to have it just labeled sport. And just to be super clear, I'm going to select this value by default. So the option tag in HTML supports not only a value attribute but it turns out a selected attribute which if present means that's the option that will be selected by default. So if we go back now to this page and reload to get a new copy of the HTM. looks a little better. I still have the name at left, but the sport now menu looks like this, so it's a little more clear what I want them to do from this drop down, and sport deliberately on the back end won't have a value, and theoretically this will help me determine if they actually selected a sport or just clicked register and ignored the drop down still. But I do need. Way for them to register ideally by clicking a button, so I'm going to add a button, the type of which is submit, and then I'm going to have this button's label be register. So now if I go back to the form once more, reload, I now have, I think, a complete form, albeit not very pretty, via which David can register, for instance, for basketball by clicking register and darn it, I have a 404 not found. But why is that? Why is nothing yet found. Why is slash register not found, yeah. What's that? Yeah, I haven't, well, I haven't linked the option to anything. I think the form has been linked, whoops, the form is telling the browser to go to slash register, so this is correct behavior. But if we go to app.ie, like there's no route defined for slash register. So of course it's not found because there's an infinite number of routes that don't exist and register is currently among those. So I can define that myself. I can say app. route. register. I do want to use post, so I need to proactively say that the methods this function will support will be indeed post instead of the default of get. I'm going to define an actual function to call when this route is used, and by convention I'm going to call it just register, even though I could call it anything I want. And inside of my register function, well, for now I'm going to cheat a little bit. I'm going to at least just say. Uh, I'm going to at least check that the user has given me a name and a sport. So how can I express this? Well, because I've already imported the request global variable that comes with flask, I can ask questions of it and I can say something like if it is not the case that request.form.get name has a value, or if it's the case that or if it's not the case that request. Forget sport has a value, then let's go ahead and give the user uh a warning of sorts or return render template of a file called failure. HTML. This doesn't exist yet, but no big deal. Let me go back into my terminal. Let me uh go into templates and create a file called failure. HTML, and in this file I'm gonna say that it extends. Uh, layout. HTML. HTML and then it has a block body inside of which is gonna be something like super trivial for now just to get us going and this failure page is simply going to say you. Are not registered and then and blocked. So that's it just sort of an error page that now exists. I'm gonna close it out of sight, out of mind, but I think this now will work. If it is not the case that the user gave us a name or it's not the case that the user gave us a sport, we will show this error message otherwise. If all seems to be well for now we're not going to do anything useful with the information, but I'm going to go ahead and return render template of success. HTML, which is simply going to assume that the user was successfully registered. So let's whip that up quickly. I'm going to go ahead and code up success. HTML. Inside of this file, which will similarly extend layout. HTML inside of which there's a body block that quite simply says how about you are registered and we'll just pretend that it is so and block. So that's it. In short, I wanted two templates that show failure or success respectively. So I think now in app.ie we're in better shape. I now have a register route that will get called if post is used to visit it, and I'm going to check request.form, which is where you get the post variables from, check whether name or sport is provided, and I'm going to render a template accordingly. So let's try this. Let me go back to my other tab and go back to the form. Let me type in my name, David, but no sport. Click register. And I have an internal server error which was not intended, so let's figure out how to diagnose this. So it seems to be the case that I'm at slash register that was intended, but something clearly went wrong, so let's go back. Now I could just kind of stare at my code endlessly, but recall that there should be some hints in my terminal window that's running flat. So let me go back to my other terminal, and there it is, unexpected char double quote at line 11. Well, so sounds like user error, so that is in failure. HTML and you can kind of see it because Flask is like underlining it literally for me. What did I do that was stupid? Yeah, I just didn't close my quote. So amateur hour here, so let me go into, I do need to open it after all, ironically, so let's go ahead in my other terminal, open up failure. HTML and there it is, one stupid character away from correctness. All right, let's close this again. Go back to the other tab. Let's try this again. David is my name, but no sport register. OK, you are not registered. I don't know why, but I know I'm not registered. Let's try it again with a uh with no name, but yes, a sport, click register, you are not registered. All right, just for good measure, let's give no name and no sport. You are not registered. So that seems to be working. Let's now cooperate. Let's go ahead and register as David for basketball. Cross my fingers, damn it. And internal server error. Let's try to learn from my past mistakes. Let's open up this eyeball it. I did it twice, even though that was not copy paste, so 0 for 2. All right, let's go back here. Notice now I can actually just click reload because the browser's smart enough to remember what I just posted to the server. So if I click reload, you'll be prompted to confirm the form submission lest you be doing this on a website with your credit card or something where you don't want to send it twice. But in this case I'm fine with sending my name in basketball twice, so I'm going to click continue. And this time it worked, telling me that I'm actually registered so I'm not doing anything with the students' data, but at least I am validating that they gave me some inputs. Now there's a catch here. The catch, of course, with HTML is that it's all executed client side. And so for instance, suppose that a student is really upset that we only offer basketball, soccer, and ultimate frisbee, and maybe they really want to register for volleyball even though we're not offering volleyball. Well, there's arguably like a security vulnerability here where technically my code right now will tolerate any user input even if it's not in that drop down because after all, let me go ahead and right click. Or control click on my web page and open up the developer tools. Let me go into the form as sort of a hacker type student. Let me go into the select menu and OK, no big deal. If I want ultimate Frisbee to exist, well, I just need to know a little HTML. I'm going to right click on that element and click edit as HTML. This literally lets me start editing the HTML. of the page I'm going to give myself my own option. Option value equals volleyball close brackets volleyball enter and now when I close developer tools, woo hoo, I can register for volleyball if I want. So let's select volleyball, type in maybe Kelly is hacking the site register, and she is registered for volleyball. Apparently, all right, so the short answer is the short, the takeaway here is do not trust user input ever for reasons we've already seen when we discuss SQL ever more so now that we're dealing with the web, because who knows what users are going to do accidentally, foolishly, or even in Kelly's case here maliciously trying to pass data that we did not expect. So what would be the defense against this? Like this is just how HTML works. And assume that I'm actually registering Kelly for sports now and somehow she's now signed up for volleyball on our database. What would a solution be logically here? Yeah. Yeah, so maybe do some server side validation. So don't just blindly check that we have a value from the user. Actually check that it's one of those sports. So if I go back to app.ie, I could do this in a few ways, and maybe my first instinct would be this. Let's check for the name and do this, but let's also do this. Like if request. Dot form do get quote unquote uh sport and actually let's put this in a variable just to make it even easier to type so sport equals this if sport, uh, how about does not equal, uh, what was it basket ball and. Sport does not equal uh soccer and sport does not equal quote unquote ultimate frisbee, then render an error. So, uh, return, render template quote unquote failure. HTML. So now if I go back to this form and try to register as Kelly again. You are not registered, so I somehow caught her because volleyball, of course, is not in the list of sports that I put there. But what might you not like about this approach? Even if you've never done web stuff before, what's bad about this? Yeah, I have to hard code every single sport now in not only A.ie to check for the validity on the server of what the human is typed in, but recall that the drop down itself came from index. HTML. So I now in duplicate have to put like all of the sports there too. So like this just seems bad to have duplication and so better might be to do something more like this at the top of my file. Here, why don't I go ahead and just give myself a global variable which in the context of this web app is perfectly reasonable so I can access it anywhere. Let's call it sports in all caps just to connote that this is a global variable and constant, even though Python does not have consts in the sense that C does, but this is sort of on the honor system. If you see a variable in all caps like this, just don't mess with it, use it, but don't mess with it. So, uh, inside of the square brackets this is gonna be a list of the sports that I do want to support, so basketball, comma, uh, soccer, comma, ultimate frisbee, and that's it. Now instead of doing all of this, what I can instead ask is a. Simpler question like this if sport not in sports, then go ahead and return render template quote unquote failure. HTML and I can actually tighten this up a little bit. I don't need two calls to failure. HTML. Why don't I just borrow this code and say. Or, uh, sport, not in sports render a failure, and now I've tightened this up quite a bit more, but I'm essentially using Python to just ask, is the sport that oops sorry I deleted too much sport equals actually let's just tighten it up further. Sport does not exist, so let's do request.form.get quote unquote sport. So if the sport that the human typed in or selected from the drop down somehow is not in this global list of possible sports, well then it's a failure. Don't let Kelly or whoever register instead, but if I now have this global variable, I can be a bit smarter in my template. I don't need to manually write out all three of these sports here. Instead, I think I can be smart about this, and when I render index. HTML itself, why don't I just pass in a variable called sports, for instance, set it equal to the value of that global array, and then in my template, and here's where templating again gets interesting and starts to save you time, let me go into index. HTML. Delete all but the default value, the blank one, and do something like this. Ginja, it turns out, also supports loops like Python for sports in sports using the curly braces and the percent signs, I can now dynamically generate options as many as I want. So option value equals quote unquote the current sport close uh there, close brackets sport. So it's a little redundant, but again this is just how HTML is. This is what the human sees. This is the value that gets submitted to the server in case you want one to differ from the other, and then below that option line I can say end 4, which is a bit weird, but that's how it works in Jinja to stop that loop. So this is kind of powerful. Now if I have 3 sports, 30 sports, all of the options will be dynamically generated by this template. And so now we're starting to save ourselves time and I can centrally manage all the sports by just updating this global list here in App.ie. So let's go back to the browser. Uh, back to the form reload, and you'll see that the drop down thankfully still works the same way, but all of those options were dynamically generated. Indeed, if I view page source from my browser, you'll see and there's some extra white space there because the loop was adding some white space on each iteration. I still have the 3 sports but not volleyball, as was my. Intention. So now if uh if Kelly even tries hacking this version of the site by going in here and select and typing in volleyball manually registering, the logic will still catch it because only those three sports are in that array. So it's perfectly fine for me now to register for basketball because it's among the sports, sorry, in that list, not array. Questions on any of these here. Techniques. All right, how about another type of form? So select menus are nice, but you also might see radio buttons on websites which are the mutually exclusive little circles that you can select to choose one or another option. Uh, let me go back to index. HTML and just show you how those can be created as well. Instead of using a select menu, turns out we can create a whole bunch of inputs of radio type type as follows, of radio button type as follows for each sport, so for sport in sports, let's go ahead and output. In between this tag and the end for the following input type equals radio. Uh, and let's give it a name. The name of this radio box is going radio button is going to be sports, and the value of the current input is going to be quote unquote sports, and the word that the human's going to see is as before sport. So notice it's just another type of input. Previously we've seen text, for instance, two lines above. We also saw last time search. We saw email. There's a bunch of text input types. This one though is going to display as a. Radio button instead and the human is going to see this label here. If I now go back to my other browser tab and click back, click reload on the form, I should see it's not pretty, but it's a radio button in the sense that these are mutually exclusive. How does the browser know that I should only be allowed to select one of them? Well, because I use the same name for each of those radio buttons. It knows that means mutual exclusivity. In fact, if I view page source in the browser, you'll see that all three of the inputs that were dynamically. type equals radio. Type equals radio, type equals radio also have identical names. And so that's just how that works. And that's the only change necessary. If I now go ahead and type in my name, David basketball, click register, we're still up and running because what the server gets is still exactly the same inside of request. form they can access, you can still access name or sport no matter what type it was in the user's own browser. Questions on these techniques. All right, well, it's kind of obnoxious that when you don't do something right in this website like forget your name but you select a sport, all you are told is generically you are not registered. Like it'd be nice and much more user friendly, better UX user experience, so to speak, to actually tell the user what's wrong so they can actually fix the problem. Now there's a bunch of. We can do this, but I'm going to propose that we go ahead and do this. Let's create a template called error. HTML, whose purpose in life is just to tell the user a little something more about what they did wrong. So I'm going to go back into my terminal window here. I'm going to code up a file called error. HTML. Enter and I'm going to go ahead and before, as before, extend layout. HTML, learning from my past mistakes and closing that quote. Then I'm going to go ahead and do body block down here and then inside of this block body I'm going to go ahead and have just some simple text like an H1 tag that just says error to the user. Then a paragraph tag that's going to contain some error message to be determined and then uh that's it for now. So I've got the template for an error message screen. Let me go back into app.ie now and let me add some logic because A.ie does know what's wrong. It's just at the moment we're very generically returning a failure template instead of something more precise. But if I know that the user hasn't given me their name, well, let me say that error message. So let's actually get rid of these two lines and be a little more specific like this. So if, or how about let's do it like this, how about validate the user's name first? So name equals request. form.get quote unquote name. That just gives me a variable containing the user's name. If they didn't give me a name, which I can express with just if not name like if name is blank or none, then let me go ahead and return render template of that error template, but let's pass in a specific message like missing name. And so by passing in another argument to this template called messages, I can trust that flask will dynamically output that message where I tell it to using the old curly braces. Meanwhile, let's go ahead and validate not just the name but validate. Uh, sport. I can do this in a couple of ways. Let's do this. So sport equals request. form.ge quote unquote sport. Then in here, let's say if there's no sport, go ahead and return render template quote unquote error. HTML message equals missing sport, so quite like name but we can be more specific now too. If the sport they did give me is not in the global sports list, well then it's Kelly trying to register for. Volleyball again, so let's return render template of error. HTML, but this time the message shall be invalid sport or something like that. So we're being ever more clear, otherwise they are presumably confirmed because we got this far logically. So if I go back to the other browser tab, go back to the form, and let's go ahead and type in no name and just click register. OK, what did I do wrong accidentally? So let's go back to VS code. Open my terminal, open the first terminal window where flaskun is running, encountered unknown tag body. So I did something stupid in error. HTML. So let's go into error. HTML and uh black. Oh, it's subtle. I just transposed the words. It's supposed to be block body. That was dumb. All right, block body. I think that's correct. So let's go back to the browser. Let's reload. It's prompting me to reconfirm that I want to submit the exact same form, which recall had no name and no spore, but now I see an error in a good way. This is not a server error. This is my error missing name. Now it's not super user friendly, but it's at least more explained. then you are not registered. All right, let's go back. Let's give it a name, but no sport register ah missing sport. Let's go back. Uh, let's go ahead and give it a sport but uh a sport but no name missing name as before. And if I took the time to actually hack the HTML and do what Kelly did before and add volleyball, it would similarly say invalid sports in this case too because it's not in that same list. All right. Questions on this technique. All right, well, it's all fun and good to have a registration site that does this, but it's literally just throwing out the information. And what I did like years ago was actually even cut a corner initially where I think I wrote code that just sent an automatic email to the proctor running fro IMs containing the person's name and the sport for which they registered, but that was very quickly replaced by a better feature which is actually store the. Data in the server itself and keep track of it rather than just send it off via email. So let's do a first pass at actually storing information on everyone who is registered for sports. Well, let me go up here and let me create another global variable to make my life easier here called registrants and set this equal to curly brace close curly brace. What do these two characters represent if empty, especially? What data type is this? It's a dictionary, so it's a Python dict, so you could similarly say dict explicitly open closed, but it's more pythonic generally to just use two curly braces. This is just giving me an empty dictionary. Why? Well, I want to store the two things I'm still collecting about all of the students their name and the sport for which they registered. So. value name sport. So how can I go about doing this? Well, it's pretty trivial down here in my register function, recall that I'm just kind of naively saying you're registered even though I'm not doing anything with their name or sport, but that's easy. Let's remember the student for real now. So in that registrants uh uh dictionary, let's go ahead and index into it using the student's name David or Kelly or whoever and set that equal to the sport for which they registered. And now notice the name is coming as before from request.form.get. For is similarly coming from that function and so this is just remembering that key value pair so that's all fine and good it's in the computer's memory how do we actually see it? Well, wouldn't it be nice after you register if you could see the actual registrants of the website, um. Uh, certainly if you're the proctor trying to run the sports, well, yes, so let's go down here and let's create another route like slash registrants, which is just gonna give me a list of everyone who's registered. Let's define a function called registrants, so I could call it anything I want, and this one's gonna be relatively simple. Render a template called registrants, which will soon exist and pass in all of the registrants that are in that global dictionary and again I can call this placeholder anything I want, but insofar as it contains the registrants, I'm setting registrants equal to. The registrants Global dictionary. So let's go now into my terminal window and create registrants. HTML and create really the beginnings of an actual Frosh IM's website that's gonna show the proctor who has now registered. So let me go. Into this terminal and do code of registrants. HTML and close the terminal. Let's try to get this right finally extends layout. HTML close quote, uh, close bracket there. Then let's do block body in the right order, then end block. Down here and then inside of the block here this is gonna be a bit more of a mouthful, but let's use some of our HTML from last week. We'll give an H1 tag that says registrants so the proctor knows what they're looking at. Then let's put this in a table, for instance, with two columns, names and sports. So tabletag followed by a T head tag for the table heading, uh, then that heading is gonna contain just a single row for TR and each of those has a TH table heading. Uh, one of which, and actually I'll make it tighter, is name, the other of which is going to be sport. So these are the column headings, the table headings, TH tags for short. After the head of the table, let's go ahead and do a T body for table body and inside of here this is where ginja comes in use. I can say for each name in the registrant's placeholder that was plugged in. And for proactively, what do I want to do on each iteration? Well, I think I want to output table row, table row table row, and in here I can do TR and then inside of that a table data for the cell on the left, putting in the student's name which is coming from this for loop just like in Python, and then one more table data, namely the registrants, uh, placeholder indexed into at that name which because it's a dictionary will give me the sport for that student's name. And then I think we're good to go. And in fact, just to hark back to something I said last week when we were imagining, actually this isn't week 5 when we were talking about stacks and like your Gmail or Outlook inbox is essentially a stack with the newest emails on top and I hypothesized at the time that it's just row after row after row after row when we started talking last week about HTML. Here is what Google and Microsoft and others are probably doing anytime. You have tabular information in a page. They've got some data in memory like the registrants, and they're just using code like this in Jinja to output table row, table row, table row. Imagine this is your email instead, same exact idea. And now we have the ability to express that kind of logic. So let's go back now into the browser, click reload on the Let's register for instance David for basketball. Click register. It claims I'm registered, but hopefully now I'm legitimately registered because that variable is storing it in memory. And in fact, let's go ahead and go now to not slash register, but I'll zoom in at the top registrants and hit enter, and we will see a very. Ugly but functional HTML table containing two columns name and sport, the so-called T head in which David and basketball are present. Moreover, if we now go back to that form and let's try registering Kelly, for instance, for soccer, click register. Now let's manually go to registrants again. Now Kelly and David are in the server's memory as well. Questions then on what this example is now doing or how it's achieving these results, yeah. Really good question. If you wanted to restrict the registrants page to only certain people, ideally you would have a password on it. And in fact one of the next examples we'll do in a few minutes is a login page for exactly that reason. Right now just sort of on the honor system that only the proctor in question goes to this URL. But just for the sake of discussion actually, suppose that you did want the registration list to be public, if only to like hype up who has already registered. Well, it's not good to just tell people go to the slash reg. URL, we can actually link them to that in a few different ways. So for instance, I can go down to uh how about uh let's say success. HTML. So let me open up success. HTML. It just says you are registered. I can do something like this um A HF equals slash registrants. So I have control now over my HTML and the routes, so slash registrants will exist. uh see who. ET registered, period. So this will create a nice little HTML link that links me to that route. So let's try this. So let's go back to the form over here. Uh, let's go ahead and register John for Ultimate Frisbee. And register. All right. And now we see you are registered. See who else registered. And if I hover over this, it's super small, but it would have showed me in the bottom left corner at the link. And indeed here now is John at the bottom of this table. And just to be clear, if I view page source on the browser, you see all of the TRs that we dynamically generated on the server side before they were sent as such to the browser. All right, what if we wanted to do something slightly more elegant here? Well, I don't have to just use this HTML hack. Like, why don't I just show the user who has registered automatically, and this is kind of a cool feature of web apps as well. In addition to importing Flask, render template, and request, I'm going to also import a function called Redirect that comes with Flask and indeed. Rather than just show success. HTML, I'm going to go ahead and return the result of redirecting the user to slash registrants. So to be clear, I'm in my register route and instead of showing them the success page anymore, which I might as well delete at this point, I'm just going to redirect them to this list of everyone who is registered, including themselves. So if I go back over. Here and type in someone like Doug who maybe will play basketball with me and click register. Watch what happens to the URL at the very top of the screen. I'm automatically whisked away to registrants in this case. I made a change to the code though, and so the server actually was smart enough to reload. So Doug is now the only one in the database, and this actually hints at. A problem we should really solve. Like, in fact, let's do this real fast. Let me go ahead and register myself again for basketball register now it's Doug and David. The catch though is if this server ever goes offline, maybe because it needs to be updated or it crashes or. It reboots when you hit control C and get back to your terminal. Flask server is no longer running, which means that global variable called registrants in all caps is gone. It's like free the memory has been freed. So if I were to rerun flask now, as would happen automatically if the server itself rebooted. Well, this is not great because if I go back to the registrant's page and click reload, no one has registered and in fact that's what happened with Doug a moment ago because I changed my actual app.ie. Flask was smart enough to realize, oh wait, the code has changed. I better reload the program which gave me a brand new version of that global. Dictionary. So what would be better clearly than storing registrants in memory in RAM in a variable in the server. Yeah. Yeah, so in an actual database and so here's to where everything kind of comes full circle and connects again. So let me go back into A.ie here. And I like generally the logic of what I've done. I don't like the fact that I'm just storing my registrants inside of this global variable, which is again just in the computer's volatile memory. Let's actually put this in a database instead. So let me go up here and get rid of this global dictionary and let me do something a little smarter up here. Let me import from CS 50's own library the SQL. Function that we've used before and again, even though we've been taking off all almost all of CS 50's training wheels, the reality is using CS50's SQL library even through final projects just makes using SQL and Python so much easier. But there's certainly third party libraries you can use. Um, let me go down now and in addition to creating my app, let's create a database, DB for short, setting that equal to SQL light and then SQL Light. And slash, which is not a typo, and let's assume that the database shall be called froshimMs.db. More on that in a moment. And then down here, now that I have a database variable, let's not remember the student by storing them in this dictionary. Let's actually execute a line of SQL. So dB.execute, insert into. Well, wait a minute, what am I going to insert them into? Not to worry, I came prepared for this, so let me go ahead and maximize my terminal window and then run SQLite 3 of a file called FroshIMs.db. And this is a file I made in advance, but it's super simple. In fact, if I type schema just to see the design of this database, you'll see that in advance I created a table in this database called registrants. It has a column called ID. A column called name and a column called sport and the primary key of this table is to use the ID value, which is just an integer. And now notice I have some constraints here. I want the user to give me a name and a sport, so I've specified that it's not just text, it's not null. That is null value should not be possible to put in here. All right, so let me go ahead and exit out of SQLite 3. Let me go back into. Uh, my code editor here and now I know what to insert into. Insert into the table called registrants. What? Well, I want to insert how about a name of the student and the sport for which they registered, and the values therefore that I want to insert are going to be whatever they came from the post request. Here's where you do not want to make yourself vulnerable to SQL injection attacks. No F strings in here, no just plugging. Students input in blindly. This is where and why we use these placeholders in both CS 50's library and in many libraries in the real world to specify that I want the library to properly sanitize the user's input and get rid of any scary characters like apostrophes or semicolons or the like. So I'm going to pass in name and sport, and this one line has the effect of, as you recommend. It's storing the registration in an actual database on the server, not just in volatile temporary memory, but we do have to change one thing. This line here is no longer valid because there's no global variable there via which we can get all of the registrants, but that's no big deal. Here's how most web apps would do this. I'm going to define a variable called registrants and set it equal to DB execute. Of select star from registrants. It's as easy as that to just get all of the registrants from my database and down here there's no longer an all capitalized variable, but there is a lowercase one registrants. So to be clear, in my register route, I am inserting the user into the database and in my registrants route I am selecting the users from the database and then the rest of the code I think can stay the same. So let's go back to Fresh AMs here. Go back to the form. Let's register David for basketball, register. Ah, I did screw up. You're seeing some weirdness here. What are you actually seeing? There's one user registered. Not intentional, but what does this syntax suggest we're looking at? This is a dictionary. Recall that the dB.execute method that comes with CS 50 SQL library gives you a list of dictionary objects. And so because there's only one registrant at the moment, you're seeing my dictionary for my registration, which is not what I want to show here and I forgot. I need to also go back into the registrants templates to tweak my syntax as follows. Let me go back into VS code here. Let me go into registrants. HTML and because I am passing in now not a dictionary but a list of dictionaries, I just need to think about the problem a little bit differently. So my syntax here is gonna be for each, uh, let's do this as follows. For each registrant. In that registrant's list of dictionaries, go ahead and display the current registrant's name and go ahead and display the current registrant's sports. In other words, I'm using Python syntax, which works as well in Gina here. This iterates over the list of registrants, each of which is a dictionary, so I'm using dictionary syndex now to index into the name key of the registrant dict object and the sport key of the same. So now let me go back to my browser and I'm just gonna go ahead and reload the registrants page without resubmitting the form. Now there it is, David and basketball. And now let's go back to the form and register a couple more people. Kelly for soccer register. Notice we're at the registrants link. Kelly is indeed still registered. Let me go back to this and let's register John Ultimate Frisbee, register. Let's go ahead and kill the flask server by going to my first terminal window, uh, control C. And now let me go ahead and rerun Flask, which was bad before. That's how Doug ended up the only registrant last time. But this time if I go back to the registrants page and immediately click reload, even though the servers running anew in memory, the database is persistent, which was the whole point of using SQL from week 7 onward. And let's do one more for good measure. If I go back to the form, we'll register Doug so he can play basketball with me too, and we even have Doug now in the database. It's an ugly looking table, but The data is in fact all there. All right, questions now on this improvement, which is getting closer and closer to what the actual Fros AM's database did, uh, website did so many years ago. All right, well, let me propose this now. We have this table of registrants. Suppose that um maybe uh Kelly was not a very sportsman like when she played soccer last time, so we want to deregister Kelly from soccer. That is, no, we're going to reject your registration. Let's. For a moment about the design here, like here's an HTML table containing names and sports, and wouldn't it be nice if we could add a button that would let me deregister Kelly or anyone for that matter. When I click on that button, what information should ideally be sent from the browser to the server to remove someone like Kelly from the database? Yeah, the ID of the person and you're proposing ID instead of name. Why? I need to be identified. Exactly, the ID uniquely identifies the user in the SQL table. So in fact, let's see this real quick. If I go back to VS code and we'll revisit essentially a week 7 issue here, let me go back into my second terminal where I can again run SQLite 3 after maximizing my terminal. And before I just wrote. schema to see what the table is, now I'm going to literally run selectar from registrants in SQLite 3 and we'll see a little Askiar table of all 4 of us who registered, but we also see. Unique ID and the value of the unique ID recall from week 7 is that it's the so-called primary key. It is the value that uniquely identifies users as minimally as possible, and that's a good thing because if we have another Kelly registering for Frosh IMs, we don't want to deregister the wrong Kelly or both Kelly's. We want only though Kelly with ID of 2. So somehow the button we add to the registrant's page should contain in it the ID of the person we want to delete, because if you do pass the ID. D of the person that you want to delete to the server, the server can do some kind of select looking or some kind of delete statement using that ID number and delete just that row. So there's a few ways we can do this, but let me propose that we proceed as follows. In our registrants route, which is where we can currently see all of these users, let's go ahead and output an ugly but functional form for each of those users. So let me go ahead and minimize this. On hide my terminal window and in registrants, let's go ahead and just do this. In addition to outputting every registrant's name in sport, let's also output a third column whose purpose in life is to contain an HTML form. The action of that form will be a route like de-register, and the method we're gonna use is going to be post just so that we don't. Accidentally store personally identifying information in a URL or such. This form is going to have a button, the type of which is submit, and the button is going to say deregister, and I could now implement the ID in a couple of ways. I could do input, name equals ID, type equals text, and now if I go back to my other browser tab and reload, I should see a button for every one of these registrants. And I do, but this is kind of like the honor system where I just let the user type in the ID of who they want to delete, and it's sort of weird that I have multiple forms in that case, but here is where dynamically generating HTML can get pretty. Uh, useful. Let's change the type of this input to hidden and set the value of this uh input to be whatever the current registrant's ID actually is, uh, storing this in here and let's go ahead and not confuse this, so we'll use single quotes on the outside instead. So inside of this value, I'm putting the current user's ID. So if I go back now, notice that the text boxes are going to disappear, but the buttons will not. But all of that information is still there. If I right click or control click and open up my developer, uh, let's open up View page source. It's just a bit bigger. Notice that David and Kelly and John and everyone else here has the same HTML as before, plus another column containing a form that contains, oh, I somehow messed up still. Why is this blank? So this is still not good. Ah, thank you. I accidentally pluralized this, but it should be registrant because I'm inside of this for loop and each iteration gives me a variable called registrant. So user error on my part. So let's go ahead and dramatically do this again. Let me view page source of the same page, scroll down a bit. Thankfully there is now for every one of these registrants a hidden ID. 1 for me, 2 for Kelly, and I bet if we keep scrolling, we'll see 3 for John and 4 for Doug. So now this form has enough information even though there's no user input other than the clicking of the button to tell the server whom to delete. So how do we delete the user from that particular registration table? Well, I think we just need to add a route. So let me go back into VS code here into app.ie and let's go ahead and create another route, for instance, uh, in here, say, uh, we'll put it up here below uh up here below index, so app.route slash deregister, whoops, deregister. And now de de register, but I could call it anything I want and how do I do this? Well, let's first get the ID from the form ID equals request.form.ge quote unquote ID. Let's do a bit of a sanity check here. So if there is an ID, and it's not blank for some reason, go ahead and do dB.execute, delete from registrants where ID equals. Uh, question mark and now let's pass in the user's actual ID and then no matter what, let's go ahead and redirect the user back to the registrant's page so that we can hopefully see the result of that change. So again, I'm just using a bit of SQL per week 7. I'm using a placeholder by using the question mark passing in the actual ID from the form, and I'm only doing this if there is an ID that was passed in and I'm letting the database actually do the deletion. All right, so let's try to do this. Let's go back to the browser here, reload the slash registrants page for good measure. Let's decree that Kelly is now deregistered by clicking this button, and oh, so close. Method not allowed at the deregister route. What did I do wrong? Let me go back to the code. What's wrong with my deregister route? Well, what method is the form using? If I go back to registrants. HTML, the the form is using post. Yeah, so I need to override the default, which is get, so I need to go up here again and just change an argument to be methods equals and then in a list containing only post now instead of get. All right, let's go back to the form and go back and now let's try to deregister Kelly. She's gone. Let's get rid of me now. I'm gone. And indeed if I go back to VS code, open my terminal, maximize it, and select star from registrants again, you'll see that the two of us are indeed. Gone in this case. Questions now On this technique because now we have most of the plumbing in place for adding people to a database, deleting people from a database it's very similar in spirit now to most any website that has this kind of interactivity. All right, subtle question. I deliberately in my registrants. HTML file uh used post, as we just discovered instead of get why though? Because it wasn't that strong an argument that I hinted at earlier of like oh I don't want like Kelly's ID to end up in my URL bar or mine like IDs are not really personally identifiable they're just opaque integers at the moment. But why would it be bad if you could delete people by using the get method? So this is kind of subtle, but the catch with using get is that by definition you can visit that resource, that route by just typing in a URL or following a hyperlink. So for instance, if an adversary were to type a URL like slash registrants question mark ID equals oh, I don't know. Uh, 4 and then send me this URL in an email or send this URL in an email to the proctor who's running the Frosh IMs program. If that Proctor simply clicks naively on this link as my code is implemented now and I've used get instead of post, what's going to happen? Doug gets deregistered just because the proctor followed a link in their email, and this is hinting at the kinds of phishing attacks that are possible too. Bad design, like generally when you are using get requests, that is just simple URLs that are clickable or typable, they should not have the effect of changing data on the server. Post is much better if only because you can't just click a link and post happens to induce a post request, you almost always have to click a button. So at least this case the proctor would receive an email. They would have to receive an email, click on a link, and then they would see a web page like this that clearly has a button label deregister or the like, which is an additional layer of protection. And there's even more tax that you can wage by supporting get. So in general post requests are preferred any time there's anything remotely personally identifiable or remotely destructive, like actually changing data on the database like this. Alright, well, what more can or should we do with Frosh IMs perhaps? Well, let's see, maybe one or so final flourishes here. Um, if I want to go ahead and maybe make those error messages a little more interesting, let's do that for just a second. Let me go back to. Uh, my other browser tab here, let's go back to the registration page where the form is, and let's deliberately not cooperate and just click register so that I get an error about missing name. Well, wouldn't it be nice if we made this a little more user friendly by including like an image on the page, as is commonly the case? Well, we can certainly include images and websites using the image tag, but the catch is we actually have to be a little more clever about how we store the image on the server in order for this to work. So for instance, let me go into that error page. We don't need success open anymore. We don't need layouts anymore or this index anymore. Let's focus on error and suppose that I did want to include an an error message containing like a grumpy cat on the screen. Well, ideally I would just do alt or I would do open bracket image, uh, source equals, and then something like cat.jpeg where cat.jpeg is the name of a cat in this current folder. And just to be clear, let's have an alternative text of grumpy cat for screen readers or slow connections. OK, this unfortunately is not going to work. Let's go over here and induce the same error by just reloading and submitting the same form, and you'll see indeed a broken image because that image that cat. JPEG does not exist, but we do at least see the alternative text. Well, I did come prepared with a cat already and so let me go. and grab this cat from another folder, and this cat is going to contain, uh, is going to exist in a file called cat.jpeg and indeed if I type LS now after having grabbed a copy of that cat, it exists alongside A.ie seems good. Let's go back to the browser here. Let's reload and we should see. Oh, still no cat. Well, why is this? Well, this is a side effect of using the framework as well. It turns out for organizational sake, any images you want to display on a page or any CSS files or JavaScript files that you want to embed in a page, if they're static assets should actually be in a folder called static, and by static that just means unchanging. You or someone else wrote them once and they're not dynamic in the way that app.ie. So I'm actually going to use my MV command and move cat.jpeg into the static folder. Indeed, if I type LS now, CA is gone, but it is in the static folder. And now if I go back over here, I think we'll be good, except that I do need to go into error. HTML and say that the source of this image is actually in static scat.jpeg to make clear it's in that folder. And so indeed when I now reload the page once more, now I see a very grumpy cat at least guiding my error message. Oh. But there is a difference here, even though when accessing the static directory I have to be explicit, notice that this whole time we have never once mentioned the templates directory. The render template function to be clear, knows automatically to look in the. Templates folder for your template you do not and you should not say something like templates here you simply specify the name of the file, but in the in the uh HTML template you do actually have to include, as I did slash static in the HTML. All right, let's do one final flourish with the actual code. Suppose that it's time to modernize and let people register, not just for one sport as per the radio buttons, but multiple sports. It's a little obnoxious to make me go back and fill out my name again and again and again if I want to register once, twice, 3 times for sports. So why don't we go ahead and in terms of you. I changed those radio buttons to checkboxes. That's a very easy fix. Let me go into my templates folder and into index. HTML where this form is. And if I want to change radio buttons to checkboxes, literally just change radio to checkbox. If I go back to the browser here and reload, you'll see the familiar checkboxes now, which are not mutually exclusive. Lets me check multiple ones, thereby registering for multiple sports at once, but my logic has to change a tiny little bit here whereby if I want to go ahead and get all of the sports for which the user is registered, well, that logic has to change in app.ie. So where is my register route? Down here, and we haven't touched this in a while, but recall that the register route here. Has a validate name chunk of code validate sport chunk of code, and we most recently did the insert into chunk of code as well. But if the user's registering for multiple sports, I'm OK with having one row per sport. Though I'm sure we could do better than that, but how do I iterate over all of the sports that the user gave me? Well, I need to change my validation code here a little bit. If you know the user can select multiple values, as with checkboxes, you're going to use request.form.getlist. And then the name of the uh parameter that you want to get the value of and then this is going to give me back a list of values. So I'm gonna go ahead and change semantically my code to say sports because I'm expecting 0 or more sports now instead of 1. So if there are no sports, we're gonna just say missing sport heck missing sports. Um, but then I can't simply do this. I can't just say, is the sport for which the user registered in that array or not because they might have given me 2 sports or 3. So logically I should really check all of the sports that the human typed in for me and I should probably do something like this instead. So for each sport. In the sports that the user typed in, go ahead and ask the question if that sport is not in sports, then go ahead and output invalid sport. So it's just a bit of tedium here. We're just adding a bit of logic, but this way I'm iterating over every check box that the user checked and making sure they didn't do what Kelly did earlier and sort of make up her own sport and submit that to me. Among all of the others, but this now should let me let's try, let's reload. oh, and then actually one other line here we also need to do it down here, uh, for each sport in sports we better execute that line of code multiple times. So let's see what happens. Let's go ahead and register David for actually let's see what who's in the database. So registrants, so we've got John and Doug, no David or Kelly. So let's reregister David for basketball and soccer click register and now I'm indeed registered for both. And I observed that it's kind of bad design that I'm just inserting myself twice into the database. So let me go ahead and open up the Fros IMS database one last time. Uh, let me do a select, uh, let me do a select star from registrants. You'll see too that David and David are both there. What would be a better design here to get rid of the redundancy? And to know that I'm the same person ideally. Yeah. Yeah, I should probably have an ID for the the person as well, so this is going to complicate it more than we want to play with today, but instead of just a registrant's table, I should probably have like a student's table that has an ID for every student and the name of every student, and then change this table as we've seen with the IMDB database and others, I should really be storing the IDs of the students, the Harvard IDs if you will, and not just their names like this. So there's room for improvement, but the point here is just how we can actually use check boxes and get back. Multiple items from folks. All right. That was a lot. Questions on where we're now at. All right, to make the coding a little less tedious, what we're going to do is look at a few final examples that have sort of come pre-made, and we'll walk through the code pointing out only what's different as opposed to some of the boilerplate that we keep seeing. Um, where we left off now recalls that we have App.ie, which is all of our logic requirements.text, which just enumerates the libraries that we want to use in the project, Static, which now contains any static files like CATs or JavaScript or CSS, and templates which contains our actual templates. It's worth noting that we're actually following a fairly common paradigm. This is not. Specific to flask, the model that we've essentially the the paradigm that we've essentially been implementing is this. If this shape over here represents the human or the user, they keep interacting with what the world generally calls a view. A view is the term of art that just describes the user interface, aka view. But that view is generated by a certain type of code, namely controller logic. So app.ie is technically what the world would call controller logic or business logic, to use an industry term, and that. Controller code, aka app.ie is generating one or more views. So the views that we're referring to here is like everything in your templates. Those are your views. But there's a third piece of the puzzle that we just introduced which is generally called a model, and initially my model was just a stupidly simple dictionary in memory, and that evolved eventually into Frosh IMs.db. So your model is generally your persistent data like where you're storing data related to the application. And even though the picture doesn't lend itself to pronouncing it in the right order. This is what's known as the MVC paradigm model view controller, and it's a very common way of developing web apps by just thinking about the different problems you need to solve with this kind of nomenclature. Like I've got to implement my controller which does all of the logic, all of the variables, functions, conditionals, loops, and so forth. I've got to implement the view which contains everything the user sees and interacts with like the HTML, and I've got to eventually implement the model which is like all of the back end data space and such. The catch though is that this is not a clean line because clearly in views, we've seen variables, we've seen loops, we've seen conditionals, so this is just a general mindset to have and then in the real world, if you ever uh explore web apps again. You are henceforth familiar with what's known as this MVC model. But now let's solve some other real world problems. So here's what you see on the occasion that you sign into something like Gmail or really any other website that asks for a username and then eventually a password or some such thing. This is just a web form. It looks a lot prettier than mine because they're using some fancy CSS to make things blue and nicely indented and so forth, but it's just HTML underneath the hood. with probably an input type equals text to give me this text box. Of course, when you log into Gmail after providing your password, somehow Gmail remembers often for days, weeks even that you have logged in already. Now how is that actually working? Well, when you first log into a site like Gmail and click submit or the next button in this case, presumably the browser is submitting in a envelope, so to speak, a message like this to Google's servers, post slash something to accounts.google.com, which happens to be the URL that Google typically uses for this. And inside of this, the is your username and password and anything else that might be submitted to the server. Ideally, the server responds to you with 200 OK, like, here is your inbox. OK, you logged in successfully, but it also underneath the hood. Every time you've been logging into Gmail has been planting a cookie on your computer, and you might be generally familiar with cookies. They have kind of a bad rap because they're often used and are used quite frequently for tracking, for advertising, and really kind of keeping eyes on you in some way. But in their basic form they're just a feature of HTTP, which is wonderfully useful because it solves some typical problems. This is. Another HTTP header that is usually inside of those virtual envelopes that come back from servers to browsers. In addition to telling the browser what the type of content is in the envelope, it might tell the browser, Please set the following cookie. A cookie is just a key value pair. It might be something like session literally equals some value, and that value is usually a random string that might be 123456, or something like that, but it's a unique identifier. Or naively, if Google implemented cookies poorly, they could technically tell your browser to store a cookie on your computer containing your username and a password so that tomorrow when you open up Gmail, you're not prompted again with the stupid form to log in. It already knows your browser that you're logged in, and your browser can do that by just sending the same cookie it got yesterday to the server. Now this is bad to use cookies to store usernames and passwords. because it's putting very precious data in the browser's memory and any sibling or roommate who walks over to your browser can now find your username and password by just poking around your cookies. So generally what browsers do is more like this screenshot here whereby all the server does is it puts a big random value on your computer somewhere, essentially a text file containing a big random value, and that is equivalent essentially to a sort of a handstamp like if you go. To a bar or a club or an amusement park, generally you show your ticket once when you go in and then thereafter you just show your hand if you want to be able to come and go again and again. So right now my hand has not yet been stamped. We have this nice little smiley face sticker. I might have a smiley face now on my hand any time I want to go back into the bar or club or amusement park because they now know we already checked who you are, presumably the very first time that you came in. That's all cookies are. Effectively doing is it's putting a virtual hand stamp in your browser because the browser, the next time you go to Gmail and click on a link or click on an email, your browser, unbeknownst to you, will send a get request that looks like this but also contains a line like Cookie colon, and then that same key value pair. It's like presenting your hand stamp again and again every time you open an email or click on a link in Gmail. This cookie header is what the browser sends. This set cookie header is what the server sends. So this is the act of stamping your hand. This is the act of presenting your hand, and that effectively is how browsers and servers remember who you are. This is how advertisers generally remember who you are because at one point or other they put a cookie on your computer and unbeknownst to you, you're going to this website, this website, this website, and your browser has been presenting this hand stamp all. All this time, so advertisers know, oh, that's David again. That's David again, that's David again because they're seeing the same hand stamp. And so one of the reasons why last week, for instance, I kept opening things in Incognito mode, which you might use generally if you want to do something private and not have it be saved in the computer's memory, is also because Incognito mode gets rid of all of your cookies when you close the window, effectively like wiping off the hand stamp the next time you go to that same website. So that's all a cookie is. It's a key value pair that can be planted on your computer, but it's a wonderfully powerful mechanism for implementing, and this is the juiciest idea for today, I'd argue what are called sessions. Sessions are this feature whereby browsers and servers have a persistent connection to each other even though HTTP is what we'll call stateless. So stateless just means that you don't have a constant. Connection to the server when you are using a website and that's not always true and nowadays you sometimes do have a consistent, a persistent connection, but cookies allow you to close your laptop, even shut down your computer, come back the next day and still have the illusion of being connected just as you were the previous day because of this virtual presentation of hand stamps. So a session more concretely, you can think of in Python as a dictionary of key value. Pairs that you can associate with each and every user. That is to say, when I log into a website that is using sessions implemented with cookies, they can store any number of key value pairs about me in the server's memory and my presentation of the hand stamp will ensure that they keep, they know which key value pairs to assign to me. Let me go back into VS code here and let me CD into a directory with which I came, which. Called Login, which is just going to be a relatively simple flask application that demonstrates how you can implement the ability to log into a website, and we'll keep it super simple with just user names, no passwords, but as you'll see in Problems at 9, we'll add some passwords to the mix as well. If I type LS inside of this login directory, you'll see some familiar friends app.ie, requirements.text, and templates. But let me draw our attention to one other library we're going to now start using called Flask Session. So Flask session is just a third party library that gives us the ability to use cookies in our application and not have to know or understand any of the screenshots we just saw of HDP requests. It sort of suffices to stipulate, OK, someone figured out how cookies works. I just want to use them now as a feature so that when a user uses my website, I can associate data with them like who they are, what their username is, and therefore that they've logged in. So let's go ahead and close requirements.text and open up. App.ie in this case. Here is an implementation of a program whose purpose in life is to enable me to log in. And in fact, before we before we walk through the code, let me do this in this terminal. Let's do flask run and I already hit control C on my other terminal window a moment ago. Uh, let me now go into my other tab up here and reload the slash route, which is now going to be this login route instead of Frosh IMs. All this website does by default is it tells me first, you are not logged in, but here's a link to log in. It's a little small, but if you look in the bottom left hand corner of my browser right now, it's a URL that ends with slash login. And in fact, I can see that more clearly if I view page source in the browser. Here is the only thing I'm really seeing. In this web app so far, but notice what happens now. If I click on log in, the route in my URL just changed to slash login. I'm again keeping it simple with just usernames, no passwords, but I'm going to log in as David and click log in. But first, let me show you the code. In View page source, I have a form that submits to slash login using the post method. The only thing about this button that's the form that's interesting is it's got a text box and a login button. Same as we've seen before. So let's click it. Now I click log in and notice I get whisked away back to the original route, the slash route, even though Chrome is hiding the slash from me, but the website somehow knows that I'm logged in as David. In fact, if I open up my page source in the browser, I'll see that now. It doesn't say you are not logged in. It says I am logged in as David, and it's now giving me apparently conditionally a logout link. So I argue this is representative now of any website that lets you log in and out of it. So how does this work? Well, in my login account, in my login app here. What do we have in Aie the following. I've got from Flask import flask redirect, render template, request, and a new one session, which you can essentially think of as a dictionary where you can store key value pairs for each and every user, and Flask will make sure that your code. has a different copy of session for every user that visits. You can just treat it as though you only have one user, but Flask will ensure that when a user visits, they get their own copy of session, their own copy of session, their own copy of session, essentially to store whatever you want. This next line here I just need to copy paste from Flask session import capital session. This line is the same. Turn this file into a flask app. This stuff is new and find a copy paste. This just says configure this app to use sessions by storing the cookies on the server as files instead of in a database or somewhere else, but this is the default that we use for our examples. All right, what's going on here? Well, in my. Slash route I've got an index function whose purpose in life seems to be to render a template called index. HTML and then pass in a name placeholder which is the value of session.get.name. So whatever name is stored in the session, if any, that gets passed into the template. So let's go down this rabbit hole. Let me open up index. HTML. Interesting. So here is the logic that implemented those two different versions of the home page that we saw. If the name has a value, so if it's not empty, we saw you are logged in as such and such. Here's a logout link. If though there was no name, as happens by default before you even log in, you see you are not logged in. Here's a link to log in. So that's all the home page is. It's conditional logic checking if there is in fact a user logged in. All right, well, let's go back to A.ie. How does the login work? Well, if you find your way to the login route, then I'm asking a question. If the user got here via post, they probably got here by clicking the login button that I gave them. So let's store in the session dictionary the word name. And make the value of that key this value here where what I've just highlighted is whatever the user typed into the form, whether it's David, Kelly, John, or anyone else, that's what comes back from the form and I'm just storing that in the session, which again is like this special global variable that you get one per user and it's implemented underneath the hood by way of cookies or these hand stamps. Then I'm just redirected to the slash route. Otherwise if the request method wasn't post, that means the user just manually. Visited example.com or whatever my website is. That's why I show them login. HTML. All right, let's go down that rabbit hole. Let's open up login. HTML. It's pretty simple. It's just a stupid form that has a text box and a submit button, but the most important part is that as we saw in the browser, it submits to slash login, the route we just saw. All right, if I go back to here, how do you log out? Well, we didn't actually click this, but here is how you can delete the contents of the. Session and actually log the user out, you just call session.lear. And so in fact, if I go back over here and click log out, how does the server know that I've logged out? Well, that route very quickly you didn't even see the URL bar change logged me out by clearing the whole session. And so the cookie that was planted on my computer was essentially deleted at this point in time or really the server side data that's associated with that cookie was deleted, so I'm no longer seeing it at all. So that's kind of it, like if you log into a website, whether it's Facebook or Gmail or Outlook or anything else like that's effectively how they're logging you in, but of course they're adding into the mix some uh passwords and other security as well. All right, how about one other example? Let me go back into VS code here and let me go into my first terminal, hit Control C to kill this login example. Let me hit CD to go back and then CD store to implement the simplest of web stores like some kind of e-commerce site that has an actual shopping cart implemented. Let me do flask run inside of this directory. Open up my other terminal window, and in my other terminal window I'm going to go CD to go back and then go into store here where I'm going to see some familiar files, namely A.ie, requirements.text, but a database file this time in addition to my templates. Well, let's see what's inside of that database. Let me go ahead and run SQLite 3 of store.db. Schema to see what's in the database. Ah, this is like a bookstore, like the very first version of Amazon.com. If you will, and the table has two columns an ID column and a title column for all of the books that this store shall sell. Well, what are those books? Select star from books, semicolon. OK, so this is a bookstore that sells only 5 books, among them The Hitchhiker's Guide to the Galaxy and sequels. All right, so wouldn't it be nice if we have a website that displays everything in this catalog and lets me Add thanks to my cart. And in fact here is maybe the better metaphor for what a session is. A session essentially gives you the ability to implement a shopping cart like this, where the shopping cart, of course, in the real world is specific to each user. Like if I'm on Amazon.com and Kelly's on Amazon.com and both logged in, we obviously don't see the contents of each other's carts, and that's because we have separate cookies on our hands and so flask or whatever Amazon is using creates the illusion. In that we each have our own global dictionary called session in which Amazon can store any key value pairs it wants like what's in our shopping cart. So let's try this. Let me go back to my other browser and reload, so I'll now see not the login example, but the bookstore example, and it's super ugly because I whipped it up using the simplest of HTML, but you'll see here every one of the books in the database plus an add to cart button. And even if again you're sort of new to all this web programming, there's not all that much you can do with HTML except use forms maybe with some hidden elements to achieve this result. So here we have the H1 tag with books. Here's an H2, which is big and bold but not quite as big. Here's the, here's the here's the button for the Hitchhiker's Guide to the Galaxy. As an aside, because there's like a curly quote or an apostrophe in the book's name. This is just an HTML entity that Flask is outputting for me, even though it's not there. Uh, visually in the database. So what does the button do for Hitchhiker's Guide to the Galaxy? Well, it's a form whose action is slash cart, presumably because I want to add it to my cart using the post method. I've got an input name equals ID, the type of which is hidden, the value of which is 1, and fast forward 234. So just like the deregister example for Kelly, similarly is each book going to be addable to a cart instead of removable by using that unique ID, and indeed every form has an add to cart button. So what's happening then on the server? Well, let's take a look at the other tab here. If I go back into uh VS code, and if I go into my, let's say, let's minimize the terminal window here and let's open up inside of store, let's open up our template for index. HTML, which is sort of the entry, which is not that, uh, let's open up app.ie first and figure out what's going on. So at the top we have some imports including our SQL library. We have an app variable being created, a DB variable being created using that same store.db. We've got this boilerplate code which just again enables cookies and stores the contents on the local file system instead of in a database. Ah, here's the interesting beginning point. How did I see that big page with all the books and the buttons? Well, for the slash route we've got this function that first uses some SQL to get all of the books from the database. Select Star from books, and then, ah, there's no index. HTML because I called it books. HTML in this case just because, and I set the book's placeholder equal to the value of the book's variable. All right, let's go down this rabbit hole now. Let's open up the templates folders, books. HTML file. OK, so here we have that H1 with books and then we have a 4 loop which is going to output for every book in H2 tag and a form tag, a form tag again and again and again, each of which has a value that equals the current book's ID, but the title in the H2, of course, is the title of the book, which is more human friendly. So what happens when I actually click on add to cart for The Hitchhiker's Guide to the Galaxy? Well, I should indeed see that now that one book has been added, and if I go back. At another like the restaurant at the end of the universe, I now have two books in my cart. So where is that data actually being stored? Well, if we go back to VS code here, hide the terminal, and focus on the cart route, the cart route, because it supports post in addition to get, also is doing this for me. Well, first, it's checking with some logic here. If there is no cart in the session, go ahead and create a key called cart and set it equal to an empty list. In other words, I can put any key value pairs into the session that I want. So if I want my shopping cart to effectively be a list of all of the books that the user has added to their cart, it stands to reason that my cart by default should just be an empty list when they first arrive. However, if the user has clicked submit in order to get here, well, I'm going to do this. I'm going to get the ID of the book that they've submitted via that form, and if it indeed exists and it's not someone like Kelly messing around and sending me invalid parameters, I am going to append to the cart list in the session. The book ID and then I'm just going to redirect the user to the cart and anytime you do a redirect that always is using get not post. And so when I come back to this cart route later, I'm not going to be using post. I'm going to be using get, which means this. chunk of code here is executed. I have a variable called books set at equal to the results of doing select star from books where ID in the following parenthesis list of IDs recall that in is the preposition that gives me back multiple IDs if I so choose, and then I'm rendering cart.html. With those their books and if I go back to the application, the reason why I'm seeing two elements here and indeed if I go to my developer tools or view page source rather, I'll see two list items inside of an ordered list or numbered list containing the contents then of that shopping cart. All right, so if we now have the ability to use sessions to remember who has logged in and we have the ability with sessions to remember what someone has added to their shopping cart, what else can we do with web applications more generally, even if not using sessions? Well, let me go ahead and close this tab here. Let me go back to VS code here, close out these two examples, and let's do a final set of examples that demonstrate what we can do with some real world data and a web application. I have lastly a directory called shows which is evocative of our use of IMDB in the past, and I'm going to go ahead into my first terminal window, hit Control C and call your attention to one thing before we move on. Every time I have executed a SQL query inside of my code in my first terminal window where Flask is running, you'll see either in green for success or yellow or red for some issues. The Actual SQL code, SQL commands that are being sent to your database. This is useful if you mess something up at some point related to a database query, you can actually see in your terminal where you're running flask run, actually what SQL command was sent to the server to try to troubleshoot errors that way. Otherwise you're just flying blind when actually interacting only with the web browser. But for now, let me go ahead and clear that away. And CD back to my default directory and CD now into shows where if I type LS we'll see a whole bunch of files A.ie, requirements.text, and this time shows.db, which is the very same database that we had in past weeks when we played with some of the very large number of shows in the internet movie database. And what does A.ie do here? Well, it implements the simplest of programs. This gives me access first to shows. with some boilerplate up top. If I scroll down here, you'll see that there's an index. HTML template that's rendered by default, and then apparently there's a search route which is akin to what Google does for us when we searched for cats and dogs in the past. But for the first time I'm implementing my own search engine for TV shows, not for dogs and cats. But what does this search route do? Well, it uses a shows variable and it executes the sequel, so Star from shows where title equals question mark, and it passes in just like Google does the Q parameter for query and then it renders a template called Search. HTML passing in those shows as a placeholder. In other words, what does this do? Well, let me go back over to the store, uh, to the store tab here, change the URL to just slash, and because I'm now running, uh, I'm no longer running the store, I do want to go ahead and run in my first terminal window, flaskun. To start off the show's application instead. So if I now go back to that tab because no servers running, what I see here now is the simplest of search boxes like our Google example asking for a query, but this time I can search for things with which I'm more familiar like The Office capital T, capital O, search, and what I get back, not that enlighteningly, but is the title of every show that matches exactly that. If I go. Head and view page source you'll see that what was generated was an unordered list of offices that are in the database and recall there's the British one, the American one, and a bunch of others as well. However, this form does not work if I type in something like the office search. I get no results in that case, which isn't so much a well it's just a lack of features here. And so let me actually go into VS code here. And let me propose that we come up with a better version of this code. So in fact, I'm gonna go into the premade examples with which I came today. I'm going to go into the next version of shows here, run flask run here, reload the application over here, and now show you that the office in lower case does actually work. Moreover, it searches for anything that mentions the office. So if you had to guess, how might this be implemented underneath the hood, well, if I open up my other terminal window and go into that same directory. Shows one and open up this version of A.ie you'll see that instead of using a simple query like before, I'm now using the like keyword here because I'm checking that it is like the office and notice this is a bit clever here or a bit confusing at first glance. The placeholder I want is question mark, but I don't want to just search for the user's input. I want to tolerate zero or more characters to the left via the SQL wildcard and zero or more characters to the right. So I'm concatenating onto the user's input, a percent sign here, a percent sign here, because we recall from our week 7 with SQL. This just means look for anything case insensitively that has THE space all F F I C E in it. No matter where that string is in the text. How did it know to render that though as this bulleted list of all of these offices? Well, let me go into my terminal here and open up. Uh, search. HTML, which is the template that the search route is using, and you'll see that I'm just iterating over with a gina 4 loop each of those shows and then outputting a list item for each of those matches effectively just as I did before. But there's this other technique I can use altogether and it's generally going to open up more possibilities for us in final projects, if not beyond, of creating essentially my own AP. rather than just make a web app that spits out the entire HTML page that I want the user to see, wouldn't it be nice if I could just start to create routes that spit out the data that I want, and then I, or even some third party making a website with the same data can integrate my application into their own. And indeed an API is an application programming interface and it's essentially web-based function. You can call to get data from someone else's services generally using HTTP, and you can return the data in any number of formats in text format, in HTML format, or in something called JSON format, which is short for JavaScript object notation, which looks a little something like this, which is quite like Python arrays and dictionaries combined. But notice here with the wave of the hand, there's a whole bunch of Key value pairs in this particular example of all of the offices that are in IMDB's database and so I wanted to show us these final versions of the same shows application that works a little bit differently. If I go into say shows 2 example here now run oops, and let's go ahead and exit out of the previous flask copy and run shows 2 inside of which is flask run, notice here that if I go back to this web form now. Notice that there is no more search button because this is meant to be highly interactive and I can search for THE space O F F I C E and you'll notice that this is effectively autocomplete, which we saw a taste of last week with JavaScript, which I am in fact using here. But how is this working? Well, let me reload and open up my developer tools and in Developer Tools, let's watch the network tab this time because when I. Type in something like T you'll see that my web page suddenly made a request to my own slash search route and if I click on my developer tools and look at the response that came back, you'll see that the slash search route spit out not a full web page but just a whole bunch of LI tags. Now why is that? Well, let me go back to VS code and open up in my other terminal. Uh app.ie and in app.ie scrolling down to search, you'll see that when I get shows from the database, I'm still using Search. HTML, which previously extended my layout and plugged in that whole ordered unordered list. But this time, if I go into this version of search. HTML, you'll see that I'm only spitting out raw HTML because I'm assuming that maybe someone, myself included, wants to use slash search to just get a Whole bunch of list items that they can put into their own unordered list or UL tag. And so what's effectively happening over here is every time I type a letter, notice at bottom left, another HTTP request goes across the internet, another HTTP request, and each of those is returning the set of LI elements that line up with the query that I've typed in. But this is a little sloppy, arguably, and so far as I'm returning a chunk of HTML but out of context and I'm. Dictating to the user that they have to use list items, wouldn't it be nice to just send the raw data, and I can do that too. Let me go back into VS code here and look at our final example, shows 3, inside of which is a version of this code that now returns that so-called JavaScript object notation. And if I go into shows 3, run flaskun, go back over now to my browser tab and click reload, I'll see now when I search for say T. And click on that row. Notice now in the response tab of my developer tools I'm getting back a whole bunch of juicy information, a massive JavaScript object notation chunk of data. Notice the square bracket means here comes a list or an array. Here comes a dictionary or dict, and indeed that's what I'm seeing. This looks like Python, but it's technically JavaScript and it's technically JavaScript's object notation. This just means this is the juicy data I'm getting back. From the server and if you now think way back to week 0 and even in our family weekend lecture on AI lecture on AI where I was writing code that talked to open AIs, so-called API, to get responses from our server side cat, they were sending us JavaScript object notation like this, and I was just grabbing the data that I actually cared about, namely the cat's actual response. And so in this case, if I open up. And my other terminal window here app.ie, you'll see in my search route that instead of returning a template, I'm using a crazy named function called Jasonify, which is just another function that comes with Flask itself that has the effect of taking the list of Python dictionaries that came back from my SQL database, Jasonifying it in such a way that I then can. Uh, serve it to anyone on the internet, myself included, as a service so that I and they can use my own data to implement their own web web applications. So that's sort of it for web programming. Ultimately you now have all of the building blocks from week zero onward to make your own web applications, and if you so choose for final projects, your own mobile applications, even if this too, like every. Else has felt like a bit of a fire hose. It is in the process of your final project of specking out and proposing and executing your own final project that will make all of this feel much more comfortable and familiar, and you'll look back on so many of the past weeks as useful building blocks, but this then was your CS 50 education week 0 through 9. We have just one more left next week, so we'll see you then.